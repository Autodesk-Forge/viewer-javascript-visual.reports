
//This file is the first one when creating minified build
//and is used to set certain flags that are needed
//for the concatenated build.

var IS_CONCAT_BUILD = true;

/** @define {string} */
var BUILD_LMV_WORKER_URL = "viewer3D.js";
var LMV_WORKER_URL = BUILD_LMV_WORKER_URL;

var ENABLE_DEBUG = false;
var ENABLE_TRACE = false;
var ENABLE_INLINE_WORKER = true;
;/**
 * Create namespace
 * @param {string} s - namespace (e.g. 'Autodesk.Viewing')
 * @return {Object} namespace
 */
AutodeskNamespace = function (s) {
    var ns = this;

    var parts = s.split('.');
    for (var i = 0; i < parts.length; ++i) {
        ns[parts[i]] = ns[parts[i]] || {};
        ns = ns[parts[i]];
    }

    return ns;
};
;var _isIE11 = !!navigator.userAgent.match(/Trident\/7\./)

// fix IE events
if(typeof window !== "undefined" && _isIE11){
    (function () {
        function CustomEvent ( event, params ) {
            params = params || { bubbles: false, cancelable: false, detail: undefined };
            var evt = document.createEvent( 'CustomEvent' );
            evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
            return evt;
        };

        CustomEvent.prototype = window.CustomEvent.prototype;

        window.CustomEvent = CustomEvent;
    })();
}

// IE does not implement ArrayBuffer slice. Handy!
if (!ArrayBuffer.prototype.slice) {
    ArrayBuffer.prototype.slice = function(start, end) {
        // Normalize start/end values
        if (!end || end > this.byteLength) {
            end = this.byteLength;
        }
        else if (end < 0) {
            end = this.byteLength + end;
            if (end < 0) end = 0;
        }
        if (start < 0) {
            start = this.byteLength + start;
            if (start < 0) start = 0;
        }

        if (end <= start) {
            return new ArrayBuffer();
        }

        // Bytewise copy- this will not be fast, but what choice do we have?
        var len = end - start;
        var view = new Uint8Array(this, start, len);
        var out = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
            out[i] = view[i];
        }
        return out.buffer;
    }
}


//The BlobBuilder object
if (typeof window !== "undefined")
    window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;


// Launch full screen on the given element with the available method
function launchFullscreen(element) {
    if (element.requestFullscreen) {
        element.requestFullscreen();
    } else if (element.mozRequestFullScreen) {
        element.mozRequestFullScreen();
    } else if (element.webkitRequestFullscreen) {
        element.webkitRequestFullscreen();
    } else if (element.msRequestFullscreen) {
        element.msRequestFullscreen();
    }
}

// Exit full screen with the available method
function exitFullscreen() {
    if (document.exitFullscreen) {
        document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
    }
}

// Determines if the browser is in full screen
function inFullscreen(){
return (document.fullscreenEnabled || document.mozFullScreenElement || document.webkitIsFullScreen || document.msFullscreenElement) ? true : false
}

function fullscreenElement() {
    return document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
}

function isFullscreenAvailable(element) {
    return element.requestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen || element.msRequestFullscreen;
}
;/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
typeof window!=="undefined"&&(!function(a,b,c,d){"use strict";function e(a,b,c){return setTimeout(k(a,c),b)}function f(a,b,c){return Array.isArray(a)?(g(a,c[b],c),!0):!1}function g(a,b,c){var e;if(a)if(a.forEach)a.forEach(b,c);else if(a.length!==d)for(e=0;e<a.length;)b.call(c,a[e],e,a),e++;else for(e in a)a.hasOwnProperty(e)&&b.call(c,a[e],e,a)}function h(a,b,c){for(var e=Object.keys(b),f=0;f<e.length;)(!c||c&&a[e[f]]===d)&&(a[e[f]]=b[e[f]]),f++;return a}function i(a,b){return h(a,b,!0)}function j(a,b,c){var d,e=b.prototype;d=a.prototype=Object.create(e),d.constructor=a,d._super=e,c&&h(d,c)}function k(a,b){return function(){return a.apply(b,arguments)}}function l(a,b){return typeof a==kb?a.apply(b?b[0]||d:d,b):a}function m(a,b){return a===d?b:a}function n(a,b,c){g(r(b),function(b){a.addEventListener(b,c,!1)})}function o(a,b,c){g(r(b),function(b){a.removeEventListener(b,c,!1)})}function p(a,b){for(;a;){if(a==b)return!0;a=a.parentNode}return!1}function q(a,b){return a.indexOf(b)>-1}function r(a){return a.trim().split(/\s+/g)}function s(a,b,c){if(a.indexOf&&!c)return a.indexOf(b);for(var d=0;d<a.length;){if(c&&a[d][c]==b||!c&&a[d]===b)return d;d++}return-1}function t(a){return Array.prototype.slice.call(a,0)}function u(a,b,c){for(var d=[],e=[],f=0;f<a.length;){var g=b?a[f][b]:a[f];s(e,g)<0&&d.push(a[f]),e[f]=g,f++}return c&&(d=b?d.sort(function(a,c){return a[b]>c[b]}):d.sort()),d}function v(a,b){for(var c,e,f=b[0].toUpperCase()+b.slice(1),g=0;g<ib.length;){if(c=ib[g],e=c?c+f:b,e in a)return e;g++}return d}function w(){return ob++}function x(a){var b=a.ownerDocument;return b.defaultView||b.parentWindow}function y(a,b){var c=this;this.manager=a,this.callback=b,this.element=a.element,this.target=a.options.inputTarget,this.domHandler=function(b){l(a.options.enable,[a])&&c.handler(b)},this.init()}function z(a){var b,c=a.options.inputClass;return new(b=c?c:rb?N:sb?Q:qb?S:M)(a,A)}function A(a,b,c){var d=c.pointers.length,e=c.changedPointers.length,f=b&yb&&d-e===0,g=b&(Ab|Bb)&&d-e===0;c.isFirst=!!f,c.isFinal=!!g,f&&(a.session={}),c.eventType=b,B(a,c),a.emit("hammer.input",c),a.recognize(c),a.session.prevInput=c}function B(a,b){var c=a.session,d=b.pointers,e=d.length;c.firstInput||(c.firstInput=E(b)),e>1&&!c.firstMultiple?c.firstMultiple=E(b):1===e&&(c.firstMultiple=!1);var f=c.firstInput,g=c.firstMultiple,h=g?g.center:f.center,i=b.center=F(d);b.timeStamp=nb(),b.deltaTime=b.timeStamp-f.timeStamp,b.angle=J(h,i),b.distance=I(h,i),C(c,b),b.offsetDirection=H(b.deltaX,b.deltaY),b.scale=g?L(g.pointers,d):1,b.rotation=g?K(g.pointers,d):0,D(c,b);var j=a.element;p(b.srcEvent.target,j)&&(j=b.srcEvent.target),b.target=j}function C(a,b){var c=b.center,d=a.offsetDelta||{},e=a.prevDelta||{},f=a.prevInput||{};(b.eventType===yb||f.eventType===Ab)&&(e=a.prevDelta={x:f.deltaX||0,y:f.deltaY||0},d=a.offsetDelta={x:c.x,y:c.y}),b.deltaX=e.x+(c.x-d.x),b.deltaY=e.y+(c.y-d.y)}function D(a,b){var c,e,f,g,h=a.lastInterval||b,i=b.timeStamp-h.timeStamp;if(b.eventType!=Bb&&(i>xb||h.velocity===d)){var j=h.deltaX-b.deltaX,k=h.deltaY-b.deltaY,l=G(i,j,k);e=l.x,f=l.y,c=mb(l.x)>mb(l.y)?l.x:l.y,g=H(j,k),a.lastInterval=b}else c=h.velocity,e=h.velocityX,f=h.velocityY,g=h.direction;b.velocity=c,b.velocityX=e,b.velocityY=f,b.direction=g}function E(a){for(var b=[],c=0;c<a.pointers.length;)b[c]={clientX:lb(a.pointers[c].clientX),clientY:lb(a.pointers[c].clientY)},c++;return{timeStamp:nb(),pointers:b,center:F(b),deltaX:a.deltaX,deltaY:a.deltaY}}function F(a){var b=a.length;if(1===b)return{x:lb(a[0].clientX),y:lb(a[0].clientY)};for(var c=0,d=0,e=0;b>e;)c+=a[e].clientX,d+=a[e].clientY,e++;return{x:lb(c/b),y:lb(d/b)}}function G(a,b,c){return{x:b/a||0,y:c/a||0}}function H(a,b){return a===b?Cb:mb(a)>=mb(b)?a>0?Db:Eb:b>0?Fb:Gb}function I(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return Math.sqrt(d*d+e*e)}function J(a,b,c){c||(c=Kb);var d=b[c[0]]-a[c[0]],e=b[c[1]]-a[c[1]];return 180*Math.atan2(e,d)/Math.PI}function K(a,b){return J(b[1],b[0],Lb)-J(a[1],a[0],Lb)}function L(a,b){return I(b[0],b[1],Lb)/I(a[0],a[1],Lb)}function M(){this.evEl=Nb,this.evWin=Ob,this.allow=!0,this.pressed=!1,y.apply(this,arguments)}function N(){this.evEl=Rb,this.evWin=Sb,y.apply(this,arguments),this.store=this.manager.session.pointerEvents=[]}function O(){this.evTarget=Ub,this.evWin=Vb,this.started=!1,y.apply(this,arguments)}function P(a,b){var c=t(a.touches),d=t(a.changedTouches);return b&(Ab|Bb)&&(c=u(c.concat(d),"identifier",!0)),[c,d]}function Q(){this.evTarget=Xb,this.targetIds={},y.apply(this,arguments)}function R(a,b){var c=t(a.touches),d=this.targetIds;if(b&(yb|zb)&&1===c.length)return d[c[0].identifier]=!0,[c,c];var e,f,g=t(a.changedTouches),h=[],i=this.target;if(f=c.filter(function(a){return p(a.target,i)}),b===yb)for(e=0;e<f.length;)d[f[e].identifier]=!0,e++;for(e=0;e<g.length;)d[g[e].identifier]&&h.push(g[e]),b&(Ab|Bb)&&delete d[g[e].identifier],e++;return h.length?[u(f.concat(h),"identifier",!0),h]:void 0}function S(){y.apply(this,arguments);var a=k(this.handler,this);this.touch=new Q(this.manager,a),this.mouse=new M(this.manager,a)}function T(a,b){this.manager=a,this.set(b)}function U(a){if(q(a,bc))return bc;var b=q(a,cc),c=q(a,dc);return b&&c?cc+" "+dc:b||c?b?cc:dc:q(a,ac)?ac:_b}function V(a){this.id=w(),this.manager=null,this.options=i(a||{},this.defaults),this.options.enable=m(this.options.enable,!0),this.state=ec,this.simultaneous={},this.requireFail=[]}function W(a){return a&jc?"cancel":a&hc?"end":a&gc?"move":a&fc?"start":""}function X(a){return a==Gb?"down":a==Fb?"up":a==Db?"left":a==Eb?"right":""}function Y(a,b){var c=b.manager;return c?c.get(a):a}function Z(){V.apply(this,arguments)}function $(){Z.apply(this,arguments),this.pX=null,this.pY=null}function _(){Z.apply(this,arguments)}function ab(){V.apply(this,arguments),this._timer=null,this._input=null}function bb(){Z.apply(this,arguments)}function cb(){Z.apply(this,arguments)}function db(){V.apply(this,arguments),this.pTime=!1,this.pCenter=!1,this._timer=null,this._input=null,this.count=0}function eb(a,b){return b=b||{},b.recognizers=m(b.recognizers,eb.defaults.preset),new fb(a,b)}function fb(a,b){b=b||{},this.options=i(b,eb.defaults),this.options.inputTarget=this.options.inputTarget||a,this.handlers={},this.session={},this.recognizers=[],this.element=a,this.input=z(this),this.touchAction=new T(this,this.options.touchAction),gb(this,!0),g(b.recognizers,function(a){var b=this.add(new a[0](a[1]));a[2]&&b.recognizeWith(a[2]),a[3]&&b.requireFailure(a[3])},this)}function gb(a,b){var c=a.element;g(a.options.cssProps,function(a,d){c.style[v(c.style,d)]=b?a:""})}function hb(a,c){var d=b.createEvent("Event");d.initEvent(a,!0,!0),d.gesture=c,c.target.dispatchEvent(d)}var ib=["","webkit","moz","MS","ms","o"],jb=b.createElement("div"),kb="function",lb=Math.round,mb=Math.abs,nb=Date.now,ob=1,pb=/mobile|tablet|ip(ad|hone|od)|android/i,qb="ontouchstart"in a,rb=v(a,"PointerEvent")!==d,sb=qb&&pb.test(navigator.userAgent),tb="touch",ub="pen",vb="mouse",wb="kinect",xb=25,yb=1,zb=2,Ab=4,Bb=8,Cb=1,Db=2,Eb=4,Fb=8,Gb=16,Hb=Db|Eb,Ib=Fb|Gb,Jb=Hb|Ib,Kb=["x","y"],Lb=["clientX","clientY"];y.prototype={handler:function(){},init:function(){this.evEl&&n(this.element,this.evEl,this.domHandler),this.evTarget&&n(this.target,this.evTarget,this.domHandler),this.evWin&&n(x(this.element),this.evWin,this.domHandler)},destroy:function(){this.evEl&&o(this.element,this.evEl,this.domHandler),this.evTarget&&o(this.target,this.evTarget,this.domHandler),this.evWin&&o(x(this.element),this.evWin,this.domHandler)}};var Mb={mousedown:yb,mousemove:zb,mouseup:Ab},Nb="mousedown",Ob="mousemove mouseup";j(M,y,{handler:function(a){var b=Mb[a.type];b&yb&&0===a.button&&(this.pressed=!0),b&zb&&1!==a.which&&(b=Ab),this.pressed&&this.allow&&(b&Ab&&(this.pressed=!1),this.callback(this.manager,b,{pointers:[a],changedPointers:[a],pointerType:vb,srcEvent:a}))}});var Pb={pointerdown:yb,pointermove:zb,pointerup:Ab,pointercancel:Bb,pointerout:Bb},Qb={2:tb,3:ub,4:vb,5:wb},Rb="pointerdown",Sb="pointermove pointerup pointercancel";a.MSPointerEvent&&(Rb="MSPointerDown",Sb="MSPointerMove MSPointerUp MSPointerCancel"),j(N,y,{handler:function(a){var b=this.store,c=!1,d=a.type.toLowerCase().replace("ms",""),e=Pb[d],f=Qb[a.pointerType]||a.pointerType,g=f==tb,h=s(b,a.pointerId,"pointerId");e&yb&&(0===a.button||g)?0>h&&(b.push(a),h=b.length-1):e&(Ab|Bb)&&(c=!0),0>h||(b[h]=a,this.callback(this.manager,e,{pointers:b,changedPointers:[a],pointerType:f,srcEvent:a}),c&&b.splice(h,1))}});var Tb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Ub="touchstart",Vb="touchstart touchmove touchend touchcancel";j(O,y,{handler:function(a){var b=Tb[a.type];if(b===yb&&(this.started=!0),this.started){var c=P.call(this,a,b);b&(Ab|Bb)&&c[0].length-c[1].length===0&&(this.started=!1),this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}});var Wb={touchstart:yb,touchmove:zb,touchend:Ab,touchcancel:Bb},Xb="touchstart touchmove touchend touchcancel";j(Q,y,{handler:function(a){var b=Wb[a.type],c=R.call(this,a,b);c&&this.callback(this.manager,b,{pointers:c[0],changedPointers:c[1],pointerType:tb,srcEvent:a})}}),j(S,y,{handler:function(a,b,c){var d=c.pointerType==tb,e=c.pointerType==vb;if(d)this.mouse.allow=!1;else if(e&&!this.mouse.allow)return;b&(Ab|Bb)&&(this.mouse.allow=!0),this.callback(a,b,c)},destroy:function(){this.touch.destroy(),this.mouse.destroy()}});var Yb=v(jb.style,"touchAction"),Zb=Yb!==d,$b="compute",_b="auto",ac="manipulation",bc="none",cc="pan-x",dc="pan-y";T.prototype={set:function(a){a==$b&&(a=this.compute()),Zb&&(this.manager.element.style[Yb]=a),this.actions=a.toLowerCase().trim()},update:function(){this.set(this.manager.options.touchAction)},compute:function(){var a=[];return g(this.manager.recognizers,function(b){l(b.options.enable,[b])&&(a=a.concat(b.getTouchAction()))}),U(a.join(" "))},preventDefaults:function(a){if(!Zb){var b=a.srcEvent,c=a.offsetDirection;if(this.manager.session.prevented)return void b.preventDefault();var d=this.actions,e=q(d,bc),f=q(d,dc),g=q(d,cc);return e||f&&c&Hb||g&&c&Ib?this.preventSrc(b):void 0}},preventSrc:function(a){this.manager.session.prevented=!0,a.preventDefault()}};var ec=1,fc=2,gc=4,hc=8,ic=hc,jc=16,kc=32;V.prototype={defaults:{},set:function(a){return h(this.options,a),this.manager&&this.manager.touchAction.update(),this},recognizeWith:function(a){if(f(a,"recognizeWith",this))return this;var b=this.simultaneous;return a=Y(a,this),b[a.id]||(b[a.id]=a,a.recognizeWith(this)),this},dropRecognizeWith:function(a){return f(a,"dropRecognizeWith",this)?this:(a=Y(a,this),delete this.simultaneous[a.id],this)},requireFailure:function(a){if(f(a,"requireFailure",this))return this;var b=this.requireFail;return a=Y(a,this),-1===s(b,a)&&(b.push(a),a.requireFailure(this)),this},dropRequireFailure:function(a){if(f(a,"dropRequireFailure",this))return this;a=Y(a,this);var b=s(this.requireFail,a);return b>-1&&this.requireFail.splice(b,1),this},hasRequireFailures:function(){return this.requireFail.length>0},canRecognizeWith:function(a){return!!this.simultaneous[a.id]},emit:function(a){function b(b){c.manager.emit(c.options.event+(b?W(d):""),a)}var c=this,d=this.state;hc>d&&b(!0),b(),d>=hc&&b(!0)},tryEmit:function(a){return this.canEmit()?this.emit(a):void(this.state=kc)},canEmit:function(){for(var a=0;a<this.requireFail.length;){if(!(this.requireFail[a].state&(kc|ec)))return!1;a++}return!0},recognize:function(a){var b=h({},a);return l(this.options.enable,[this,b])?(this.state&(ic|jc|kc)&&(this.state=ec),this.state=this.process(b),void(this.state&(fc|gc|hc|jc)&&this.tryEmit(b))):(this.reset(),void(this.state=kc))},process:function(){},getTouchAction:function(){},reset:function(){}},j(Z,V,{defaults:{pointers:1},attrTest:function(a){var b=this.options.pointers;return 0===b||a.pointers.length===b},process:function(a){var b=this.state,c=a.eventType,d=b&(fc|gc),e=this.attrTest(a);return d&&(c&Bb||!e)?b|jc:d||e?c&Ab?b|hc:b&fc?b|gc:fc:kc}}),j($,Z,{defaults:{event:"pan",threshold:10,pointers:1,direction:Jb},getTouchAction:function(){var a=this.options.direction,b=[];return a&Hb&&b.push(dc),a&Ib&&b.push(cc),b},directionTest:function(a){var b=this.options,c=!0,d=a.distance,e=a.direction,f=a.deltaX,g=a.deltaY;return e&b.direction||(b.direction&Hb?(e=0===f?Cb:0>f?Db:Eb,c=f!=this.pX,d=Math.abs(a.deltaX)):(e=0===g?Cb:0>g?Fb:Gb,c=g!=this.pY,d=Math.abs(a.deltaY))),a.direction=e,c&&d>b.threshold&&e&b.direction},attrTest:function(a){return Z.prototype.attrTest.call(this,a)&&(this.state&fc||!(this.state&fc)&&this.directionTest(a))},emit:function(a){this.pX=a.deltaX,this.pY=a.deltaY;var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this._super.emit.call(this,a)}}),j(_,Z,{defaults:{event:"pinch",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.scale-1)>this.options.threshold||this.state&fc)},emit:function(a){if(this._super.emit.call(this,a),1!==a.scale){var b=a.scale<1?"in":"out";this.manager.emit(this.options.event+b,a)}}}),j(ab,V,{defaults:{event:"press",pointers:1,time:500,threshold:5},getTouchAction:function(){return[_b]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime>b.time;if(this._input=a,!d||!c||a.eventType&(Ab|Bb)&&!f)this.reset();else if(a.eventType&yb)this.reset(),this._timer=e(function(){this.state=ic,this.tryEmit()},b.time,this);else if(a.eventType&Ab)return ic;return kc},reset:function(){clearTimeout(this._timer)},emit:function(a){this.state===ic&&(a&&a.eventType&Ab?this.manager.emit(this.options.event+"up",a):(this._input.timeStamp=nb(),this.manager.emit(this.options.event,this._input)))}}),j(bb,Z,{defaults:{event:"rotate",threshold:0,pointers:2},getTouchAction:function(){return[bc]},attrTest:function(a){return this._super.attrTest.call(this,a)&&(Math.abs(a.rotation)>this.options.threshold||this.state&fc)}}),j(cb,Z,{defaults:{event:"swipe",threshold:10,velocity:.65,direction:Hb|Ib,pointers:1},getTouchAction:function(){return $.prototype.getTouchAction.call(this)},attrTest:function(a){var b,c=this.options.direction;return c&(Hb|Ib)?b=a.velocity:c&Hb?b=a.velocityX:c&Ib&&(b=a.velocityY),this._super.attrTest.call(this,a)&&c&a.direction&&a.distance>this.options.threshold&&mb(b)>this.options.velocity&&a.eventType&Ab},emit:function(a){var b=X(a.direction);b&&this.manager.emit(this.options.event+b,a),this.manager.emit(this.options.event,a)}}),j(db,V,{defaults:{event:"tap",pointers:1,taps:1,interval:300,time:250,threshold:2,posThreshold:10},getTouchAction:function(){return[ac]},process:function(a){var b=this.options,c=a.pointers.length===b.pointers,d=a.distance<b.threshold,f=a.deltaTime<b.time;if(this.reset(),a.eventType&yb&&0===this.count)return this.failTimeout();if(d&&f&&c){if(a.eventType!=Ab)return this.failTimeout();var g=this.pTime?a.timeStamp-this.pTime<b.interval:!0,h=!this.pCenter||I(this.pCenter,a.center)<b.posThreshold;this.pTime=a.timeStamp,this.pCenter=a.center,h&&g?this.count+=1:this.count=1,this._input=a;var i=this.count%b.taps;if(0===i)return this.hasRequireFailures()?(this._timer=e(function(){this.state=ic,this.tryEmit()},b.interval,this),fc):ic}return kc},failTimeout:function(){return this._timer=e(function(){this.state=kc},this.options.interval,this),kc},reset:function(){clearTimeout(this._timer)},emit:function(){this.state==ic&&(this._input.tapCount=this.count,this.manager.emit(this.options.event,this._input))}}),eb.VERSION="2.0.4",eb.defaults={domEvents:!1,touchAction:$b,enable:!0,inputTarget:null,inputClass:null,preset:[[bb,{enable:!1}],[_,{enable:!1},["rotate"]],[cb,{direction:Hb}],[$,{direction:Hb},["swipe"]],[db],[db,{event:"doubletap",taps:2},["tap"]],[ab]],cssProps:{userSelect:"none",touchSelect:"none",touchCallout:"none",contentZooming:"none",userDrag:"none",tapHighlightColor:"rgba(0,0,0,0)"}};var lc=1,mc=2;fb.prototype={set:function(a){return h(this.options,a),a.touchAction&&this.touchAction.update(),a.inputTarget&&(this.input.destroy(),this.input.target=a.inputTarget,this.input.init()),this},stop:function(a){this.session.stopped=a?mc:lc},recognize:function(a){var b=this.session;if(!b.stopped){this.touchAction.preventDefaults(a);var c,d=this.recognizers,e=b.curRecognizer;(!e||e&&e.state&ic)&&(e=b.curRecognizer=null);for(var f=0;f<d.length;)c=d[f],b.stopped===mc||e&&c!=e&&!c.canRecognizeWith(e)?c.reset():c.recognize(a),!e&&c.state&(fc|gc|hc)&&(e=b.curRecognizer=c),f++}},get:function(a){if(a instanceof V)return a;for(var b=this.recognizers,c=0;c<b.length;c++)if(b[c].options.event==a)return b[c];return null},add:function(a){if(f(a,"add",this))return this;var b=this.get(a.options.event);return b&&this.remove(b),this.recognizers.push(a),a.manager=this,this.touchAction.update(),a},remove:function(a){if(f(a,"remove",this))return this;var b=this.recognizers;return a=this.get(a),b.splice(s(b,a),1),this.touchAction.update(),this},on:function(a,b){var c=this.handlers;return g(r(a),function(a){c[a]=c[a]||[],c[a].push(b)}),this},off:function(a,b){var c=this.handlers;return g(r(a),function(a){b?c[a].splice(s(c[a],b),1):delete c[a]}),this},emit:function(a,b){this.options.domEvents&&hb(a,b);var c=this.handlers[a]&&this.handlers[a].slice();if(c&&c.length){b.type=a,b.preventDefault=function(){b.srcEvent.preventDefault()};for(var d=0;d<c.length;)c[d](b),d++}},destroy:function(){this.element&&gb(this,!1),this.handlers={},this.session={},this.input.destroy(),this.element=null}},h(eb,{INPUT_START:yb,INPUT_MOVE:zb,INPUT_END:Ab,INPUT_CANCEL:Bb,STATE_POSSIBLE:ec,STATE_BEGAN:fc,STATE_CHANGED:gc,STATE_ENDED:hc,STATE_RECOGNIZED:ic,STATE_CANCELLED:jc,STATE_FAILED:kc,DIRECTION_NONE:Cb,DIRECTION_LEFT:Db,DIRECTION_RIGHT:Eb,DIRECTION_UP:Fb,DIRECTION_DOWN:Gb,DIRECTION_HORIZONTAL:Hb,DIRECTION_VERTICAL:Ib,DIRECTION_ALL:Jb,Manager:fb,Input:y,TouchAction:T,TouchInput:Q,MouseInput:M,PointerEventInput:N,TouchMouseInput:S,SingleTouchInput:O,Recognizer:V,AttrRecognizer:Z,Tap:db,Pan:$,Swipe:cb,Pinch:_,Rotate:bb,Press:ab,on:n,off:o,each:g,merge:i,extend:h,inherit:j,bindFn:k,prefixed:v}),/*Workaround for 'define' being overridden in A360*/false && typeof define==kb&&define.amd?define(function(){return eb}):"undefined"!=typeof module&&module.exports?module.exports=eb:a[c]=eb}(window,document,"Hammer"));
//# sourceMappingURL=hammer.min.map
;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

/**
 * This is the Tessera canvas API for design content.
 */
AutodeskNamespace('Autodesk.Viewing');

/**
 * Global Viewer events
 */

Autodesk.Viewing.ESCAPE_EVENT                   = 'escape';
Autodesk.Viewing.PROGRESS_UPDATE_EVENT          = 'progress';
Autodesk.Viewing.FULLSCREEN_MODE_EVENT          = 'fullScreenMode';
Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT  = 'navmode';
Autodesk.Viewing.VIEWER_STATE_RESTORED_EVENT    = 'viewerStateRestored';
Autodesk.Viewing.VIEWER_RESIZE_EVENT            = 'viewerResize';
Autodesk.Viewing.TOOLBAR_CREATED_EVENT          = 'toolbarCreated';
Autodesk.Viewing.VIEWER_UNINITIALIZED           = 'viewerUninitialized';

/**
 * This is the viewer base class for all viewers
 *
 * @constructor
 * @param {HTMLElement} container - The main container
 * @param {object} config - The initial settings object.
 * @param {Array} [config.extensions] - The list of ids for the extensions to load.
 * @param {bool} [config.disableBrowserContextMenu=true] - Disables the browser's default context menu
 *                                                         within the viewer's container.
 */
Autodesk.Viewing.Viewer = function(container, config) {

  // Hold a reference to the container
    this.clientContainer = container;
    this.container = document.createElement("div");
    this.container.className = "adsk-viewing-viewer";
    this.container.style.height = "100%";
    this.container.style.width = "100%";
    this.container.style.overflow = "hidden";

    this.clientContainer.appendChild(this.container);

    // all the event listeners
    this.listeners = {};

    // Container for the UI docking panels
    this.dockingPanels = [];

    this.config = config;

    this.contextMenu = null;
    this.__firefoxLMBfix = false;

    this.screenModeDelegate = null;
    this.screenModeDelegateClass = null;
    this.setScreenModeDelegate(config ? config.screenModeDelegate : undefined);

    this.loadedExtensions = {};
    this.started = false;

    // TODO: Error codes should go here as well
};


Autodesk.Viewing.Viewer.prototype = {
/**
 *
 * @virtual
 */
  load: function(urn, onLoadCallback) {
    throw 'bool load(urn, function(void)) must be implemented.  For more details, read the Viewer class documentation.';
  }
};

/**
 * Initializes the viewer and loads any extensions specified in the constructor's
 * config parameter.
 *
 * @returns {int} - 0 if the viewer has started, an error code (same as that returned by initialize()) otherwise.
 */
Autodesk.Viewing.Viewer.prototype.start = function () {
    if (this.started) {
        return 0;
    }

    // Initialize
    var result = this.initialize();

    if (result === 0) {
        this.started = true;

        // Load the extensions specified in the config.
        //
        if (this.config && this.config.hasOwnProperty('extensions')) {
            var extensions = this.config.extensions;
            for (var i = 0; i < extensions.length; ++i) {
                this.loadExtension(extensions[i], this.config);
            }
        }
    }
    return result;
};

/**
 *
 * @virtual
 */
Autodesk.Viewing.Viewer.prototype.initialize = function() {
    // Add a callback for the panels to resize when the viewer resizes.
    //
    // Note, we can't pass viewer.resize() as the callback - it will not evaluate
    // 'this' as the viewer when it's called.  We save the viewer here as a closure
    // variable ensuring resize() is called on the viewer.
    //
    var self = this;
    this.onResizeCallback = function(e) {
        self.resize();
    };

    window.addEventListener('resize', this.onResizeCallback, false);

    // Disable the browser's default context menu by default, or if explicitly specified.
    //
    var disableBrowserContextMenu = !this.config || (this.config.hasOwnProperty("disableBrowserContextMenu") ? this.config.disableBrowserContextMenu : true);
    if (disableBrowserContextMenu) {
        this.onDefaultContextMenu = function (e) {
            e.preventDefault();
        }
        this.container.addEventListener('contextmenu', this.onDefaultContextMenu, false);
    }

    this.initContextMenu();

    // Localize the viewer.
    this.localize();
};

Autodesk.Viewing.Viewer.prototype.uninitialize = function () {
    if (this.onDefaultContextMenu) {
        this.container.removeEventListener('contextmenu', this.onDefaultContextMenu, false);
    }

    if (this.container && this.container.parentNode)
        this.container.parentNode.removeChild(this.container);
    this.container = null;

    if (this.screenModeDelegate) {
        this.screenModeDelegate.uninitialize();
        this.screenModeDelegate = null;
    }

    this.clientContainer = null;
    this.config = null;
    this.listeners = {};
    this.dockingPanels = [];
    this.contextMenu = null;

    window.removeEventListener('resize', this.onResizeCallback, false);
    this.fireEvent({type: Autodesk.Viewing.VIEWER_UNINITIALIZED});
};

/**
 * Unloads any loaded extensions and then uninitializes the viewer.
 */
Autodesk.Viewing.Viewer.prototype.finish = function() {
    for (var extensionId in this.loadedExtensions) {
        this.unloadExtension(extensionId);
    }

    this.uninitialize();
};

/**
 * Loads the extension with the given id and options.
 * For internal use only.
 * 
 * @param {string} extensionId - The string id of the extension.
 * @param {Object} options - An optional dictionary of options.
 * 
 * @returns {boolean} - True if the extension was successfully loaded.
 * @private
 */
Autodesk.Viewing.Viewer.prototype.loadExtension = function (extensionId, options) {
    var success = false;
    if (!this.isExtensionLoaded(extensionId)) {
        var extensionClass = Autodesk.Viewing.theExtensionManager.getExtension(extensionId);
        if (extensionClass) {
            var extension = new extensionClass(this, options);
            success = extension.load();
            if (success) {
                this.loadedExtensions[extensionId] = extension;
                stderr('Extension loaded: ' + extensionId);
            }
        } else {
            stderr('Extension not found: ' + extensionId);
        }
    } else {
        stderr('Extension already loaded: ' + extensionId);
    }
    return success;
};

/**
 * Returns whether the extension with the given extensionId is loaded.  
 * For internal use only.
 *
 * @param {string} extensionId - The string id of the extension.
 * @returns {boolean} - True if the extension is currently loaded.
 * @private
 */
Autodesk.Viewing.Viewer.prototype.isExtensionLoaded = function (extensionId) {
    return extensionId in this.loadedExtensions;
};

/**
 * Unloads the extension with the given id.
 * For internal use only.
 *
 * @param {string} extensionId - The string id of the extension.
 * @returns {boolean} - True if the extension was successfully unloaded.
 * @private
 */
Autodesk.Viewing.Viewer.prototype.unloadExtension = function (extensionId) {
    var success = false;
    if (this.isExtensionLoaded(extensionId)) {
        var extension = this.loadedExtensions[extensionId];
        success = extension.unload();
        stderr('Extension unloaded: ' + extensionId);
        delete this.loadedExtensions[extensionId];
    } else {
        stderr('Extension not found: ' + extensionId);
    }
    return success;
};

/**
 * Localize the viewer. This method can be overwritten so that the subclasses
 * can localize any additional elements.
 *
**/
Autodesk.Viewing.Viewer.prototype.localize = function()
{
    Autodesk.Viewing.i18n.localize();
};

///////////////////////////////////////////////////
// Events

/**
 * Adds an event listener.
 * @param {(string | type)} type
 * @param {function} listener
 */
Autodesk.Viewing.Viewer.prototype.addEventListener = function(type, listener)
{
    if (typeof this.listeners[type] == "undefined"){
        this.listeners[type] = [];
    }

    this.listeners[type].push(listener);
};

/**
 * Returns true if the specified listener already exists, false otherwise.
 * @param {(string)} type
 * @param {function} listener
 */
Autodesk.Viewing.Viewer.prototype.hasEventListener = function (type, listener) {

    if (this.listeners === undefined) return false;
    var listeners = this.listeners;
    if (listeners[ type ] !== undefined && listeners[ type ].indexOf(listener) !== -1) {
        return true;
    }

    return false;
};


/**
 * @param {(string)} type
 * @param {function} listener
 */
Autodesk.Viewing.Viewer.prototype.removeEventListener = function(type, listener)
{
    if (this.listeners[type] instanceof Array){
        var li = this.listeners[type];
        for (var i=0, len=li.length; i < len; i++){
            if (li[i] === listener){
                li.splice(i, 1);
                break;
            }
        }
    }
};


/**
 * @param {(string | type)} event
 */
Autodesk.Viewing.Viewer.prototype.fireEvent = function(event)
{
    if (typeof event == "string"){
        event = { type: event };
    }
    if (!event.target){
        event.target = this;
    }

    if (!event.type){
        throw new Error("event type unknown.");
    }

    if (this.listeners[event.type] instanceof Array) {
        var typeListeners = this.listeners[event.type].slice();
        for (var i=0; i < typeListeners.length; i++) {
                typeListeners[i].call(this, event);
        }
    }
};

/**
 *
 * @returns {rect} Client Rectangle Bounds
 */
Autodesk.Viewing.Viewer.prototype.getDimensions = function() {
  if (this.container) {
    // NB: Getting dimensions of the client container instead of the container.
    //     At least in IE11, getting dimensions on the dynamically created
    //     child of the dynamically created parent returns a 0 height.
    var rect = {};
    if (this.getScreenMode() === this.ScreenMode.kFullScreen) {
      rect.width = screen.width;
      rect.height = screen.height;
    } else {
      rect = this.container.getBoundingClientRect();
    }

    return {
      width: rect.width,
      height: rect.height
    };
  }

  return null;
};

/**
 * Gets the view state as a plain object.
 *
 * @param {Object} [filter] - Specifies which viewer values to get.
 * @returns {Object} viewers state.
 *
 * @virtual
 */
Autodesk.Viewing.Viewer.prototype.getState = function( filter ) {
    throw 'Implement getState() in derived class';
};

/**
 * Restores the viewer state from a given object.
 * @param {Object} viewerState
 * @param {Object} [filter] - Similar in structure to viewerState used to filter out values
 *                            that should not be restored.
 * @param {boolean} [immediate] - Whether the new view is applied with (true) or without transition (false)
 *
 * @returns {boolean} true if restore operation was successful.
 *
 * @virtual
 */
Autodesk.Viewing.Viewer.prototype.restoreState = function (viewerState, filter, immediate) {
    throw 'Implement restoreState() in derived class';
};

/**
 * Checks whether a viewerState object is valid for the current loaded URN.
 * @param {Object} viewerState - Viewer State Object to check for validity.
 * @returns {boolean} true if the viewerState is valid for the loaded URN.
 */
Autodesk.Viewing.Viewer.prototype.isValidState = function (viewerState) {
    throw 'Implement isValidState() in derived class';
};

/**
 * Sets the view from an array of parameters
 * @param {Array} params - View parameters
 *
 * @virtual
 */
Autodesk.Viewing.Viewer.prototype.setViewFromArray = function (params) {
};

/**
 * Sets the view from an array representing a view box
 * @param {Array} viewbox - The view box
 *
 * @virtual
 */
Autodesk.Viewing.Viewer.prototype.setViewFromViewBox = function (viewbox) {
};

/**
 * Sets the view using default view in the source file
 *
 * @virtual
 */

Autodesk.Viewing.Viewer.prototype.setViewFromFile = function () {
};

/**
 *
 * @virtual
 */
Autodesk.Viewing.Viewer.prototype.resize = function()
{
    this.resizePanels();
};

/**
 * Adds a panel to the viewer.  The panel will be moved and resized if the viewer
 * is resized and the panel falls outside of the bounds of the viewer.
 *
 * @param {PropertyPanel} panel - the panel to add.
 * @returns {boolean} true if panel was successfully added.
 *
 */
Autodesk.Viewing.Viewer.prototype.addPanel = function(panel) {
    var index = this.dockingPanels.indexOf(panel);
    if(index === -1) {
        this.dockingPanels.push(panel);
        return true;
    }
    return false;
};

/**
 * Removes a panel from the viewer.  The panel will no longer be moved and
 * resized if the viewer is resized.
 *
 * @param {PropertyPanel} panel - the panel to remove.
 * @returns {boolean} true if panel was successfully removed.
 *
 */
Autodesk.Viewing.Viewer.prototype.removePanel = function(panel) {
    var index = this.dockingPanels.indexOf(panel);
    if(index > -1) {
        this.dockingPanels.splice(index, 1);
        return true;
    }
    return false;
};

/**
 * Resizes the panels currently held by the viewer.
 *
 * @param {object} [options] - An optional dictionary of options.
 * @param {array} [options.dockingPanels=all] - a list of panels to resize.
 * @param {object} [options.viewer] - the viewer to use, specify if this method is being used as a callback.
 * @param {object} [options.dimensions] - the area for the panels to occupy.
 * @param {number} options.dimensions.width - the width
 * @param {number} options.dimensions.height - the height
 */
Autodesk.Viewing.Viewer.prototype.resizePanels = function(options) {
    var viewer = options ? options.viewer : null;
    if(!viewer) {
        viewer = this;
    }

    var dockingPanels = options ? options.dockingPanels : null;
    if(!dockingPanels) {
        dockingPanels = viewer.dockingPanels;
    }

    var viewerRect = viewer.container.getBoundingClientRect(),
        vt = viewerRect.top,
        vb = viewerRect.bottom,
        vl = viewerRect.left,
        vr = viewerRect.right,
        vw = viewerRect.width,
        vh = viewerRect.height;

    for (var i = 0; i < dockingPanels.length; ++i) {
        var panel = dockingPanels[i].container,
            panelRect = panel.getBoundingClientRect(),
            pt = panelRect.top,
            pb = panelRect.bottom,
            pl = panelRect.left,
            pr = panelRect.right,
            pw = panelRect.width,
            ph = panelRect.height;

        if (pw && ph) {

            // Panel width should not be greater than viewer width.
            //
            if (vw < pw) {
                pw = Math.round(vw);
                panel.style.width = pw + "px";
            }

            // Panel height should not be greater than viewer height.
            //
            if (vh < ph) {
                ph = Math.round(vh);
                panel.style.height = ph + "px";
            }

            // Adjust horizontally if panel extends beyond right edge of viewer or panel is docked.
            //
            if ((vr < pr) || panel.dockRight) {
                pl = Math.round(vr - pw - vl);
                panel.style.left = pl + "px";
            }

            // Adjust vertically if panel extends beyond bottom edge of viewer or panel is docked.
            //
            if ((vb < pb) || panel.dockBottom) {
                pt = Math.round(vb - ph - vt);
                panel.style.top = pt + "px";
            }

            // Set panel max width/height based upon viewer width/height.
            //
            panel.style.maxWidth = Math.round(vw) + "px";
            panel.style.maxHeight = Math.round(vh) + "px";
        }
    }
};

/**
 * Searches the elements for the given text.  When the search is complete,
 * the callback onResultsReturned(idArray) is invoked.
 * @param {string} text - the search term
 * @param {function(idArray)} onSuccessCallback - the callback to invoke when search is complete.
 * @param {function(errorCode, errorMsg)} onErrorCallback - the callback to invoke when search is complete.
 *
 * @virtual
 */
Autodesk.Viewing.Viewer.prototype.search = function(text, onSuccessCallback, onErrorCallback)
{
    // Virtual method - should be implemented by subclasses
};

/**
 * Sets the object context menu.
 * @param {?ObjectContextMenu=} [contextMenu]
 */
Autodesk.Viewing.Viewer.prototype.setContextMenu = function (contextMenu) {

    if (this.contextMenu) {

        // Hide the current context menu, just in case it's open right now.
        // This does nothing if the context menu is not open.
        //
        this.contextMenu.hide();
    }

    this.contextMenu = contextMenu;
};

Autodesk.Viewing.Viewer.prototype.initContextMenu = function() {
    var self = this;

    function isRightClick(event) {
        var button = event.button;

        // Check for Firefox spoof: Control+LMB converted to RMB.
        // The "buttons" property in Firefox will include 1 for LMB and 2 for RMB.
        if( "buttons" in event ) {
            // For button down the 1 bit will be on indicating LMB.
            // For button up it's off so check the flag to see if we
            // switched the down event.
            if( self.__firefoxLMBfix && !(event.buttons & 1) ) { // Button up?
                self.__firefoxLMBfix = false;
                button = 0;
                // console.log("FIREFOX UP!!!");
            }
            else if( (button === 2) && (event.buttons & 1) ) {
                button = 0;    // Convert back to reality.
                self.__firefoxLMBfix = true;
                // console.log("FIREFOX SUX!!!");
            }
        }

        var useLeftHandedInput = self.navigation ? self.navigation.getUseLeftHandedInput() : false;
        var rightButton = useLeftHandedInput ? 0 : 2;

        if( button === rightButton )
            return true;

        /* See SPK-930 and SPK-928
         var isMac = (navigator.userAgent.search("Mac OS") !== -1);
         var leftButton = (rightButton === 2) ? 0 : 2;
         return isMac && event.ctrlKey && (event.button === leftButton);
         */
        return false;
    }

    var canvas = this.canvas || this.container;

    canvas.addEventListener( 'mousedown',
        function(event) {
            if (isRightClick(event)) {
                self.startX = event.clientX;
                self.startY = event.clientY;
            }
        } );

    canvas.addEventListener( 'mouseup',
        function ( event ) {
            if (isRightClick(event) ) {
                if (self.contextMenu && event.clientX === self.startX && event.clientY === self.startY) {
                    if (self.preContextMenuShow(event)) {
                        return self.contextMenu.show(event);
                    }
                }
            }
            return true;
        }, false );
};

/**
 * Called before showing the context menu.
 * @param {Event} event - Mouse event that triggered this context menu
 * @returns {boolean} true if the context menu should be shown
 */
Autodesk.Viewing.Viewer.prototype.preContextMenuShow = function (event) {
    return true;
};

/**
 * Enum for screen modes: normal, full browser, and full screen
 * @readonly
 * @enum {number}
 */
Autodesk.Viewing.Viewer.ScreenMode = {kNormal: 0, kFullBrowser: 1, kFullScreen: 2};

/**
 * Enum for screen modes: normal, full browser, and full screen
 * @readonly
 * @enum {number}
 * @deprecated Please use the static version ({@link Autodesk.Viewing.Viewer.ScreenMode}).
 */
Autodesk.Viewing.Viewer.prototype.ScreenMode = {kNormal: 0, kFullBrowser: 1, kFullScreen: 2};

/**
 * Set new screen mode delegate
 * @param {Autodesk.Viewing.ScreenModeDelegate} delegate - New screen mode delegate class
 */
Autodesk.Viewing.Viewer.prototype.setScreenModeDelegate = function (delegate) {
    if (this.screenModeDelegate) {
        this.screenModeDelegate.uninitialize();
        this.screenModeDelegate = null;
    }

    // null -> Fullscreen not available
    // undefined -> Use default ViewerScreenModeDelegate
    //
    if (delegate) {
        this.screenModeDelegateClass = delegate;
    } else if (delegate === null) {
        this.screenModeDelegateClass = Autodesk.Viewing.NullScreenModeDelegate;
    } else { // undefined
        this.screenModeDelegateClass = Autodesk.Viewing.ViewerScreenModeDelegate;
    }
};

/**
 * Get current screen mode delegate
 * If no screen mode delegate has been set, then use Autodesk.Viewing.ViewerScreenModeDelegate.
 * @returns {Autodesk.Viewing.ScreenModeDelegate} Current screen mode delegate
 */
Autodesk.Viewing.Viewer.prototype.getScreenModeDelegate = function () {
    if (!this.screenModeDelegate) {
        this.screenModeDelegate = new this.screenModeDelegateClass(this);
    }
    return this.screenModeDelegate;
};

/**
 * Is specified screen mode supported?
 * @param {Autodesk.Viewing.Viewer.ScreenMode} mode
 * @returns {boolean} true if screen mode is supported
 */
Autodesk.Viewing.Viewer.prototype.isScreenModeSupported = function (mode) {
    return this.getScreenModeDelegate().isModeSupported(mode);
};

/**
 * Is changing screen modes supported?
 * @returns {boolean} true if viewer supports changing screen modes
 */
Autodesk.Viewing.Viewer.prototype.canChangeScreenMode = function () {
    return this.isScreenModeSupported(Autodesk.Viewing.Viewer.prototype.kNormal);
};

/**
 * Set new screen mode
 * @param {Autodesk.Viewing.Viewer.ScreenMode} mode - New screen mode
 * @returns {boolean} true if screen mode was changed
 */
Autodesk.Viewing.Viewer.prototype.setScreenMode = function (mode) {
    return this.getScreenModeDelegate().setMode(mode);
};

/**
 * Get current screen mode
 * @returns {Autodesk.Viewing.Viewer.ScreenMode} Current screen mode
 */
Autodesk.Viewing.Viewer.prototype.getScreenMode = function () {
    return this.getScreenModeDelegate().getMode();
};

/**
 * Set screen mode to next in sequence
 * @returns {boolean} true if screen mode was changed
 */
Autodesk.Viewing.Viewer.prototype.nextScreenMode = function () {
    var mode = this.getScreenModeDelegate().getNextMode();
    return (mode !== undefined) ? this.setScreenMode(mode) : false;
};

/**
 * Screen mode escape key handler
 * @returns {boolean} true if screen mode was changed
 */
Autodesk.Viewing.Viewer.prototype.escapeScreenMode = function () {
    var mode = this.getScreenModeDelegate().getEscapeMode();
    return (mode !== undefined) ? this.setScreenMode(mode) : false;
};

/**
 * ScreenModeDelegate virtual base class
 * Derive from this class and use it to allow viewer to go full screen
 * @constructor
 * @param {Autodesk.Viewing.Viewer} viewer
 */
Autodesk.Viewing.ScreenModeDelegate = function (viewer) {
    this.viewer = viewer;
    this.bindFullscreenEventListener = this.fullscreenEventListener.bind(this);

    if (this.getMode() === Autodesk.Viewing.Viewer.ScreenMode.kFullScreen) {
        document.addEventListener('fullscreenchange', this.bindFullscreenEventListener, false);
        document.addEventListener('mozfullscreenchange', this.bindFullscreenEventListener, false);
        document.addEventListener('webkitfullscreenchange', this.bindFullscreenEventListener, false);
        document.addEventListener('MSFullscreenChange', this.bindFullscreenEventListener, false);
    }
};

/**
 * Perform any cleanup required for a ScreenModeDelegate instance
 */
Autodesk.Viewing.ScreenModeDelegate.prototype.uninitialize = function () {
    document.removeEventListener('fullscreenchange', this.bindFullscreenEventListener, false);
    document.removeEventListener('mozfullscreenchange', this.bindFullscreenEventListener, false);
    document.removeEventListener('webkitfullscreenchange', this.bindFullscreenEventListener, false);
    document.removeEventListener('MSFullscreenChange', this.bindFullscreenEventListener, false);

    this.viewer = null;
};

/**
 * Is screen mode supported?
 * Returning false for kNormal means no screen mode changes are supported
 * @param {Autodesk.Viewing.Viewer.ScreenMode} mode
 * @returns {boolean} true if screen mode is supported
 */
Autodesk.Viewing.ScreenModeDelegate.prototype.isModeSupported = function (mode) {
    return true;
};

/**
 * Set new screen mode
 * @param {Autodesk.Viewing.Viewer.ScreenMode} mode - New screen mode
 * @returns {boolean} true if screen mode was changed
 */
Autodesk.Viewing.ScreenModeDelegate.prototype.setMode = function (mode) {
    var currentMode = this.getMode();
    if ((mode !== currentMode) && this.isModeSupported(mode)) {
        this.doScreenModeChange(currentMode, mode);
        if (currentMode !== Autodesk.Viewing.Viewer.ScreenMode.kFullScreen) {
            this.onScreenModeChanged(currentMode, mode);
        }
        return true;
    }
    return false;
};

/**
 * Override this method to get the current screen mode
 * @returns {Autodesk.Viewing.Viewer.ScreenMode} Current screen mode
 */
Autodesk.Viewing.ScreenModeDelegate.prototype.getMode = function () {
    throw 'Implement getMode() in derived class';
};

/**
 * Return next screen mode in sequence
 * Depending upon isModeSupported(), this may be a toggle or a 3-state
 * @returns {Autodesk.Viewing.Viewer.ScreenMode|undefined} Next screen mode in sequence or undefined if no change
 */
Autodesk.Viewing.ScreenModeDelegate.prototype.getNextMode = function () {
    var currentMode = this.getMode(),
        newMode;

    if (currentMode === Autodesk.Viewing.Viewer.ScreenMode.kNormal &&
        this.isModeSupported(Autodesk.Viewing.Viewer.ScreenMode.kFullBrowser)) {

        newMode = Autodesk.Viewing.Viewer.ScreenMode.kFullBrowser;

    } else if (currentMode === Autodesk.Viewing.Viewer.ScreenMode.kNormal &&
        this.isModeSupported(Autodesk.Viewing.Viewer.ScreenMode.kFullScreen)) {

        newMode = Autodesk.Viewing.Viewer.ScreenMode.kFullScreen;

    } else if (currentMode === Autodesk.Viewing.Viewer.ScreenMode.kFullBrowser &&
        this.isModeSupported(Autodesk.Viewing.Viewer.ScreenMode.kFullScreen)) {

        newMode = Autodesk.Viewing.Viewer.ScreenMode.kFullScreen;

    } else if (currentMode === Autodesk.Viewing.Viewer.ScreenMode.kFullBrowser &&
        this.isModeSupported(Autodesk.Viewing.Viewer.ScreenMode.kNormal)) {

        newMode = Autodesk.Viewing.Viewer.ScreenMode.kNormal;

    } else if (currentMode === Autodesk.Viewing.Viewer.ScreenMode.kFullScreen &&
        this.isModeSupported(Autodesk.Viewing.Viewer.ScreenMode.kNormal)) {

        newMode = Autodesk.Viewing.Viewer.ScreenMode.kNormal;

    } else if (currentMode === Autodesk.Viewing.Viewer.ScreenMode.kFullScreen &&
        this.isModeSupported(Autodesk.Viewing.Viewer.ScreenMode.kFullBrowser)) {

        newMode = Autodesk.Viewing.Viewer.ScreenMode.kFullBrowser;
    }
    return newMode;
};

/**
 * Return new screen mode on escape
 * @returns {Autodesk.Viewing.Viewer.ScreenMode|undefined} New screen mode or undefined if no change
 */
Autodesk.Viewing.ScreenModeDelegate.prototype.getEscapeMode = function () {
    return (this.getMode() !== Autodesk.Viewing.Viewer.ScreenMode.kNormal) ?
        Autodesk.Viewing.Viewer.ScreenMode.kNormal : undefined;
};

/**
 * Full screen event listener.
 */
Autodesk.Viewing.ScreenModeDelegate.prototype.fullscreenEventListener = function () {
    if (inFullscreen()) {
        this.viewer.resize();
    } else {
        var ScreenMode = Autodesk.Viewing.Viewer.ScreenMode;
        this.doScreenModeChange(ScreenMode.kFullScreen, ScreenMode.kNormal);
        this.onScreenModeChanged(ScreenMode.kFullScreen, ScreenMode.kNormal);
    }
};

/**
 * Override this method to make the screen mode change occur
 * @param {Autodesk.Viewing.Viewer.ScreenMode} oldMode - Old screen mode
 * @param {Autodesk.Viewing.Viewer.ScreenMode} newMode - New screen mode
 */
Autodesk.Viewing.ScreenModeDelegate.prototype.doScreenModeChange = function (oldMode, newMode) {
    throw 'Implement doScreenModeChange() in derived class';
};

/**
 * Called after the screen mode changes
 * @param {Autodesk.Viewing.Viewer.ScreenMode} oldMode - Old screen mode
 * @param {Autodesk.Viewing.Viewer.ScreenMode} newMode - New screen mode
 */
Autodesk.Viewing.ScreenModeDelegate.prototype.onScreenModeChanged = function (oldMode, newMode) {
    if (oldMode === Autodesk.Viewing.Viewer.ScreenMode.kFullScreen) {
        document.removeEventListener('fullscreenchange', this.bindFullscreenEventListener, false);
        document.removeEventListener('mozfullscreenchange', this.bindFullscreenEventListener, false);
        document.removeEventListener('webkitfullscreenchange', this.bindFullscreenEventListener, false);
        document.removeEventListener('MSFullscreenChange', this.bindFullscreenEventListener, false);

    } else if (newMode === Autodesk.Viewing.Viewer.ScreenMode.kFullScreen) {
        document.addEventListener('fullscreenchange', this.bindFullscreenEventListener, false);
        document.addEventListener('mozfullscreenchange', this.bindFullscreenEventListener, false);
        document.addEventListener('webkitfullscreenchange', this.bindFullscreenEventListener, false);
        document.addEventListener('MSFullscreenChange', this.bindFullscreenEventListener, false);
    }

    this.viewer.resize();
    this.viewer.fireEvent({type: Autodesk.Viewing.FULLSCREEN_MODE_EVENT, mode: newMode});
};

/**
 * ViewerScreenModeDelegate class
 * Allows viewer to go full screen.
 * @constructor
 * @extends Autodesk.Viewing.ScreenModeDelegate
 * @param {Autodesk.Viewing.Viewer} viewer
 */
Autodesk.Viewing.ViewerScreenModeDelegate = function (viewer) {
    Autodesk.Viewing.ScreenModeDelegate.call(this, viewer);
};

Autodesk.Viewing.ViewerScreenModeDelegate.prototype = Object.create(Autodesk.Viewing.ScreenModeDelegate.prototype);
Autodesk.Viewing.ViewerScreenModeDelegate.prototype.constructor = Autodesk.Viewing.ViewerScreenModeDelegate;

/**
 * Overridden base class method to get current screen mode
 * @override
 * @returns {Autodesk.Viewing.Viewer.ScreenMode} Current screen mode
 */
Autodesk.Viewing.ViewerScreenModeDelegate.prototype.getMode = function () {
    if (inFullscreen() && fullscreenElement() === this.viewer.container) {
        return Autodesk.Viewing.Viewer.ScreenMode.kFullScreen;
    } else if (this.viewer.container.classList.contains('viewer-fill-browser')) {
        return Autodesk.Viewing.Viewer.ScreenMode.kFullBrowser;
    }
    return Autodesk.Viewing.Viewer.ScreenMode.kNormal;
};

/**
 * Overridden base class method to make the screen mode change occur
 * @override
 * @param {Autodesk.Viewing.Viewer.ScreenMode} oldMode - Old screen mode
 * @param {Autodesk.Viewing.Viewer.ScreenMode} newMode - New screen mode
 */
Autodesk.Viewing.ViewerScreenModeDelegate.prototype.doScreenModeChange = function (oldMode, newMode) {
    var container = this.viewer.container;

    // TODO: properly handle kFullScreen -> kFullBrowser

    switch (newMode) {
        case Autodesk.Viewing.Viewer.ScreenMode.kNormal:
            container.classList.remove('viewer-fill-browser');
            exitFullscreen();
            break;

        case Autodesk.Viewing.Viewer.ScreenMode.kFullBrowser:
            container.classList.add('viewer-fill-browser');
            break;

        case Autodesk.Viewing.Viewer.ScreenMode.kFullScreen:
            container.classList.add('viewer-fill-browser');
            launchFullscreen(container);
            break;
    }
};

/**
 * ApplicationScreenModeDelegate class
 * Allows viewer to go full screen. Unlike ViewerScreenModeDelegate class, this delegate
 * doesn't use the full browser state, and it takes the entire page full screen, not just
 * the viewer.
 * @constructor
 * @extends Autodesk.Viewing.ScreenModeDelegate
 * @param {Autodesk.Viewing.Viewer} viewer
 */
Autodesk.Viewing.ApplicationScreenModeDelegate = function (viewer) {
    Autodesk.Viewing.ScreenModeDelegate.call(this, viewer);
};

Autodesk.Viewing.ApplicationScreenModeDelegate.prototype = Object.create(Autodesk.Viewing.ScreenModeDelegate.prototype);
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype.constructor = Autodesk.Viewing.ApplicationScreenModeDelegate;

/**
 * Is screen mode supported?
 * @override
 * @param {Autodesk.Viewing.Viewer.ScreenMode} mode
 * @returns {boolean} true if screen mode is supported
 */
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype.isModeSupported = function (mode) {
    return mode !== Autodesk.Viewing.Viewer.ScreenMode.kFullBrowser;
};

/**
 * Overridden base class method to get current screen mode
 * @override
 * @returns {Autodesk.Viewing.Viewer.ScreenMode} Current screen mode
 */
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype.getMode = function () {
    return inFullscreen() && fullscreenElement() === document.documentElement ?
        Autodesk.Viewing.Viewer.ScreenMode.kFullScreen :
        Autodesk.Viewing.Viewer.ScreenMode.kNormal;
};

/**
 * Overridden base class method to make the screen mode change occur
 * @override
 * @param {Autodesk.Viewing.Viewer.ScreenMode} oldMode - Old screen mode
 * @param {Autodesk.Viewing.Viewer.ScreenMode} newMode - New screen mode
 */
Autodesk.Viewing.ApplicationScreenModeDelegate.prototype.doScreenModeChange = function (oldMode, newMode) {
    if (newMode === Autodesk.Viewing.Viewer.ScreenMode.kNormal) {
        exitFullscreen();
    } else if (newMode === Autodesk.Viewing.Viewer.ScreenMode.kFullScreen) {
        launchFullscreen(document.documentElement);
    }
};

/**
 * NullScreenModeDelegate class
 * No full screen functionality.
 * @constructor
 * @extends Autodesk.Viewing.ScreenModeDelegate
 * @param {Autodesk.Viewing.Viewer} viewer
 */
Autodesk.Viewing.NullScreenModeDelegate = function (viewer) {
    Autodesk.Viewing.ScreenModeDelegate.call(this, viewer);
};

Autodesk.Viewing.NullScreenModeDelegate.prototype = Object.create(Autodesk.Viewing.ScreenModeDelegate.prototype);
Autodesk.Viewing.NullScreenModeDelegate.prototype.constructor = Autodesk.Viewing.ScreenModeDelegate;

/**
 * Is screen mode supported?
 * @override
 * @param {Autodesk.Viewing.Viewer.ScreenMode} mode
 * @returns {boolean} true if screen mode is supported
 */
Autodesk.Viewing.NullScreenModeDelegate.prototype.isModeSupported = function (mode) {
    return false; // No screen modes supported
};

/**
 * Override this method to get the current screen mode
 * @override
 * @returns {Autodesk.Viewing.Viewer.ScreenMode} Current screen mode
 */
Autodesk.Viewing.NullScreenModeDelegate.prototype.getMode = function () {
    return Autodesk.Viewing.Viewer.ScreenMode.kNormal;
};
;// threejs.org/license
'use strict';var THREE={REVISION:"68"};"object"===typeof module&&(module.exports=THREE);THREE.CullFaceNone=0;THREE.CullFaceBack=1;THREE.CullFaceFront=2;THREE.CullFaceFrontBack=3;THREE.FrontFaceDirectionCW=0;THREE.FrontFaceDirectionCCW=1;THREE.BasicShadowMap=0;THREE.PCFShadowMap=1;THREE.PCFSoftShadowMap=2;THREE.FrontSide=0;THREE.BackSide=1;THREE.DoubleSide=2;THREE.NoShading=0;THREE.FlatShading=1;THREE.SmoothShading=2;THREE.NoColors=0;THREE.FaceColors=1;THREE.VertexColors=2;THREE.NoBlending=0;
THREE.NormalBlending=1;THREE.AdditiveBlending=2;THREE.SubtractiveBlending=3;THREE.MultiplyBlending=4;THREE.CustomBlending=5;THREE.AddEquation=100;THREE.SubtractEquation=101;THREE.ReverseSubtractEquation=102;THREE.ZeroFactor=200;THREE.OneFactor=201;THREE.SrcColorFactor=202;THREE.OneMinusSrcColorFactor=203;THREE.SrcAlphaFactor=204;THREE.OneMinusSrcAlphaFactor=205;THREE.DstAlphaFactor=206;THREE.OneMinusDstAlphaFactor=207;THREE.DstColorFactor=208;THREE.OneMinusDstColorFactor=209;
THREE.SrcAlphaSaturateFactor=210;THREE.MultiplyOperation=0;THREE.MixOperation=1;THREE.AddOperation=2;THREE.UVMapping=function(){};THREE.CubeReflectionMapping=function(){};THREE.CubeRefractionMapping=function(){};THREE.SphericalReflectionMapping=function(){};THREE.SphericalRefractionMapping=function(){};THREE.RepeatWrapping=1E3;THREE.ClampToEdgeWrapping=1001;THREE.MirroredRepeatWrapping=1002;THREE.NearestFilter=1003;THREE.NearestMipMapNearestFilter=1004;THREE.NearestMipMapLinearFilter=1005;
THREE.LinearFilter=1006;THREE.LinearMipMapNearestFilter=1007;THREE.LinearMipMapLinearFilter=1008;THREE.UnsignedByteType=1009;THREE.ByteType=1010;THREE.ShortType=1011;THREE.UnsignedShortType=1012;THREE.IntType=1013;THREE.UnsignedIntType=1014;THREE.FloatType=1015;THREE.UnsignedShort4444Type=1016;THREE.UnsignedShort5551Type=1017;THREE.UnsignedShort565Type=1018;THREE.AlphaFormat=1019;THREE.RGBFormat=1020;THREE.RGBAFormat=1021;THREE.LuminanceFormat=1022;THREE.LuminanceAlphaFormat=1023;
THREE.RGB_S3TC_DXT1_Format=2001;THREE.RGBA_S3TC_DXT1_Format=2002;THREE.RGBA_S3TC_DXT3_Format=2003;THREE.RGBA_S3TC_DXT5_Format=2004;THREE.Color=function(a){return 3===arguments.length?this.setRGB(arguments[0],arguments[1],arguments[2]):this.set(a)};
THREE.Color.prototype={constructor:THREE.Color,r:1,g:1,b:1,set:function(a){a instanceof THREE.Color?this.copy(a):"number"===typeof a?this.setHex(a):"string"===typeof a&&this.setStyle(a);return this},setHex:function(a){a=Math.floor(a);this.r=(a>>16&255)/255;this.g=(a>>8&255)/255;this.b=(a&255)/255;return this},setRGB:function(a,b,c){this.r=a;this.g=b;this.b=c;return this},setHSL:function(a,b,c){if(0===b)this.r=this.g=this.b=c;else{var d=function(a,b,c){0>c&&(c+=1);1<c&&(c-=1);return c<1/6?a+6*(b-a)*
c:0.5>c?b:c<2/3?a+6*(b-a)*(2/3-c):a};b=0.5>=c?c*(1+b):c+b-c*b;c=2*c-b;this.r=d(c,b,a+1/3);this.g=d(c,b,a);this.b=d(c,b,a-1/3)}return this},setStyle:function(a){if(/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a))return a=/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a),this.r=Math.min(255,parseInt(a[1],10))/255,this.g=Math.min(255,parseInt(a[2],10))/255,this.b=Math.min(255,parseInt(a[3],10))/255,this;if(/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a))return a=/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a),this.r=
Math.min(100,parseInt(a[1],10))/100,this.g=Math.min(100,parseInt(a[2],10))/100,this.b=Math.min(100,parseInt(a[3],10))/100,this;if(/^\#([0-9a-f]{6})$/i.test(a))return a=/^\#([0-9a-f]{6})$/i.exec(a),this.setHex(parseInt(a[1],16)),this;if(/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a))return a=/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a),this.setHex(parseInt(a[1]+a[1]+a[2]+a[2]+a[3]+a[3],16)),this;if(/^(\w+)$/i.test(a))return this.setHex(THREE.ColorKeywords[a]),this},copy:function(a){this.r=a.r;this.g=
a.g;this.b=a.b;return this},copyGammaToLinear:function(a){this.r=a.r*a.r;this.g=a.g*a.g;this.b=a.b*a.b;return this},copyLinearToGamma:function(a){this.r=Math.sqrt(a.r);this.g=Math.sqrt(a.g);this.b=Math.sqrt(a.b);return this},convertGammaToLinear:function(){var a=this.r,b=this.g,c=this.b;this.r=a*a;this.g=b*b;this.b=c*c;return this},convertLinearToGamma:function(){this.r=Math.sqrt(this.r);this.g=Math.sqrt(this.g);this.b=Math.sqrt(this.b);return this},getHex:function(){return 255*this.r<<16^255*this.g<<
8^255*this.b<<0},getHexString:function(){return("000000"+this.getHex().toString(16)).slice(-6)},getHSL:function(a){a=a||{h:0,s:0,l:0};var b=this.r,c=this.g,d=this.b,e=Math.max(b,c,d),f=Math.min(b,c,d),g,h=(f+e)/2;if(f===e)f=g=0;else{var k=e-f,f=0.5>=h?k/(e+f):k/(2-e-f);switch(e){case b:g=(c-d)/k+(c<d?6:0);break;case c:g=(d-b)/k+2;break;case d:g=(b-c)/k+4}g/=6}a.h=g;a.s=f;a.l=h;return a},getStyle:function(){return"rgb("+(255*this.r|0)+","+(255*this.g|0)+","+(255*this.b|0)+")"},offsetHSL:function(a,
b,c){var d=this.getHSL();d.h+=a;d.s+=b;d.l+=c;this.setHSL(d.h,d.s,d.l);return this},add:function(a){this.r+=a.r;this.g+=a.g;this.b+=a.b;return this},addColors:function(a,b){this.r=a.r+b.r;this.g=a.g+b.g;this.b=a.b+b.b;return this},addScalar:function(a){this.r+=a;this.g+=a;this.b+=a;return this},multiply:function(a){this.r*=a.r;this.g*=a.g;this.b*=a.b;return this},multiplyScalar:function(a){this.r*=a;this.g*=a;this.b*=a;return this},lerp:function(a,b){this.r+=(a.r-this.r)*b;this.g+=(a.g-this.g)*b;
this.b+=(a.b-this.b)*b;return this},equals:function(a){return a.r===this.r&&a.g===this.g&&a.b===this.b},fromArray:function(a){this.r=a[0];this.g=a[1];this.b=a[2];return this},toArray:function(){return[this.r,this.g,this.b]},clone:function(){return(new THREE.Color).setRGB(this.r,this.g,this.b)}};
THREE.ColorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,
darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,
grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,
lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,
palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,
tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};THREE.Quaternion=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._w=void 0!==d?d:1};
THREE.Quaternion.prototype={constructor:THREE.Quaternion,_x:0,_y:0,_z:0,_w:0,get x(){return this._x},set x(a){this._x=a;this.onChangeCallback()},get y(){return this._y},set y(a){this._y=a;this.onChangeCallback()},get z(){return this._z},set z(a){this._z=a;this.onChangeCallback()},get w(){return this._w},set w(a){this._w=a;this.onChangeCallback()},set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._w=d;this.onChangeCallback();return this},copy:function(a){this._x=a.x;this._y=a.y;this._z=a.z;
this._w=a.w;this.onChangeCallback();return this},setFromEuler:function(a,b){if(!1===a instanceof THREE.Euler)throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");var c=Math.cos(a._x/2),d=Math.cos(a._y/2),e=Math.cos(a._z/2),f=Math.sin(a._x/2),g=Math.sin(a._y/2),h=Math.sin(a._z/2);"XYZ"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e-f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):"YXZ"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e-f*d*h,this._z=
c*d*h-f*g*e,this._w=c*d*e+f*g*h):"ZXY"===a.order?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e-f*g*h):"ZYX"===a.order?(this._x=f*d*e-c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e+f*g*h):"YZX"===a.order?(this._x=f*d*e+c*g*h,this._y=c*g*e+f*d*h,this._z=c*d*h-f*g*e,this._w=c*d*e-f*g*h):"XZY"===a.order&&(this._x=f*d*e-c*g*h,this._y=c*g*e-f*d*h,this._z=c*d*h+f*g*e,this._w=c*d*e+f*g*h);if(!1!==b)this.onChangeCallback();return this},setFromAxisAngle:function(a,
b){var c=b/2,d=Math.sin(c);this._x=a.x*d;this._y=a.y*d;this._z=a.z*d;this._w=Math.cos(c);this.onChangeCallback();return this},setFromRotationMatrix:function(a){var b=a.elements,c=b[0];a=b[4];var d=b[8],e=b[1],f=b[5],g=b[9],h=b[2],k=b[6],b=b[10],m=c+f+b;0<m?(c=0.5/Math.sqrt(m+1),this._w=0.25/c,this._x=(k-g)*c,this._y=(d-h)*c,this._z=(e-a)*c):c>f&&c>b?(c=2*Math.sqrt(1+c-f-b),this._w=(k-g)/c,this._x=0.25*c,this._y=(a+e)/c,this._z=(d+h)/c):f>b?(c=2*Math.sqrt(1+f-c-b),this._w=(d-h)/c,this._x=(a+e)/c,this._y=
0.25*c,this._z=(g+k)/c):(c=2*Math.sqrt(1+b-c-f),this._w=(e-a)/c,this._x=(d+h)/c,this._y=(g+k)/c,this._z=0.25*c);this.onChangeCallback();return this},setFromUnitVectors:function(){var a,b;return function(c,d){void 0===a&&(a=new THREE.Vector3);b=c.dot(d)+1;1E-6>b?(b=0,Math.abs(c.x)>Math.abs(c.z)?a.set(-c.y,c.x,0):a.set(0,-c.z,c.y)):a.crossVectors(c,d);this._x=a.x;this._y=a.y;this._z=a.z;this._w=b;this.normalize();return this}}(),inverse:function(){this.conjugate().normalize();return this},conjugate:function(){this._x*=
-1;this._y*=-1;this._z*=-1;this.onChangeCallback();return this},dot:function(a){return this._x*a._x+this._y*a._y+this._z*a._z+this._w*a._w},lengthSq:function(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w},length:function(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)},normalize:function(){var a=this.length();0===a?(this._z=this._y=this._x=0,this._w=1):(a=1/a,this._x*=a,this._y*=a,this._z*=a,this._w*=a);this.onChangeCallback();return this},
multiply:function(a,b){return void 0!==b?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(a,b)):this.multiplyQuaternions(this,a)},multiplyQuaternions:function(a,b){var c=a._x,d=a._y,e=a._z,f=a._w,g=b._x,h=b._y,k=b._z,m=b._w;this._x=c*m+f*g+d*k-e*h;this._y=d*m+f*h+e*g-c*k;this._z=e*m+f*k+c*h-d*g;this._w=f*m-c*g-d*h-e*k;this.onChangeCallback();return this},multiplyVector3:function(a){console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
return a.applyQuaternion(this)},slerp:function(a,b){var c=this._x,d=this._y,e=this._z,f=this._w,g=f*a._w+c*a._x+d*a._y+e*a._z;0>g?(this._w=-a._w,this._x=-a._x,this._y=-a._y,this._z=-a._z,g=-g):this.copy(a);if(1<=g)return this._w=f,this._x=c,this._y=d,this._z=e,this;var h=Math.acos(g),k=Math.sqrt(1-g*g);if(0.001>Math.abs(k))return this._w=0.5*(f+this._w),this._x=0.5*(c+this._x),this._y=0.5*(d+this._y),this._z=0.5*(e+this._z),this;g=Math.sin((1-b)*h)/k;h=Math.sin(b*h)/k;this._w=f*g+this._w*h;this._x=
c*g+this._x*h;this._y=d*g+this._y*h;this._z=e*g+this._z*h;this.onChangeCallback();return this},equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._w===this._w},fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];this._w=a[3];this.onChangeCallback();return this},toArray:function(){return[this._x,this._y,this._z,this._w]},onChange:function(a){this.onChangeCallback=a;return this},onChangeCallback:function(){},clone:function(){return new THREE.Quaternion(this._x,this._y,
this._z,this._w)}};THREE.Quaternion.slerp=function(a,b,c,d){return c.copy(a).slerp(b,d)};THREE.Vector2=function(a,b){this.x=a||0;this.y=b||0};
THREE.Vector2.prototype={constructor:THREE.Vector2,set:function(a,b){this.x=a;this.y=b;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;default:throw Error("index is out of range: "+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+a);}},copy:function(a){this.x=a.x;this.y=a.y;return this},add:function(a,
b){if(void 0!==b)return console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this},addScalar:function(a){this.x+=a;this.y+=a;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;return this},
subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this},multiply:function(a){this.x*=a.x;this.y*=a.y;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;return this},divide:function(a){this.x/=a.x;this.y/=a.y;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a):this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);return this},clamp:function(a,
b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);return this},clampScalar:function(){var a,b;return function(c,d){void 0===a&&(a=new THREE.Vector2,b=new THREE.Vector2);a.set(c,c);b.set(d,d);return this.clamp(a,b)}}(),floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this},
roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);return this},negate:function(){this.x=-this.x;this.y=-this.y;return this},dot:function(a){return this.x*a.x+this.y*a.y},lengthSq:function(){return this.x*this.x+this.y*this.y},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},normalize:function(){return this.divideScalar(this.length())},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=
this.x-a.x;a=this.y-a.y;return b*b+a*a},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y},fromArray:function(a){this.x=a[0];this.y=a[1];return this},toArray:function(){return[this.x,this.y]},clone:function(){return new THREE.Vector2(this.x,this.y)}};THREE.Vector3=function(a,b,c){this.x=a||0;this.y=b||0;this.z=c||0};
THREE.Vector3.prototype={constructor:THREE.Vector3,set:function(a,b,c){this.x=a;this.y=b;this.z=c;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;default:throw Error("index is out of range: "+a);}},getComponent:function(a){switch(a){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+
a);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;return this},add:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;return this},addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this},multiply:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(a,b);this.x*=a.x;this.y*=a.y;this.z*=a.z;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;return this},multiplyVectors:function(a,b){this.x=a.x*b.x;this.y=
a.y*b.y;this.z=a.z*b.z;return this},applyEuler:function(){var a;return function(b){!1===b instanceof THREE.Euler&&console.error("THREE.Vector3: .applyEuler() now expects a Euler rotation rather than a Vector3 and order.");void 0===a&&(a=new THREE.Quaternion);this.applyQuaternion(a.setFromEuler(b));return this}}(),applyAxisAngle:function(){var a;return function(b,c){void 0===a&&(a=new THREE.Quaternion);this.applyQuaternion(a.setFromAxisAngle(b,c));return this}}(),applyMatrix3:function(a){var b=this.x,
c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[3]*c+a[6]*d;this.y=a[1]*b+a[4]*c+a[7]*d;this.z=a[2]*b+a[5]*c+a[8]*d;return this},applyMatrix4:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12];this.y=a[1]*b+a[5]*c+a[9]*d+a[13];this.z=a[2]*b+a[6]*c+a[10]*d+a[14];return this},applyProjection:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;var e=1/(a[3]*b+a[7]*c+a[11]*d+a[15]);this.x=(a[0]*b+a[4]*c+a[8]*d+a[12])*e;this.y=(a[1]*b+a[5]*c+a[9]*d+a[13])*e;this.z=
(a[2]*b+a[6]*c+a[10]*d+a[14])*e;return this},applyQuaternion:function(a){var b=this.x,c=this.y,d=this.z,e=a.x,f=a.y,g=a.z;a=a.w;var h=a*b+f*d-g*c,k=a*c+g*b-e*d,m=a*d+e*c-f*b,b=-e*b-f*c-g*d;this.x=h*a+b*-e+k*-g-m*-f;this.y=k*a+b*-f+m*-e-h*-g;this.z=m*a+b*-g+h*-f-k*-e;return this},transformDirection:function(a){var b=this.x,c=this.y,d=this.z;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d;this.y=a[1]*b+a[5]*c+a[9]*d;this.z=a[2]*b+a[6]*c+a[10]*d;this.normalize();return this},divide:function(a){this.x/=a.x;
this.y/=a.y;this.z/=a.z;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a):this.z=this.y=this.x=0;return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);this.z<a.z&&(this.z=a.z);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=
b.z);return this},clampScalar:function(){var a,b;return function(c,d){void 0===a&&(a=new THREE.Vector3,b=new THREE.Vector3);a.set(c,c,c);b.set(d,d,d);return this.clamp(a,b)}}(),floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this},roundToZero:function(){this.x=
0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);return this},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+
Math.abs(this.z)},normalize:function(){return this.divideScalar(this.length())},setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;return this},cross:function(a,b){if(void 0!==b)return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(a,b);var c=this.x,d=this.y,e=this.z;this.x=d*a.z-e*a.y;this.y=
e*a.x-c*a.z;this.z=c*a.y-d*a.x;return this},crossVectors:function(a,b){var c=a.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;this.x=d*h-e*g;this.y=e*f-c*h;this.z=c*g-d*f;return this},projectOnVector:function(){var a,b;return function(c){void 0===a&&(a=new THREE.Vector3);a.copy(c).normalize();b=this.dot(a);return this.copy(a).multiplyScalar(b)}}(),projectOnPlane:function(){var a;return function(b){void 0===a&&(a=new THREE.Vector3);a.copy(this).projectOnVector(b);return this.sub(a)}}(),reflect:function(){var a;return function(b){void 0===
a&&(a=new THREE.Vector3);return this.sub(a.copy(b).multiplyScalar(2*this.dot(b)))}}(),angleTo:function(a){a=this.dot(a)/(this.length()*a.length());return Math.acos(THREE.Math.clamp(a,-1,1))},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y;a=this.z-a.z;return b*b+c*c+a*a},setEulerFromRotationMatrix:function(a,b){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")},
setEulerFromQuaternion:function(a,b){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")},getPositionFromMatrix:function(a){console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");return this.setFromMatrixPosition(a)},getScaleFromMatrix:function(a){console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");return this.setFromMatrixScale(a)},getColumnFromMatrix:function(a,
b){console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");return this.setFromMatrixColumn(a,b)},setFromMatrixPosition:function(a){this.x=a.elements[12];this.y=a.elements[13];this.z=a.elements[14];return this},setFromMatrixScale:function(a){var b=this.set(a.elements[0],a.elements[1],a.elements[2]).length(),c=this.set(a.elements[4],a.elements[5],a.elements[6]).length();a=this.set(a.elements[8],a.elements[9],a.elements[10]).length();this.x=b;this.y=c;this.z=
a;return this},setFromMatrixColumn:function(a,b){var c=4*a,d=b.elements;this.x=d[c];this.y=d[c+1];this.z=d[c+2];return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];return this},toArray:function(){return[this.x,this.y,this.z]},clone:function(){return new THREE.Vector3(this.x,this.y,this.z)}};THREE.Vector4=function(a,b,c,d){this.x=a||0;this.y=b||0;this.z=c||0;this.w=void 0!==d?d:1};
THREE.Vector4.prototype={constructor:THREE.Vector4,set:function(a,b,c,d){this.x=a;this.y=b;this.z=c;this.w=d;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},setW:function(a){this.w=a;return this},setComponent:function(a,b){switch(a){case 0:this.x=b;break;case 1:this.y=b;break;case 2:this.z=b;break;case 3:this.w=b;break;default:throw Error("index is out of range: "+a);}},getComponent:function(a){switch(a){case 0:return this.x;
case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+a);}},copy:function(a){this.x=a.x;this.y=a.y;this.z=a.z;this.w=void 0!==a.w?a.w:1;return this},add:function(a,b){if(void 0!==b)return console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(a,b);this.x+=a.x;this.y+=a.y;this.z+=a.z;this.w+=a.w;return this},addScalar:function(a){this.x+=a;this.y+=a;this.z+=a;this.w+=a;return this},
addVectors:function(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this},sub:function(a,b){if(void 0!==b)return console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(a,b);this.x-=a.x;this.y-=a.y;this.z-=a.z;this.w-=a.w;return this},subVectors:function(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this},multiplyScalar:function(a){this.x*=a;this.y*=a;this.z*=a;this.w*=a;return this},applyMatrix4:function(a){var b=
this.x,c=this.y,d=this.z,e=this.w;a=a.elements;this.x=a[0]*b+a[4]*c+a[8]*d+a[12]*e;this.y=a[1]*b+a[5]*c+a[9]*d+a[13]*e;this.z=a[2]*b+a[6]*c+a[10]*d+a[14]*e;this.w=a[3]*b+a[7]*c+a[11]*d+a[15]*e;return this},divideScalar:function(a){0!==a?(a=1/a,this.x*=a,this.y*=a,this.z*=a,this.w*=a):(this.z=this.y=this.x=0,this.w=1);return this},setAxisAngleFromQuaternion:function(a){this.w=2*Math.acos(a.w);var b=Math.sqrt(1-a.w*a.w);1E-4>b?(this.x=1,this.z=this.y=0):(this.x=a.x/b,this.y=a.y/b,this.z=a.z/b);return this},
setAxisAngleFromRotationMatrix:function(a){var b,c,d;a=a.elements;var e=a[0];d=a[4];var f=a[8],g=a[1],h=a[5],k=a[9];c=a[2];b=a[6];var m=a[10];if(0.01>Math.abs(d-g)&&0.01>Math.abs(f-c)&&0.01>Math.abs(k-b)){if(0.1>Math.abs(d+g)&&0.1>Math.abs(f+c)&&0.1>Math.abs(k+b)&&0.1>Math.abs(e+h+m-3))return this.set(1,0,0,0),this;a=Math.PI;e=(e+1)/2;h=(h+1)/2;m=(m+1)/2;d=(d+g)/4;f=(f+c)/4;k=(k+b)/4;e>h&&e>m?0.01>e?(b=0,d=c=0.707106781):(b=Math.sqrt(e),c=d/b,d=f/b):h>m?0.01>h?(b=0.707106781,c=0,d=0.707106781):(c=
Math.sqrt(h),b=d/c,d=k/c):0.01>m?(c=b=0.707106781,d=0):(d=Math.sqrt(m),b=f/d,c=k/d);this.set(b,c,d,a);return this}a=Math.sqrt((b-k)*(b-k)+(f-c)*(f-c)+(g-d)*(g-d));0.001>Math.abs(a)&&(a=1);this.x=(b-k)/a;this.y=(f-c)/a;this.z=(g-d)/a;this.w=Math.acos((e+h+m-1)/2);return this},min:function(a){this.x>a.x&&(this.x=a.x);this.y>a.y&&(this.y=a.y);this.z>a.z&&(this.z=a.z);this.w>a.w&&(this.w=a.w);return this},max:function(a){this.x<a.x&&(this.x=a.x);this.y<a.y&&(this.y=a.y);this.z<a.z&&(this.z=a.z);this.w<
a.w&&(this.w=a.w);return this},clamp:function(a,b){this.x<a.x?this.x=a.x:this.x>b.x&&(this.x=b.x);this.y<a.y?this.y=a.y:this.y>b.y&&(this.y=b.y);this.z<a.z?this.z=a.z:this.z>b.z&&(this.z=b.z);this.w<a.w?this.w=a.w:this.w>b.w&&(this.w=b.w);return this},clampScalar:function(){var a,b;return function(c,d){void 0===a&&(a=new THREE.Vector4,b=new THREE.Vector4);a.set(c,c,c,c);b.set(d,d,d,d);return this.clamp(a,b)}}(),floor:function(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);
this.w=Math.floor(this.w);return this},ceil:function(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this},round:function(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this},roundToZero:function(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);this.w=0>this.w?Math.ceil(this.w):
Math.floor(this.w);return this},negate:function(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},lengthManhattan:function(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)},normalize:function(){return this.divideScalar(this.length())},
setLength:function(a){var b=this.length();0!==b&&a!==b&&this.multiplyScalar(a/b);return this},lerp:function(a,b){this.x+=(a.x-this.x)*b;this.y+=(a.y-this.y)*b;this.z+=(a.z-this.z)*b;this.w+=(a.w-this.w)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z&&a.w===this.w},fromArray:function(a){this.x=a[0];this.y=a[1];this.z=a[2];this.w=a[3];return this},toArray:function(){return[this.x,this.y,this.z,this.w]},clone:function(){return new THREE.Vector4(this.x,this.y,this.z,
this.w)}};THREE.Euler=function(a,b,c,d){this._x=a||0;this._y=b||0;this._z=c||0;this._order=d||THREE.Euler.DefaultOrder};THREE.Euler.RotationOrders="XYZ YZX ZXY XZY YXZ ZYX".split(" ");THREE.Euler.DefaultOrder="XYZ";
THREE.Euler.prototype={constructor:THREE.Euler,_x:0,_y:0,_z:0,_order:THREE.Euler.DefaultOrder,get x(){return this._x},set x(a){this._x=a;this.onChangeCallback()},get y(){return this._y},set y(a){this._y=a;this.onChangeCallback()},get z(){return this._z},set z(a){this._z=a;this.onChangeCallback()},get order(){return this._order},set order(a){this._order=a;this.onChangeCallback()},set:function(a,b,c,d){this._x=a;this._y=b;this._z=c;this._order=d||this._order;this.onChangeCallback();return this},copy:function(a){this._x=
a._x;this._y=a._y;this._z=a._z;this._order=a._order;this.onChangeCallback();return this},setFromRotationMatrix:function(a,b){var c=THREE.Math.clamp,d=a.elements,e=d[0],f=d[4],g=d[8],h=d[1],k=d[5],m=d[9],l=d[2],n=d[6],d=d[10];b=b||this._order;"XYZ"===b?(this._y=Math.asin(c(g,-1,1)),0.99999>Math.abs(g)?(this._x=Math.atan2(-m,d),this._z=Math.atan2(-f,e)):(this._x=Math.atan2(n,k),this._z=0)):"YXZ"===b?(this._x=Math.asin(-c(m,-1,1)),0.99999>Math.abs(m)?(this._y=Math.atan2(g,d),this._z=Math.atan2(h,k)):
(this._y=Math.atan2(-l,e),this._z=0)):"ZXY"===b?(this._x=Math.asin(c(n,-1,1)),0.99999>Math.abs(n)?(this._y=Math.atan2(-l,d),this._z=Math.atan2(-f,k)):(this._y=0,this._z=Math.atan2(h,e))):"ZYX"===b?(this._y=Math.asin(-c(l,-1,1)),0.99999>Math.abs(l)?(this._x=Math.atan2(n,d),this._z=Math.atan2(h,e)):(this._x=0,this._z=Math.atan2(-f,k))):"YZX"===b?(this._z=Math.asin(c(h,-1,1)),0.99999>Math.abs(h)?(this._x=Math.atan2(-m,k),this._y=Math.atan2(-l,e)):(this._x=0,this._y=Math.atan2(g,d))):"XZY"===b?(this._z=
Math.asin(-c(f,-1,1)),0.99999>Math.abs(f)?(this._x=Math.atan2(n,k),this._y=Math.atan2(g,e)):(this._x=Math.atan2(-m,d),this._y=0)):console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: "+b);this._order=b;this.onChangeCallback();return this},setFromQuaternion:function(a,b,c){var d=THREE.Math.clamp,e=a.x*a.x,f=a.y*a.y,g=a.z*a.z,h=a.w*a.w;b=b||this._order;"XYZ"===b?(this._x=Math.atan2(2*(a.x*a.w-a.y*a.z),h-e-f+g),this._y=Math.asin(d(2*(a.x*a.z+a.y*a.w),-1,1)),this._z=Math.atan2(2*
(a.z*a.w-a.x*a.y),h+e-f-g)):"YXZ"===b?(this._x=Math.asin(d(2*(a.x*a.w-a.y*a.z),-1,1)),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),h-e-f+g),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),h-e+f-g)):"ZXY"===b?(this._x=Math.asin(d(2*(a.x*a.w+a.y*a.z),-1,1)),this._y=Math.atan2(2*(a.y*a.w-a.z*a.x),h-e-f+g),this._z=Math.atan2(2*(a.z*a.w-a.x*a.y),h-e+f-g)):"ZYX"===b?(this._x=Math.atan2(2*(a.x*a.w+a.z*a.y),h-e-f+g),this._y=Math.asin(d(2*(a.y*a.w-a.x*a.z),-1,1)),this._z=Math.atan2(2*(a.x*a.y+a.z*a.w),h+e-f-g)):"YZX"===
b?(this._x=Math.atan2(2*(a.x*a.w-a.z*a.y),h-e+f-g),this._y=Math.atan2(2*(a.y*a.w-a.x*a.z),h+e-f-g),this._z=Math.asin(d(2*(a.x*a.y+a.z*a.w),-1,1))):"XZY"===b?(this._x=Math.atan2(2*(a.x*a.w+a.y*a.z),h-e+f-g),this._y=Math.atan2(2*(a.x*a.z+a.y*a.w),h+e-f-g),this._z=Math.asin(d(2*(a.z*a.w-a.x*a.y),-1,1))):console.warn("THREE.Euler: .setFromQuaternion() given unsupported order: "+b);this._order=b;if(!1!==c)this.onChangeCallback();return this},reorder:function(){var a=new THREE.Quaternion;return function(b){a.setFromEuler(this);
this.setFromQuaternion(a,b)}}(),equals:function(a){return a._x===this._x&&a._y===this._y&&a._z===this._z&&a._order===this._order},fromArray:function(a){this._x=a[0];this._y=a[1];this._z=a[2];void 0!==a[3]&&(this._order=a[3]);this.onChangeCallback();return this},toArray:function(){return[this._x,this._y,this._z,this._order]},onChange:function(a){this.onChangeCallback=a;return this},onChangeCallback:function(){},clone:function(){return new THREE.Euler(this._x,this._y,this._z,this._order)}};
THREE.Line3=function(a,b){this.start=void 0!==a?a:new THREE.Vector3;this.end=void 0!==b?b:new THREE.Vector3};
THREE.Line3.prototype={constructor:THREE.Line3,set:function(a,b){this.start.copy(a);this.end.copy(b);return this},copy:function(a){this.start.copy(a.start);this.end.copy(a.end);return this},center:function(a){return(a||new THREE.Vector3).addVectors(this.start,this.end).multiplyScalar(0.5)},delta:function(a){return(a||new THREE.Vector3).subVectors(this.end,this.start)},distanceSq:function(){return this.start.distanceToSquared(this.end)},distance:function(){return this.start.distanceTo(this.end)},at:function(a,
b){var c=b||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},closestPointToPointParameter:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d){a.subVectors(c,this.start);b.subVectors(this.end,this.start);var e=b.dot(b),e=b.dot(a)/e;d&&(e=THREE.Math.clamp(e,0,1));return e}}(),closestPointToPoint:function(a,b,c){a=this.closestPointToPointParameter(a,b);c=c||new THREE.Vector3;return this.delta(c).multiplyScalar(a).add(this.start)},applyMatrix4:function(a){this.start.applyMatrix4(a);
this.end.applyMatrix4(a);return this},equals:function(a){return a.start.equals(this.start)&&a.end.equals(this.end)},clone:function(){return(new THREE.Line3).copy(this)}};THREE.Box2=function(a,b){this.min=void 0!==a?a:new THREE.Vector2(Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector2(-Infinity,-Infinity)};
THREE.Box2.prototype={constructor:THREE.Box2,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=new THREE.Vector2;return function(b,c){var d=a.copy(c).multiplyScalar(0.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=
this.min.y=Infinity;this.max.x=this.max.y=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y},center:function(a){return(a||new THREE.Vector2).addVectors(this.min,this.max).multiplyScalar(0.5)},size:function(a){return(a||new THREE.Vector2).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);
this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector2).set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>
this.max.y?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector2).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector2;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},union:function(a){this.min.min(a.min);this.max.max(a.max);return this},translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&
a.max.equals(this.max)},clone:function(){return(new THREE.Box2).copy(this)}};THREE.Box3=function(a,b){this.min=void 0!==a?a:new THREE.Vector3(Infinity,Infinity,Infinity);this.max=void 0!==b?b:new THREE.Vector3(-Infinity,-Infinity,-Infinity)};
THREE.Box3.prototype={constructor:THREE.Box3,set:function(a,b){this.min.copy(a);this.max.copy(b);return this},setFromPoints:function(a){this.makeEmpty();for(var b=0,c=a.length;b<c;b++)this.expandByPoint(a[b]);return this},setFromCenterAndSize:function(){var a=new THREE.Vector3;return function(b,c){var d=a.copy(c).multiplyScalar(0.5);this.min.copy(b).sub(d);this.max.copy(b).add(d);return this}}(),setFromObject:function(){var a=new THREE.Vector3;return function(b){var c=this;b.updateMatrixWorld(!0);
this.makeEmpty();b.traverse(function(b){if(void 0!==b.geometry&&void 0!==b.geometry.vertices)for(var e=b.geometry.vertices,f=0,g=e.length;f<g;f++)a.copy(e[f]),a.applyMatrix4(b.matrixWorld),c.expandByPoint(a)});return this}}(),copy:function(a){this.min.copy(a.min);this.max.copy(a.max);return this},makeEmpty:function(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this},empty:function(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z},
center:function(a){return(a||new THREE.Vector3).addVectors(this.min,this.max).multiplyScalar(0.5)},size:function(a){return(a||new THREE.Vector3).subVectors(this.max,this.min)},expandByPoint:function(a){this.min.min(a);this.max.max(a);return this},expandByVector:function(a){this.min.sub(a);this.max.add(a);return this},expandByScalar:function(a){this.min.addScalar(-a);this.max.addScalar(a);return this},containsPoint:function(a){return a.x<this.min.x||a.x>this.max.x||a.y<this.min.y||a.y>this.max.y||
a.z<this.min.z||a.z>this.max.z?!1:!0},containsBox:function(a){return this.min.x<=a.min.x&&a.max.x<=this.max.x&&this.min.y<=a.min.y&&a.max.y<=this.max.y&&this.min.z<=a.min.z&&a.max.z<=this.max.z?!0:!1},getParameter:function(a,b){return(b||new THREE.Vector3).set((a.x-this.min.x)/(this.max.x-this.min.x),(a.y-this.min.y)/(this.max.y-this.min.y),(a.z-this.min.z)/(this.max.z-this.min.z))},isIntersectionBox:function(a){return a.max.x<this.min.x||a.min.x>this.max.x||a.max.y<this.min.y||a.min.y>this.max.y||
a.max.z<this.min.z||a.min.z>this.max.z?!1:!0},clampPoint:function(a,b){return(b||new THREE.Vector3).copy(a).clamp(this.min,this.max)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){return a.copy(b).clamp(this.min,this.max).sub(b).length()}}(),getBoundingSphere:function(){var a=new THREE.Vector3;return function(b){b=b||new THREE.Sphere;b.center=this.center();b.radius=0.5*this.size(a).length();return b}}(),intersect:function(a){this.min.max(a.min);this.max.min(a.max);return this},
union:function(a){this.min.min(a.min);this.max.max(a.max);return this},applyMatrix4:function(){var a=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];return function(b){a[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(b);a[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(b);a[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(b);a[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(b);
a[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(b);a[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(b);a[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(b);a[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(b);this.makeEmpty();this.setFromPoints(a);return this}}(),translate:function(a){this.min.add(a);this.max.add(a);return this},equals:function(a){return a.min.equals(this.min)&&a.max.equals(this.max)},clone:function(){return(new THREE.Box3).copy(this)}};
THREE.Matrix3=function(a,b,c,d,e,f,g,h,k){var m=this.elements=new Float32Array(9);m[0]=void 0!==a?a:1;m[3]=b||0;m[6]=c||0;m[1]=d||0;m[4]=void 0!==e?e:1;m[7]=f||0;m[2]=g||0;m[5]=h||0;m[8]=void 0!==k?k:1};
THREE.Matrix3.prototype={constructor:THREE.Matrix3,set:function(a,b,c,d,e,f,g,h,k){var m=this.elements;m[0]=a;m[3]=b;m[6]=c;m[1]=d;m[4]=e;m[7]=f;m[2]=g;m[5]=h;m[8]=k;return this},identity:function(){this.set(1,0,0,0,1,0,0,0,1);return this},copy:function(a){a=a.elements;this.set(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8]);return this},multiplyVector3:function(a){console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");return a.applyMatrix3(this)},
multiplyVector3Array:function(a){console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");return this.applyToVector3Array(a)},applyToVector3Array:function(){var a=new THREE.Vector3;return function(b,c,d){void 0===c&&(c=0);void 0===d&&(d=b.length);for(var e=0;e<d;e+=3,c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyMatrix3(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[3]*=a;b[6]*=
a;b[1]*=a;b[4]*=a;b[7]*=a;b[2]*=a;b[5]*=a;b[8]*=a;return this},determinant:function(){var a=this.elements,b=a[0],c=a[1],d=a[2],e=a[3],f=a[4],g=a[5],h=a[6],k=a[7],a=a[8];return b*f*a-b*g*k-c*e*a+c*g*h+d*e*k-d*f*h},getInverse:function(a,b){var c=a.elements,d=this.elements;d[0]=c[10]*c[5]-c[6]*c[9];d[1]=-c[10]*c[1]+c[2]*c[9];d[2]=c[6]*c[1]-c[2]*c[5];d[3]=-c[10]*c[4]+c[6]*c[8];d[4]=c[10]*c[0]-c[2]*c[8];d[5]=-c[6]*c[0]+c[2]*c[4];d[6]=c[9]*c[4]-c[5]*c[8];d[7]=-c[9]*c[0]+c[1]*c[8];d[8]=c[5]*c[0]-c[1]*c[4];
c=c[0]*d[0]+c[1]*d[3]+c[2]*d[6];if(0===c){if(b)throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0");this.identity();return this}this.multiplyScalar(1/c);return this},transpose:function(){var a,b=this.elements;a=b[1];b[1]=b[3];b[3]=a;a=b[2];b[2]=b[6];b[6]=a;a=b[5];b[5]=b[7];b[7]=a;return this},flattenToArrayOffset:function(a,b){var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];
a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];return a},getNormalMatrix:function(a){this.getInverse(a).transpose();return this},transposeIntoArray:function(a){var b=this.elements;a[0]=b[0];a[1]=b[3];a[2]=b[6];a[3]=b[1];a[4]=b[4];a[5]=b[7];a[6]=b[2];a[7]=b[5];a[8]=b[8];return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8]]},clone:function(){var a=this.elements;return new THREE.Matrix3(a[0],a[3],
a[6],a[1],a[4],a[7],a[2],a[5],a[8])}};THREE.Matrix4=function(a,b,c,d,e,f,g,h,k,m,l,n,q,t,r,p){var s=this.elements=new Float32Array(16);s[0]=void 0!==a?a:1;s[4]=b||0;s[8]=c||0;s[12]=d||0;s[1]=e||0;s[5]=void 0!==f?f:1;s[9]=g||0;s[13]=h||0;s[2]=k||0;s[6]=m||0;s[10]=void 0!==l?l:1;s[14]=n||0;s[3]=q||0;s[7]=t||0;s[11]=r||0;s[15]=void 0!==p?p:1};
THREE.Matrix4.prototype={constructor:THREE.Matrix4,set:function(a,b,c,d,e,f,g,h,k,m,l,n,q,t,r,p){var s=this.elements;s[0]=a;s[4]=b;s[8]=c;s[12]=d;s[1]=e;s[5]=f;s[9]=g;s[13]=h;s[2]=k;s[6]=m;s[10]=l;s[14]=n;s[3]=q;s[7]=t;s[11]=r;s[15]=p;return this},identity:function(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this},copy:function(a){this.elements.set(a.elements);return this},extractPosition:function(a){console.warn("THREEMatrix4: .extractPosition() has been renamed to .copyPosition().");return this.copyPosition(a)},
copyPosition:function(a){var b=this.elements;a=a.elements;b[12]=a[12];b[13]=a[13];b[14]=a[14];return this},extractRotation:function(){var a=new THREE.Vector3;return function(b){var c=this.elements;b=b.elements;var d=1/a.set(b[0],b[1],b[2]).length(),e=1/a.set(b[4],b[5],b[6]).length(),f=1/a.set(b[8],b[9],b[10]).length();c[0]=b[0]*d;c[1]=b[1]*d;c[2]=b[2]*d;c[4]=b[4]*e;c[5]=b[5]*e;c[6]=b[6]*e;c[8]=b[8]*f;c[9]=b[9]*f;c[10]=b[10]*f;return this}}(),makeRotationFromEuler:function(a){!1===a instanceof THREE.Euler&&
console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");var b=this.elements,c=a.x,d=a.y,e=a.z,f=Math.cos(c),c=Math.sin(c),g=Math.cos(d),d=Math.sin(d),h=Math.cos(e),e=Math.sin(e);if("XYZ"===a.order){a=f*h;var k=f*e,m=c*h,l=c*e;b[0]=g*h;b[4]=-g*e;b[8]=d;b[1]=k+m*d;b[5]=a-l*d;b[9]=-c*g;b[2]=l-a*d;b[6]=m+k*d;b[10]=f*g}else"YXZ"===a.order?(a=g*h,k=g*e,m=d*h,l=d*e,b[0]=a+l*c,b[4]=m*c-k,b[8]=f*d,b[1]=f*e,b[5]=f*h,b[9]=-c,b[2]=k*c-m,b[6]=l+a*c,
b[10]=f*g):"ZXY"===a.order?(a=g*h,k=g*e,m=d*h,l=d*e,b[0]=a-l*c,b[4]=-f*e,b[8]=m+k*c,b[1]=k+m*c,b[5]=f*h,b[9]=l-a*c,b[2]=-f*d,b[6]=c,b[10]=f*g):"ZYX"===a.order?(a=f*h,k=f*e,m=c*h,l=c*e,b[0]=g*h,b[4]=m*d-k,b[8]=a*d+l,b[1]=g*e,b[5]=l*d+a,b[9]=k*d-m,b[2]=-d,b[6]=c*g,b[10]=f*g):"YZX"===a.order?(a=f*g,k=f*d,m=c*g,l=c*d,b[0]=g*h,b[4]=l-a*e,b[8]=m*e+k,b[1]=e,b[5]=f*h,b[9]=-c*h,b[2]=-d*h,b[6]=k*e+m,b[10]=a-l*e):"XZY"===a.order&&(a=f*g,k=f*d,m=c*g,l=c*d,b[0]=g*h,b[4]=-e,b[8]=d*h,b[1]=a*e+l,b[5]=f*h,b[9]=k*
e-m,b[2]=m*e-k,b[6]=c*h,b[10]=l*e+a);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},setRotationFromQuaternion:function(a){console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");return this.makeRotationFromQuaternion(a)},makeRotationFromQuaternion:function(a){var b=this.elements,c=a.x,d=a.y,e=a.z,f=a.w,g=c+c,h=d+d,k=e+e;a=c*g;var m=c*h,c=c*k,l=d*h,d=d*k,e=e*k,g=f*g,h=f*h,f=f*k;b[0]=1-(l+e);b[4]=m-f;b[8]=c+h;b[1]=m+f;b[5]=1-
(a+e);b[9]=d-g;b[2]=c-h;b[6]=d+g;b[10]=1-(a+l);b[3]=0;b[7]=0;b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return this},lookAt:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f){var g=this.elements;c.subVectors(d,e).normalize();0===c.length()&&(c.z=1);a.crossVectors(f,c).normalize();0===a.length()&&(c.x+=1E-4,a.crossVectors(f,c).normalize());b.crossVectors(c,a);g[0]=a.x;g[4]=b.x;g[8]=c.x;g[1]=a.y;g[5]=b.y;g[9]=c.y;g[2]=a.z;g[6]=b.z;g[10]=c.z;return this}}(),
multiply:function(a,b){return void 0!==b?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(a,b)):this.multiplyMatrices(this,a)},multiplyMatrices:function(a,b){var c=a.elements,d=b.elements,e=this.elements,f=c[0],g=c[4],h=c[8],k=c[12],m=c[1],l=c[5],n=c[9],q=c[13],t=c[2],r=c[6],p=c[10],s=c[14],u=c[3],x=c[7],A=c[11],c=c[15],w=d[0],v=d[4],z=d[8],F=d[12],B=d[1],y=d[5],E=d[9],J=d[13],M=d[2],K=d[6],Q=d[10],L=d[14],H=d[3],
G=d[7],C=d[11],d=d[15];e[0]=f*w+g*B+h*M+k*H;e[4]=f*v+g*y+h*K+k*G;e[8]=f*z+g*E+h*Q+k*C;e[12]=f*F+g*J+h*L+k*d;e[1]=m*w+l*B+n*M+q*H;e[5]=m*v+l*y+n*K+q*G;e[9]=m*z+l*E+n*Q+q*C;e[13]=m*F+l*J+n*L+q*d;e[2]=t*w+r*B+p*M+s*H;e[6]=t*v+r*y+p*K+s*G;e[10]=t*z+r*E+p*Q+s*C;e[14]=t*F+r*J+p*L+s*d;e[3]=u*w+x*B+A*M+c*H;e[7]=u*v+x*y+A*K+c*G;e[11]=u*z+x*E+A*Q+c*C;e[15]=u*F+x*J+A*L+c*d;return this},multiplyToArray:function(a,b,c){var d=this.elements;this.multiplyMatrices(a,b);c[0]=d[0];c[1]=d[1];c[2]=d[2];c[3]=d[3];c[4]=
d[4];c[5]=d[5];c[6]=d[6];c[7]=d[7];c[8]=d[8];c[9]=d[9];c[10]=d[10];c[11]=d[11];c[12]=d[12];c[13]=d[13];c[14]=d[14];c[15]=d[15];return this},multiplyScalar:function(a){var b=this.elements;b[0]*=a;b[4]*=a;b[8]*=a;b[12]*=a;b[1]*=a;b[5]*=a;b[9]*=a;b[13]*=a;b[2]*=a;b[6]*=a;b[10]*=a;b[14]*=a;b[3]*=a;b[7]*=a;b[11]*=a;b[15]*=a;return this},multiplyVector3:function(a){console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
return a.applyProjection(this)},multiplyVector4:function(a){console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");return a.applyMatrix4(this)},multiplyVector3Array:function(a){console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.");return this.applyToVector3Array(a)},applyToVector3Array:function(){var a=new THREE.Vector3;return function(b,c,d){void 0===c&&(c=0);void 0===d&&(d=
b.length);for(var e=0;e<d;e+=3,c+=3)a.x=b[c],a.y=b[c+1],a.z=b[c+2],a.applyMatrix4(this),b[c]=a.x,b[c+1]=a.y,b[c+2]=a.z;return b}}(),rotateAxis:function(a){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");a.transformDirection(this)},crossVector:function(a){console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");return a.applyMatrix4(this)},determinant:function(){var a=this.elements,b=
a[0],c=a[4],d=a[8],e=a[12],f=a[1],g=a[5],h=a[9],k=a[13],m=a[2],l=a[6],n=a[10],q=a[14];return a[3]*(+e*h*l-d*k*l-e*g*n+c*k*n+d*g*q-c*h*q)+a[7]*(+b*h*q-b*k*n+e*f*n-d*f*q+d*k*m-e*h*m)+a[11]*(+b*k*l-b*g*q-e*f*l+c*f*q+e*g*m-c*k*m)+a[15]*(-d*g*m-b*h*l+b*g*n+d*f*l-c*f*n+c*h*m)},transpose:function(){var a=this.elements,b;b=a[1];a[1]=a[4];a[4]=b;b=a[2];a[2]=a[8];a[8]=b;b=a[6];a[6]=a[9];a[9]=b;b=a[3];a[3]=a[12];a[12]=b;b=a[7];a[7]=a[13];a[13]=b;b=a[11];a[11]=a[14];a[14]=b;return this},flattenToArrayOffset:function(a,
b){var c=this.elements;a[b]=c[0];a[b+1]=c[1];a[b+2]=c[2];a[b+3]=c[3];a[b+4]=c[4];a[b+5]=c[5];a[b+6]=c[6];a[b+7]=c[7];a[b+8]=c[8];a[b+9]=c[9];a[b+10]=c[10];a[b+11]=c[11];a[b+12]=c[12];a[b+13]=c[13];a[b+14]=c[14];a[b+15]=c[15];return a},getPosition:function(){var a=new THREE.Vector3;return function(){console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");var b=this.elements;return a.set(b[12],b[13],b[14])}}(),setPosition:function(a){var b=
this.elements;b[12]=a.x;b[13]=a.y;b[14]=a.z;return this},getInverse:function(a,b){var c=this.elements,d=a.elements,e=d[0],f=d[4],g=d[8],h=d[12],k=d[1],m=d[5],l=d[9],n=d[13],q=d[2],t=d[6],r=d[10],p=d[14],s=d[3],u=d[7],x=d[11],d=d[15];c[0]=l*p*u-n*r*u+n*t*x-m*p*x-l*t*d+m*r*d;c[4]=h*r*u-g*p*u-h*t*x+f*p*x+g*t*d-f*r*d;c[8]=g*n*u-h*l*u+h*m*x-f*n*x-g*m*d+f*l*d;c[12]=h*l*t-g*n*t-h*m*r+f*n*r+g*m*p-f*l*p;c[1]=n*r*s-l*p*s-n*q*x+k*p*x+l*q*d-k*r*d;c[5]=g*p*s-h*r*s+h*q*x-e*p*x-g*q*d+e*r*d;c[9]=h*l*s-g*n*s-h*k*
x+e*n*x+g*k*d-e*l*d;c[13]=g*n*q-h*l*q+h*k*r-e*n*r-g*k*p+e*l*p;c[2]=m*p*s-n*t*s+n*q*u-k*p*u-m*q*d+k*t*d;c[6]=h*t*s-f*p*s-h*q*u+e*p*u+f*q*d-e*t*d;c[10]=f*n*s-h*m*s+h*k*u-e*n*u-f*k*d+e*m*d;c[14]=h*m*q-f*n*q-h*k*t+e*n*t+f*k*p-e*m*p;c[3]=l*t*s-m*r*s-l*q*u+k*r*u+m*q*x-k*t*x;c[7]=f*r*s-g*t*s+g*q*u-e*r*u-f*q*x+e*t*x;c[11]=g*m*s-f*l*s-g*k*u+e*l*u+f*k*x-e*m*x;c[15]=f*l*q-g*m*q+g*k*t-e*l*t-f*k*r+e*m*r;c=e*c[0]+k*c[4]+q*c[8]+s*c[12];if(0==c){if(b)throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0");this.identity();return this}this.multiplyScalar(1/c);return this},translate:function(a){console.warn("THREE.Matrix4: .translate() has been removed.")},rotateX:function(a){console.warn("THREE.Matrix4: .rotateX() has been removed.")},rotateY:function(a){console.warn("THREE.Matrix4: .rotateY() has been removed.")},rotateZ:function(a){console.warn("THREE.Matrix4: .rotateZ() has been removed.")},rotateByAxis:function(a,b){console.warn("THREE.Matrix4: .rotateByAxis() has been removed.")},
scale:function(a){var b=this.elements,c=a.x,d=a.y;a=a.z;b[0]*=c;b[4]*=d;b[8]*=a;b[1]*=c;b[5]*=d;b[9]*=a;b[2]*=c;b[6]*=d;b[10]*=a;b[3]*=c;b[7]*=d;b[11]*=a;return this},getMaxScaleOnAxis:function(){var a=this.elements;return Math.sqrt(Math.max(a[0]*a[0]+a[1]*a[1]+a[2]*a[2],Math.max(a[4]*a[4]+a[5]*a[5]+a[6]*a[6],a[8]*a[8]+a[9]*a[9]+a[10]*a[10])))},makeTranslation:function(a,b,c){this.set(1,0,0,a,0,1,0,b,0,0,1,c,0,0,0,1);return this},makeRotationX:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(1,
0,0,0,0,b,-a,0,0,a,b,0,0,0,0,1);return this},makeRotationY:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,0,a,0,0,1,0,0,-a,0,b,0,0,0,0,1);return this},makeRotationZ:function(a){var b=Math.cos(a);a=Math.sin(a);this.set(b,-a,0,0,a,b,0,0,0,0,1,0,0,0,0,1);return this},makeRotationAxis:function(a,b){var c=Math.cos(b),d=Math.sin(b),e=1-c,f=a.x,g=a.y,h=a.z,k=e*f,m=e*g;this.set(k*f+c,k*g-d*h,k*h+d*g,0,k*g+d*h,m*g+c,m*h-d*f,0,k*h-d*g,m*h+d*f,e*h*h+c,0,0,0,0,1);return this},makeScale:function(a,b,c){this.set(a,
0,0,0,0,b,0,0,0,0,c,0,0,0,0,1);return this},compose:function(a,b,c){this.makeRotationFromQuaternion(b);this.scale(c);this.setPosition(a);return this},decompose:function(){var a=new THREE.Vector3,b=new THREE.Matrix4;return function(c,d,e){var f=this.elements,g=a.set(f[0],f[1],f[2]).length(),h=a.set(f[4],f[5],f[6]).length(),k=a.set(f[8],f[9],f[10]).length();0>this.determinant()&&(g=-g);c.x=f[12];c.y=f[13];c.z=f[14];b.elements.set(this.elements);c=1/g;var f=1/h,m=1/k;b.elements[0]*=c;b.elements[1]*=
c;b.elements[2]*=c;b.elements[4]*=f;b.elements[5]*=f;b.elements[6]*=f;b.elements[8]*=m;b.elements[9]*=m;b.elements[10]*=m;d.setFromRotationMatrix(b);e.x=g;e.y=h;e.z=k;return this}}(),makeFrustum:function(a,b,c,d,e,f){var g=this.elements;g[0]=2*e/(b-a);g[4]=0;g[8]=(b+a)/(b-a);g[12]=0;g[1]=0;g[5]=2*e/(d-c);g[9]=(d+c)/(d-c);g[13]=0;g[2]=0;g[6]=0;g[10]=-(f+e)/(f-e);g[14]=-2*f*e/(f-e);g[3]=0;g[7]=0;g[11]=-1;g[15]=0;return this},makePerspective:function(a,b,c,d){a=c*Math.tan(THREE.Math.degToRad(0.5*a));
var e=-a;return this.makeFrustum(e*b,a*b,e,a,c,d)},makeOrthographic:function(a,b,c,d,e,f){var g=this.elements,h=b-a,k=c-d,m=f-e;g[0]=2/h;g[4]=0;g[8]=0;g[12]=-((b+a)/h);g[1]=0;g[5]=2/k;g[9]=0;g[13]=-((c+d)/k);g[2]=0;g[6]=0;g[10]=-2/m;g[14]=-((f+e)/m);g[3]=0;g[7]=0;g[11]=0;g[15]=1;return this},fromArray:function(a){this.elements.set(a);return this},toArray:function(){var a=this.elements;return[a[0],a[1],a[2],a[3],a[4],a[5],a[6],a[7],a[8],a[9],a[10],a[11],a[12],a[13],a[14],a[15]]},clone:function(){var a=
this.elements;return new THREE.Matrix4(a[0],a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15])}};THREE.Ray=function(a,b){this.origin=void 0!==a?a:new THREE.Vector3;this.direction=void 0!==b?b:new THREE.Vector3};
THREE.Ray.prototype={constructor:THREE.Ray,set:function(a,b){this.origin.copy(a);this.direction.copy(b);return this},copy:function(a){this.origin.copy(a.origin);this.direction.copy(a.direction);return this},at:function(a,b){return(b||new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)},recast:function(){var a=new THREE.Vector3;return function(b){this.origin.copy(this.at(b,a));return this}}(),closestPointToPoint:function(a,b){var c=b||new THREE.Vector3;c.subVectors(a,this.origin);
var d=c.dot(this.direction);return 0>d?c.copy(this.origin):c.copy(this.direction).multiplyScalar(d).add(this.origin)},distanceToPoint:function(){var a=new THREE.Vector3;return function(b){var c=a.subVectors(b,this.origin).dot(this.direction);if(0>c)return this.origin.distanceTo(b);a.copy(this.direction).multiplyScalar(c).add(this.origin);return a.distanceTo(b)}}(),distanceSqToSegment:function(a,b,c,d){var e=a.clone().add(b).multiplyScalar(0.5),f=b.clone().sub(a).normalize(),g=0.5*a.distanceTo(b),
h=this.origin.clone().sub(e);a=-this.direction.dot(f);b=h.dot(this.direction);var k=-h.dot(f),m=h.lengthSq(),l=Math.abs(1-a*a),n,q;0<=l?(h=a*k-b,n=a*b-k,q=g*l,0<=h?n>=-q?n<=q?(g=1/l,h*=g,n*=g,a=h*(h+a*n+2*b)+n*(a*h+n+2*k)+m):(n=g,h=Math.max(0,-(a*n+b)),a=-h*h+n*(n+2*k)+m):(n=-g,h=Math.max(0,-(a*n+b)),a=-h*h+n*(n+2*k)+m):n<=-q?(h=Math.max(0,-(-a*g+b)),n=0<h?-g:Math.min(Math.max(-g,-k),g),a=-h*h+n*(n+2*k)+m):n<=q?(h=0,n=Math.min(Math.max(-g,-k),g),a=n*(n+2*k)+m):(h=Math.max(0,-(a*g+b)),n=0<h?g:Math.min(Math.max(-g,
-k),g),a=-h*h+n*(n+2*k)+m)):(n=0<a?-g:g,h=Math.max(0,-(a*n+b)),a=-h*h+n*(n+2*k)+m);c&&c.copy(this.direction.clone().multiplyScalar(h).add(this.origin));d&&d.copy(f.clone().multiplyScalar(n).add(e));return a},isIntersectionSphere:function(a){return this.distanceToPoint(a.center)<=a.radius},intersectSphere:function(){var a=new THREE.Vector3;return function(b,c){a.subVectors(b.center,this.origin);var d=a.dot(this.direction),e=a.dot(a)-d*d,f=b.radius*b.radius;if(e>f)return null;f=Math.sqrt(f-e);e=d-f;
d+=f;return 0>e&&0>d?null:0>e?this.at(d,c):this.at(e,c)}}(),isIntersectionPlane:function(a){var b=a.distanceToPoint(this.origin);return 0===b||0>a.normal.dot(this.direction)*b?!0:!1},distanceToPlane:function(a){var b=a.normal.dot(this.direction);if(0==b)return 0==a.distanceToPoint(this.origin)?0:null;a=-(this.origin.dot(a.normal)+a.constant)/b;return 0<=a?a:null},intersectPlane:function(a,b){var c=this.distanceToPlane(a);return null===c?null:this.at(c,b)},isIntersectionBox:function(){var a=new THREE.Vector3;
return function(b){return null!==this.intersectBox(b,a)}}(),intersectBox:function(a,b){var c,d,e,f,g;d=1/this.direction.x;f=1/this.direction.y;g=1/this.direction.z;var h=this.origin;0<=d?(c=(a.min.x-h.x)*d,d*=a.max.x-h.x):(c=(a.max.x-h.x)*d,d*=a.min.x-h.x);0<=f?(e=(a.min.y-h.y)*f,f*=a.max.y-h.y):(e=(a.max.y-h.y)*f,f*=a.min.y-h.y);if(c>f||e>d)return null;if(e>c||c!==c)c=e;if(f<d||d!==d)d=f;0<=g?(e=(a.min.z-h.z)*g,g*=a.max.z-h.z):(e=(a.max.z-h.z)*g,g*=a.min.z-h.z);if(c>g||e>d)return null;if(e>c||c!==
c)c=e;if(g<d||d!==d)d=g;return 0>d?null:this.at(0<=c?c:d,b)},intersectTriangle:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3,d=new THREE.Vector3;return function(e,f,g,h,k){b.subVectors(f,e);c.subVectors(g,e);d.crossVectors(b,c);f=this.direction.dot(d);if(0<f){if(h)return null;h=1}else if(0>f)h=-1,f=-f;else return null;a.subVectors(this.origin,e);e=h*this.direction.dot(c.crossVectors(a,c));if(0>e)return null;g=h*this.direction.dot(b.cross(a));if(0>g||e+g>f)return null;
e=-h*a.dot(d);return 0>e?null:this.at(e/f,k)}}(),applyMatrix4:function(a){this.direction.add(this.origin).applyMatrix4(a);this.origin.applyMatrix4(a);this.direction.sub(this.origin);this.direction.normalize();return this},equals:function(a){return a.origin.equals(this.origin)&&a.direction.equals(this.direction)},clone:function(){return(new THREE.Ray).copy(this)}};THREE.Sphere=function(a,b){this.center=void 0!==a?a:new THREE.Vector3;this.radius=void 0!==b?b:0};
THREE.Sphere.prototype={constructor:THREE.Sphere,set:function(a,b){this.center.copy(a);this.radius=b;return this},setFromPoints:function(){var a=new THREE.Box3;return function(b,c){var d=this.center;void 0!==c?d.copy(c):a.setFromPoints(b).center(d);for(var e=0,f=0,g=b.length;f<g;f++)e=Math.max(e,d.distanceToSquared(b[f]));this.radius=Math.sqrt(e);return this}}(),copy:function(a){this.center.copy(a.center);this.radius=a.radius;return this},empty:function(){return 0>=this.radius},containsPoint:function(a){return a.distanceToSquared(this.center)<=
this.radius*this.radius},distanceToPoint:function(a){return a.distanceTo(this.center)-this.radius},intersectsSphere:function(a){var b=this.radius+a.radius;return a.center.distanceToSquared(this.center)<=b*b},clampPoint:function(a,b){var c=this.center.distanceToSquared(a),d=b||new THREE.Vector3;d.copy(a);c>this.radius*this.radius&&(d.sub(this.center).normalize(),d.multiplyScalar(this.radius).add(this.center));return d},getBoundingBox:function(a){a=a||new THREE.Box3;a.set(this.center,this.center);a.expandByScalar(this.radius);
return a},applyMatrix4:function(a){this.center.applyMatrix4(a);this.radius*=a.getMaxScaleOnAxis();return this},translate:function(a){this.center.add(a);return this},equals:function(a){return a.center.equals(this.center)&&a.radius===this.radius},clone:function(){return(new THREE.Sphere).copy(this)}};
THREE.Frustum=function(a,b,c,d,e,f){this.planes=[void 0!==a?a:new THREE.Plane,void 0!==b?b:new THREE.Plane,void 0!==c?c:new THREE.Plane,void 0!==d?d:new THREE.Plane,void 0!==e?e:new THREE.Plane,void 0!==f?f:new THREE.Plane]};
THREE.Frustum.prototype={constructor:THREE.Frustum,set:function(a,b,c,d,e,f){var g=this.planes;g[0].copy(a);g[1].copy(b);g[2].copy(c);g[3].copy(d);g[4].copy(e);g[5].copy(f);return this},copy:function(a){for(var b=this.planes,c=0;6>c;c++)b[c].copy(a.planes[c]);return this},setFromMatrix:function(a){var b=this.planes,c=a.elements;a=c[0];var d=c[1],e=c[2],f=c[3],g=c[4],h=c[5],k=c[6],m=c[7],l=c[8],n=c[9],q=c[10],t=c[11],r=c[12],p=c[13],s=c[14],c=c[15];b[0].setComponents(f-a,m-g,t-l,c-r).normalize();b[1].setComponents(f+
a,m+g,t+l,c+r).normalize();b[2].setComponents(f+d,m+h,t+n,c+p).normalize();b[3].setComponents(f-d,m-h,t-n,c-p).normalize();b[4].setComponents(f-e,m-k,t-q,c-s).normalize();b[5].setComponents(f+e,m+k,t+q,c+s).normalize();return this},intersectsObject:function(){var a=new THREE.Sphere;return function(b){var c=b.geometry;null===c.boundingSphere&&c.computeBoundingSphere();a.copy(c.boundingSphere);a.applyMatrix4(b.matrixWorld);return this.intersectsSphere(a)}}(),intersectsSphere:function(a){var b=this.planes,
c=a.center;a=-a.radius;for(var d=0;6>d;d++)if(b[d].distanceToPoint(c)<a)return!1;return!0},intersectsBox:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c){for(var d=this.planes,e=0;6>e;e++){var f=d[e];a.x=0<f.normal.x?c.min.x:c.max.x;b.x=0<f.normal.x?c.max.x:c.min.x;a.y=0<f.normal.y?c.min.y:c.max.y;b.y=0<f.normal.y?c.max.y:c.min.y;a.z=0<f.normal.z?c.min.z:c.max.z;b.z=0<f.normal.z?c.max.z:c.min.z;var g=f.distanceToPoint(a),f=f.distanceToPoint(b);if(0>g&&0>f)return!1}return!0}}(),
containsPoint:function(a){for(var b=this.planes,c=0;6>c;c++)if(0>b[c].distanceToPoint(a))return!1;return!0},clone:function(){return(new THREE.Frustum).copy(this)}};THREE.Plane=function(a,b){this.normal=void 0!==a?a:new THREE.Vector3(1,0,0);this.constant=void 0!==b?b:0};
THREE.Plane.prototype={constructor:THREE.Plane,set:function(a,b){this.normal.copy(a);this.constant=b;return this},setComponents:function(a,b,c,d){this.normal.set(a,b,c);this.constant=d;return this},setFromNormalAndCoplanarPoint:function(a,b){this.normal.copy(a);this.constant=-b.dot(this.normal);return this},setFromCoplanarPoints:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(c,d,e){d=a.subVectors(e,d).cross(b.subVectors(c,d)).normalize();this.setFromNormalAndCoplanarPoint(d,
c);return this}}(),copy:function(a){this.normal.copy(a.normal);this.constant=a.constant;return this},normalize:function(){var a=1/this.normal.length();this.normal.multiplyScalar(a);this.constant*=a;return this},negate:function(){this.constant*=-1;this.normal.negate();return this},distanceToPoint:function(a){return this.normal.dot(a)+this.constant},distanceToSphere:function(a){return this.distanceToPoint(a.center)-a.radius},projectPoint:function(a,b){return this.orthoPoint(a,b).sub(a).negate()},orthoPoint:function(a,
b){var c=this.distanceToPoint(a);return(b||new THREE.Vector3).copy(this.normal).multiplyScalar(c)},isIntersectionLine:function(a){var b=this.distanceToPoint(a.start);a=this.distanceToPoint(a.end);return 0>b&&0<a||0>a&&0<b},intersectLine:function(){var a=new THREE.Vector3;return function(b,c){var d=c||new THREE.Vector3,e=b.delta(a),f=this.normal.dot(e);if(0==f){if(0==this.distanceToPoint(b.start))return d.copy(b.start)}else return f=-(b.start.dot(this.normal)+this.constant)/f,0>f||1<f?void 0:d.copy(e).multiplyScalar(f).add(b.start)}}(),
coplanarPoint:function(a){return(a||new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)},applyMatrix4:function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Matrix3;return function(d,e){var f=e||c.getNormalMatrix(d),f=a.copy(this.normal).applyMatrix3(f),g=this.coplanarPoint(b);g.applyMatrix4(d);this.setFromNormalAndCoplanarPoint(f,g);return this}}(),translate:function(a){this.constant-=a.dot(this.normal);return this},equals:function(a){return a.normal.equals(this.normal)&&
a.constant==this.constant},clone:function(){return(new THREE.Plane).copy(this)}};
THREE.Math={generateUUID:function(){var a="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),b=Array(36),c=0,d;return function(){for(var e=0;36>e;e++)8==e||13==e||18==e||23==e?b[e]="-":14==e?b[e]="4":(2>=c&&(c=33554432+16777216*Math.random()|0),d=c&15,c>>=4,b[e]=a[19==e?d&3|8:d]);return b.join("")}}(),clamp:function(a,b,c){return a<b?b:a>c?c:a},clampBottom:function(a,b){return a<b?b:a},mapLinear:function(a,b,c,d,e){return d+(a-b)*(e-d)/(c-b)},smoothstep:function(a,b,c){if(a<=
b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*(3-2*a)},smootherstep:function(a,b,c){if(a<=b)return 0;if(a>=c)return 1;a=(a-b)/(c-b);return a*a*a*(a*(6*a-15)+10)},random16:function(){return(65280*Math.random()+255*Math.random())/65535},randInt:function(a,b){return a+Math.floor(Math.random()*(b-a+1))},randFloat:function(a,b){return a+Math.random()*(b-a)},randFloatSpread:function(a){return a*(0.5-Math.random())},sign:function(a){return 0>a?-1:0<a?1:0},degToRad:function(){var a=Math.PI/180;return function(b){return b*
a}}(),radToDeg:function(){var a=180/Math.PI;return function(b){return b*a}}(),isPowerOfTwo:function(a){return 0===(a&a-1)&&0!==a}};
THREE.Spline=function(a){function b(a,b,c,d,e,f,g){a=0.5*(c-a);d=0.5*(d-b);return(2*(b-c)+a+d)*g+(-3*(b-c)-2*a-d)*f+a*e+b}this.points=a;var c=[],d={x:0,y:0,z:0},e,f,g,h,k,m,l,n,q;this.initFromArray=function(a){this.points=[];for(var b=0;b<a.length;b++)this.points[b]={x:a[b][0],y:a[b][1],z:a[b][2]}};this.getPoint=function(a){e=(this.points.length-1)*a;f=Math.floor(e);g=e-f;c[0]=0===f?f:f-1;c[1]=f;c[2]=f>this.points.length-2?this.points.length-1:f+1;c[3]=f>this.points.length-3?this.points.length-1:
f+2;m=this.points[c[0]];l=this.points[c[1]];n=this.points[c[2]];q=this.points[c[3]];h=g*g;k=g*h;d.x=b(m.x,l.x,n.x,q.x,g,h,k);d.y=b(m.y,l.y,n.y,q.y,g,h,k);d.z=b(m.z,l.z,n.z,q.z,g,h,k);return d};this.getControlPointsArray=function(){var a,b,c=this.points.length,d=[];for(a=0;a<c;a++)b=this.points[a],d[a]=[b.x,b.y,b.z];return d};this.getLength=function(a){var b,c,d,e=b=b=0,f=new THREE.Vector3,g=new THREE.Vector3,h=[],k=0;h[0]=0;a||(a=100);c=this.points.length*a;f.copy(this.points[0]);for(a=1;a<c;a++)b=
a/c,d=this.getPoint(b),g.copy(d),k+=g.distanceTo(f),f.copy(d),b*=this.points.length-1,b=Math.floor(b),b!=e&&(h[b]=k,e=b);h[h.length]=k;return{chunks:h,total:k}};this.reparametrizeByArcLength=function(a){var b,c,d,e,f,g,h=[],k=new THREE.Vector3,l=this.getLength();h.push(k.copy(this.points[0]).clone());for(b=1;b<this.points.length;b++){c=l.chunks[b]-l.chunks[b-1];g=Math.ceil(a*c/l.total);e=(b-1)/(this.points.length-1);f=b/(this.points.length-1);for(c=1;c<g-1;c++)d=e+1/g*c*(f-e),d=this.getPoint(d),h.push(k.copy(d).clone());
h.push(k.copy(this.points[b]).clone())}this.points=h}};THREE.Triangle=function(a,b,c){this.a=void 0!==a?a:new THREE.Vector3;this.b=void 0!==b?b:new THREE.Vector3;this.c=void 0!==c?c:new THREE.Vector3};THREE.Triangle.normal=function(){var a=new THREE.Vector3;return function(b,c,d,e){e=e||new THREE.Vector3;e.subVectors(d,c);a.subVectors(b,c);e.cross(a);b=e.lengthSq();return 0<b?e.multiplyScalar(1/Math.sqrt(b)):e.set(0,0,0)}}();
THREE.Triangle.barycoordFromPoint=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(d,e,f,g,h){a.subVectors(g,e);b.subVectors(f,e);c.subVectors(d,e);d=a.dot(a);e=a.dot(b);f=a.dot(c);var k=b.dot(b);g=b.dot(c);var m=d*k-e*e;h=h||new THREE.Vector3;if(0==m)return h.set(-2,-1,-1);m=1/m;k=(k*f-e*g)*m;d=(d*g-e*f)*m;return h.set(1-k-d,d,k)}}();
THREE.Triangle.containsPoint=function(){var a=new THREE.Vector3;return function(b,c,d,e){b=THREE.Triangle.barycoordFromPoint(b,c,d,e,a);return 0<=b.x&&0<=b.y&&1>=b.x+b.y}}();
THREE.Triangle.prototype={constructor:THREE.Triangle,set:function(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this},setFromPointsAndIndices:function(a,b,c,d){this.a.copy(a[b]);this.b.copy(a[c]);this.c.copy(a[d]);return this},copy:function(a){this.a.copy(a.a);this.b.copy(a.b);this.c.copy(a.c);return this},area:function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){a.subVectors(this.c,this.b);b.subVectors(this.a,this.b);return 0.5*a.cross(b).length()}}(),midpoint:function(a){return(a||
new THREE.Vector3).addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)},normal:function(a){return THREE.Triangle.normal(this.a,this.b,this.c,a)},plane:function(a){return(a||new THREE.Plane).setFromCoplanarPoints(this.a,this.b,this.c)},barycoordFromPoint:function(a,b){return THREE.Triangle.barycoordFromPoint(a,this.a,this.b,this.c,b)},containsPoint:function(a){return THREE.Triangle.containsPoint(a,this.a,this.b,this.c)},equals:function(a){return a.a.equals(this.a)&&a.b.equals(this.b)&&a.c.equals(this.c)},
clone:function(){return(new THREE.Triangle).copy(this)}};THREE.Clock=function(a){this.autoStart=void 0!==a?a:!0;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1};
THREE.Clock.prototype={constructor:THREE.Clock,start:function(){this.oldTime=this.startTime=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now();this.running=!0},stop:function(){this.getElapsedTime();this.running=!1},getElapsedTime:function(){this.getDelta();return this.elapsedTime},getDelta:function(){var a=0;this.autoStart&&!this.running&&this.start();if(this.running){var b=void 0!==self.performance&&void 0!==self.performance.now?self.performance.now():Date.now(),
a=0.001*(b-this.oldTime);this.oldTime=b;this.elapsedTime+=a}return a}};THREE.EventDispatcher=function(){};
THREE.EventDispatcher.prototype={constructor:THREE.EventDispatcher,apply:function(a){a.addEventListener=THREE.EventDispatcher.prototype.addEventListener;a.hasEventListener=THREE.EventDispatcher.prototype.hasEventListener;a.removeEventListener=THREE.EventDispatcher.prototype.removeEventListener;a.dispatchEvent=THREE.EventDispatcher.prototype.dispatchEvent},addEventListener:function(a,b){void 0===this._listeners&&(this._listeners={});var c=this._listeners;void 0===c[a]&&(c[a]=[]);-1===c[a].indexOf(b)&&
c[a].push(b)},hasEventListener:function(a,b){if(void 0===this._listeners)return!1;var c=this._listeners;return void 0!==c[a]&&-1!==c[a].indexOf(b)?!0:!1},removeEventListener:function(a,b){if(void 0!==this._listeners){var c=this._listeners[a];if(void 0!==c){var d=c.indexOf(b);-1!==d&&c.splice(d,1)}}},dispatchEvent:function(a){if(void 0!==this._listeners){var b=this._listeners[a.type];if(void 0!==b){a.target=this;for(var c=[],d=b.length,e=0;e<d;e++)c[e]=b[e];for(e=0;e<d;e++)c[e].call(this,a)}}}};
(function(a){a.Raycaster=function(b,c,f,g){this.ray=new a.Ray(b,c);this.near=f||0;this.far=g||Infinity;this.params={Sprite:{},Mesh:{},PointCloud:{threshold:1},LOD:{},Line:{}}};var b=function(a,b){return a.distance-b.distance},c=function(a,b,f,g){a.raycast(b,f);if(!0===g&&(a=a.children)){g=0;for(var h=a.length;g<h;g++)c(a[g],b,f,!0)}};a.Raycaster.prototype={constructor:a.Raycaster,precision:1E-4,linePrecision:1,set:function(a,b){this.ray.set(a,b)},intersectObject:function(a,e){var f=[];c(a,this,f,
e);f.sort(b);return f},intersectObjects:function(a,e){for(var f=[],g=0,h=a.length;g<h;g++)c(a[g],this,f,e);f.sort(b);return f}}})(THREE);
THREE.Object3D=function(a){this.id=THREE.Object3DIdCount++;this.parent=void 0;if(a)this.matrixAutoUpdate=!1,this.skipModTerms=!0;else{this.up=THREE.Object3D.DefaultUp.clone();a=new THREE.Vector3;var b=new THREE.Euler,c=new THREE.Quaternion,d=new THREE.Vector3(1,1,1);b.onChange(function(){c.setFromEuler(b,!1)});c.onChange(function(){b.setFromQuaternion(c,void 0,!1)});Object.defineProperties(this,{position:{enumerable:!0,value:a},rotation:{enumerable:!0,value:b},quaternion:{enumerable:!0,value:c},scale:{enumerable:!0,
value:d}});this.matrix=new THREE.Matrix4;this.rotationAutoUpdate=this.matrixAutoUpdate=!0;this.skipModTerms=!1}this.renderDepth=null;this.matrixWorld=new THREE.Matrix4;this.visible=this.matrixWorldNeedsUpdate=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=!0};THREE.Object3D.DefaultUp=new THREE.Vector3(0,1,0);
THREE.Object3D.prototype={constructor:THREE.Object3D,get eulerOrder(){console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order.");return this.rotation.order},set eulerOrder(a){console.warn("THREE.Object3D: .eulerOrder has been moved to .rotation.order.");this.rotation.order=a},get useQuaternion(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set useQuaternion(a){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},
applyMatrix:function(a){this.matrix.multiplyMatrices(a,this.matrix);this.matrix.decompose(this.position,this.quaternion,this.scale)},setRotationFromAxisAngle:function(a,b){this.quaternion.setFromAxisAngle(a,b)},setRotationFromEuler:function(a){this.quaternion.setFromEuler(a,!0)},setRotationFromMatrix:function(a){this.quaternion.setFromRotationMatrix(a)},setRotationFromQuaternion:function(a){this.quaternion.copy(a)},rotateOnAxis:function(){var a=new THREE.Quaternion;return function(b,c){a.setFromAxisAngle(b,
c);this.quaternion.multiply(a);return this}}(),rotateX:function(){var a=new THREE.Vector3(1,0,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.rotateOnAxis(a,b)}}(),rotateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.rotateOnAxis(a,b)}}(),translateOnAxis:function(){var a=new THREE.Vector3;return function(b,c){a.copy(b).applyQuaternion(this.quaternion);this.position.add(a.multiplyScalar(c));
return this}}(),translate:function(a,b){console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");return this.translateOnAxis(b,a)},translateX:function(){var a=new THREE.Vector3(1,0,0);return function(b){return this.translateOnAxis(a,b)}}(),translateY:function(){var a=new THREE.Vector3(0,1,0);return function(b){return this.translateOnAxis(a,b)}}(),translateZ:function(){var a=new THREE.Vector3(0,0,1);return function(b){return this.translateOnAxis(a,
b)}}(),localToWorld:function(a){return a.applyMatrix4(this.matrixWorld)},worldToLocal:function(){var a=new THREE.Matrix4;return function(b){return b.applyMatrix4(a.getInverse(this.matrixWorld))}}(),lookAt:function(){var a=new THREE.Matrix4;return function(b){a.lookAt(b,this.position,this.up);this.quaternion.setFromRotationMatrix(a)}}(),add:function(a){if(1<arguments.length){for(var b=0;b<arguments.length;b++)this.add(arguments[b]);return this}if(a===this)return console.error("THREE.Object3D.add:",
a,"can't be added as a child of itself."),this;if(a instanceof THREE.Object3D){void 0!==a.parent&&a.parent.remove(a);a.parent=this;a.dispatchEvent({type:"added"});this.children||(this.children=[]);this.children.push(a);for(b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__addObject(a)}else console.error("THREE.Object3D.add:",a,"is not an instance of THREE.Object3D.");return this},remove:function(a){if(1<arguments.length)for(var b=0;b<arguments.length;b++)this.remove(arguments[b]);
b=this.children.indexOf(a);if(-1!==b){a.parent=void 0;a.dispatchEvent({type:"removed"});this.children.splice(b,1);for(b=this;void 0!==b.parent;)b=b.parent;void 0!==b&&b instanceof THREE.Scene&&b.__removeObject(a)}},raycast:function(){},traverse:function(a){a(this);if(this.children)for(var b=0,c=this.children.length;b<c;b++)this.children[b].traverse(a)},traverseVisible:function(a){if(!1!==this.visible&&(a(this),this.children))for(var b=0,c=this.children.length;b<c;b++)this.children[b].traverseVisible(a)},
getObjectById:function(a,b){if(this.children)for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.id===a||!0===b&&(e=e.getObjectById(a,b),void 0!==e))return e}},getObjectByName:function(a,b){if(this.children)for(var c=0,d=this.children.length;c<d;c++){var e=this.children[c];if(e.name===a||!0===b&&(e=e.getObjectByName(a,b),void 0!==e))return e}},getChildByName:function(a,b){console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");return this.getObjectByName(a,
b)},updateMatrix:function(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0},updateMatrixWorld:function(a){!0===this.matrixAutoUpdate&&this.updateMatrix();if(!0===this.matrixWorldNeedsUpdate||!0===a)void 0===this.parent&&this.matrix?this.matrixWorld.copy(this.matrix):this.matrix&&this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,a=!0;if(this.children)for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)},
clone:function(a,b){void 0===a&&(a=new THREE.Object3D(this.skipModTerms));void 0===b&&(b=!0);a.name=this.name;this.skipModTerms||(a.up.copy(this.up),a.position.copy(this.position),a.quaternion.copy(this.quaternion),a.scale.copy(this.scale),a.renderDepth=this.renderDepth,a.rotationAutoUpdate=this.rotationAutoUpdate,a.matrix.copy(this.matrix),a.matrixAutoUpdate=this.matrixAutoUpdate);a.matrixWorld.copy(this.matrixWorld);a.matrixWorldNeedsUpdate=this.matrixWorldNeedsUpdate;a.visible=this.visible;a.castShadow=
this.castShadow;a.receiveShadow=this.receiveShadow;a.frustumCulled=this.frustumCulled;this.userData&&(a.userData=JSON.parse(JSON.stringify(this.userData)));if(!0===b&&this.children)for(var c=0;c<this.children.length;c++)a.add(this.children[c].clone());return a}};THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);THREE.Object3DIdCount=0;
THREE.Projector=function(){function a(){if(n===t){var a=new THREE.RenderableVertex;q.push(a);t++;n++;return a}return q[n++]}function b(){if(p===u){var a=new THREE.RenderableFace;s.push(a);u++;p++;return a}return s[p++]}function c(){if(A===v){var a=new THREE.RenderableLine;w.push(a);v++;A++;return a}return w[A++]}function d(){if(F===y){var a=new THREE.RenderableSprite;B.push(a);y++;F++;return a}return B[F++]}function e(a,b){return a.z!==b.z?b.z-a.z:a.id!==b.id?a.id-b.id:0}function f(a,b){var c=0,d=
1,e=a.z+a.w,f=b.z+b.w,g=-a.z+a.w,h=-b.z+b.w;if(0<=e&&0<=f&&0<=g&&0<=h)return!0;if(0>e&&0>f||0>g&&0>h)return!1;0>e?c=Math.max(c,e/(e-f)):0>f&&(d=Math.min(d,e/(e-f)));0>g?c=Math.max(c,g/(g-h)):0>h&&(d=Math.min(d,g/(g-h)));if(d<c)return!1;a.lerp(b,c);b.lerp(a,1-d);return!0}var g,h,k=[],m=0,l,n,q=[],t=0,r,p,s=[],u=0,x,A,w=[],v=0,z,F,B=[],y=0,E={objects:[],lights:[],elements:[]},J=new THREE.Vector3,M=new THREE.Vector3,K=new THREE.Vector3,Q=new THREE.Vector3,L=new THREE.Vector4,H=new THREE.Box3(new THREE.Vector3(-1,
-1,-1),new THREE.Vector3(1,1,1)),G=new THREE.Box3,C=Array(3),V=new THREE.Matrix4,I=new THREE.Matrix4,P,O=new THREE.Matrix4,T=new THREE.Matrix3,D=new THREE.Frustum,U=new THREE.Vector4,R=new THREE.Vector4;this.projectVector=function(a,b){b.matrixWorldInverse.getInverse(b.matrixWorld);I.multiplyMatrices(b.projectionMatrix,b.matrixWorldInverse);return a.applyProjection(I)};this.unprojectVector=function(){var a=new THREE.Matrix4;return function(b,c){a.getInverse(c.projectionMatrix);I.multiplyMatrices(c.matrixWorld,
a);return b.applyProjection(I)}}();this.pickingRay=function(a,b){a.z=-1;var c=new THREE.Vector3(a.x,a.y,1);this.unprojectVector(a,b);this.unprojectVector(c,b);c.sub(a).normalize();return new THREE.Raycaster(a,c)};var N=new function(){var d=[],e=[],g=null,f=null,h=new THREE.Matrix3,k=function(a){var b=a.positionWorld,c=a.positionScreen;b.copy(a.position).applyMatrix4(P);c.copy(b).applyMatrix4(I);b=1/c.w;c.x*=b;c.y*=b;c.z*=b;a.visible=-1<=c.x&&1>=c.x&&-1<=c.y&&1>=c.y&&-1<=c.z&&1>=c.z},m=function(a,
b,c){if(!0===a.visible||!0===b.visible||!0===c.visible)return!0;C[0]=a.positionScreen;C[1]=b.positionScreen;C[2]=c.positionScreen;return H.isIntersectionBox(G.setFromPoints(C))},n=function(a,b,c){return 0>(c.positionScreen.x-a.positionScreen.x)*(b.positionScreen.y-a.positionScreen.y)-(c.positionScreen.y-a.positionScreen.y)*(b.positionScreen.x-a.positionScreen.x)};return{setObject:function(a){g=a;f=g.material;h.getNormalMatrix(g.matrixWorld);d.length=0;e.length=0},projectVertex:k,checkTriangleVisibility:m,
checkBackfaceCulling:n,pushVertex:function(b,c,d){l=a();l.position.set(b,c,d);k(l)},pushNormal:function(a,b,c){d.push(a,b,c)},pushUv:function(a,b){e.push(a,b)},pushLine:function(a,b){var d=q[a],e=q[b];x=c();x.id=g.id;x.v1.copy(d);x.v2.copy(e);x.z=(d.positionScreen.z+e.positionScreen.z)/2;x.material=g.material;E.elements.push(x)},pushTriangle:function(a,c,k){var l=q[a],p=q[c],t=q[k];if(!1!==m(l,p,t)&&(f.side===THREE.DoubleSide||!0===n(l,p,t))){r=b();r.id=g.id;r.v1.copy(l);r.v2.copy(p);r.v3.copy(t);
r.z=(l.positionScreen.z+p.positionScreen.z+t.positionScreen.z)/3;for(l=0;3>l;l++)p=3*arguments[l],t=r.vertexNormalsModel[l],t.set(d[p],d[p+1],d[p+2]),t.applyMatrix3(h).normalize(),p=2*arguments[l],r.uvs[l].set(e[p],e[p+1]);r.vertexNormalsLength=3;r.material=g.material;E.elements.push(r)}}}};this.projectScene=function(l,t,s,u){F=A=p=0;E.elements.length=0;!0===l.autoUpdate&&l.updateMatrixWorld();void 0===t.parent&&t.updateMatrixWorld();V.copy(t.matrixWorldInverse.getInverse(t.matrixWorld));I.multiplyMatrices(t.projectionMatrix,
V);D.setFromMatrix(I);h=0;E.objects.length=0;E.lights.length=0;l.traverseVisible(function(a){if(a instanceof THREE.Light)E.lights.push(a);else if(a instanceof THREE.Mesh||a instanceof THREE.Line||a instanceof THREE.Sprite)if(!1===a.frustumCulled||!0===D.intersectsObject(a)){if(h===m){var b=new THREE.RenderableObject;k.push(b);m++;h++;g=b}else g=k[h++];g.id=a.id;g.object=a;null!==a.renderDepth?g.z=a.renderDepth:(Q.setFromMatrixPosition(a.matrixWorld),Q.applyProjection(I),g.z=Q.z);E.objects.push(g)}});
!0===s&&E.objects.sort(e);l=0;for(s=E.objects.length;l<s;l++){var w=E.objects[l].object,v=w.geometry;N.setObject(w);P=w.matrixWorld;n=0;if(w instanceof THREE.Mesh)if(v instanceof THREE.BufferGeometry){var y=v.attributes,w=v.offsets;if(void 0!==y.position){for(var B=y.position.array,v=0,C=B.length;v<C;v+=3)N.pushVertex(B[v],B[v+1],B[v+2]);if(void 0!==y.normal)for(var Y=y.normal.array,v=0,C=Y.length;v<C;v+=3)N.pushNormal(Y[v],Y[v+1],Y[v+2]);if(void 0!==y.uv)for(Y=y.uv.array,v=0,C=Y.length;v<C;v+=2)N.pushUv(Y[v],
Y[v+1]);if(void 0!==y.index)if(y=y.index.array,0<w.length)for(l=0;l<w.length;l++)for(C=w[l],B=C.index,v=C.start,C=C.start+C.count;v<C;v+=3)N.pushTriangle(y[v]+B,y[v+1]+B,y[v+2]+B);else for(v=0,C=y.length;v<C;v+=3)N.pushTriangle(y[v],y[v+1],y[v+2]);else for(v=0,C=B.length/3;v<C;v+=3)N.pushTriangle(v,v+1,v+2)}}else{if(v instanceof THREE.Geometry){var G=v.vertices,C=v.faces,y=v.faceVertexUvs[0];T.getNormalMatrix(P);for(var B=w.material instanceof THREE.MeshFaceMaterial,Y=!0===B?w.material:null,H=0,S=
G.length;H<S;H++){var W=G[H];N.pushVertex(W.x,W.y,W.z)}G=0;for(H=C.length;G<H;G++){var S=C[G],ma=!0===B?Y.materials[S.materialIndex]:w.material;if(void 0!==ma){var Z=ma.side,W=q[S.a],aa=q[S.b],fa=q[S.c];if(!0===ma.morphTargets){var X=v.morphTargets,ja=w.morphTargetInfluences,da=W.position,ka=aa.position,ga=fa.position;J.set(0,0,0);M.set(0,0,0);K.set(0,0,0);for(var na=0,sa=X.length;na<sa;na++){var $=ja[na];if(0!==$){var ba=X[na].vertices;J.x+=(ba[S.a].x-da.x)*$;J.y+=(ba[S.a].y-da.y)*$;J.z+=(ba[S.a].z-
da.z)*$;M.x+=(ba[S.b].x-ka.x)*$;M.y+=(ba[S.b].y-ka.y)*$;M.z+=(ba[S.b].z-ka.z)*$;K.x+=(ba[S.c].x-ga.x)*$;K.y+=(ba[S.c].y-ga.y)*$;K.z+=(ba[S.c].z-ga.z)*$}}W.position.add(J);aa.position.add(M);fa.position.add(K);N.projectVertex(W);N.projectVertex(aa);N.projectVertex(fa)}if(!1!==N.checkTriangleVisibility(W,aa,fa)){X=N.checkBackfaceCulling(W,aa,fa);if(Z!==THREE.DoubleSide){if(Z===THREE.FrontSide&&!1===X)continue;if(Z===THREE.BackSide&&!0===X)continue}r=b();r.id=w.id;r.v1.copy(W);r.v2.copy(aa);r.v3.copy(fa);
r.normalModel.copy(S.normal);!1!==X||Z!==THREE.BackSide&&Z!==THREE.DoubleSide||r.normalModel.negate();r.normalModel.applyMatrix3(T).normalize();ja=S.vertexNormals;da=0;for(ka=Math.min(ja.length,3);da<ka;da++)ga=r.vertexNormalsModel[da],ga.copy(ja[da]),!1!==X||Z!==THREE.BackSide&&Z!==THREE.DoubleSide||ga.negate(),ga.applyMatrix3(T).normalize();r.vertexNormalsLength=ja.length;Z=y[G];if(void 0!==Z)for(X=0;3>X;X++)r.uvs[X].copy(Z[X]);r.color=S.color;r.material=ma;r.z=(W.positionScreen.z+aa.positionScreen.z+
fa.positionScreen.z)/3;E.elements.push(r)}}}}}else if(w instanceof THREE.Line)if(v instanceof THREE.BufferGeometry){if(y=v.attributes,void 0!==y.position){B=y.position.array;v=0;for(C=B.length;v<C;v+=3)N.pushVertex(B[v],B[v+1],B[v+2]);if(void 0!==y.index)for(y=y.index.array,v=0,C=y.length;v<C;v+=2)N.pushLine(y[v],y[v+1]);else for(y=w.type===THREE.LinePieces?2:1,v=0,C=B.length/3-1;v<C;v+=y)N.pushLine(v,v+1)}}else{if(v instanceof THREE.Geometry&&(O.multiplyMatrices(I,P),G=w.geometry.vertices,0!==G.length))for(W=
a(),W.positionScreen.copy(G[0]).applyMatrix4(O),y=w.type===THREE.LinePieces?2:1,H=1,S=G.length;H<S;H++)W=a(),W.positionScreen.copy(G[H]).applyMatrix4(O),0<(H+1)%y||(aa=q[n-2],U.copy(W.positionScreen),R.copy(aa.positionScreen),!0===f(U,R)&&(U.multiplyScalar(1/U.w),R.multiplyScalar(1/R.w),x=c(),x.id=w.id,x.v1.positionScreen.copy(U),x.v2.positionScreen.copy(R),x.z=Math.max(U.z,R.z),x.material=w.material,w.material.vertexColors===THREE.VertexColors&&(x.vertexColors[0].copy(w.geometry.colors[H]),x.vertexColors[1].copy(w.geometry.colors[H-
1])),E.elements.push(x)))}else w instanceof THREE.Sprite&&(L.set(P.elements[12],P.elements[13],P.elements[14],1),L.applyMatrix4(I),v=1/L.w,L.z*=v,-1<=L.z&&1>=L.z&&(z=d(),z.id=w.id,z.x=L.x*v,z.y=L.y*v,z.z=L.z,z.object=w,z.rotation=w.rotation,z.scale.x=w.scale.x*Math.abs(z.x-(L.x+t.projectionMatrix.elements[0])/(L.w+t.projectionMatrix.elements[12])),z.scale.y=w.scale.y*Math.abs(z.y-(L.y+t.projectionMatrix.elements[5])/(L.w+t.projectionMatrix.elements[13])),z.material=w.material,E.elements.push(z)))}!0===
u&&E.elements.sort(e);return E}};THREE.Face3=function(a,b,c,d,e,f){this.a=a;this.b=b;this.c=c;this.normal=d instanceof THREE.Vector3?d:new THREE.Vector3;this.vertexNormals=d instanceof Array?d:[];this.color=e instanceof THREE.Color?e:new THREE.Color;this.vertexColors=e instanceof Array?e:[];this.vertexTangents=[];this.materialIndex=void 0!==f?f:0};
THREE.Face3.prototype={constructor:THREE.Face3,clone:function(){var a=new THREE.Face3(this.a,this.b,this.c);a.normal.copy(this.normal);a.color.copy(this.color);a.materialIndex=this.materialIndex;for(var b=0,c=this.vertexNormals.length;b<c;b++)a.vertexNormals[b]=this.vertexNormals[b].clone();b=0;for(c=this.vertexColors.length;b<c;b++)a.vertexColors[b]=this.vertexColors[b].clone();b=0;for(c=this.vertexTangents.length;b<c;b++)a.vertexTangents[b]=this.vertexTangents[b].clone();return a}};
THREE.Face4=function(a,b,c,d,e,f,g){console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");return new THREE.Face3(a,b,c,e,f,g)};THREE.BufferAttribute=function(a,b){this.array=a;this.itemSize=b};
THREE.BufferAttribute.prototype={constructor:THREE.BufferAttribute,get length(){return this.array.length},set:function(a){this.array.set(a);return this},setX:function(a,b){this.array[a*this.itemSize]=b;return this},setY:function(a,b){this.array[a*this.itemSize+1]=b;return this},setZ:function(a,b){this.array[a*this.itemSize+2]=b;return this},setXY:function(a,b,c){a*=this.itemSize;this.array[a]=b;this.array[a+1]=c;return this},setXYZ:function(a,b,c,d){a*=this.itemSize;this.array[a]=b;this.array[a+1]=
c;this.array[a+2]=d;return this},setXYZW:function(a,b,c,d,e){a*=this.itemSize;this.array[a]=b;this.array[a+1]=c;this.array[a+2]=d;this.array[a+3]=e;return this}};THREE.Int8Attribute=function(a,b){console.warn("THREE.Int8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");return new THREE.BufferAttribute(a,b)};
THREE.Uint8Attribute=function(a,b){console.warn("THREE.Uint8Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");return new THREE.BufferAttribute(a,b)};THREE.Uint8ClampedAttribute=function(a,b){console.warn("THREE.Uint8ClampedAttribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");return new THREE.BufferAttribute(a,b)};
THREE.Int16Attribute=function(a,b){console.warn("THREE.Int16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");return new THREE.BufferAttribute(a,b)};THREE.Uint16Attribute=function(a,b){console.warn("THREE.Uint16Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");return new THREE.BufferAttribute(a,b)};
THREE.Int32Attribute=function(a,b){console.warn("THREE.Int32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");return new THREE.BufferAttribute(a,b)};THREE.Uint32Attribute=function(a,b){console.warn("THREE.Uint32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");return new THREE.BufferAttribute(a,b)};
THREE.Float32Attribute=function(a,b){console.warn("THREE.Float32Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");return new THREE.BufferAttribute(a,b)};THREE.Float64Attribute=function(a,b){console.warn("THREE.Float64Attribute has been removed. Use THREE.BufferAttribute( array, itemSize ) instead.");return new THREE.BufferAttribute(a,b)};
THREE.BufferGeometry=function(){this.id=THREE.GeometryIdCount++;this.attributes={};this.offsets=this.drawcalls=[];this.boundingSphere=this.boundingBox=null};
THREE.BufferGeometry.prototype={constructor:THREE.BufferGeometry,addAttribute:function(a,b,c){!1===b instanceof THREE.BufferAttribute?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.attributes[a]={array:b,itemSize:c}):this.attributes[a]=b},getAttribute:function(a){return this.attributes[a]},addDrawCall:function(a,b,c){this.drawcalls.push({start:a,count:b,index:void 0!==c?c:0})},applyMatrix:function(a){var b=this.attributes.position;void 0!==b&&(a.applyToVector3Array(b.array),
b.needsUpdate=!0);b=this.attributes.normal;void 0!==b&&((new THREE.Matrix3).getNormalMatrix(a).applyToVector3Array(b.array),b.needsUpdate=!0)},fromGeometry:function(a,b){b=b||{vertexColors:THREE.NoColors};var c=a.vertices,d=a.faces,e=a.faceVertexUvs,f=b.vertexColors,g=0<e[0].length,h=3==d[0].vertexNormals.length,k=new Float32Array(9*d.length);this.addAttribute("position",new THREE.BufferAttribute(k,3));var m=new Float32Array(9*d.length);this.addAttribute("normal",new THREE.BufferAttribute(m,3));if(f!==
THREE.NoColors){var l=new Float32Array(9*d.length);this.addAttribute("color",new THREE.BufferAttribute(l,3))}if(!0===g){var n=new Float32Array(6*d.length);this.addAttribute("uvs",new THREE.BufferAttribute(n,2))}for(var q=0,t=0,r=0;q<d.length;q++,t+=6,r+=9){var p=d[q],s=c[p.a],u=c[p.b],x=c[p.c];k[r]=s.x;k[r+1]=s.y;k[r+2]=s.z;k[r+3]=u.x;k[r+4]=u.y;k[r+5]=u.z;k[r+6]=x.x;k[r+7]=x.y;k[r+8]=x.z;!0===h?(s=p.vertexNormals[0],u=p.vertexNormals[1],x=p.vertexNormals[2],m[r]=s.x,m[r+1]=s.y,m[r+2]=s.z,m[r+3]=
u.x,m[r+4]=u.y,m[r+5]=u.z,m[r+6]=x.x,m[r+7]=x.y,m[r+8]=x.z):(s=p.normal,m[r]=s.x,m[r+1]=s.y,m[r+2]=s.z,m[r+3]=s.x,m[r+4]=s.y,m[r+5]=s.z,m[r+6]=s.x,m[r+7]=s.y,m[r+8]=s.z);f===THREE.FaceColors?(p=p.color,l[r]=p.r,l[r+1]=p.g,l[r+2]=p.b,l[r+3]=p.r,l[r+4]=p.g,l[r+5]=p.b,l[r+6]=p.r,l[r+7]=p.g,l[r+8]=p.b):f===THREE.VertexColors&&(s=p.vertexColors[0],u=p.vertexColors[1],p=p.vertexColors[2],l[r]=s.r,l[r+1]=s.g,l[r+2]=s.b,l[r+3]=u.r,l[r+4]=u.g,l[r+5]=u.b,l[r+6]=p.r,l[r+7]=p.g,l[r+8]=p.b);!0===g&&(p=e[0][q][0],
s=e[0][q][1],u=e[0][q][2],n[t]=p.x,n[t+1]=p.y,n[t+2]=s.x,n[t+3]=s.y,n[t+4]=u.x,n[t+5]=u.y)}this.computeBoundingSphere();return this},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);var a=this.attributes.position.array;if(a){var b=this.boundingBox;3<=a.length&&(b.min.x=b.max.x=a[0],b.min.y=b.max.y=a[1],b.min.z=b.max.z=a[2]);for(var c=3,d=a.length;c<d;c+=3){var e=a[c],f=a[c+1],g=a[c+2];e<b.min.x?b.min.x=e:e>b.max.x&&(b.max.x=e);f<b.min.y?b.min.y=f:f>b.max.y&&
(b.max.y=f);g<b.min.z?b.min.z=g:g>b.max.z&&(b.max.z=g)}}if(void 0===a||0===a.length)this.boundingBox.min.set(0,0,0),this.boundingBox.max.set(0,0,0);(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.')},computeBoundingSphere:function(){var a=new THREE.Box3,b=new THREE.Vector3;return function(){null===this.boundingSphere&&
(this.boundingSphere=new THREE.Sphere);var c=this.attributes.position.array;if(c){a.makeEmpty();for(var d=this.boundingSphere.center,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),a.expandByPoint(b);a.center(d);for(var g=0,e=0,f=c.length;e<f;e+=3)b.set(c[e],c[e+1],c[e+2]),g=Math.max(g,d.distanceToSquared(b));this.boundingSphere.radius=Math.sqrt(g);isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.')}}}(),
computeFaceNormals:function(){},computeVertexNormals:function(){if(this.attributes.position){var a,b,c,d;a=this.attributes.position.array.length;if(void 0===this.attributes.normal)this.attributes.normal={itemSize:3,array:new Float32Array(a)};else for(a=0,b=this.attributes.normal.array.length;a<b;a++)this.attributes.normal.array[a]=0;var e=this.attributes.position.array,f=this.attributes.normal.array,g,h,k,m,l,n,q=new THREE.Vector3,t=new THREE.Vector3,r=new THREE.Vector3,p=new THREE.Vector3,s=new THREE.Vector3;
if(this.attributes.index){var u=this.attributes.index.array,x=0<this.offsets.length?this.offsets:[{start:0,count:u.length,index:0}];c=0;for(d=x.length;c<d;++c){b=x[c].start;g=x[c].count;var A=x[c].index;a=b;for(b+=g;a<b;a+=3)g=A+u[a],h=A+u[a+1],k=A+u[a+2],m=e[3*g],l=e[3*g+1],n=e[3*g+2],q.set(m,l,n),m=e[3*h],l=e[3*h+1],n=e[3*h+2],t.set(m,l,n),m=e[3*k],l=e[3*k+1],n=e[3*k+2],r.set(m,l,n),p.subVectors(r,t),s.subVectors(q,t),p.cross(s),f[3*g]+=p.x,f[3*g+1]+=p.y,f[3*g+2]+=p.z,f[3*h]+=p.x,f[3*h+1]+=p.y,
f[3*h+2]+=p.z,f[3*k]+=p.x,f[3*k+1]+=p.y,f[3*k+2]+=p.z}}else for(a=0,b=e.length;a<b;a+=9)m=e[a],l=e[a+1],n=e[a+2],q.set(m,l,n),m=e[a+3],l=e[a+4],n=e[a+5],t.set(m,l,n),m=e[a+6],l=e[a+7],n=e[a+8],r.set(m,l,n),p.subVectors(r,t),s.subVectors(q,t),p.cross(s),f[a]=p.x,f[a+1]=p.y,f[a+2]=p.z,f[a+3]=p.x,f[a+4]=p.y,f[a+5]=p.z,f[a+6]=p.x,f[a+7]=p.y,f[a+8]=p.z;this.normalizeNormals();this.normalsNeedUpdate=!0}},computeTangents:function(){function a(a,b,c){n=d[3*a];q=d[3*a+1];t=d[3*a+2];r=d[3*b];p=d[3*b+1];s=d[3*
b+2];u=d[3*c];x=d[3*c+1];A=d[3*c+2];w=f[2*a];v=f[2*a+1];z=f[2*b];F=f[2*b+1];B=f[2*c];y=f[2*c+1];E=r-n;J=u-n;M=p-q;K=x-q;Q=s-t;L=A-t;H=z-w;G=B-w;C=F-v;V=y-v;I=1/(H*V-G*C);P.set((V*E-C*J)*I,(V*M-C*K)*I,(V*Q-C*L)*I);O.set((H*J-G*E)*I,(H*K-G*M)*I,(H*L-G*Q)*I);k[a].add(P);k[b].add(P);k[c].add(P);m[a].add(O);m[b].add(O);m[c].add(O)}function b(a){ha.x=e[3*a];ha.y=e[3*a+1];ha.z=e[3*a+2];pa.copy(ha);la=k[a];ia.copy(la);ia.sub(ha.multiplyScalar(ha.dot(la))).normalize();oa.crossVectors(pa,la);ra=oa.dot(m[a]);
qa=0>ra?-1:1;h[4*a]=ia.x;h[4*a+1]=ia.y;h[4*a+2]=ia.z;h[4*a+3]=qa}if(void 0===this.attributes.index||void 0===this.attributes.position||void 0===this.attributes.normal||void 0===this.attributes.uv)console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");else{var c=this.attributes.index.array,d=this.attributes.position.array,e=this.attributes.normal.array,f=this.attributes.uv.array,g=d.length/3;void 0===this.attributes.tangent&&(this.attributes.tangent=
{itemSize:4,array:new Float32Array(4*g)});for(var h=this.attributes.tangent.array,k=[],m=[],l=0;l<g;l++)k[l]=new THREE.Vector3,m[l]=new THREE.Vector3;var n,q,t,r,p,s,u,x,A,w,v,z,F,B,y,E,J,M,K,Q,L,H,G,C,V,I,P=new THREE.Vector3,O=new THREE.Vector3,T,D,U,R,N,ca=this.offsets,l=0;for(D=ca.length;l<D;++l){T=ca[l].start;U=ca[l].count;var ea=ca[l].index,g=T;for(T+=U;g<T;g+=3)U=ea+c[g],R=ea+c[g+1],N=ea+c[g+2],a(U,R,N)}var ia=new THREE.Vector3,oa=new THREE.Vector3,ha=new THREE.Vector3,pa=new THREE.Vector3,
qa,la,ra,l=0;for(D=ca.length;l<D;++l)for(T=ca[l].start,U=ca[l].count,ea=ca[l].index,g=T,T+=U;g<T;g+=3)U=ea+c[g],R=ea+c[g+1],N=ea+c[g+2],b(U),b(R),b(N)}},computeOffsets:function(a){var b=a;void 0===a&&(b=65535);Date.now();a=this.attributes.index.array;for(var c=this.attributes.position.array,d=a.length/3,e=new Uint16Array(a.length),f=0,g=0,h=[{start:0,count:0,index:0}],k=h[0],m=0,l=0,n=new Int32Array(6),q=new Int32Array(c.length),t=new Int32Array(c.length),r=0;r<c.length;r++)q[r]=-1,t[r]=-1;for(c=
0;c<d;c++){for(var p=l=0;3>p;p++)r=a[3*c+p],-1==q[r]?(n[2*p]=r,n[2*p+1]=-1,l++):q[r]<k.index?(n[2*p]=r,n[2*p+1]=-1,m++):(n[2*p]=r,n[2*p+1]=q[r]);if(g+l>k.index+b)for(k={start:f,count:0,index:g},h.push(k),l=0;6>l;l+=2)p=n[l+1],-1<p&&p<k.index&&(n[l+1]=-1);for(l=0;6>l;l+=2)r=n[l],p=n[l+1],-1===p&&(p=g++),q[r]=p,t[p]=r,e[f++]=p-k.index,k.count++}this.reorderBuffers(e,t,g);return this.offsets=h},merge:function(){console.log("BufferGeometry.merge(): TODO")},normalizeNormals:function(){for(var a=this.attributes.normal.array,
b,c,d,e=0,f=a.length;e<f;e+=3)b=a[e],c=a[e+1],d=a[e+2],b=1/Math.sqrt(b*b+c*c+d*d),a[e]*=b,a[e+1]*=b,a[e+2]*=b},reorderBuffers:function(a,b,c){var d={},e=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],f;for(f in this.attributes)if("index"!=f)for(var g=this.attributes[f].array,h=0,k=e.length;h<k;h++){var m=e[h];if(g instanceof m){d[f]=new m(this.attributes[f].itemSize*c);break}}for(e=0;e<c;e++)for(f in g=b[e],this.attributes)if("index"!=
f)for(var h=this.attributes[f].array,k=this.attributes[f].itemSize,m=d[f],l=0;l<k;l++)m[e*k+l]=h[g*k+l];this.attributes.index.array=a;for(f in this.attributes)"index"!=f&&(this.attributes[f].array=d[f],this.attributes[f].numItems=this.attributes[f].itemSize*c)},clone:function(){var a=new THREE.BufferGeometry,b=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],c;for(c in this.attributes){for(var d=this.attributes[c],e=d.array,f={itemSize:d.itemSize,
array:null},d=0,g=b.length;d<g;d++){var h=b[d];if(e instanceof h){f.array=new h(e);break}}a.attributes[c]=f}d=0;for(g=this.offsets.length;d<g;d++)b=this.offsets[d],a.offsets.push({start:b.start,index:b.index,count:b.count});return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.Geometry=function(){this.id=THREE.GeometryIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphColors=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingSphere=this.boundingBox=null;this.hasTangents=!1;this.dynamic=!0;this.groupsNeedUpdate=this.buffersNeedUpdate=this.lineDistancesNeedUpdate=this.colorsNeedUpdate=this.tangentsNeedUpdate=this.normalsNeedUpdate=
this.uvsNeedUpdate=this.elementsNeedUpdate=this.verticesNeedUpdate=!1};
THREE.Geometry.prototype={constructor:THREE.Geometry,applyMatrix:function(a){for(var b=(new THREE.Matrix3).getNormalMatrix(a),c=0,d=this.vertices.length;c<d;c++)this.vertices[c].applyMatrix4(a);c=0;for(d=this.faces.length;c<d;c++){a=this.faces[c];a.normal.applyMatrix3(b).normalize();for(var e=0,f=a.vertexNormals.length;e<f;e++)a.vertexNormals[e].applyMatrix3(b).normalize()}this.boundingBox instanceof THREE.Box3&&this.computeBoundingBox();this.boundingSphere instanceof THREE.Sphere&&this.computeBoundingSphere()},
center:function(){this.computeBoundingBox();var a=new THREE.Vector3;a.addVectors(this.boundingBox.min,this.boundingBox.max);a.multiplyScalar(-0.5);this.applyMatrix((new THREE.Matrix4).makeTranslation(a.x,a.y,a.z));this.computeBoundingBox();return a},computeFaceNormals:function(){for(var a=new THREE.Vector3,b=new THREE.Vector3,c=0,d=this.faces.length;c<d;c++){var e=this.faces[c],f=this.vertices[e.a],g=this.vertices[e.b];a.subVectors(this.vertices[e.c],g);b.subVectors(f,g);a.cross(b);a.normalize();
e.normal.copy(a)}},computeVertexNormals:function(a){var b,c,d;d=Array(this.vertices.length);b=0;for(c=this.vertices.length;b<c;b++)d[b]=new THREE.Vector3;if(a){var e,f,g,h=new THREE.Vector3,k=new THREE.Vector3;new THREE.Vector3;new THREE.Vector3;new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],e=this.vertices[c.a],f=this.vertices[c.b],g=this.vertices[c.c],h.subVectors(g,f),k.subVectors(e,f),h.cross(k),d[c.a].add(h),d[c.b].add(h),d[c.c].add(h)}else for(a=0,b=this.faces.length;a<
b;a++)c=this.faces[a],d[c.a].add(c.normal),d[c.b].add(c.normal),d[c.c].add(c.normal);b=0;for(c=this.vertices.length;b<c;b++)d[b].normalize();a=0;for(b=this.faces.length;a<b;a++)c=this.faces[a],c.vertexNormals[0]=d[c.a].clone(),c.vertexNormals[1]=d[c.b].clone(),c.vertexNormals[2]=d[c.c].clone()},computeMorphNormals:function(){var a,b,c,d,e;c=0;for(d=this.faces.length;c<d;c++)for(e=this.faces[c],e.__originalFaceNormal?e.__originalFaceNormal.copy(e.normal):e.__originalFaceNormal=e.normal.clone(),e.__originalVertexNormals||
(e.__originalVertexNormals=[]),a=0,b=e.vertexNormals.length;a<b;a++)e.__originalVertexNormals[a]?e.__originalVertexNormals[a].copy(e.vertexNormals[a]):e.__originalVertexNormals[a]=e.vertexNormals[a].clone();var f=new THREE.Geometry;f.faces=this.faces;a=0;for(b=this.morphTargets.length;a<b;a++){if(!this.morphNormals[a]){this.morphNormals[a]={};this.morphNormals[a].faceNormals=[];this.morphNormals[a].vertexNormals=[];e=this.morphNormals[a].faceNormals;var g=this.morphNormals[a].vertexNormals,h,k;c=
0;for(d=this.faces.length;c<d;c++)h=new THREE.Vector3,k={a:new THREE.Vector3,b:new THREE.Vector3,c:new THREE.Vector3},e.push(h),g.push(k)}g=this.morphNormals[a];f.vertices=this.morphTargets[a].vertices;f.computeFaceNormals();f.computeVertexNormals();c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],h=g.faceNormals[c],k=g.vertexNormals[c],h.copy(e.normal),k.a.copy(e.vertexNormals[0]),k.b.copy(e.vertexNormals[1]),k.c.copy(e.vertexNormals[2])}c=0;for(d=this.faces.length;c<d;c++)e=this.faces[c],e.normal=
e.__originalFaceNormal,e.vertexNormals=e.__originalVertexNormals},computeTangents:function(){var a,b,c,d,e,f,g,h,k,m,l,n,q,t,r,p,s,u=[],x=[];c=new THREE.Vector3;var A=new THREE.Vector3,w=new THREE.Vector3,v=new THREE.Vector3,z=new THREE.Vector3;a=0;for(b=this.vertices.length;a<b;a++)u[a]=new THREE.Vector3,x[a]=new THREE.Vector3;a=0;for(b=this.faces.length;a<b;a++)e=this.faces[a],f=this.faceVertexUvs[0][a],d=e.a,s=e.b,e=e.c,g=this.vertices[d],h=this.vertices[s],k=this.vertices[e],m=f[0],l=f[1],n=f[2],
f=h.x-g.x,q=k.x-g.x,t=h.y-g.y,r=k.y-g.y,h=h.z-g.z,g=k.z-g.z,k=l.x-m.x,p=n.x-m.x,l=l.y-m.y,m=n.y-m.y,n=1/(k*m-p*l),c.set((m*f-l*q)*n,(m*t-l*r)*n,(m*h-l*g)*n),A.set((k*q-p*f)*n,(k*r-p*t)*n,(k*g-p*h)*n),u[d].add(c),u[s].add(c),u[e].add(c),x[d].add(A),x[s].add(A),x[e].add(A);A=["a","b","c","d"];a=0;for(b=this.faces.length;a<b;a++)for(e=this.faces[a],c=0;c<Math.min(e.vertexNormals.length,3);c++)z.copy(e.vertexNormals[c]),d=e[A[c]],s=u[d],w.copy(s),w.sub(z.multiplyScalar(z.dot(s))).normalize(),v.crossVectors(e.vertexNormals[c],
s),d=v.dot(x[d]),d=0>d?-1:1,e.vertexTangents[c]=new THREE.Vector4(w.x,w.y,w.z,d);this.hasTangents=!0},computeLineDistances:function(){for(var a=0,b=this.vertices,c=0,d=b.length;c<d;c++)0<c&&(a+=b[c].distanceTo(b[c-1])),this.lineDistances[c]=a},computeBoundingBox:function(){null===this.boundingBox&&(this.boundingBox=new THREE.Box3);this.boundingBox.setFromPoints(this.vertices)},computeBoundingSphere:function(){null===this.boundingSphere&&(this.boundingSphere=new THREE.Sphere);this.boundingSphere.setFromPoints(this.vertices)},
merge:function(a,b,c){if(!1===a instanceof THREE.Geometry)console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.",a);else{var d,e=this.vertices.length,f=this.vertices,g=a.vertices,h=this.faces,k=a.faces,m=this.faceVertexUvs[0];a=a.faceVertexUvs[0];void 0===c&&(c=0);void 0!==b&&(d=(new THREE.Matrix3).getNormalMatrix(b));for(var l=0,n=g.length;l<n;l++){var q=g[l].clone();void 0!==b&&q.applyMatrix4(b);f.push(q)}l=0;for(n=k.length;l<n;l++){var g=k[l],t,r=g.vertexNormals,p=
g.vertexColors,q=new THREE.Face3(g.a+e,g.b+e,g.c+e);q.normal.copy(g.normal);void 0!==d&&q.normal.applyMatrix3(d).normalize();b=0;for(f=r.length;b<f;b++)t=r[b].clone(),void 0!==d&&t.applyMatrix3(d).normalize(),q.vertexNormals.push(t);q.color.copy(g.color);b=0;for(f=p.length;b<f;b++)t=p[b],q.vertexColors.push(t.clone());q.materialIndex=g.materialIndex+c;h.push(q)}l=0;for(n=a.length;l<n;l++)if(c=a[l],d=[],void 0!==c){b=0;for(f=c.length;b<f;b++)d.push(new THREE.Vector2(c[b].x,c[b].y));m.push(d)}}},mergeVertices:function(){var a=
{},b=[],c=[],d,e=Math.pow(10,4),f,g;f=0;for(g=this.vertices.length;f<g;f++)d=this.vertices[f],d=Math.round(d.x*e)+"_"+Math.round(d.y*e)+"_"+Math.round(d.z*e),void 0===a[d]?(a[d]=f,b.push(this.vertices[f]),c[f]=b.length-1):c[f]=c[a[d]];a=[];f=0;for(g=this.faces.length;f<g;f++)for(e=this.faces[f],e.a=c[e.a],e.b=c[e.b],e.c=c[e.c],e=[e.a,e.b,e.c],d=0;3>d;d++)if(e[d]==e[(d+1)%3]){a.push(f);break}for(f=a.length-1;0<=f;f--)for(e=a[f],this.faces.splice(e,1),c=0,g=this.faceVertexUvs.length;c<g;c++)this.faceVertexUvs[c].splice(e,
1);f=this.vertices.length-b.length;this.vertices=b;return f},makeGroups:function(){var a=0;return function(b,c){var d,e,f,g,h={},k,m=this.morphTargets.length,l=this.morphNormals.length;this.geometryGroups={};this.geometryGroupsList=[];d=0;for(e=this.faces.length;d<e;d++)f=this.faces[d],f=b?f.materialIndex:0,f in h||(h[f]={hash:f,counter:0}),g=h[f].hash+"_"+h[f].counter,g in this.geometryGroups||(k={id:a++,faces3:[],materialIndex:f,vertices:0,numMorphTargets:m,numMorphNormals:l},this.geometryGroups[g]=
k,this.geometryGroupsList.push(k)),this.geometryGroups[g].vertices+3>c&&(h[f].counter+=1,g=h[f].hash+"_"+h[f].counter,g in this.geometryGroups||(k={id:a++,faces3:[],materialIndex:f,vertices:0,numMorphTargets:m,numMorphNormals:l},this.geometryGroups[g]=k,this.geometryGroupsList.push(k))),this.geometryGroups[g].faces3.push(d),this.geometryGroups[g].vertices+=3}}(),clone:function(){for(var a=new THREE.Geometry,b=this.vertices,c=0,d=b.length;c<d;c++)a.vertices.push(b[c].clone());b=this.faces;c=0;for(d=
b.length;c<d;c++)a.faces.push(b[c].clone());b=this.faceVertexUvs[0];c=0;for(d=b.length;c<d;c++){for(var e=b[c],f=[],g=0,h=e.length;g<h;g++)f.push(new THREE.Vector2(e[g].x,e[g].y));a.faceVertexUvs[0].push(f)}return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);THREE.GeometryIdCount=0;THREE.Camera=function(){THREE.Object3D.call(this);this.matrixWorldInverse=new THREE.Matrix4;this.projectionMatrix=new THREE.Matrix4};
THREE.Camera.prototype=Object.create(THREE.Object3D.prototype);THREE.Camera.prototype.lookAt=function(){var a=new THREE.Matrix4;return function(b){a.lookAt(this.position,b,this.up);this.quaternion.setFromRotationMatrix(a)}}();THREE.Camera.prototype.clone=function(a){void 0===a&&(a=new THREE.Camera);THREE.Object3D.prototype.clone.call(this,a);a.matrixWorldInverse.copy(this.matrixWorldInverse);a.projectionMatrix.copy(this.projectionMatrix);return a};
THREE.CubeCamera=function(a,b,c){THREE.Object3D.call(this);var d=new THREE.PerspectiveCamera(90,1,a,b);d.up.set(0,-1,0);d.lookAt(new THREE.Vector3(1,0,0));this.add(d);var e=new THREE.PerspectiveCamera(90,1,a,b);e.up.set(0,-1,0);e.lookAt(new THREE.Vector3(-1,0,0));this.add(e);var f=new THREE.PerspectiveCamera(90,1,a,b);f.up.set(0,0,1);f.lookAt(new THREE.Vector3(0,1,0));this.add(f);var g=new THREE.PerspectiveCamera(90,1,a,b);g.up.set(0,0,-1);g.lookAt(new THREE.Vector3(0,-1,0));this.add(g);var h=new THREE.PerspectiveCamera(90,
1,a,b);h.up.set(0,-1,0);h.lookAt(new THREE.Vector3(0,0,1));this.add(h);var k=new THREE.PerspectiveCamera(90,1,a,b);k.up.set(0,-1,0);k.lookAt(new THREE.Vector3(0,0,-1));this.add(k);this.renderTarget=new THREE.WebGLRenderTargetCube(c,c,{format:THREE.RGBFormat,magFilter:THREE.LinearFilter,minFilter:THREE.LinearFilter});this.updateCubeMap=function(a,b){var c=this.renderTarget,q=c.generateMipmaps;c.generateMipmaps=!1;c.activeCubeFace=0;a.render(b,d,c);c.activeCubeFace=1;a.render(b,e,c);c.activeCubeFace=
2;a.render(b,f,c);c.activeCubeFace=3;a.render(b,g,c);c.activeCubeFace=4;a.render(b,h,c);c.generateMipmaps=q;c.activeCubeFace=5;a.render(b,k,c)}};THREE.CubeCamera.prototype=Object.create(THREE.Object3D.prototype);THREE.OrthographicCamera=function(a,b,c,d,e,f){THREE.Camera.call(this);this.left=a;this.right=b;this.top=c;this.bottom=d;this.near=void 0!==e?e:0.1;this.far=void 0!==f?f:2E3;this.updateProjectionMatrix()};THREE.OrthographicCamera.prototype=Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.updateProjectionMatrix=function(){this.projectionMatrix.makeOrthographic(this.left,this.right,this.top,this.bottom,this.near,this.far)};THREE.OrthographicCamera.prototype.clone=function(){var a=new THREE.OrthographicCamera;THREE.Camera.prototype.clone.call(this,a);a.left=this.left;a.right=this.right;a.top=this.top;a.bottom=this.bottom;a.near=this.near;a.far=this.far;return a};
THREE.PerspectiveCamera=function(a,b,c,d){THREE.Camera.call(this);this.fov=void 0!==a?a:50;this.aspect=void 0!==b?b:1;this.near=void 0!==c?c:0.1;this.far=void 0!==d?d:2E3;this.updateProjectionMatrix()};THREE.PerspectiveCamera.prototype=Object.create(THREE.Camera.prototype);THREE.PerspectiveCamera.prototype.setLens=function(a,b){void 0===b&&(b=24);this.fov=2*THREE.Math.radToDeg(Math.atan(b/(2*a)));this.updateProjectionMatrix()};
THREE.PerspectiveCamera.prototype.setViewOffset=function(a,b,c,d,e,f){this.fullWidth=a;this.fullHeight=b;this.x=c;this.y=d;this.width=e;this.height=f;this.updateProjectionMatrix()};
THREE.PerspectiveCamera.prototype.updateProjectionMatrix=function(){if(this.fullWidth){var a=this.fullWidth/this.fullHeight,b=Math.tan(THREE.Math.degToRad(0.5*this.fov))*this.near,c=-b,d=a*c,a=Math.abs(a*b-d),c=Math.abs(b-c);this.projectionMatrix.makeFrustum(d+this.x*a/this.fullWidth,d+(this.x+this.width)*a/this.fullWidth,b-(this.y+this.height)*c/this.fullHeight,b-this.y*c/this.fullHeight,this.near,this.far)}else this.projectionMatrix.makePerspective(this.fov,this.aspect,this.near,this.far)};
THREE.PerspectiveCamera.prototype.clone=function(){var a=new THREE.PerspectiveCamera;THREE.Camera.prototype.clone.call(this,a);a.fov=this.fov;a.aspect=this.aspect;a.near=this.near;a.far=this.far;return a};THREE.Light=function(a){THREE.Object3D.call(this);this.color=new THREE.Color(a)};THREE.Light.prototype=Object.create(THREE.Object3D.prototype);THREE.Light.prototype.clone=function(a){void 0===a&&(a=new THREE.Light);THREE.Object3D.prototype.clone.call(this,a);a.color.copy(this.color);return a};
THREE.AmbientLight=function(a){THREE.Light.call(this,a)};THREE.AmbientLight.prototype=Object.create(THREE.Light.prototype);THREE.AmbientLight.prototype.clone=function(){var a=new THREE.AmbientLight;THREE.Light.prototype.clone.call(this,a);return a};
THREE.AreaLight=function(a,b){THREE.Light.call(this,a);this.normal=new THREE.Vector3(0,-1,0);this.right=new THREE.Vector3(1,0,0);this.intensity=void 0!==b?b:1;this.height=this.width=1;this.constantAttenuation=1.5;this.linearAttenuation=0.5;this.quadraticAttenuation=0.1};THREE.AreaLight.prototype=Object.create(THREE.Light.prototype);
THREE.DirectionalLight=function(a,b){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraLeft=-500;this.shadowCameraTop=this.shadowCameraRight=500;this.shadowCameraBottom=-500;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowCascade=!1;this.shadowCascadeOffset=new THREE.Vector3(0,
0,-1E3);this.shadowCascadeCount=2;this.shadowCascadeBias=[0,0,0];this.shadowCascadeWidth=[512,512,512];this.shadowCascadeHeight=[512,512,512];this.shadowCascadeNearZ=[-1,0.99,0.998];this.shadowCascadeFarZ=[0.99,0.998,1];this.shadowCascadeArray=[];this.shadowMatrix=this.shadowCamera=this.shadowMapSize=this.shadowMap=null};THREE.DirectionalLight.prototype=Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone=function(){var a=new THREE.DirectionalLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;a.shadowCameraNear=this.shadowCameraNear;a.shadowCameraFar=this.shadowCameraFar;a.shadowCameraLeft=this.shadowCameraLeft;a.shadowCameraRight=this.shadowCameraRight;a.shadowCameraTop=this.shadowCameraTop;a.shadowCameraBottom=this.shadowCameraBottom;a.shadowCameraVisible=
this.shadowCameraVisible;a.shadowBias=this.shadowBias;a.shadowDarkness=this.shadowDarkness;a.shadowMapWidth=this.shadowMapWidth;a.shadowMapHeight=this.shadowMapHeight;a.shadowCascade=this.shadowCascade;a.shadowCascadeOffset.copy(this.shadowCascadeOffset);a.shadowCascadeCount=this.shadowCascadeCount;a.shadowCascadeBias=this.shadowCascadeBias.slice(0);a.shadowCascadeWidth=this.shadowCascadeWidth.slice(0);a.shadowCascadeHeight=this.shadowCascadeHeight.slice(0);a.shadowCascadeNearZ=this.shadowCascadeNearZ.slice(0);
a.shadowCascadeFarZ=this.shadowCascadeFarZ.slice(0);return a};THREE.HemisphereLight=function(a,b,c){THREE.Light.call(this,a);this.position.set(0,100,0);this.groundColor=new THREE.Color(b);this.intensity=void 0!==c?c:1};THREE.HemisphereLight.prototype=Object.create(THREE.Light.prototype);THREE.HemisphereLight.prototype.clone=function(){var a=new THREE.HemisphereLight;THREE.Light.prototype.clone.call(this,a);a.groundColor.copy(this.groundColor);a.intensity=this.intensity;return a};
THREE.PointLight=function(a,b,c){THREE.Light.call(this,a);this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0};THREE.PointLight.prototype=Object.create(THREE.Light.prototype);THREE.PointLight.prototype.clone=function(){var a=new THREE.PointLight;THREE.Light.prototype.clone.call(this,a);a.intensity=this.intensity;a.distance=this.distance;return a};
THREE.SpotLight=function(a,b,c,d,e){THREE.Light.call(this,a);this.position.set(0,1,0);this.target=new THREE.Object3D;this.intensity=void 0!==b?b:1;this.distance=void 0!==c?c:0;this.angle=void 0!==d?d:Math.PI/3;this.exponent=void 0!==e?e:10;this.onlyShadow=this.castShadow=!1;this.shadowCameraNear=50;this.shadowCameraFar=5E3;this.shadowCameraFov=50;this.shadowCameraVisible=!1;this.shadowBias=0;this.shadowDarkness=0.5;this.shadowMapHeight=this.shadowMapWidth=512;this.shadowMatrix=this.shadowCamera=this.shadowMapSize=
this.shadowMap=null};THREE.SpotLight.prototype=Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.clone=function(){var a=new THREE.SpotLight;THREE.Light.prototype.clone.call(this,a);a.target=this.target.clone();a.intensity=this.intensity;a.distance=this.distance;a.angle=this.angle;a.exponent=this.exponent;a.castShadow=this.castShadow;a.onlyShadow=this.onlyShadow;a.shadowCameraNear=this.shadowCameraNear;a.shadowCameraFar=this.shadowCameraFar;a.shadowCameraFov=this.shadowCameraFov;a.shadowCameraVisible=this.shadowCameraVisible;a.shadowBias=this.shadowBias;a.shadowDarkness=
this.shadowDarkness;a.shadowMapWidth=this.shadowMapWidth;a.shadowMapHeight=this.shadowMapHeight;return a};THREE.Cache=function(){this.files={}};THREE.Cache.prototype={constructor:THREE.Cache,add:function(a,b){this.files[a]=b},get:function(a){return this.files[a]},remove:function(a){delete this.files[a]},clear:function(){this.files={}}};
THREE.Loader=function(a){this.statusDomElement=(this.showStatus=a)?THREE.Loader.prototype.addStatusElement():null;this.imageLoader=new THREE.ImageLoader;this.onLoadStart=function(){};this.onLoadProgress=function(){};this.onLoadComplete=function(){}};
THREE.Loader.prototype={constructor:THREE.Loader,crossOrigin:void 0,addStatusElement:function(){var a=document.createElement("div");a.style.position="absolute";a.style.right="0px";a.style.top="0px";a.style.fontSize="0.8em";a.style.textAlign="left";a.style.background="rgba(0,0,0,0.25)";a.style.color="#fff";a.style.width="120px";a.style.padding="0.5em 0.5em 0.5em 0.5em";a.style.zIndex=1E3;a.innerHTML="Loading ...";return a},updateProgress:function(a){var b="Loaded ",b=a.total?b+((100*a.loaded/a.total).toFixed(0)+
"%"):b+((a.loaded/1024).toFixed(2)+" KB");this.statusDomElement.innerHTML=b},extractUrlBase:function(a){a=a.split("/");if(1===a.length)return"./";a.pop();return a.join("/")+"/"},initMaterials:function(a,b){for(var c=[],d=0;d<a.length;++d)c[d]=this.createMaterial(a[d],b);return c},needsTangents:function(a){for(var b=0,c=a.length;b<c;b++)if(a[b]instanceof THREE.ShaderMaterial)return!0;return!1},createMaterial:function(a,b){function c(a){a=Math.log(a)/Math.LN2;return Math.pow(2,Math.round(a))}function d(a,
d,e,g,h,k,p){var s=b+e,u,x=THREE.Loader.Handlers.get(s);null!==x?u=x.load(s):(u=new THREE.Texture,x=f.imageLoader,x.crossOrigin=f.crossOrigin,x.load(s,function(a){if(!1===THREE.Math.isPowerOfTwo(a.width)||!1===THREE.Math.isPowerOfTwo(a.height)){var b=c(a.width),d=c(a.height),e=document.createElement("canvas");e.width=b;e.height=d;e.getContext("2d").drawImage(a,0,0,b,d);u.image=e}else u.image=a;u.needsUpdate=!0}));u.sourceFile=e;g&&(u.repeat.set(g[0],g[1]),1!==g[0]&&(u.wrapS=THREE.RepeatWrapping),
1!==g[1]&&(u.wrapT=THREE.RepeatWrapping));h&&u.offset.set(h[0],h[1]);k&&(e={repeat:THREE.RepeatWrapping,mirror:THREE.MirroredRepeatWrapping},void 0!==e[k[0]]&&(u.wrapS=e[k[0]]),void 0!==e[k[1]]&&(u.wrapT=e[k[1]]));p&&(u.anisotropy=p);a[d]=u}function e(a){return(255*a[0]<<16)+(255*a[1]<<8)+255*a[2]}var f=this,g="MeshLambertMaterial",h={color:15658734,opacity:1,map:null,lightMap:null,normalMap:null,bumpMap:null,wireframe:!1};if(a.shading){var k=a.shading.toLowerCase();"phong"===k?g="MeshPhongMaterial":
"basic"===k&&(g="MeshBasicMaterial")}void 0!==a.blending&&void 0!==THREE[a.blending]&&(h.blending=THREE[a.blending]);if(void 0!==a.transparent||1>a.opacity)h.transparent=a.transparent;void 0!==a.depthTest&&(h.depthTest=a.depthTest);void 0!==a.depthWrite&&(h.depthWrite=a.depthWrite);void 0!==a.visible&&(h.visible=a.visible);void 0!==a.flipSided&&(h.side=THREE.BackSide);void 0!==a.doubleSided&&(h.side=THREE.DoubleSide);void 0!==a.wireframe&&(h.wireframe=a.wireframe);void 0!==a.vertexColors&&("face"===
a.vertexColors?h.vertexColors=THREE.FaceColors:a.vertexColors&&(h.vertexColors=THREE.VertexColors));a.colorDiffuse?h.color=e(a.colorDiffuse):a.DbgColor&&(h.color=a.DbgColor);a.colorSpecular&&(h.specular=e(a.colorSpecular));a.colorAmbient&&(h.ambient=e(a.colorAmbient));a.colorEmissive&&(h.emissive=e(a.colorEmissive));a.transparency&&(h.opacity=a.transparency);a.specularCoef&&(h.shininess=a.specularCoef);a.mapDiffuse&&b&&d(h,"map",a.mapDiffuse,a.mapDiffuseRepeat,a.mapDiffuseOffset,a.mapDiffuseWrap,
a.mapDiffuseAnisotropy);a.mapLight&&b&&d(h,"lightMap",a.mapLight,a.mapLightRepeat,a.mapLightOffset,a.mapLightWrap,a.mapLightAnisotropy);a.mapBump&&b&&d(h,"bumpMap",a.mapBump,a.mapBumpRepeat,a.mapBumpOffset,a.mapBumpWrap,a.mapBumpAnisotropy);a.mapNormal&&b&&d(h,"normalMap",a.mapNormal,a.mapNormalRepeat,a.mapNormalOffset,a.mapNormalWrap,a.mapNormalAnisotropy);a.mapSpecular&&b&&d(h,"specularMap",a.mapSpecular,a.mapSpecularRepeat,a.mapSpecularOffset,a.mapSpecularWrap,a.mapSpecularAnisotropy);a.mapAlpha&&
b&&d(h,"alphaMap",a.mapAlpha,a.mapAlphaRepeat,a.mapAlphaOffset,a.mapAlphaWrap,a.mapAlphaAnisotropy);a.mapBumpScale&&(h.bumpScale=a.mapBumpScale);a.mapNormal?(g=THREE.ShaderLib.normalmap,k=THREE.UniformsUtils.clone(g.uniforms),k.tNormal.value=h.normalMap,a.mapNormalFactor&&k.uNormalScale.value.set(a.mapNormalFactor,a.mapNormalFactor),h.map&&(k.tDiffuse.value=h.map,k.enableDiffuse.value=!0),h.specularMap&&(k.tSpecular.value=h.specularMap,k.enableSpecular.value=!0),h.lightMap&&(k.tAO.value=h.lightMap,
k.enableAO.value=!0),k.diffuse.value.setHex(h.color),k.specular.value.setHex(h.specular),k.ambient.value.setHex(h.ambient),k.shininess.value=h.shininess,void 0!==h.opacity&&(k.opacity.value=h.opacity),g=new THREE.ShaderMaterial({fragmentShader:g.fragmentShader,vertexShader:g.vertexShader,uniforms:k,lights:!0,fog:!0}),h.transparent&&(g.transparent=!0)):g=new THREE[g](h);void 0!==a.DbgName&&(g.name=a.DbgName);return g}};
THREE.Loader.Handlers={handlers:[],add:function(a,b){this.handlers.push(a,b)},get:function(a){for(var b=0,c=this.handlers.length;b<c;b+=2){var d=this.handlers[b+1];if(this.handlers[b].test(a))return d}return null}};THREE.XHRLoader=function(a){this.cache=new THREE.Cache;this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.XHRLoader.prototype={constructor:THREE.XHRLoader,load:function(a,b,c,d){var e=this,f=e.cache.get(a);void 0!==f?b&&b(f):(f=new XMLHttpRequest,f.open("GET",a,!0),f.addEventListener("load",function(c){e.cache.add(a,this.response);b&&b(this.response);e.manager.itemEnd(a)},!1),void 0!==c&&f.addEventListener("progress",function(a){c(a)},!1),void 0!==d&&f.addEventListener("error",function(a){d(a)},!1),void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin),void 0!==this.responseType&&(f.responseType=
this.responseType),f.send(null),e.manager.itemStart(a))},setResponseType:function(a){this.responseType=a},setCrossOrigin:function(a){this.crossOrigin=a}};THREE.ImageLoader=function(a){this.cache=new THREE.Cache;this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.ImageLoader.prototype={constructor:THREE.ImageLoader,load:function(a,b,c,d){var e=this,f=e.cache.get(a);if(void 0!==f)b(f);else return f=document.createElement("img"),void 0!==b&&f.addEventListener("load",function(c){e.cache.add(a,this);b(this);e.manager.itemEnd(a)},!1),void 0!==c&&f.addEventListener("progress",function(a){c(a)},!1),void 0!==d&&f.addEventListener("error",function(a){d(a)},!1),void 0!==this.crossOrigin&&(f.crossOrigin=this.crossOrigin),f.src=a,e.manager.itemStart(a),f},setCrossOrigin:function(a){this.crossOrigin=
a}};THREE.LoadingManager=function(a,b,c){var d=this,e=0,f=0;this.onLoad=a;this.onProgress=b;this.onError=c;this.itemStart=function(a){f++};this.itemEnd=function(a){e++;if(void 0!==d.onProgress)d.onProgress(a,e,f);if(e===f&&void 0!==d.onLoad)d.onLoad()}};THREE.DefaultLoadingManager=new THREE.LoadingManager;THREE.TextureLoader=function(a){this.manager=void 0!==a?a:THREE.DefaultLoadingManager};
THREE.TextureLoader.prototype={constructor:THREE.TextureLoader,load:function(a,b,c,d){var e=new THREE.ImageLoader(this.manager);e.setCrossOrigin(this.crossOrigin);e.load(a,function(a){a=new THREE.Texture(a);a.needsUpdate=!0;void 0!==b&&b(a)},c,d)},setCrossOrigin:function(a){this.crossOrigin=a}};
THREE.Material=function(){this.id=THREE.MaterialIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.side=THREE.FrontSide;this.opacity=1;this.transparent=!1;this.blending=THREE.NormalBlending;this.blendSrc=THREE.SrcAlphaFactor;this.blendDst=THREE.OneMinusSrcAlphaFactor;this.blendEquation=THREE.AddEquation;this.depthWrite=this.depthTest=!0;this.polygonOffset=!1;this.overdraw=this.alphaTest=this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.needsUpdate=this.visible=!0};
THREE.Material.prototype={constructor:THREE.Material,setValues:function(a){if(void 0!==a)for(var b in a){var c=a[b];if(void 0===c)console.warn("THREE.Material: '"+b+"' parameter is undefined.");else if(b in this){var d=this[b];d instanceof THREE.Color?d.set(c):d instanceof THREE.Vector3&&c instanceof THREE.Vector3?d.copy(c):this[b]="overdraw"==b?Number(c):c}}},clone:function(a){void 0===a&&(a=new THREE.Material);a.name=this.name;a.side=this.side;a.opacity=this.opacity;a.transparent=this.transparent;
a.blending=this.blending;a.blendSrc=this.blendSrc;a.blendDst=this.blendDst;a.blendEquation=this.blendEquation;a.depthTest=this.depthTest;a.depthWrite=this.depthWrite;a.polygonOffset=this.polygonOffset;a.polygonOffsetFactor=this.polygonOffsetFactor;a.polygonOffsetUnits=this.polygonOffsetUnits;a.alphaTest=this.alphaTest;a.overdraw=this.overdraw;a.visible=this.visible;return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount=0;THREE.LineBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.linewidth=1;this.linejoin=this.linecap="round";this.vertexColors=THREE.NoColors;this.fog=!0;this.setValues(a)};THREE.LineBasicMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone=function(){var a=new THREE.LineBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.linecap=this.linecap;a.linejoin=this.linejoin;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};THREE.LineDashedMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.scale=this.linewidth=1;this.dashSize=3;this.gapSize=1;this.vertexColors=!1;this.fog=!0;this.setValues(a)};
THREE.LineDashedMaterial.prototype=Object.create(THREE.Material.prototype);THREE.LineDashedMaterial.prototype.clone=function(){var a=new THREE.LineDashedMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.linewidth=this.linewidth;a.scale=this.scale;a.dashSize=this.dashSize;a.gapSize=this.gapSize;a.vertexColors=this.vertexColors;a.fog=this.fog;return a};
THREE.MeshBasicMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.envMap=this.alphaMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.vertexColors=THREE.NoColors;this.morphTargets=this.skinning=!1;this.setValues(a)};
THREE.MeshBasicMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone=function(){var a=new THREE.MeshBasicMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.alphaMap=this.alphaMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;
a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;return a};
THREE.MeshLambertMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.wrapAround=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.envMap=this.alphaMap=this.specularMap=this.lightMap=this.map=null;this.combine=THREE.MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap=
"round";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshLambertMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone=function(){var a=new THREE.MeshLambertMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.specularMap=this.specularMap;a.alphaMap=this.alphaMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;
a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};
THREE.MeshPhongMaterial=function(a){THREE.Material.call(this);this.color=new THREE.Color(16777215);this.ambient=new THREE.Color(16777215);this.emissive=new THREE.Color(0);this.specular=new THREE.Color(1118481);this.shininess=30;this.wrapAround=this.metal=!1;this.wrapRGB=new THREE.Vector3(1,1,1);this.bumpMap=this.lightMap=this.map=null;this.bumpScale=1;this.normalMap=null;this.normalScale=new THREE.Vector2(1,1);this.envMap=this.alphaMap=this.specularMap=null;this.combine=THREE.MultiplyOperation;this.reflectivity=
1;this.refractionRatio=0.98;this.fog=!0;this.shading=THREE.SmoothShading;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=!1;this.setValues(a)};THREE.MeshPhongMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone=function(){var a=new THREE.MeshPhongMaterial;THREE.Material.prototype.clone.call(this,a);a.color.copy(this.color);a.ambient.copy(this.ambient);a.emissive.copy(this.emissive);a.specular.copy(this.specular);a.shininess=this.shininess;a.metal=this.metal;a.wrapAround=this.wrapAround;a.wrapRGB.copy(this.wrapRGB);a.map=this.map;a.lightMap=this.lightMap;a.bumpMap=this.bumpMap;a.bumpScale=this.bumpScale;a.normalMap=this.normalMap;a.normalScale.copy(this.normalScale);
a.specularMap=this.specularMap;a.alphaMap=this.alphaMap;a.envMap=this.envMap;a.combine=this.combine;a.reflectivity=this.reflectivity;a.refractionRatio=this.refractionRatio;a.fog=this.fog;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.wireframeLinecap=this.wireframeLinecap;a.wireframeLinejoin=this.wireframeLinejoin;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=this.morphTargets;a.morphNormals=this.morphNormals;return a};
THREE.MeshDepthMaterial=function(a){THREE.Material.call(this);this.wireframe=this.morphTargets=!1;this.wireframeLinewidth=1;this.setValues(a)};THREE.MeshDepthMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshDepthMaterial.prototype.clone=function(){var a=new THREE.MeshDepthMaterial;THREE.Material.prototype.clone.call(this,a);a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};
THREE.MeshNormalMaterial=function(a){THREE.Material.call(this,a);this.shading=THREE.FlatShading;this.wireframe=!1;this.wireframeLinewidth=1;this.morphTargets=!1;this.setValues(a)};THREE.MeshNormalMaterial.prototype=Object.create(THREE.Material.prototype);THREE.MeshNormalMaterial.prototype.clone=function(){var a=new THREE.MeshNormalMaterial;THREE.Material.prototype.clone.call(this,a);a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;return a};
THREE.MeshFaceMaterial=function(a){this.materials=a instanceof Array?a:[]};THREE.MeshFaceMaterial.prototype.clone=function(){for(var a=new THREE.MeshFaceMaterial,b=0;b<this.materials.length;b++)a.materials.push(this.materials[b].clone());return a};
THREE.ShaderMaterial=function(a){THREE.Material.call(this);this.defines={};this.uniforms={};this.attributes=null;this.vertexShader="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";this.fragmentShader="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";this.shading=THREE.SmoothShading;this.linewidth=1;this.wireframe=!1;this.wireframeLinewidth=1;this.lights=this.fog=!1;this.vertexColors=THREE.NoColors;this.morphNormals=this.morphTargets=this.skinning=
!1;this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName=void 0;this.setValues(a)};THREE.ShaderMaterial.prototype=Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone=function(){var a=new THREE.ShaderMaterial;THREE.Material.prototype.clone.call(this,a);a.fragmentShader=this.fragmentShader;a.vertexShader=this.vertexShader;a.uniforms=THREE.UniformsUtils.clone(this.uniforms);a.attributes=this.attributes;a.defines=this.defines;a.shading=this.shading;a.wireframe=this.wireframe;a.wireframeLinewidth=this.wireframeLinewidth;a.fog=this.fog;a.lights=this.lights;a.vertexColors=this.vertexColors;a.skinning=this.skinning;a.morphTargets=
this.morphTargets;a.morphNormals=this.morphNormals;return a};THREE.RawShaderMaterial=function(a){THREE.ShaderMaterial.call(this,a)};THREE.RawShaderMaterial.prototype=Object.create(THREE.ShaderMaterial.prototype);THREE.RawShaderMaterial.prototype.clone=function(){var a=new THREE.RawShaderMaterial;THREE.ShaderMaterial.prototype.clone.call(this,a);return a};
THREE.Texture=function(a,b,c,d,e,f,g,h,k){this.id=THREE.TextureIdCount++;this.uuid=THREE.Math.generateUUID();this.name="";this.image=void 0!==a?a:THREE.Texture.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=void 0!==b?b:THREE.Texture.DEFAULT_MAPPING;this.wrapS=void 0!==c?c:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==d?d:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==e?e:THREE.LinearFilter;this.minFilter=void 0!==f?f:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==k?k:1;this.format=void 0!==
g?g:THREE.RGBAFormat;this.type=void 0!==h?h:THREE.UnsignedByteType;this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this._needsUpdate=!1;this.onUpdate=null};THREE.Texture.DEFAULT_IMAGE=void 0;THREE.Texture.DEFAULT_MAPPING=new THREE.UVMapping;
THREE.Texture.prototype={constructor:THREE.Texture,get needsUpdate(){return this._needsUpdate},set needsUpdate(a){!0===a&&this.update();this._needsUpdate=a},clone:function(a){void 0===a&&(a=new THREE.Texture);a.image=this.image;a.mipmaps=this.mipmaps.slice(0);a.mapping=this.mapping;a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.format=this.format;a.type=this.type;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.generateMipmaps=
this.generateMipmaps;a.premultiplyAlpha=this.premultiplyAlpha;a.flipY=this.flipY;a.unpackAlignment=this.unpackAlignment;return a},update:function(){this.dispatchEvent({type:"update"})},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);THREE.TextureIdCount=0;THREE.CubeTexture=function(a,b,c,d,e,f,g,h,k){THREE.Texture.call(this,a,b,c,d,e,f,g,h,k);this.images=a};THREE.CubeTexture.prototype=Object.create(THREE.Texture.prototype);
THREE.CubeTexture.clone=function(a){void 0===a&&(a=new THREE.CubeTexture);THREE.Texture.prototype.clone.call(this,a);a.images=this.images;return a};THREE.CompressedTexture=function(a,b,c,d,e,f,g,h,k,m,l){THREE.Texture.call(this,null,f,g,h,k,m,d,e,l);this.image={width:b,height:c};this.mipmaps=a;this.generateMipmaps=!1};THREE.CompressedTexture.prototype=Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.clone=function(){var a=new THREE.CompressedTexture;THREE.Texture.prototype.clone.call(this,a);return a};THREE.DataTexture=function(a,b,c,d,e,f,g,h,k,m,l){THREE.Texture.call(this,null,f,g,h,k,m,d,e,l);this.image={data:a,width:b,height:c}};THREE.DataTexture.prototype=Object.create(THREE.Texture.prototype);THREE.DataTexture.prototype.clone=function(){var a=new THREE.DataTexture;THREE.Texture.prototype.clone.call(this,a);return a};
THREE.Line=function(a,b,c){THREE.Object3D.call(this);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.LineBasicMaterial({color:16777215*Math.random()});this.type=void 0!==c?c:THREE.LineStrip};THREE.LineStrip=0;THREE.LinePieces=1;THREE.Line.prototype=Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.raycast=function(){var a=new THREE.Matrix4,b=new THREE.Ray,c=new THREE.Sphere;return function(d,e){var f=d.linePrecision,f=f*f,g=this.geometry;null===g.boundingSphere&&g.computeBoundingSphere();c.copy(g.boundingSphere);c.applyMatrix4(this.matrixWorld);if(!1!==d.ray.isIntersectionSphere(c)&&(a.getInverse(this.matrixWorld),b.copy(d.ray).applyMatrix4(a),g instanceof THREE.Geometry))for(var g=g.vertices,h=g.length,k=new THREE.Vector3,m=new THREE.Vector3,l=this.type===THREE.LineStrip?
1:2,n=0;n<h-1;n+=l)if(!(b.distanceSqToSegment(g[n],g[n+1],m,k)>f)){var q=b.origin.distanceTo(m);q<d.near||q>d.far||e.push({distance:q,point:k.clone().applyMatrix4(this.matrixWorld),face:null,faceIndex:null,object:this})}}}();THREE.Line.prototype.clone=function(a){void 0===a&&(a=new THREE.Line(this.geometry,this.material,this.type));THREE.Object3D.prototype.clone.call(this,a);return a};
THREE.Mesh=function(a,b,c){THREE.Object3D.call(this,c);this.geometry=void 0!==a?a:new THREE.Geometry;this.material=void 0!==b?b:new THREE.MeshBasicMaterial({color:16777215*Math.random()});this.updateMorphTargets()};THREE.Mesh.prototype=Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets=function(){if(void 0!==this.geometry.morphTargets&&0<this.geometry.morphTargets.length){this.morphTargetBase=-1;this.morphTargetForcedOrder=[];this.morphTargetInfluences=[];this.morphTargetDictionary={};for(var a=0,b=this.geometry.morphTargets.length;a<b;a++)this.morphTargetInfluences.push(0),this.morphTargetDictionary[this.geometry.morphTargets[a].name]=a}};
THREE.Mesh.prototype.getMorphTargetIndexByName=function(a){if(void 0!==this.morphTargetDictionary[a])return this.morphTargetDictionary[a];console.log("THREE.Mesh.getMorphTargetIndexByName: morph target "+a+" does not exist. Returning 0.");return 0};
THREE.Mesh.prototype.raycast=function(){var a=new THREE.Matrix4,b=new THREE.Ray,c=new THREE.Sphere,d=new THREE.Vector3,e=new THREE.Vector3,f=new THREE.Vector3;return function(g,h){var k=this.geometry;null===k.boundingSphere&&k.computeBoundingSphere();c.copy(k.boundingSphere);c.applyMatrix4(this.matrixWorld);if(!1!==g.ray.isIntersectionSphere(c)&&(a.getInverse(this.matrixWorld),b.copy(g.ray).applyMatrix4(a),null===k.boundingBox||!1!==b.isIntersectionBox(k.boundingBox)))if(k instanceof THREE.BufferGeometry){var m=
this.material;if(void 0!==m){var l=k.attributes,n,q,t=g.precision;if(void 0!==l.index){var r=l.index.array,p=k.vb?k.vb:l.position.array,s=k.vb?k.vbstride:3;(k=k.offsets)&&0!==k.length||(k=[{start:0,count:r.length,index:0}]);for(var u=0,x=k.length;u<x;++u)for(var l=k[u].start,A=k[u].index,w=l,v=l+k[u].count;w<v;w+=3){l=A+r[w];n=A+r[w+1];q=A+r[w+2];d.set(p[l*s],p[l*s+1],p[l*s+2]);e.set(p[n*s],p[n*s+1],p[n*s+2]);f.set(p[q*s],p[q*s+1],p[q*s+2]);var z=m.side===THREE.BackSide?b.intersectTriangle(f,e,d,
!0):b.intersectTriangle(d,e,f,m.side!==THREE.DoubleSide);if(null!==z){z.applyMatrix4(this.matrixWorld);var F=g.ray.origin.distanceTo(z);F<t||F<g.near||F>g.far||h.push({distance:F,point:z,indices:[l,n,q],face:null,faceIndex:null,object:this})}}}else for(p=k.vb?k.vb:l.position.array,s=k.vb?k.vbstride:3,w=0,v=p.length;w<v;w+=3)l=w,n=w+1,q=w+2,d.set(p[l*s],p[l*s+1],p[l*s+2]),e.set(p[n*s],p[n*s+1],p[n*s+2]),f.set(p[q*s],p[q*s+1],p[q*s+2]),z=m.side===THREE.BackSide?b.intersectTriangle(f,e,d,!0):b.intersectTriangle(d,
e,f,m.side!==THREE.DoubleSide),null!==z&&(z.applyMatrix4(this.matrixWorld),F=g.ray.origin.distanceTo(z),F<t||F<g.near||F>g.far||h.push({distance:F,point:z,indices:[l,n,q],face:null,faceIndex:null,object:this}))}}else if(k instanceof THREE.Geometry)for(r=this.material instanceof THREE.MeshFaceMaterial,p=!0===r?this.material.materials:null,t=g.precision,s=k.vertices,u=0,x=k.faces.length;u<x;u++)if(A=k.faces[u],m=!0===r?p[A.materialIndex]:this.material,void 0!==m){l=s[A.a];n=s[A.b];q=s[A.c];if(!0===
m.morphTargets){z=k.morphTargets;F=this.morphTargetInfluences;d.set(0,0,0);e.set(0,0,0);f.set(0,0,0);w=0;for(v=z.length;w<v;w++){var B=F[w];if(0!==B){var y=z[w].vertices;d.x+=(y[A.a].x-l.x)*B;d.y+=(y[A.a].y-l.y)*B;d.z+=(y[A.a].z-l.z)*B;e.x+=(y[A.b].x-n.x)*B;e.y+=(y[A.b].y-n.y)*B;e.z+=(y[A.b].z-n.z)*B;f.x+=(y[A.c].x-q.x)*B;f.y+=(y[A.c].y-q.y)*B;f.z+=(y[A.c].z-q.z)*B}}d.add(l);e.add(n);f.add(q);l=d;n=e;q=f}z=m.side===THREE.BackSide?b.intersectTriangle(q,n,l,!0):b.intersectTriangle(l,n,q,m.side!==THREE.DoubleSide);
null!==z&&(z.applyMatrix4(this.matrixWorld),F=g.ray.origin.distanceTo(z),F<t||F<g.near||F>g.far||h.push({distance:F,point:z,face:A,faceIndex:u,object:this}))}}}();THREE.Mesh.prototype.clone=function(a,b){void 0===a&&(a=new THREE.Mesh(this.geometry,this.material));THREE.Object3D.prototype.clone.call(this,a,b);return a};
THREE.Scene=function(a){THREE.Object3D.call(this,a);this.children||(this.children=[]);this.overrideMaterial=this.fog=null;this.autoUpdate=!0;this.matrixAutoUpdate=!1;this.__lights=[];this.__objectsAdded=[];this.__objectsRemoved=[]};THREE.Scene.prototype=Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject=function(a){if(a instanceof THREE.Light)-1===this.__lights.indexOf(a)&&this.__lights.push(a),a.target&&void 0===a.target.parent&&this.add(a.target);else if(!(a instanceof THREE.Camera)){this.__objectsAdded.push(a);var b=this.__objectsRemoved.indexOf(a);-1!==b&&this.__objectsRemoved.splice(b,1)}this.dispatchEvent({type:"objectAdded",object:a});a.dispatchEvent({type:"addedToScene",scene:this});if(a.children)for(b=0;b<a.children.length;b++)this.__addObject(a.children[b])};
THREE.Scene.prototype.__removeObject=function(a){if(a instanceof THREE.Light){var b=this.__lights.indexOf(a);-1!==b&&this.__lights.splice(b,1);if(a.shadowCascadeArray)for(b=0;b<a.shadowCascadeArray.length;b++)this.__removeObject(a.shadowCascadeArray[b])}else a instanceof THREE.Camera||(this.__objectsRemoved.push(a),b=this.__objectsAdded.indexOf(a),-1!==b&&this.__objectsAdded.splice(b,1));this.dispatchEvent({type:"objectRemoved",object:a});a.dispatchEvent({type:"removedFromScene",scene:this});if(a.children)for(b=
0;b<a.children.length;b++)this.__removeObject(a.children[b])};THREE.Scene.prototype.clone=function(a){void 0===a&&(a=new THREE.Scene);THREE.Object3D.prototype.clone.call(this,a);null!==this.fog&&(a.fog=this.fog.clone());null!==this.overrideMaterial&&(a.overrideMaterial=this.overrideMaterial.clone());a.autoUpdate=this.autoUpdate;a.matrixAutoUpdate=this.matrixAutoUpdate;return a};THREE.Fog=function(a,b,c){this.name="";this.color=new THREE.Color(a);this.near=void 0!==b?b:1;this.far=void 0!==c?c:1E3};
THREE.Fog.prototype.clone=function(){return new THREE.Fog(this.color.getHex(),this.near,this.far)};THREE.FogExp2=function(a,b){this.name="";this.color=new THREE.Color(a);this.density=void 0!==b?b:2.5E-4};THREE.FogExp2.prototype.clone=function(){return new THREE.FogExp2(this.color.getHex(),this.density)};THREE.ShaderChunk={};THREE.ShaderChunk.alphatest_fragment="#ifdef ALPHATEST\n\n\tif ( gl_FragColor.a < ALPHATEST ) discard;\n\n#endif\n";THREE.ShaderChunk.lights_lambert_vertex="vLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack = vec3( 0.0 );\n\n#endif\n\ntransformedNormal = normalize( transformedNormal );\n\n#if MAX_DIR_LIGHTS > 0\n\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\tvec3 dirVector = normalize( lDirection.xyz );\n\n\tfloat dotProduct = dot( transformedNormal, dirVector );\n\tvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t#endif\n\n\t#endif\n\n\t#ifdef WRAP_AROUND\n\n\t\tvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\tdirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tdirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n\n\t\t#endif\n\n\t#endif\n\n\tvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n\n\t#endif\n\n}\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat lDistance = 1.0;\n\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n\t\tlVector = normalize( lVector );\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\tpointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tpointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t\tvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n\n\t\t#endif\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz - mvPosition.xyz;\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\tfloat lDistance = 1.0;\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\n\t\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n\t\t\tlVector = normalize( lVector );\n\n\t\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\t\t\tvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n\n\t\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\t\tvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\n\t\t\t\tspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n\n\t\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\t\tspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n\n\t\t\t\t#endif\n\n\t\t\t#endif\n\n\t\t\tvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n\n\t\t\t#ifdef DOUBLE_SIDED\n\n\t\t\t\tvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n\n\t\t\t#endif\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n\t\tvec3 lVector = normalize( lDirection.xyz );\n\n\t\tfloat dotProduct = dot( transformedNormal, lVector );\n\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\tfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\n\n\t\tvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n\n\t\t#endif\n\n\t}\n\n#endif\n\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n\n#ifdef DOUBLE_SIDED\n\n\tvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n\n#endif";
THREE.ShaderChunk.map_particle_pars_fragment="#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif";THREE.ShaderChunk.default_vertex="vec4 mvPosition;\n\n#ifdef USE_SKINNING\n\n\tmvPosition = modelViewMatrix * skinned;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\n\n\tmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\n\n\tmvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n#endif\n\ngl_Position = projectionMatrix * mvPosition;";
THREE.ShaderChunk.map_pars_fragment="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\n#endif\n\n#ifdef USE_MAP\n\n\tuniform sampler2D map;\n\n#endif";THREE.ShaderChunk.logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n\tuniform float logDepthBufFC;\n\n#endif";THREE.ShaderChunk.lightmap_pars_vertex="#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\n#endif";
THREE.ShaderChunk.lights_phong_fragment="vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n\n#ifdef DOUBLE_SIDED\n\n\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\n#endif\n\n#ifdef USE_NORMALMAP\n\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\n#elif defined( USE_BUMPMAP )\n\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tvec3 pointDiffuse = vec3( 0.0 );\n\tvec3 pointSpecular = vec3( 0.0 );\n\n\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat lDistance = 1.0;\n\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\n\n\t\tlVector = normalize( lVector );\n\n\t\t\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\tpointDiffuse += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\n\n\t\t\t\t// specular\n\n\t\tvec3 pointHalfVector = normalize( lVector + viewPosition );\n\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n\t\tfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );\n\t\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;\n\n\t}\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tvec3 spotDiffuse = vec3( 0.0 );\n\tvec3 spotSpecular = vec3( 0.0 );\n\n\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\n\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\tvec3 lVector = lPosition.xyz + vViewPosition.xyz;\n\n\t\tfloat lDistance = 1.0;\n\t\tif ( spotLightDistance[ i ] > 0.0 )\n\t\t\tlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\n\n\t\tlVector = normalize( lVector );\n\n\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\n\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\n\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\n\t\t\t\t\t// diffuse\n\n\t\t\tfloat dotProduct = dot( normal, lVector );\n\n\t\t\t#ifdef WRAP_AROUND\n\n\t\t\t\tfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\n\t\t\t#else\n\n\t\t\t\tfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t\t#endif\n\n\t\t\tspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\n\n\t\t\t\t\t// specular\n\n\t\t\tvec3 spotHalfVector = normalize( lVector + viewPosition );\n\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n\t\t\tfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );\n\t\t\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n\n\t\t}\n\n\t}\n\n#endif\n\n#if MAX_DIR_LIGHTS > 0\n\n\tvec3 dirDiffuse = vec3( 0.0 );\n\tvec3 dirSpecular = vec3( 0.0 );\n\n\tfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\n\n\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\t\tvec3 dirVector = normalize( lDirection.xyz );\n\n\t\t\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, dirVector );\n\n\t\t#ifdef WRAP_AROUND\n\n\t\t\tfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\n\t\t\tfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\n\n\t\t\tvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n\n\t\t#else\n\n\t\t\tfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n\n\t\t#endif\n\n\t\tdirDiffuse += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\n\n\t\t// specular\n\n\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\n\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n\t\tfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\n\t\t/*\n\t\t// fresnel term from skin shader\n\t\tconst float F0 = 0.128;\n\n\t\tfloat base = 1.0 - dot( viewPosition, dirHalfVector );\n\t\tfloat exponential = pow( base, 5.0 );\n\n\t\tfloat fresnel = exponential + F0 * ( 1.0 - exponential );\n\t\t*/\n\n\t\t/*\n\t\t// fresnel term from fresnel shader\n\t\tconst float mFresnelBias = 0.08;\n\t\tconst float mFresnelScale = 0.3;\n\t\tconst float mFresnelPower = 5.0;\n\n\t\tfloat fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );\n\t\t*/\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\t// \t\tdirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;\n\n\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n\t\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\n\n\t}\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tvec3 hemiDiffuse = vec3( 0.0 );\n\tvec3 hemiSpecular = vec3( 0.0 );\n\n\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\n\t\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n\t\tvec3 lVector = normalize( lDirection.xyz );\n\n\t\t// diffuse\n\n\t\tfloat dotProduct = dot( normal, lVector );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\n\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\n\t\themiDiffuse += diffuse * hemiColor;\n\n\t\t// specular (sky light)\n\n\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n\t\tfloat hemiSpecularWeightSky = specularStrength * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\n\t\t// specular (ground light)\n\n\t\tvec3 lVectorGround = -lVector;\n\n\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n\t\tfloat hemiSpecularWeightGround = specularStrength * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\n\t\tfloat dotProductGround = dot( normal, lVectorGround );\n\n\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\n\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n\t\themiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\n\t}\n\n#endif\n\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n\n#if MAX_DIR_LIGHTS > 0\n\n\ttotalDiffuse += dirDiffuse;\n\ttotalSpecular += dirSpecular;\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\ttotalDiffuse += hemiDiffuse;\n\ttotalSpecular += hemiSpecular;\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\ttotalDiffuse += pointDiffuse;\n\ttotalSpecular += pointSpecular;\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\ttotalDiffuse += spotDiffuse;\n\ttotalSpecular += spotSpecular;\n\n#endif\n\n#ifdef METAL\n\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\n#else\n\n\tgl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\n#endif";
THREE.ShaderChunk.fog_pars_fragment="#ifdef USE_FOG\n\n\tuniform vec3 fogColor;\n\n\t#ifdef FOG_EXP2\n\n\t\tuniform float fogDensity;\n\n\t#else\n\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n\n#endif";THREE.ShaderChunk.envmap_pars_fragment="#ifdef USE_ENVMAP\n\n\tuniform float reflectivity;\n\tuniform samplerCube envMap;\n\tuniform float flipEnvMap;\n\tuniform int combine;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\n\t\tuniform bool useRefract;\n\t\tuniform float refractionRatio;\n\n\t#else\n\n\t\tvarying vec3 vReflect;\n\n\t#endif\n\n#endif";
THREE.ShaderChunk.logdepthbuf_fragment="#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n#endif";THREE.ShaderChunk.normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\n\t\t\t// Per-Pixel Tangent Space Normal Mapping\n\t\t\t// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\n\t}\n\n#endif\n";
THREE.ShaderChunk.lights_phong_pars_vertex="#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n";THREE.ShaderChunk.lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\n\tvarying vec2 vUv2;\n\tuniform sampler2D lightMap;\n\n#endif";THREE.ShaderChunk.shadowmap_vertex="#ifdef USE_SHADOWMAP\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\n\t}\n\n#endif";
THREE.ShaderChunk.lights_phong_vertex="#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif";THREE.ShaderChunk.map_fragment="#ifdef USE_MAP\n\n\tvec4 texelColor = texture2D( map, vUv );\n\n\t#ifdef GAMMA_INPUT\n\n\t\ttexelColor.xyz *= texelColor.xyz;\n\n\t#endif\n\n\tgl_FragColor = gl_FragColor * texelColor;\n\n#endif";THREE.ShaderChunk.lightmap_vertex="#ifdef USE_LIGHTMAP\n\n\tvUv2 = uv2;\n\n#endif";
THREE.ShaderChunk.map_particle_fragment="#ifdef USE_MAP\n\n\tgl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n\n#endif";THREE.ShaderChunk.color_pars_fragment="#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif\n";THREE.ShaderChunk.color_vertex="#ifdef USE_COLOR\n\n\t#ifdef GAMMA_INPUT\n\n\t\tvColor = color * color;\n\n\t#else\n\n\t\tvColor = color;\n\n\t#endif\n\n#endif";THREE.ShaderChunk.envmap_pars_vertex="#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n\n\tvarying vec3 vReflect;\n\n\tuniform float refractionRatio;\n\tuniform bool useRefract;\n\n#endif\n";
THREE.ShaderChunk.linear_to_gamma_fragment="#ifdef GAMMA_OUTPUT\n\n\tgl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n\n#endif";THREE.ShaderChunk.color_pars_vertex="#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif";THREE.ShaderChunk.lights_lambert_pars_vertex="uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\n\nuniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n";
THREE.ShaderChunk.map_pars_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n\n#endif\n";THREE.ShaderChunk.envmap_fragment="#ifdef USE_ENVMAP\n\n\tvec3 reflectVec;\n\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n\t\t// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\n\t\t// Transforming Normal Vectors with the Inverse Transformation\n\n\t\tvec3 worldNormal = normalize( vec3( vec4( normal, 0.0 ) * viewMatrix ) );\n\n\t\tif ( useRefract ) {\n\n\t\t\treflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t\t} else { \n\n\t\t\treflectVec = reflect( cameraToVertex, worldNormal );\n\n\t\t}\n\n\t#else\n\n\t\treflectVec = vReflect;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n\t\tvec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#else\n\n\t\tvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n\t#endif\n\n\t#ifdef GAMMA_INPUT\n\n\t\tcubeColor.xyz *= cubeColor.xyz;\n\n\t#endif\n\n\tif ( combine == 1 ) {\n\n\t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );\n\n\t} else if ( combine == 2 ) {\n\n\t\tgl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;\n\n\t} else {\n\n\t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );\n\n\t}\n\n#endif";
THREE.ShaderChunk.specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\n\tuniform sampler2D specularMap;\n\n#endif";THREE.ShaderChunk.logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\n\tgl_Position.z = log2(max(1e-6, gl_Position.w + 1.0)) * logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\n#else\n\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n\t#endif\n\n#endif";THREE.ShaderChunk.specularmap_fragment="float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n\n#else\n\n\tspecularStrength = 1.0;\n\n#endif";
THREE.ShaderChunk.fog_fragment="#ifdef USE_FOG\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\n\t#else\n\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\n\t#endif\n\n\t#ifdef FOG_EXP2\n\n\t\tconst float LOG2 = 1.442695;\n\t\tfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\n\t\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n\n\t#else\n\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\n\t#endif\n\t\n\tgl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n\n#endif";
THREE.ShaderChunk.bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\n\t\t\t// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n\t\t\t//\thttp://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n\t\t\t// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n\tvec2 dHdxy_fwd() {\n\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n\t\treturn vec2( dBx, dBy );\n\n\t}\n\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\t\t// normalized\n\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\n\t}\n\n#endif";
THREE.ShaderChunk.defaultnormal_vertex="vec3 objectNormal;\n\n#ifdef USE_SKINNING\n\n\tobjectNormal = skinnedNormal.xyz;\n\n#endif\n\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\n\n\tobjectNormal = morphedNormal;\n\n#endif\n\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\n\n\tobjectNormal = normal;\n\n#endif\n\n#ifdef FLIP_SIDED\n\n\tobjectNormal = -objectNormal;\n\n#endif\n\nvec3 transformedNormal = normalMatrix * objectNormal;";
THREE.ShaderChunk.lights_phong_pars_fragment="uniform vec3 ambientLightColor;\n\n#if MAX_DIR_LIGHTS > 0\n\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n\n#endif\n\n#if MAX_HEMI_LIGHTS > 0\n\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n\n#endif\n\n#if MAX_POINT_LIGHTS > 0\n\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0\n\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n\n#endif\n\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_ENVMAP )\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n#ifdef WRAP_AROUND\n\n\tuniform vec3 wrapRGB;\n\n#endif\n\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;";
THREE.ShaderChunk.map_vertex="#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP )\n\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n\n#endif";THREE.ShaderChunk.lightmap_fragment="#ifdef USE_LIGHTMAP\n\n\tgl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n\n#endif";THREE.ShaderChunk.shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\tuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n\n#endif";
THREE.ShaderChunk.color_fragment="#ifdef USE_COLOR\n\n\tgl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n\n#endif";THREE.ShaderChunk.envmap_vertex="#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\n\n\tvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\n\tworldNormal = normalize( worldNormal );\n\n\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n\tif ( useRefract ) {\n\n\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n\t} else {\n\n\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\n\t}\n\n#endif";
THREE.ShaderChunk.shadowmap_fragment="#ifdef USE_SHADOWMAP\n\n\t#ifdef SHADOWMAP_DEBUG\n\n\t\tvec3 frustumColors[3];\n\t\tfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\n\t\tfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\n\t\tfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n\n\t#endif\n\n\t#ifdef SHADOWMAP_CASCADE\n\n\t\tint inFrustumCount = 0;\n\n\t#endif\n\n\tfloat fDepth;\n\tvec3 shadowColor = vec3( 1.0 );\n\n\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\n\t\tvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\n\n\t\t\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\n\t\t\t\t// if ( all( something, something ) ) using this instead\n\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\n\t\t\t\t// don't shadow pixels outside of light frustum\n\t\t\t\t// use just first frustum (for cascades)\n\t\t\t\t// don't shadow pixels behind far plane of light frustum\n\n\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\tinFrustumCount += int( inFrustum );\n\t\t\tbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n\n\t\t#else\n\n\t\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n\t\t#endif\n\n\t\tbool frustumTest = all( frustumTestVec );\n\n\t\tif ( frustumTest ) {\n\n\t\t\tshadowCoord.z += shadowBias[ i ];\n\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t/*\n\t\t\t\t\t\t// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL\n\t\t\t\t\t\t// must enroll loop manually\n\n\t\t\t\tfor ( float y = -1.25; y <= 1.25; y += 1.25 )\n\t\t\t\t\tfor ( float x = -1.25; x <= 1.25; x += 1.25 ) {\n\n\t\t\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );\n\n\t\t\t\t\t\t\t\t// doesn't seem to produce any noticeable visual difference compared to simple texture2D lookup\n\t\t\t\t\t\t\t\t//vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );\n\n\t\t\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\t\t\tif ( fDepth < shadowCoord.z )\n\t\t\t\t\t\t\tshadow += 1.0;\n\n\t\t\t\t}\n\n\t\t\t\tshadow /= 9.0;\n\n\t\t*/\n\n\t\t\t\tconst float shadowDelta = 1.0 / 9.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.25 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.25 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.25 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.25 * yPixelOffset;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\t\t\t\tif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\t\t\t\t// Percentage-close filtering\n\t\t\t\t\t\t// (9 pixel kernel)\n\t\t\t\t\t\t// http://fabiensanglard.net/shadowmappingPCF/\n\n\t\t\t\tfloat shadow = 0.0;\n\n\t\t\t\tfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\n\t\t\t\tfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\n\n\t\t\t\tfloat dx0 = -1.0 * xPixelOffset;\n\t\t\t\tfloat dy0 = -1.0 * yPixelOffset;\n\t\t\t\tfloat dx1 = 1.0 * xPixelOffset;\n\t\t\t\tfloat dy1 = 1.0 * yPixelOffset;\n\n\t\t\t\tmat3 shadowKernel;\n\t\t\t\tmat3 depthKernel;\n\n\t\t\t\tdepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\n\t\t\t\tdepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\n\t\t\t\tdepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\n\t\t\t\tdepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\n\t\t\t\tdepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\n\t\t\t\tdepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\n\t\t\t\tdepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\n\t\t\t\tdepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\n\t\t\t\tdepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\n\n\t\t\t\tvec3 shadowZ = vec3( shadowCoord.z );\n\t\t\t\tshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\n\t\t\t\tshadowKernel[0] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\n\t\t\t\tshadowKernel[1] *= vec3(0.25);\n\n\t\t\t\tshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\n\t\t\t\tshadowKernel[2] *= vec3(0.25);\n\n\t\t\t\tvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\n\n\t\t\t\tshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\n\t\t\t\tshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\n\n\t\t\t\tvec4 shadowValues;\n\t\t\t\tshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\n\t\t\t\tshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\n\t\t\t\tshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\n\t\t\t\tshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\n\n\t\t\t\tshadow = dot( shadowValues, vec4( 1.0 ) );\n\n\t\t\t\tshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n\n\t\t\t#else\n\n\t\t\t\tvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\n\t\t\t\tfloat fDepth = unpackDepth( rgbaDepth );\n\n\t\t\t\tif ( fDepth < shadowCoord.z )\n\n\t\t// spot with multiple shadows is darker\n\n\t\t\t\t\tshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n\n\t\t// spot with multiple shadows has the same color as single shadow spot\n\n\t\t// \t\t\t\t\tshadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );\n\n\t\t\t#endif\n\n\t\t}\n\n\n\t\t#ifdef SHADOWMAP_DEBUG\n\n\t\t\t#ifdef SHADOWMAP_CASCADE\n\n\t\t\t\tif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n\n\t\t\t#else\n\n\t\t\t\tif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n\n\t\t\t#endif\n\n\t\t#endif\n\n\t}\n\n\t#ifdef GAMMA_OUTPUT\n\n\t\tshadowColor *= shadowColor;\n\n\t#endif\n\n\tgl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n\n#endif\n";
THREE.ShaderChunk.worldpos_vertex="#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\n\t#ifdef USE_SKINNING\n\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\n\t#endif\n\n\t#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n\t\tvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n\n\t#endif\n\n\t#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\n\n\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\n\t#endif\n\n#endif";
THREE.ShaderChunk.shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\n\tuniform sampler2D shadowMap[ MAX_SHADOWS ];\n\tuniform vec2 shadowMapSize[ MAX_SHADOWS ];\n\n\tuniform float shadowDarkness[ MAX_SHADOWS ];\n\tuniform float shadowBias[ MAX_SHADOWS ];\n\n\tvarying vec4 vShadowCoord[ MAX_SHADOWS ];\n\n\tfloat unpackDepth( const in vec4 rgba_depth ) {\n\n\t\tconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n\t\tfloat depth = dot( rgba_depth, bit_shift );\n\t\treturn depth;\n\n\t}\n\n#endif";
THREE.ShaderChunk.logdepthbuf_pars_fragment="#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\t#extension GL_EXT_frag_depth : enable\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif";THREE.ShaderChunk.alphamap_fragment="#ifdef USE_ALPHAMAP\n\n\tgl_FragColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";THREE.ShaderChunk.alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\n\tuniform sampler2D alphaMap;\n\n#endif\n";
THREE.UniformsUtils={merge:function(a){var b,c,d,e={};for(b=0;b<a.length;b++)for(c in d=this.clone(a[b]),d)e[c]=d[c];return e},clone:function(a){var b,c,d,e={};for(b in a)for(c in e[b]={},a[b])d=a[b][c],e[b][c]=d instanceof THREE.Color||d instanceof THREE.Vector2||d instanceof THREE.Vector3||d instanceof THREE.Vector4||d instanceof THREE.Matrix4||d instanceof THREE.Texture?d.clone():d instanceof Array?d.slice():d;return e}};
THREE.UniformsLib={common:{diffuse:{type:"c",value:new THREE.Color(15658734)},opacity:{type:"f",value:1},map:{type:"t",value:null},offsetRepeat:{type:"v4",value:new THREE.Vector4(0,0,1,1)},lightMap:{type:"t",value:null},specularMap:{type:"t",value:null},alphaMap:{type:"t",value:null},envMap:{type:"t",value:null},flipEnvMap:{type:"f",value:-1},useRefract:{type:"i",value:0},reflectivity:{type:"f",value:1},refractionRatio:{type:"f",value:0.98},combine:{type:"i",value:0},morphTargetInfluences:{type:"f",
value:0}},bump:{bumpMap:{type:"t",value:null},bumpScale:{type:"f",value:1}},normalmap:{normalMap:{type:"t",value:null},normalScale:{type:"v2",value:new THREE.Vector2(1,1)}},fog:{fogDensity:{type:"f",value:2.5E-4},fogNear:{type:"f",value:1},fogFar:{type:"f",value:2E3},fogColor:{type:"c",value:new THREE.Color(16777215)}},lights:{ambientLightColor:{type:"fv",value:[]},directionalLightDirection:{type:"fv",value:[]},directionalLightColor:{type:"fv",value:[]},hemisphereLightDirection:{type:"fv",value:[]},
hemisphereLightSkyColor:{type:"fv",value:[]},hemisphereLightGroundColor:{type:"fv",value:[]},pointLightColor:{type:"fv",value:[]},pointLightPosition:{type:"fv",value:[]},pointLightDistance:{type:"fv1",value:[]},spotLightColor:{type:"fv",value:[]},spotLightPosition:{type:"fv",value:[]},spotLightDirection:{type:"fv",value:[]},spotLightDistance:{type:"fv1",value:[]},spotLightAngleCos:{type:"fv1",value:[]},spotLightExponent:{type:"fv1",value:[]}},particle:{psColor:{type:"c",value:new THREE.Color(15658734)},
opacity:{type:"f",value:1},size:{type:"f",value:1},scale:{type:"f",value:1},map:{type:"t",value:null},fogDensity:{type:"f",value:2.5E-4},fogNear:{type:"f",value:1},fogFar:{type:"f",value:2E3},fogColor:{type:"c",value:new THREE.Color(16777215)}},shadowmap:{shadowMap:{type:"tv",value:[]},shadowMapSize:{type:"v2v",value:[]},shadowBias:{type:"fv1",value:[]},shadowDarkness:{type:"fv1",value:[]},shadowMatrix:{type:"m4v",value:[]}}};
THREE.ShaderLib={basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.shadowmap]),vertexShader:[THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,"void main() {",THREE.ShaderChunk.map_vertex,
THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.skinbase_vertex,"\t#ifdef USE_ENVMAP",THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,"\t#endif",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),
fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.alphamap_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,"void main() {\n\tgl_FragColor = vec4( diffuse, opacity );",THREE.ShaderChunk.logdepthbuf_fragment,
THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphamap_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},lambert:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,
{ambient:{type:"c",value:new THREE.Color(16777215)},emissive:{type:"c",value:new THREE.Color(0)},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),vertexShader:["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif",THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_lambert_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,
THREE.ShaderChunk.shadowmap_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,"void main() {",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,THREE.ShaderChunk.worldpos_vertex,
THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.lights_lambert_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.alphamap_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,
THREE.ShaderChunk.specularmap_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,"void main() {\n\tgl_FragColor = vec4( vec3( 1.0 ), opacity );",THREE.ShaderChunk.logdepthbuf_fragment,THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphamap_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,"\t#ifdef DOUBLE_SIDED\n\t\tif ( gl_FrontFacing )\n\t\t\tgl_FragColor.xyz *= vLightFront;\n\t\telse\n\t\t\tgl_FragColor.xyz *= vLightBack;\n\t#else\n\t\tgl_FragColor.xyz *= vLightFront;\n\t#endif",
THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},phong:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,THREE.UniformsLib.bump,THREE.UniformsLib.normalmap,THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{ambient:{type:"c",value:new THREE.Color(16777215)},emissive:{type:"c",value:new THREE.Color(0)},
specular:{type:"c",value:new THREE.Color(1118481)},shininess:{type:"f",value:30},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),vertexShader:["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",THREE.ShaderChunk.map_pars_vertex,THREE.ShaderChunk.lightmap_pars_vertex,THREE.ShaderChunk.envmap_pars_vertex,THREE.ShaderChunk.lights_phong_pars_vertex,THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,
THREE.ShaderChunk.logdepthbuf_pars_vertex,"void main() {",THREE.ShaderChunk.map_vertex,THREE.ShaderChunk.lightmap_vertex,THREE.ShaderChunk.color_vertex,THREE.ShaderChunk.morphnormal_vertex,THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,THREE.ShaderChunk.defaultnormal_vertex,"\tvNormal = normalize( transformedNormal );",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,"\tvViewPosition = -mvPosition.xyz;",
THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.envmap_vertex,THREE.ShaderChunk.lights_phong_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_pars_fragment,THREE.ShaderChunk.alphamap_pars_fragment,THREE.ShaderChunk.lightmap_pars_fragment,THREE.ShaderChunk.envmap_pars_fragment,
THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.lights_phong_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.bumpmap_pars_fragment,THREE.ShaderChunk.normalmap_pars_fragment,THREE.ShaderChunk.specularmap_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,"void main() {\n\tgl_FragColor = vec4( vec3( 1.0 ), opacity );",THREE.ShaderChunk.logdepthbuf_fragment,THREE.ShaderChunk.map_fragment,THREE.ShaderChunk.alphamap_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.specularmap_fragment,
THREE.ShaderChunk.lights_phong_fragment,THREE.ShaderChunk.lightmap_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.envmap_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},particle_basic:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.particle,THREE.UniformsLib.shadowmap]),vertexShader:["uniform float size;\nuniform float scale;",THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,
THREE.ShaderChunk.logdepthbuf_pars_vertex,"void main() {",THREE.ShaderChunk.color_vertex,"\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\tgl_Position = projectionMatrix * mvPosition;",THREE.ShaderChunk.logdepthbuf_vertex,THREE.ShaderChunk.worldpos_vertex,THREE.ShaderChunk.shadowmap_vertex,"}"].join("\n"),fragmentShader:["uniform vec3 psColor;\nuniform float opacity;",
THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.map_particle_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,"void main() {\n\tgl_FragColor = vec4( psColor, opacity );",THREE.ShaderChunk.logdepthbuf_fragment,THREE.ShaderChunk.map_particle_fragment,THREE.ShaderChunk.alphatest_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n")},dashed:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.common,
THREE.UniformsLib.fog,{scale:{type:"f",value:1},dashSize:{type:"f",value:1},totalSize:{type:"f",value:2}}]),vertexShader:["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;",THREE.ShaderChunk.color_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,"void main() {",THREE.ShaderChunk.color_vertex,"\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;",THREE.ShaderChunk.logdepthbuf_vertex,
"}"].join("\n"),fragmentShader:["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;",THREE.ShaderChunk.color_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,"void main() {\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tgl_FragColor = vec4( diffuse, opacity );",THREE.ShaderChunk.logdepthbuf_fragment,THREE.ShaderChunk.color_fragment,THREE.ShaderChunk.fog_fragment,
"}"].join("\n")},depth:{uniforms:{mNear:{type:"f",value:1},mFar:{type:"f",value:2E3},opacity:{type:"f",value:1}},vertexShader:[THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,"void main() {",THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,"}"].join("\n"),fragmentShader:["uniform float mNear;\nuniform float mFar;\nuniform float opacity;",THREE.ShaderChunk.logdepthbuf_pars_fragment,"void main() {",THREE.ShaderChunk.logdepthbuf_fragment,
"\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\tfloat color = 1.0 - smoothstep( mNear, mFar, depth );\n\tgl_FragColor = vec4( vec3( color ), opacity );\n}"].join("\n")},normal:{uniforms:{opacity:{type:"f",value:1}},vertexShader:["varying vec3 vNormal;",THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,"void main() {\n\tvNormal = normalize( normalMatrix * normal );",
THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,"}"].join("\n"),fragmentShader:["uniform float opacity;\nvarying vec3 vNormal;",THREE.ShaderChunk.logdepthbuf_pars_fragment,"void main() {\n\tgl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",THREE.ShaderChunk.logdepthbuf_fragment,"}"].join("\n")},normalmap:{uniforms:THREE.UniformsUtils.merge([THREE.UniformsLib.fog,THREE.UniformsLib.lights,THREE.UniformsLib.shadowmap,{enableAO:{type:"i",
value:0},enableDiffuse:{type:"i",value:0},enableSpecular:{type:"i",value:0},enableReflection:{type:"i",value:0},enableDisplacement:{type:"i",value:0},tDisplacement:{type:"t",value:null},tDiffuse:{type:"t",value:null},tCube:{type:"t",value:null},tNormal:{type:"t",value:null},tSpecular:{type:"t",value:null},tAO:{type:"t",value:null},uNormalScale:{type:"v2",value:new THREE.Vector2(1,1)},uDisplacementBias:{type:"f",value:0},uDisplacementScale:{type:"f",value:1},diffuse:{type:"c",value:new THREE.Color(16777215)},
specular:{type:"c",value:new THREE.Color(1118481)},ambient:{type:"c",value:new THREE.Color(16777215)},shininess:{type:"f",value:30},opacity:{type:"f",value:1},useRefract:{type:"i",value:0},refractionRatio:{type:"f",value:0.98},reflectivity:{type:"f",value:0.5},uOffset:{type:"v2",value:new THREE.Vector2(0,0)},uRepeat:{type:"v2",value:new THREE.Vector2(1,1)},wrapRGB:{type:"v3",value:new THREE.Vector3(1,1,1)}}]),fragmentShader:["uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\n\tuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\n\tuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\n\tuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\n\tuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\n\tuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\n\tuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\n\tuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\n\tuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\n\tuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n\tuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\n\tuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
THREE.ShaderChunk.shadowmap_pars_fragment,THREE.ShaderChunk.fog_pars_fragment,THREE.ShaderChunk.logdepthbuf_pars_fragment,"void main() {",THREE.ShaderChunk.logdepthbuf_fragment,"\tgl_FragColor = vec4( vec3( 1.0 ), opacity );\n\tvec3 specularTex = vec3( 1.0 );\n\tvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\n\tnormalTex.xy *= uNormalScale;\n\tnormalTex = normalize( normalTex );\n\tif( enableDiffuse ) {\n\t\t#ifdef GAMMA_INPUT\n\t\t\tvec4 texelColor = texture2D( tDiffuse, vUv );\n\t\t\ttexelColor.xyz *= texelColor.xyz;\n\t\t\tgl_FragColor = gl_FragColor * texelColor;\n\t\t#else\n\t\t\tgl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n\t\t#endif\n\t}\n\tif( enableAO ) {\n\t\t#ifdef GAMMA_INPUT\n\t\t\tvec4 aoColor = texture2D( tAO, vUv );\n\t\t\taoColor.xyz *= aoColor.xyz;\n\t\t\tgl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n\t\t#else\n\t\t\tgl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n\t\t#endif\n\t}",
THREE.ShaderChunk.alphatest_fragment,"\tif( enableSpecular )\n\t\tspecularTex = texture2D( tSpecular, vUv ).xyz;\n\tmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\n\tvec3 finalNormal = tsb * normalTex;\n\t#ifdef FLIP_SIDED\n\t\tfinalNormal = -finalNormal;\n\t#endif\n\tvec3 normal = normalize( finalNormal );\n\tvec3 viewPosition = normalize( vViewPosition );\n\t#if MAX_POINT_LIGHTS > 0\n\t\tvec3 pointDiffuse = vec3( 0.0 );\n\t\tvec3 pointSpecular = vec3( 0.0 );\n\t\tfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\n\t\t\tvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\n\t\t\tvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\n\t\t\tfloat pointDistance = 1.0;\n\t\t\tif ( pointLightDistance[ i ] > 0.0 )\n\t\t\t\tpointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\n\t\t\tpointVector = normalize( pointVector );\n\t\t\t#ifdef WRAP_AROUND\n\t\t\t\tfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\n\t\t\t\tfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\n\t\t\t\tvec3 pointDiffuseWeight = mix( vec3( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n\t\t\t#else\n\t\t\t\tfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n\t\t\t#endif\n\t\t\tpointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\n\t\t\tvec3 pointHalfVector = normalize( pointVector + viewPosition );\n\t\t\tfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\n\t\t\tfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( pointVector, pointHalfVector ), 0.0 ), 5.0 );\n\t\t\tpointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n\t\t}\n\t#endif\n\t#if MAX_SPOT_LIGHTS > 0\n\t\tvec3 spotDiffuse = vec3( 0.0 );\n\t\tvec3 spotSpecular = vec3( 0.0 );\n\t\tfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\n\t\t\tvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\n\t\t\tvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\n\t\t\tfloat spotDistance = 1.0;\n\t\t\tif ( spotLightDistance[ i ] > 0.0 )\n\t\t\t\tspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\n\t\t\tspotVector = normalize( spotVector );\n\t\t\tfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\n\t\t\tif ( spotEffect > spotLightAngleCos[ i ] ) {\n\t\t\t\tspotEffect = max( pow( max( spotEffect, 0.0 ), spotLightExponent[ i ] ), 0.0 );\n\t\t\t\t#ifdef WRAP_AROUND\n\t\t\t\t\tfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\n\t\t\t\t\tfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\n\t\t\t\t\tvec3 spotDiffuseWeight = mix( vec3( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n\t\t\t\t#else\n\t\t\t\t\tfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n\t\t\t\t#endif\n\t\t\t\tspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\n\t\t\t\tvec3 spotHalfVector = normalize( spotVector + viewPosition );\n\t\t\t\tfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\n\t\t\t\tfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\n\t\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\t\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( spotVector, spotHalfVector ), 0.0 ), 5.0 );\n\t\t\t\tspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n\t\t\t}\n\t\t}\n\t#endif\n\t#if MAX_DIR_LIGHTS > 0\n\t\tvec3 dirDiffuse = vec3( 0.0 );\n\t\tvec3 dirSpecular = vec3( 0.0 );\n\t\tfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\n\t\t\tvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\n\t\t\tvec3 dirVector = normalize( lDirection.xyz );\n\t\t\t#ifdef WRAP_AROUND\n\t\t\t\tfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\n\t\t\t\tfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\n\t\t\t\tvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n\t\t\t#else\n\t\t\t\tfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n\t\t\t#endif\n\t\t\tdirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\n\t\t\tvec3 dirHalfVector = normalize( dirVector + viewPosition );\n\t\t\tfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\n\t\t\tfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\t\t\tvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );\n\t\t\tdirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n\t\t}\n\t#endif\n\t#if MAX_HEMI_LIGHTS > 0\n\t\tvec3 hemiDiffuse = vec3( 0.0 );\n\t\tvec3 hemiSpecular = vec3( 0.0 );\n\t\tfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\n\t\t\tvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\n\t\t\tvec3 lVector = normalize( lDirection.xyz );\n\t\t\tfloat dotProduct = dot( normal, lVector );\n\t\t\tfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\n\t\t\tvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n\t\t\themiDiffuse += diffuse * hemiColor;\n\t\t\tvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\n\t\t\tfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\n\t\t\tfloat hemiSpecularWeightSky = specularTex.r * max( pow( max( hemiDotNormalHalfSky, 0.0 ), shininess ), 0.0 );\n\t\t\tvec3 lVectorGround = -lVector;\n\t\t\tvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\n\t\t\tfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\n\t\t\tfloat hemiSpecularWeightGround = specularTex.r * max( pow( max( hemiDotNormalHalfGround, 0.0 ), shininess ), 0.0 );\n\t\t\tfloat dotProductGround = dot( normal, lVectorGround );\n\t\t\tfloat specularNormalization = ( shininess + 2.0 ) / 8.0;\n\t\t\tvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\n\t\t\tvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\n\t\t\themiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n\t\t}\n\t#endif\n\tvec3 totalDiffuse = vec3( 0.0 );\n\tvec3 totalSpecular = vec3( 0.0 );\n\t#if MAX_DIR_LIGHTS > 0\n\t\ttotalDiffuse += dirDiffuse;\n\t\ttotalSpecular += dirSpecular;\n\t#endif\n\t#if MAX_HEMI_LIGHTS > 0\n\t\ttotalDiffuse += hemiDiffuse;\n\t\ttotalSpecular += hemiSpecular;\n\t#endif\n\t#if MAX_POINT_LIGHTS > 0\n\t\ttotalDiffuse += pointDiffuse;\n\t\ttotalSpecular += pointSpecular;\n\t#endif\n\t#if MAX_SPOT_LIGHTS > 0\n\t\ttotalDiffuse += spotDiffuse;\n\t\ttotalSpecular += spotSpecular;\n\t#endif\n\t#ifdef METAL\n\t\tgl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n\t#else\n\t\tgl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n\t#endif\n\tif ( enableReflection ) {\n\t\tvec3 vReflect;\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tif ( useRefract ) {\n\t\t\tvReflect = refract( cameraToVertex, normal, refractionRatio );\n\t\t} else {\n\t\t\tvReflect = reflect( cameraToVertex, normal );\n\t\t}\n\t\tvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n\t\t#ifdef GAMMA_INPUT\n\t\t\tcubeColor.xyz *= cubeColor.xyz;\n\t\t#endif\n\t\tgl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n\t}",
THREE.ShaderChunk.shadowmap_fragment,THREE.ShaderChunk.linear_to_gamma_fragment,THREE.ShaderChunk.fog_fragment,"}"].join("\n"),vertexShader:["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\n\tuniform sampler2D tDisplacement;\n\tuniform float uDisplacementScale;\n\tuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;",
THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.shadowmap_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,"void main() {",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.skinnormal_vertex,"\t#ifdef USE_SKINNING\n\t\tvNormal = normalize( normalMatrix * skinnedNormal.xyz );\n\t\tvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\n\t\tvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n\t#else\n\t\tvNormal = normalize( normalMatrix * normal );\n\t\tvTangent = normalize( normalMatrix * tangent.xyz );\n\t#endif\n\tvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\n\tvUv = uv * uRepeat + uOffset;\n\tvec3 displacedPosition;\n\t#ifdef VERTEX_TEXTURES\n\t\tif ( enableDisplacement ) {\n\t\t\tvec3 dv = texture2D( tDisplacement, uv ).xyz;\n\t\t\tfloat df = uDisplacementScale * dv.x + uDisplacementBias;\n\t\t\tdisplacedPosition = position + normalize( normal ) * df;\n\t\t} else {\n\t\t\t#ifdef USE_SKINNING\n\t\t\t\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\t\t\t\tvec4 skinned = vec4( 0.0 );\n\t\t\t\tskinned += boneMatX * skinVertex * skinWeight.x;\n\t\t\t\tskinned += boneMatY * skinVertex * skinWeight.y;\n\t\t\t\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\t\t\t\tskinned += boneMatW * skinVertex * skinWeight.w;\n\t\t\t\tskinned  = bindMatrixInverse * skinned;\n\t\t\t\tdisplacedPosition = skinned.xyz;\n\t\t\t#else\n\t\t\t\tdisplacedPosition = position;\n\t\t\t#endif\n\t\t}\n\t#else\n\t\t#ifdef USE_SKINNING\n\t\t\tvec4 skinVertex = bindMatrix * vec4( position, 1.0 );\n\t\t\tvec4 skinned = vec4( 0.0 );\n\t\t\tskinned += boneMatX * skinVertex * skinWeight.x;\n\t\t\tskinned += boneMatY * skinVertex * skinWeight.y;\n\t\t\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\t\t\tskinned += boneMatW * skinVertex * skinWeight.w;\n\t\t\tskinned  = bindMatrixInverse * skinned;\n\t\t\tdisplacedPosition = skinned.xyz;\n\t\t#else\n\t\t\tdisplacedPosition = position;\n\t\t#endif\n\t#endif\n\tvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\n\tvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;",
THREE.ShaderChunk.logdepthbuf_vertex,"\tvWorldPosition = worldPosition.xyz;\n\tvViewPosition = -mvPosition.xyz;\n\t#ifdef USE_SHADOWMAP\n\t\tfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\n\t\t\tvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n\t\t}\n\t#endif\n}"].join("\n")},cube:{uniforms:{tCube:{type:"t",value:null},tFlip:{type:"f",value:-1}},vertexShader:["varying vec3 vWorldPosition;",THREE.ShaderChunk.logdepthbuf_pars_vertex,"void main() {\n\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\tvWorldPosition = worldPosition.xyz;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
THREE.ShaderChunk.logdepthbuf_vertex,"}"].join("\n"),fragmentShader:["uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;",THREE.ShaderChunk.logdepthbuf_pars_fragment,"void main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",THREE.ShaderChunk.logdepthbuf_fragment,"}"].join("\n")},depthRGBA:{uniforms:{},vertexShader:[THREE.ShaderChunk.morphtarget_pars_vertex,THREE.ShaderChunk.skinning_pars_vertex,THREE.ShaderChunk.logdepthbuf_pars_vertex,
"void main() {",THREE.ShaderChunk.skinbase_vertex,THREE.ShaderChunk.morphtarget_vertex,THREE.ShaderChunk.skinning_vertex,THREE.ShaderChunk.default_vertex,THREE.ShaderChunk.logdepthbuf_vertex,"}"].join("\n"),fragmentShader:[THREE.ShaderChunk.logdepthbuf_pars_fragment,"vec4 pack_depth( const in float depth ) {\n\tconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n\tconst vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\tvec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main() {",
THREE.ShaderChunk.logdepthbuf_fragment,"\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n\t#else\n\t\tgl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n\t#endif\n}"].join("\n")}};
THREE.WebGLRenderTarget=function(a,b,c){this.width=a;this.height=b;c=c||{};this.wrapS=void 0!==c.wrapS?c.wrapS:THREE.ClampToEdgeWrapping;this.wrapT=void 0!==c.wrapT?c.wrapT:THREE.ClampToEdgeWrapping;this.magFilter=void 0!==c.magFilter?c.magFilter:THREE.LinearFilter;this.minFilter=void 0!==c.minFilter?c.minFilter:THREE.LinearMipMapLinearFilter;this.anisotropy=void 0!==c.anisotropy?c.anisotropy:1;this.offset=new THREE.Vector2(0,0);this.repeat=new THREE.Vector2(1,1);this.format=void 0!==c.format?c.format:
THREE.RGBAFormat;this.type=void 0!==c.type?c.type:THREE.UnsignedByteType;this.depthBuffer=void 0!==c.depthBuffer?c.depthBuffer:!0;this.stencilBuffer=void 0!==c.stencilBuffer?c.stencilBuffer:!0;this.generateMipmaps=!0;this.shareDepthFrom=null};
THREE.WebGLRenderTarget.prototype={constructor:THREE.WebGLRenderTarget,setSize:function(a,b){this.width=a;this.height=b},clone:function(){var a=new THREE.WebGLRenderTarget(this.width,this.height);a.wrapS=this.wrapS;a.wrapT=this.wrapT;a.magFilter=this.magFilter;a.minFilter=this.minFilter;a.anisotropy=this.anisotropy;a.offset.copy(this.offset);a.repeat.copy(this.repeat);a.format=this.format;a.type=this.type;a.depthBuffer=this.depthBuffer;a.stencilBuffer=this.stencilBuffer;a.generateMipmaps=this.generateMipmaps;
a.shareDepthFrom=this.shareDepthFrom;return a},dispose:function(){this.dispatchEvent({type:"dispose"})}};THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);THREE.WebGLRenderTargetCube=function(a,b,c){THREE.WebGLRenderTarget.call(this,a,b,c);this.activeCubeFace=0};THREE.WebGLRenderTargetCube.prototype=Object.create(THREE.WebGLRenderTarget.prototype);
THREE.WebGLProgram=function(){var a=0;return function(b,c,d,e){var f=b.context,g=d.defines,h=d.__webglShader.uniforms,k=d.attributes,m=d.__webglShader.vertexShader,l=d.__webglShader.fragmentShader,n=d.index0AttributeName;void 0===n&&!0===e.morphTargets&&(n="position");var q="SHADOWMAP_TYPE_BASIC";e.shadowMapType===THREE.PCFShadowMap?q="SHADOWMAP_TYPE_PCF":e.shadowMapType===THREE.PCFSoftShadowMap&&(q="SHADOWMAP_TYPE_PCF_SOFT");var t,r;t=[];for(var p in g)r=g[p],!1!==r&&(r="#define "+p+" "+r,t.push(r));
t=t.join("\n");g=f.createProgram();d instanceof THREE.RawShaderMaterial?b=d="":(d=["precision "+e.precision+" float;","precision "+e.precision+" int;",t,e.supportsVertexTextures?"#define VERTEX_TEXTURES":"",b.gammaInput?"#define GAMMA_INPUT":"",b.gammaOutput?"#define GAMMA_OUTPUT":"","#define MAX_DIR_LIGHTS "+e.maxDirLights,"#define MAX_POINT_LIGHTS "+e.maxPointLights,"#define MAX_SPOT_LIGHTS "+e.maxSpotLights,"#define MAX_HEMI_LIGHTS "+e.maxHemiLights,"#define MAX_SHADOWS "+e.maxShadows,"#define MAX_BONES "+
e.maxBones,e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.lightMap?"#define USE_LIGHTMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.vertexColors?"#define USE_COLOR":"",e.skinning?"#define USE_SKINNING":"",e.useVertexTexture?"#define BONE_TEXTURE":"",e.morphTargets?"#define USE_MORPHTARGETS":"",e.morphNormals?"#define USE_MORPHNORMALS":"",e.wrapAround?"#define WRAP_AROUND":
"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":"",e.shadowMapEnabled?"#define "+q:"",e.shadowMapDebug?"#define SHADOWMAP_DEBUG":"",e.shadowMapCascade?"#define SHADOWMAP_CASCADE":"",e.sizeAttenuation?"#define USE_SIZEATTENUATION":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\n\tattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n\tattribute vec3 morphTarget0;\n\tattribute vec3 morphTarget1;\n\tattribute vec3 morphTarget2;\n\tattribute vec3 morphTarget3;\n\t#ifdef USE_MORPHNORMALS\n\t\tattribute vec3 morphNormal0;\n\t\tattribute vec3 morphNormal1;\n\t\tattribute vec3 morphNormal2;\n\t\tattribute vec3 morphNormal3;\n\t#else\n\t\tattribute vec3 morphTarget4;\n\t\tattribute vec3 morphTarget5;\n\t\tattribute vec3 morphTarget6;\n\t\tattribute vec3 morphTarget7;\n\t#endif\n#endif\n#ifdef USE_SKINNING\n\tattribute vec4 skinIndex;\n\tattribute vec4 skinWeight;\n#endif\n"].join("\n"),
b=["precision "+e.precision+" float;","precision "+e.precision+" int;",e.bumpMap||e.normalMap?"#extension GL_OES_standard_derivatives : enable":"",t,"#define MAX_DIR_LIGHTS "+e.maxDirLights,"#define MAX_POINT_LIGHTS "+e.maxPointLights,"#define MAX_SPOT_LIGHTS "+e.maxSpotLights,"#define MAX_HEMI_LIGHTS "+e.maxHemiLights,"#define MAX_SHADOWS "+e.maxShadows,e.alphaTest?"#define ALPHATEST "+e.alphaTest:"",b.gammaInput?"#define GAMMA_INPUT":"",b.gammaOutput?"#define GAMMA_OUTPUT":"",e.useFog&&e.fog?"#define USE_FOG":
"",e.useFog&&e.fogExp?"#define FOG_EXP2":"",e.map?"#define USE_MAP":"",e.envMap?"#define USE_ENVMAP":"",e.lightMap?"#define USE_LIGHTMAP":"",e.bumpMap?"#define USE_BUMPMAP":"",e.normalMap?"#define USE_NORMALMAP":"",e.specularMap?"#define USE_SPECULARMAP":"",e.alphaMap?"#define USE_ALPHAMAP":"",e.vertexColors?"#define USE_COLOR":"",e.metal?"#define METAL":"",e.wrapAround?"#define WRAP_AROUND":"",e.doubleSided?"#define DOUBLE_SIDED":"",e.flipSided?"#define FLIP_SIDED":"",e.shadowMapEnabled?"#define USE_SHADOWMAP":
"",e.shadowMapEnabled?"#define "+q:"",e.shadowMapDebug?"#define SHADOWMAP_DEBUG":"",e.shadowMapCascade?"#define SHADOWMAP_CASCADE":"",e.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n"));m=new THREE.WebGLShader(f,f.VERTEX_SHADER,d+m);l=new THREE.WebGLShader(f,f.FRAGMENT_SHADER,b+l);f.attachShader(g,m);f.attachShader(g,l);void 0!==n&&f.bindAttribLocation(g,0,n);f.linkProgram(g);!1===f.getProgramParameter(g,f.LINK_STATUS)&&(console.error("THREE.WebGLProgram: Could not initialise shader."),
console.error("gl.VALIDATE_STATUS",f.getProgramParameter(g,f.VALIDATE_STATUS)),console.error("gl.getError()",f.getError()));""!==f.getProgramInfoLog(g)&&console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()",f.getProgramInfoLog(g));f.deleteShader(m);f.deleteShader(l);n="viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition morphTargetInfluences bindMatrix bindMatrixInverse".split(" ");e.useVertexTexture?(n.push("boneTexture"),n.push("boneTextureWidth"),n.push("boneTextureHeight")):
n.push("boneGlobalMatrices");e.logarithmicDepthBuffer&&n.push("logDepthBufFC");for(var s in h)n.push(s);h=n;s={};n=0;for(b=h.length;n<b;n++)q=h[n],s[q]=f.getUniformLocation(g,q);this.uniforms=s;n="position normal uv uv2 tangent color skinIndex skinWeight lineDistance".split(" ");for(h=0;h<e.maxMorphTargets;h++)n.push("morphTarget"+h);for(h=0;h<e.maxMorphNormals;h++)n.push("morphNormal"+h);for(var u in k)n.push(u);e=n;k={};u=0;for(h=e.length;u<h;u++)s=e[u],k[s]=f.getAttribLocation(g,s);this.attributes=
k;this.id=a++;this.code=c;this.usedTimes=1;this.program=g;this.vertexShader=m;this.fragmentShader=l;return this}}();
THREE.WebGLShader=function(){var a=function(a){a=a.split("\n");for(var c=0;c<a.length;c++)a[c]=c+1+": "+a[c];return a.join("\n")};return function(b,c,d){c=b.createShader(c);b.shaderSource(c,d);b.compileShader(c);!1===b.getShaderParameter(c,b.COMPILE_STATUS)&&console.error("THREE.WebGLShader: Shader couldn't compile.");""!==b.getShaderInfoLog(c)&&(console.warn("THREE.WebGLShader: gl.getShaderInfoLog()",b.getShaderInfoLog(c)),console.warn(a(d)));return c}}();
THREE.RenderableVertex=function(){this.position=new THREE.Vector3;this.positionWorld=new THREE.Vector3;this.positionScreen=new THREE.Vector4;this.visible=!0};THREE.RenderableVertex.prototype.copy=function(a){this.positionWorld.copy(a.positionWorld);this.positionScreen.copy(a.positionScreen)};
THREE.RenderableFace=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.v3=new THREE.RenderableVertex;this.normalModel=new THREE.Vector3;this.vertexNormalsModel=[new THREE.Vector3,new THREE.Vector3,new THREE.Vector3];this.vertexNormalsLength=0;this.color=new THREE.Color;this.material=null;this.uvs=[new THREE.Vector2,new THREE.Vector2,new THREE.Vector2];this.z=0};THREE.RenderableObject=function(){this.id=0;this.object=null;this.z=0};
THREE.RenderableSprite=function(){this.id=0;this.object=null;this.rotation=this.z=this.y=this.x=0;this.scale=new THREE.Vector2;this.material=null};THREE.RenderableLine=function(){this.id=0;this.v1=new THREE.RenderableVertex;this.v2=new THREE.RenderableVertex;this.vertexColors=[new THREE.Color,new THREE.Color];this.material=null;this.z=0};
THREE.GeometryUtils={merge:function(a,b,c){console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");var d;b instanceof THREE.Mesh&&(b.matrixAutoUpdate&&b.updateMatrix(),d=b.matrix,b=b.geometry);a.merge(b,d,c)},center:function(a){console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");return a.center()}};
THREE.ImageUtils={crossOrigin:"",loadTexture:function(a,b,c,d){var e=new THREE.ImageLoader;e.crossOrigin=this.crossOrigin;var f=new THREE.Texture(void 0,b);e.load(a,function(a){f.image=a;f.needsUpdate=!0;c&&c(f)},void 0,function(a){d&&d(a)});f.sourceFile=a;return f},loadTextureCube:function(a,b,c,d){var e=new THREE.ImageLoader;e.crossOrigin=this.crossOrigin;var f=new THREE.CubeTexture([],b);f.flipY=!1;var g=0;b=function(b){e.load(a[b],function(a){f.images[b]=a;g+=1;6===g&&(f.needsUpdate=!0,c&&c(f))})};
d=0;for(var h=a.length;d<h;++d)b(d);return f},loadCompressedTexture:function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")},loadCompressedTextureCube:function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")},getNormalMap:function(a,b){var c=function(a){var b=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);return[a[0]/b,a[1]/b,a[2]/b]};b|=1;var d=a.width,e=a.height,f=document.createElement("canvas");
f.width=d;f.height=e;var g=f.getContext("2d");g.drawImage(a,0,0);for(var h=g.getImageData(0,0,d,e).data,k=g.createImageData(d,e),m=k.data,l=0;l<d;l++)for(var n=0;n<e;n++){var q=0>n-1?0:n-1,t=n+1>e-1?e-1:n+1,r=0>l-1?0:l-1,p=l+1>d-1?d-1:l+1,s=[],u=[0,0,h[4*(n*d+l)]/255*b];s.push([-1,0,h[4*(n*d+r)]/255*b]);s.push([-1,-1,h[4*(q*d+r)]/255*b]);s.push([0,-1,h[4*(q*d+l)]/255*b]);s.push([1,-1,h[4*(q*d+p)]/255*b]);s.push([1,0,h[4*(n*d+p)]/255*b]);s.push([1,1,h[4*(t*d+p)]/255*b]);s.push([0,1,h[4*(t*d+l)]/255*
b]);s.push([-1,1,h[4*(t*d+r)]/255*b]);q=[];r=s.length;for(t=0;t<r;t++){var p=s[t],x=s[(t+1)%r],p=[p[0]-u[0],p[1]-u[1],p[2]-u[2]],x=[x[0]-u[0],x[1]-u[1],x[2]-u[2]];q.push(c([p[1]*x[2]-p[2]*x[1],p[2]*x[0]-p[0]*x[2],p[0]*x[1]-p[1]*x[0]]))}s=[0,0,0];for(t=0;t<q.length;t++)s[0]+=q[t][0],s[1]+=q[t][1],s[2]+=q[t][2];s[0]/=q.length;s[1]/=q.length;s[2]/=q.length;u=4*(n*d+l);m[u]=(s[0]+1)/2*255|0;m[u+1]=(s[1]+1)/2*255|0;m[u+2]=255*s[2]|0;m[u+3]=255}g.putImageData(k,0,0);return f},generateDataTexture:function(a,
b,c){var d=a*b,e=new Uint8Array(3*d),f=Math.floor(255*c.r),g=Math.floor(255*c.g);c=Math.floor(255*c.b);for(var h=0;h<d;h++)e[3*h]=f,e[3*h+1]=g,e[3*h+2]=c;a=new THREE.DataTexture(e,a,b,THREE.RGBFormat);a.needsUpdate=!0;return a}};
THREE.SceneUtils={createMultiMaterialObject:function(a,b){for(var c=new THREE.Object3D,d=0,e=b.length;d<e;d++)c.add(new THREE.Mesh(a,b[d]));return c},detach:function(a,b,c){a.applyMatrix(b.matrixWorld);b.remove(a);c.add(a)},attach:function(a,b,c){var d=new THREE.Matrix4;d.getInverse(c.matrixWorld);a.applyMatrix(d);b.remove(a);c.add(a)}};
THREE.FontUtils={faces:{},face:"helvetiker",weight:"normal",style:"normal",size:150,divisions:10,getFace:function(){try{return this.faces[this.face][this.weight][this.style]}catch(a){throw"The font "+this.face+" with "+this.weight+" weight and "+this.style+" style is missing.";}},loadFace:function(a){var b=a.familyName.toLowerCase();this.faces[b]=this.faces[b]||{};this.faces[b][a.cssFontWeight]=this.faces[b][a.cssFontWeight]||{};this.faces[b][a.cssFontWeight][a.cssFontStyle]=a;return this.faces[b][a.cssFontWeight][a.cssFontStyle]=
a},drawText:function(a){var b=this.getFace(),c=this.size/b.resolution,d=0,e=String(a).split(""),f=e.length,g=[];for(a=0;a<f;a++){var h=new THREE.Path,h=this.extractGlyphPoints(e[a],b,c,d,h),d=d+h.offset;g.push(h.path)}return{paths:g,offset:d/2}},extractGlyphPoints:function(a,b,c,d,e){var f=[],g,h,k,m,l,n,q,t,r,p,s,u=b.glyphs[a]||b.glyphs["?"];if(u){if(u.o)for(b=u._cachedOutline||(u._cachedOutline=u.o.split(" ")),m=b.length,a=0;a<m;)switch(k=b[a++],k){case "m":k=b[a++]*c+d;l=b[a++]*c;e.moveTo(k,l);
break;case "l":k=b[a++]*c+d;l=b[a++]*c;e.lineTo(k,l);break;case "q":k=b[a++]*c+d;l=b[a++]*c;t=b[a++]*c+d;r=b[a++]*c;e.quadraticCurveTo(t,r,k,l);if(g=f[f.length-1])for(n=g.x,q=g.y,g=1,h=this.divisions;g<=h;g++){var x=g/h;THREE.Shape.Utils.b2(x,n,t,k);THREE.Shape.Utils.b2(x,q,r,l)}break;case "b":if(k=b[a++]*c+d,l=b[a++]*c,t=b[a++]*c+d,r=b[a++]*c,p=b[a++]*c+d,s=b[a++]*c,e.bezierCurveTo(t,r,p,s,k,l),g=f[f.length-1])for(n=g.x,q=g.y,g=1,h=this.divisions;g<=h;g++)x=g/h,THREE.Shape.Utils.b3(x,n,t,p,k),THREE.Shape.Utils.b3(x,
q,r,s,l)}return{offset:u.ha*c,path:e}}}};
THREE.FontUtils.generateShapes=function(a,b){b=b||{};var c=void 0!==b.curveSegments?b.curveSegments:4,d=void 0!==b.font?b.font:"helvetiker",e=void 0!==b.weight?b.weight:"normal",f=void 0!==b.style?b.style:"normal";THREE.FontUtils.size=void 0!==b.size?b.size:100;THREE.FontUtils.divisions=c;THREE.FontUtils.face=d;THREE.FontUtils.weight=e;THREE.FontUtils.style=f;c=THREE.FontUtils.drawText(a).paths;d=[];e=0;for(f=c.length;e<f;e++)Array.prototype.push.apply(d,c[e].toShapes());return d};
(function(a){var b=function(a){for(var b=a.length,e=0,f=b-1,g=0;g<b;f=g++)e+=a[f].x*a[g].y-a[g].x*a[f].y;return 0.5*e};a.Triangulate=function(a,d){var e=a.length;if(3>e)return null;var f=[],g=[],h=[],k,m,l;if(0<b(a))for(m=0;m<e;m++)g[m]=m;else for(m=0;m<e;m++)g[m]=e-1-m;var n=2*e;for(m=e-1;2<e;){if(0>=n--){console.log("Warning, unable to triangulate polygon!");break}k=m;e<=k&&(k=0);m=k+1;e<=m&&(m=0);l=m+1;e<=l&&(l=0);var q;a:{var t=q=void 0,r=void 0,p=void 0,s=void 0,u=void 0,x=void 0,A=void 0,w=
void 0,t=a[g[k]].x,r=a[g[k]].y,p=a[g[m]].x,s=a[g[m]].y,u=a[g[l]].x,x=a[g[l]].y;if(1E-10>(p-t)*(x-r)-(s-r)*(u-t))q=!1;else{var v=void 0,z=void 0,F=void 0,B=void 0,y=void 0,E=void 0,J=void 0,M=void 0,K=void 0,Q=void 0,K=M=J=w=A=void 0,v=u-p,z=x-s,F=t-u,B=r-x,y=p-t,E=s-r;for(q=0;q<e;q++)if(A=a[g[q]].x,w=a[g[q]].y,!(A===t&&w===r||A===p&&w===s||A===u&&w===x)&&(J=A-t,M=w-r,K=A-p,Q=w-s,A-=u,w-=x,K=v*Q-z*K,J=y*M-E*J,M=F*w-B*A,-1E-10<=K&&-1E-10<=M&&-1E-10<=J)){q=!1;break a}q=!0}}if(q){f.push([a[g[k]],a[g[m]],
a[g[l]]]);h.push([g[k],g[m],g[l]]);k=m;for(l=m+1;l<e;k++,l++)g[k]=g[l];e--;n=2*e}}return d?h:f};a.Triangulate.area=b;return a})(THREE.FontUtils);self._typeface_js={faces:THREE.FontUtils.faces,loadFace:THREE.FontUtils.loadFace};THREE.typeface_js=self._typeface_js;THREE.Gyroscope=function(){THREE.Object3D.call(this)};THREE.Gyroscope.prototype=Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld=function(a){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||a)this.parent?(this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorld.decompose(this.translationWorld,this.quaternionWorld,this.scaleWorld),this.matrix.decompose(this.translationObject,this.quaternionObject,this.scaleObject),this.matrixWorld.compose(this.translationWorld,this.quaternionObject,this.scaleWorld)):this.matrixWorld.copy(this.matrix),
this.matrixWorldNeedsUpdate=!1,a=!0;for(var b=0,c=this.children.length;b<c;b++)this.children[b].updateMatrixWorld(a)};THREE.Gyroscope.prototype.translationWorld=new THREE.Vector3;THREE.Gyroscope.prototype.translationObject=new THREE.Vector3;THREE.Gyroscope.prototype.quaternionWorld=new THREE.Quaternion;THREE.Gyroscope.prototype.quaternionObject=new THREE.Quaternion;THREE.Gyroscope.prototype.scaleWorld=new THREE.Vector3;THREE.Gyroscope.prototype.scaleObject=new THREE.Vector3;
THREE.AnimationHandler={LINEAR:0,CATMULLROM:1,CATMULLROM_FORWARD:2,add:function(){console.warn("THREE.AnimationHandler.add() has been deprecated.")},get:function(){console.warn("THREE.AnimationHandler.get() has been deprecated.")},remove:function(){console.warn("THREE.AnimationHandler.remove() has been deprecated.")},animations:[],init:function(a){if(!0!==a.initialized){for(var b=0;b<a.hierarchy.length;b++){for(var c=0;c<a.hierarchy[b].keys.length;c++)if(0>a.hierarchy[b].keys[c].time&&(a.hierarchy[b].keys[c].time=
0),void 0!==a.hierarchy[b].keys[c].rot&&!(a.hierarchy[b].keys[c].rot instanceof THREE.Quaternion)){var d=a.hierarchy[b].keys[c].rot;a.hierarchy[b].keys[c].rot=(new THREE.Quaternion).fromArray(d)}if(a.hierarchy[b].keys.length&&void 0!==a.hierarchy[b].keys[0].morphTargets){d={};for(c=0;c<a.hierarchy[b].keys.length;c++)for(var e=0;e<a.hierarchy[b].keys[c].morphTargets.length;e++){var f=a.hierarchy[b].keys[c].morphTargets[e];d[f]=-1}a.hierarchy[b].usedMorphTargets=d;for(c=0;c<a.hierarchy[b].keys.length;c++){var g=
{};for(f in d){for(e=0;e<a.hierarchy[b].keys[c].morphTargets.length;e++)if(a.hierarchy[b].keys[c].morphTargets[e]===f){g[f]=a.hierarchy[b].keys[c].morphTargetsInfluences[e];break}e===a.hierarchy[b].keys[c].morphTargets.length&&(g[f]=0)}a.hierarchy[b].keys[c].morphTargetsInfluences=g}}for(c=1;c<a.hierarchy[b].keys.length;c++)a.hierarchy[b].keys[c].time===a.hierarchy[b].keys[c-1].time&&(a.hierarchy[b].keys.splice(c,1),c--);for(c=0;c<a.hierarchy[b].keys.length;c++)a.hierarchy[b].keys[c].index=c}a.initialized=
!0;return a}},parse:function(a){var b=function(a,c){c.push(a);for(var d=0;d<a.children.length;d++)b(a.children[d],c)},c=[];if(a instanceof THREE.SkinnedMesh)for(var d=0;d<a.skeleton.bones.length;d++)c.push(a.skeleton.bones[d]);else b(a,c);return c},play:function(a){-1===this.animations.indexOf(a)&&this.animations.push(a)},stop:function(a){a=this.animations.indexOf(a);-1!==a&&this.animations.splice(a,1)},update:function(a){for(var b=0;b<this.animations.length;b++)this.animations[b].update(a)}};
THREE.Animation=function(a,b){this.root=a;this.data=THREE.AnimationHandler.init(b);this.hierarchy=THREE.AnimationHandler.parse(a);this.currentTime=0;this.timeScale=1;this.isPlaying=!1;this.loop=!0;this.weight=0;this.interpolationType=THREE.AnimationHandler.LINEAR};THREE.Animation.prototype.keyTypes=["pos","rot","scl"];THREE.Animation.prototype.play=function(a,b){this.currentTime=void 0!==a?a:0;this.weight=void 0!==b?b:1;this.isPlaying=!0;this.reset();THREE.AnimationHandler.play(this)};
THREE.Animation.prototype.stop=function(){this.isPlaying=!1;THREE.AnimationHandler.stop(this)};
THREE.Animation.prototype.reset=function(){for(var a=0,b=this.hierarchy.length;a<b;a++){var c=this.hierarchy[a];c.matrixAutoUpdate=!0;void 0===c.animationCache&&(c.animationCache={});void 0===c.animationCache[this.data.name]&&(c.animationCache[this.data.name]={},c.animationCache[this.data.name].prevKey={pos:0,rot:0,scl:0},c.animationCache[this.data.name].nextKey={pos:0,rot:0,scl:0},c.animationCache[this.data.name].originalMatrix=c.matrix);for(var c=c.animationCache[this.data.name],d=0;3>d;d++){for(var e=
this.keyTypes[d],f=this.data.hierarchy[a].keys[0],g=this.getNextKeyWith(e,a,1);g.time<this.currentTime&&g.index>f.index;)f=g,g=this.getNextKeyWith(e,a,g.index+1);c.prevKey[e]=f;c.nextKey[e]=g}}};
THREE.Animation.prototype.update=function(){var a=[],b=new THREE.Vector3,c=new THREE.Vector3,d=new THREE.Quaternion,e=function(a,b){var c=[],d=[],e,n,q,t,r,p;e=(a.length-1)*b;n=Math.floor(e);e-=n;c[0]=0===n?n:n-1;c[1]=n;c[2]=n>a.length-2?n:n+1;c[3]=n>a.length-3?n:n+2;n=a[c[0]];t=a[c[1]];r=a[c[2]];p=a[c[3]];c=e*e;q=e*c;d[0]=f(n[0],t[0],r[0],p[0],e,c,q);d[1]=f(n[1],t[1],r[1],p[1],e,c,q);d[2]=f(n[2],t[2],r[2],p[2],e,c,q);return d},f=function(a,b,c,d,e,f,q){a=0.5*(c-a);d=0.5*(d-b);return(2*(b-c)+a+d)*
q+(-3*(b-c)-2*a-d)*f+a*e+b};return function(f){if(!1!==this.isPlaying&&(this.currentTime+=f*this.timeScale,0!==this.weight)){f=this.data.length;if(!0===this.loop&&this.currentTime>f)this.currentTime%=f,this.reset();else if(!1===this.loop&&this.currentTime>f){this.stop();return}f=0;for(var h=this.hierarchy.length;f<h;f++)for(var k=this.hierarchy[f],m=k.animationCache[this.data.name],l=0;3>l;l++){var n=this.keyTypes[l],q=m.prevKey[n],t=m.nextKey[n];if(t.time<=this.currentTime){q=this.data.hierarchy[f].keys[0];
for(t=this.getNextKeyWith(n,f,1);t.time<this.currentTime&&t.index>q.index;)q=t,t=this.getNextKeyWith(n,f,t.index+1);m.prevKey[n]=q;m.nextKey[n]=t}k.matrixAutoUpdate=!0;k.matrixWorldNeedsUpdate=!0;var r=(this.currentTime-q.time)/(t.time-q.time),p=q[n],s=t[n];0>r&&(r=0);1<r&&(r=1);if("pos"===n)if(this.interpolationType===THREE.AnimationHandler.LINEAR)c.x=p[0]+(s[0]-p[0])*r,c.y=p[1]+(s[1]-p[1])*r,c.z=p[2]+(s[2]-p[2])*r,k instanceof THREE.Bone?(q=this.weight/(this.weight+k.accumulatedPosWeight),k.position.lerp(c,
q),k.accumulatedPosWeight+=this.weight):k.position.copy(c);else{if(this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD)a[0]=this.getPrevKeyWith("pos",f,q.index-1).pos,a[1]=p,a[2]=s,a[3]=this.getNextKeyWith("pos",f,t.index+1).pos,r=0.33*r+0.33,t=e(a,r),q=1,k instanceof THREE.Bone&&(q=this.weight/(this.weight+k.accumulatedPosWeight),k.accumulatedPosWeight+=this.weight),n=k.position,n.x+=(t[0]-n.x)*q,n.y+=(t[1]-n.y)*q,n.z+=(t[2]-
n.z)*q,this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD&&(r=e(a,1.01*r),b.set(r[0],r[1],r[2]),b.sub(n),b.y=0,b.normalize(),r=Math.atan2(b.x,b.z),k.rotation.set(0,r,0))}else"rot"===n?(THREE.Quaternion.slerp(p,s,d,r),k instanceof THREE.Bone?0===k.accumulatedRotWeight?(k.quaternion.copy(d),k.accumulatedRotWeight=this.weight):(q=this.weight/(this.weight+k.accumulatedRotWeight),THREE.Quaternion.slerp(k.quaternion,d,k.quaternion,q),k.accumulatedRotWeight+=this.weight):k.quaternion.copy(d)):
"scl"===n&&(c.x=p[0]+(s[0]-p[0])*r,c.y=p[1]+(s[1]-p[1])*r,c.z=p[2]+(s[2]-p[2])*r,k instanceof THREE.Bone?(q=this.weight/(this.weight+k.accumulatedSclWeight),k.scale.lerp(c,q),k.accumulatedSclWeight+=this.weight):k.scale.copy(c))}return!0}}}();
THREE.Animation.prototype.getNextKeyWith=function(a,b,c){var d=this.data.hierarchy[b].keys;for(c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?c<d.length-1?c:d.length-1:c%d.length;c<d.length;c++)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[0]};
THREE.Animation.prototype.getPrevKeyWith=function(a,b,c){var d=this.data.hierarchy[b].keys;for(c=this.interpolationType===THREE.AnimationHandler.CATMULLROM||this.interpolationType===THREE.AnimationHandler.CATMULLROM_FORWARD?0<c?c:0:0<=c?c:c+d.length;0<=c;c--)if(void 0!==d[c][a])return d[c];return this.data.hierarchy[b].keys[d.length-1]};
THREE.KeyFrameAnimation=function(a){this.root=a.node;this.data=THREE.AnimationHandler.init(a);this.hierarchy=THREE.AnimationHandler.parse(this.root);this.currentTime=0;this.timeScale=0.001;this.isPlaying=!1;this.loop=this.isPaused=!0;a=0;for(var b=this.hierarchy.length;a<b;a++){var c=this.data.hierarchy[a].sids,d=this.hierarchy[a];if(this.data.hierarchy[a].keys.length&&c){for(var e=0;e<c.length;e++){var f=c[e],g=this.getNextKeyWith(f,a,0);g&&g.apply(f)}d.matrixAutoUpdate=!1;this.data.hierarchy[a].node.updateMatrix();
d.matrixWorldNeedsUpdate=!0}}};
THREE.KeyFrameAnimation.prototype.play=function(a){this.currentTime=void 0!==a?a:0;if(!1===this.isPlaying){this.isPlaying=!0;var b=this.hierarchy.length,c,d;for(a=0;a<b;a++)c=this.hierarchy[a],d=this.data.hierarchy[a],void 0===d.animationCache&&(d.animationCache={},d.animationCache.prevKey=null,d.animationCache.nextKey=null,d.animationCache.originalMatrix=c.matrix),c=this.data.hierarchy[a].keys,c.length&&(d.animationCache.prevKey=c[0],d.animationCache.nextKey=c[1],this.startTime=Math.min(c[0].time,
this.startTime),this.endTime=Math.max(c[c.length-1].time,this.endTime));this.update(0)}this.isPaused=!1;THREE.AnimationHandler.play(this)};THREE.KeyFrameAnimation.prototype.stop=function(){this.isPaused=this.isPlaying=!1;THREE.AnimationHandler.stop(this);for(var a=0;a<this.data.hierarchy.length;a++){var b=this.hierarchy[a],c=this.data.hierarchy[a];if(void 0!==c.animationCache){var d=c.animationCache.originalMatrix;d.copy(b.matrix);b.matrix=d;delete c.animationCache}}};
THREE.KeyFrameAnimation.prototype.update=function(a){if(!1!==this.isPlaying){this.currentTime+=a*this.timeScale;a=this.data.length;!0===this.loop&&this.currentTime>a&&(this.currentTime%=a);this.currentTime=Math.min(this.currentTime,a);a=0;for(var b=this.hierarchy.length;a<b;a++){var c=this.hierarchy[a],d=this.data.hierarchy[a],e=d.keys,d=d.animationCache;if(e.length){var f=d.prevKey,g=d.nextKey;if(g.time<=this.currentTime){for(;g.time<this.currentTime&&g.index>f.index;)f=g,g=e[f.index+1];d.prevKey=
f;d.nextKey=g}g.time>=this.currentTime?f.interpolate(g,this.currentTime):f.interpolate(g,g.time);this.data.hierarchy[a].node.updateMatrix();c.matrixWorldNeedsUpdate=!0}}}};THREE.KeyFrameAnimation.prototype.getNextKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c%=b.length;c<b.length;c++)if(b[c].hasTarget(a))return b[c];return b[0]};
THREE.KeyFrameAnimation.prototype.getPrevKeyWith=function(a,b,c){b=this.data.hierarchy[b].keys;for(c=0<=c?c:c+b.length;0<=c;c--)if(b[c].hasTarget(a))return b[c];return b[b.length-1]};THREE.MorphAnimation=function(a){this.mesh=a;this.frames=a.morphTargetInfluences.length;this.currentTime=0;this.duration=1E3;this.loop=!0;this.isPlaying=!1};
THREE.MorphAnimation.prototype={play:function(){this.isPlaying=!0},pause:function(){this.isPlaying=!1},update:function(){var a=0,b=0;return function(c){if(!1!==this.isPlaying){this.currentTime+=c;!0===this.loop&&this.currentTime>this.duration&&(this.currentTime%=this.duration);this.currentTime=Math.min(this.currentTime,this.duration);c=this.duration/this.frames;var d=Math.floor(this.currentTime/c);d!=b&&(this.mesh.morphTargetInfluences[a]=0,this.mesh.morphTargetInfluences[b]=1,this.mesh.morphTargetInfluences[d]=
0,a=b,b=d);this.mesh.morphTargetInfluences[d]=this.currentTime%c/c;this.mesh.morphTargetInfluences[a]=1-this.mesh.morphTargetInfluences[d]}}}()};
THREE.BoxGeometry=function(a,b,c,d,e,f){function g(a,b,c,d,e,f,g,p){var s,u=h.widthSegments,x=h.heightSegments,A=e/2,w=f/2,v=h.vertices.length;if("x"===a&&"y"===b||"y"===a&&"x"===b)s="z";else if("x"===a&&"z"===b||"z"===a&&"x"===b)s="y",x=h.depthSegments;else if("z"===a&&"y"===b||"y"===a&&"z"===b)s="x",u=h.depthSegments;var z=u+1,F=x+1,B=e/u,y=f/x,E=new THREE.Vector3;E[s]=0<g?1:-1;for(e=0;e<F;e++)for(f=0;f<z;f++){var J=new THREE.Vector3;J[a]=(f*B-A)*c;J[b]=(e*y-w)*d;J[s]=g;h.vertices.push(J)}for(e=
0;e<x;e++)for(f=0;f<u;f++)w=f+z*e,a=f+z*(e+1),b=f+1+z*(e+1),c=f+1+z*e,d=new THREE.Vector2(f/u,1-e/x),g=new THREE.Vector2(f/u,1-(e+1)/x),s=new THREE.Vector2((f+1)/u,1-(e+1)/x),A=new THREE.Vector2((f+1)/u,1-e/x),w=new THREE.Face3(w+v,a+v,c+v),w.normal.copy(E),w.vertexNormals.push(E.clone(),E.clone(),E.clone()),w.materialIndex=p,h.faces.push(w),h.faceVertexUvs[0].push([d,g,A]),w=new THREE.Face3(a+v,b+v,c+v),w.normal.copy(E),w.vertexNormals.push(E.clone(),E.clone(),E.clone()),w.materialIndex=p,h.faces.push(w),
h.faceVertexUvs[0].push([g.clone(),s,A.clone()])}THREE.Geometry.call(this);this.parameters={width:a,height:b,depth:c,widthSegments:d,heightSegments:e,depthSegments:f};this.widthSegments=d||1;this.heightSegments=e||1;this.depthSegments=f||1;var h=this;d=a/2;e=b/2;f=c/2;g("z","y",-1,-1,c,b,d,0);g("z","y",1,-1,c,b,-d,1);g("x","z",1,1,a,c,e,2);g("x","z",1,-1,a,c,-e,3);g("x","y",1,-1,a,b,f,4);g("x","y",-1,-1,a,b,-f,5);this.mergeVertices()};THREE.BoxGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.CircleGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.parameters={radius:a,segments:b,thetaStart:c,thetaLength:d};a=a||50;b=void 0!==b?Math.max(3,b):8;c=void 0!==c?c:0;d=void 0!==d?d:2*Math.PI;var e,f=[];e=new THREE.Vector3;var g=new THREE.Vector2(0.5,0.5);this.vertices.push(e);f.push(g);for(e=0;e<=b;e++){var h=new THREE.Vector3,k=c+e/b*d;h.x=a*Math.cos(k);h.y=a*Math.sin(k);this.vertices.push(h);f.push(new THREE.Vector2((h.x/a+1)/2,(h.y/a+1)/2))}c=new THREE.Vector3(0,0,1);for(e=1;e<=
b;e++)this.faces.push(new THREE.Face3(e,e+1,0,[c.clone(),c.clone(),c.clone()])),this.faceVertexUvs[0].push([f[e].clone(),f[e+1].clone(),g.clone()]);this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,a)};THREE.CircleGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.CubeGeometry=function(a,b,c,d,e,f){console.warn("THEE.CubeGeometry has been renamed to THREE.BoxGeometry.");return new THREE.BoxGeometry(a,b,c,d,e,f)};
THREE.CylinderGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);this.parameters={radiusTop:a,radiusBottom:b,height:c,radialSegments:d,heightSegments:e,openEnded:f};a=void 0!==a?a:20;b=void 0!==b?b:20;c=void 0!==c?c:100;d=d||8;e=e||1;f=void 0!==f?f:!1;var g=c/2,h,k,m=[],l=[];for(k=0;k<=e;k++){var n=[],q=[],t=k/e,r=t*(b-a)+a;for(h=0;h<=d;h++){var p=h/d,s=new THREE.Vector3;s.x=r*Math.sin(p*Math.PI*2);s.y=-t*c+g;s.z=r*Math.cos(p*Math.PI*2);this.vertices.push(s);n.push(this.vertices.length-1);q.push(new THREE.Vector2(p,
1-t))}m.push(n);l.push(q)}c=(b-a)/c;for(h=0;h<d;h++)for(0!==a?(n=this.vertices[m[0][h]].clone(),q=this.vertices[m[0][h+1]].clone()):(n=this.vertices[m[1][h]].clone(),q=this.vertices[m[1][h+1]].clone()),n.setY(Math.sqrt(n.x*n.x+n.z*n.z)*c).normalize(),q.setY(Math.sqrt(q.x*q.x+q.z*q.z)*c).normalize(),k=0;k<e;k++){var t=m[k][h],r=m[k+1][h],p=m[k+1][h+1],s=m[k][h+1],u=n.clone(),x=n.clone(),A=q.clone(),w=q.clone(),v=l[k][h].clone(),z=l[k+1][h].clone(),F=l[k+1][h+1].clone(),B=l[k][h+1].clone();this.faces.push(new THREE.Face3(t,
r,s,[u,x,w]));this.faceVertexUvs[0].push([v,z,B]);this.faces.push(new THREE.Face3(r,p,s,[x.clone(),A,w.clone()]));this.faceVertexUvs[0].push([z.clone(),F,B.clone()])}if(!1===f&&0<a)for(this.vertices.push(new THREE.Vector3(0,g,0)),h=0;h<d;h++)t=m[0][h],r=m[0][h+1],p=this.vertices.length-1,u=new THREE.Vector3(0,1,0),x=new THREE.Vector3(0,1,0),A=new THREE.Vector3(0,1,0),v=l[0][h].clone(),z=l[0][h+1].clone(),F=new THREE.Vector2(z.x,0),this.faces.push(new THREE.Face3(t,r,p,[u,x,A])),this.faceVertexUvs[0].push([v,
z,F]);if(!1===f&&0<b)for(this.vertices.push(new THREE.Vector3(0,-g,0)),h=0;h<d;h++)t=m[k][h+1],r=m[k][h],p=this.vertices.length-1,u=new THREE.Vector3(0,-1,0),x=new THREE.Vector3(0,-1,0),A=new THREE.Vector3(0,-1,0),v=l[k][h+1].clone(),z=l[k][h].clone(),F=new THREE.Vector2(z.x,1),this.faces.push(new THREE.Face3(t,r,p,[u,x,A])),this.faceVertexUvs[0].push([v,z,F]);this.computeFaceNormals()};THREE.CylinderGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry=function(a,b){"undefined"!==typeof a&&(THREE.Geometry.call(this),a=a instanceof Array?a:[a],this.addShapeList(a,b),this.computeFaceNormals())};THREE.ExtrudeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ExtrudeGeometry.prototype.addShapeList=function(a,b){for(var c=a.length,d=0;d<c;d++)this.addShape(a[d],b)};
THREE.ExtrudeGeometry.prototype.addShape=function(a,b){function c(a,b,c){b||console.log("die");return b.clone().multiplyScalar(c).add(a)}function d(a,b,c){var d=THREE.Math.sign,e=1,e=a.x-b.x,f=a.y-b.y,g=c.x-a.x,h=c.y-a.y,k=e*e+f*f;if(1E-10<Math.abs(e*h-f*g)){var l=Math.sqrt(k),d=Math.sqrt(g*g+h*h),k=b.x-f/l;b=b.y+e/l;g=((c.x-h/d-k)*h-(c.y+g/d-b)*g)/(e*h-f*g);c=k+e*g-a.x;a=b+f*g-a.y;e=c*c+a*a;if(2>=e)return new THREE.Vector2(c,a);e=Math.sqrt(e/2)}else a=!1,1E-10<e?1E-10<g&&(a=!0):-1E-10>e?-1E-10>g&&
(a=!0):d(f)==d(h)&&(a=!0),a?(c=-f,a=e,e=Math.sqrt(k)):(c=e,a=f,e=Math.sqrt(k/2));return new THREE.Vector2(c/e,a/e)}function e(c,d){var e,f;for(D=c.length;0<=--D;){e=D;f=D-1;0>f&&(f=c.length-1);for(var g=0,h=t+2*l,g=0;g<h;g++){var k=P*g,m=P*(g+1),n=d+e+k,k=d+f+k,p=d+f+m,m=d+e+m,q=c,r=g,s=h,u=e,v=f,n=n+M,k=k+M,p=p+M,m=m+M;J.faces.push(new THREE.Face3(n,k,m,null,null,x));J.faces.push(new THREE.Face3(k,p,m,null,null,x));n=A.generateSideWallUV(J,a,q,b,n,k,p,m,r,s,u,v);J.faceVertexUvs[0].push([n[0],n[1],
n[3]]);J.faceVertexUvs[0].push([n[1],n[2],n[3]])}}}function f(a,b,c){J.vertices.push(new THREE.Vector3(a,b,c))}function g(c,d,e,f){c+=M;d+=M;e+=M;J.faces.push(new THREE.Face3(c,d,e,null,null,u));c=f?A.generateBottomUV(J,a,b,c,d,e):A.generateTopUV(J,a,b,c,d,e);J.faceVertexUvs[0].push(c)}var h=void 0!==b.amount?b.amount:100,k=void 0!==b.bevelThickness?b.bevelThickness:6,m=void 0!==b.bevelSize?b.bevelSize:k-2,l=void 0!==b.bevelSegments?b.bevelSegments:3,n=void 0!==b.bevelEnabled?b.bevelEnabled:!0,q=
void 0!==b.curveSegments?b.curveSegments:12,t=void 0!==b.steps?b.steps:1,r=b.extrudePath,p,s=!1,u=b.material,x=b.extrudeMaterial,A=void 0!==b.UVGenerator?b.UVGenerator:THREE.ExtrudeGeometry.WorldUVGenerator,w,v,z,F;r&&(p=r.getSpacedPoints(t),s=!0,n=!1,w=void 0!==b.frames?b.frames:new THREE.TubeGeometry.FrenetFrames(r,t,!1),v=new THREE.Vector3,z=new THREE.Vector3,F=new THREE.Vector3);n||(m=k=l=0);var B,y,E,J=this,M=this.vertices.length,r=a.extractPoints(q),q=r.shape,K=r.holes;if(r=!THREE.Shape.Utils.isClockWise(q)){q=
q.reverse();y=0;for(E=K.length;y<E;y++)B=K[y],THREE.Shape.Utils.isClockWise(B)&&(K[y]=B.reverse());r=!1}var Q=THREE.Shape.Utils.triangulateShape(q,K),L=q;y=0;for(E=K.length;y<E;y++)B=K[y],q=q.concat(B);var H,G,C,V,I,P=q.length,O,T=Q.length,r=[],D=0;C=L.length;H=C-1;for(G=D+1;D<C;D++,H++,G++)H===C&&(H=0),G===C&&(G=0),r[D]=d(L[D],L[H],L[G]);var U=[],R,N=r.concat();y=0;for(E=K.length;y<E;y++){B=K[y];R=[];D=0;C=B.length;H=C-1;for(G=D+1;D<C;D++,H++,G++)H===C&&(H=0),G===C&&(G=0),R[D]=d(B[D],B[H],B[G]);
U.push(R);N=N.concat(R)}for(H=0;H<l;H++){C=H/l;V=k*(1-C);G=m*Math.sin(C*Math.PI/2);D=0;for(C=L.length;D<C;D++)I=c(L[D],r[D],G),f(I.x,I.y,-V);y=0;for(E=K.length;y<E;y++)for(B=K[y],R=U[y],D=0,C=B.length;D<C;D++)I=c(B[D],R[D],G),f(I.x,I.y,-V)}G=m;for(D=0;D<P;D++)I=n?c(q[D],N[D],G):q[D],s?(z.copy(w.normals[0]).multiplyScalar(I.x),v.copy(w.binormals[0]).multiplyScalar(I.y),F.copy(p[0]).add(z).add(v),f(F.x,F.y,F.z)):f(I.x,I.y,0);for(C=1;C<=t;C++)for(D=0;D<P;D++)I=n?c(q[D],N[D],G):q[D],s?(z.copy(w.normals[C]).multiplyScalar(I.x),
v.copy(w.binormals[C]).multiplyScalar(I.y),F.copy(p[C]).add(z).add(v),f(F.x,F.y,F.z)):f(I.x,I.y,h/t*C);for(H=l-1;0<=H;H--){C=H/l;V=k*(1-C);G=m*Math.sin(C*Math.PI/2);D=0;for(C=L.length;D<C;D++)I=c(L[D],r[D],G),f(I.x,I.y,h+V);y=0;for(E=K.length;y<E;y++)for(B=K[y],R=U[y],D=0,C=B.length;D<C;D++)I=c(B[D],R[D],G),s?f(I.x,I.y+p[t-1].y,p[t-1].x+V):f(I.x,I.y,h+V)}(function(){if(n){var a;a=0*P;for(D=0;D<T;D++)O=Q[D],g(O[2]+a,O[1]+a,O[0]+a,!0);a=t+2*l;a*=P;for(D=0;D<T;D++)O=Q[D],g(O[0]+a,O[1]+a,O[2]+a,!1)}else{for(D=
0;D<T;D++)O=Q[D],g(O[2],O[1],O[0],!0);for(D=0;D<T;D++)O=Q[D],g(O[0]+P*t,O[1]+P*t,O[2]+P*t,!1)}})();(function(){var a=0;e(L,a);a+=L.length;y=0;for(E=K.length;y<E;y++)B=K[y],e(B,a),a+=B.length})()};
THREE.ExtrudeGeometry.WorldUVGenerator={generateTopUV:function(a,b,c,d,e,f){b=a.vertices[e].x;e=a.vertices[e].y;c=a.vertices[f].x;f=a.vertices[f].y;return[new THREE.Vector2(a.vertices[d].x,a.vertices[d].y),new THREE.Vector2(b,e),new THREE.Vector2(c,f)]},generateBottomUV:function(a,b,c,d,e,f){return this.generateTopUV(a,b,c,d,e,f)},generateSideWallUV:function(a,b,c,d,e,f,g,h,k,m,l,n){b=a.vertices[e].x;c=a.vertices[e].y;e=a.vertices[e].z;d=a.vertices[f].x;k=a.vertices[f].y;f=a.vertices[f].z;m=a.vertices[g].x;
l=a.vertices[g].y;g=a.vertices[g].z;n=a.vertices[h].x;var q=a.vertices[h].y;a=a.vertices[h].z;return 0.01>Math.abs(c-k)?[new THREE.Vector2(b,1-e),new THREE.Vector2(d,1-f),new THREE.Vector2(m,1-g),new THREE.Vector2(n,1-a)]:[new THREE.Vector2(c,1-e),new THREE.Vector2(k,1-f),new THREE.Vector2(l,1-g),new THREE.Vector2(q,1-a)]}};THREE.ExtrudeGeometry.__v1=new THREE.Vector2;THREE.ExtrudeGeometry.__v2=new THREE.Vector2;THREE.ExtrudeGeometry.__v3=new THREE.Vector2;THREE.ExtrudeGeometry.__v4=new THREE.Vector2;
THREE.ExtrudeGeometry.__v5=new THREE.Vector2;THREE.ExtrudeGeometry.__v6=new THREE.Vector2;THREE.ShapeGeometry=function(a,b){THREE.Geometry.call(this);!1===a instanceof Array&&(a=[a]);this.addShapeList(a,b);this.computeFaceNormals()};THREE.ShapeGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.ShapeGeometry.prototype.addShapeList=function(a,b){for(var c=0,d=a.length;c<d;c++)this.addShape(a[c],b);return this};
THREE.ShapeGeometry.prototype.addShape=function(a,b){void 0===b&&(b={});var c=b.material,d=void 0===b.UVGenerator?THREE.ExtrudeGeometry.WorldUVGenerator:b.UVGenerator,e,f,g,h=this.vertices.length;e=a.extractPoints(void 0!==b.curveSegments?b.curveSegments:12);var k=e.shape,m=e.holes;if(!THREE.Shape.Utils.isClockWise(k))for(k=k.reverse(),e=0,f=m.length;e<f;e++)g=m[e],THREE.Shape.Utils.isClockWise(g)&&(m[e]=g.reverse());var l=THREE.Shape.Utils.triangulateShape(k,m);e=0;for(f=m.length;e<f;e++)g=m[e],
k=k.concat(g);m=k.length;f=l.length;for(e=0;e<m;e++)g=k[e],this.vertices.push(new THREE.Vector3(g.x,g.y,0));for(e=0;e<f;e++)m=l[e],k=m[0]+h,g=m[1]+h,m=m[2]+h,this.faces.push(new THREE.Face3(k,g,m,null,null,c)),this.faceVertexUvs[0].push(d.generateBottomUV(this,a,b,k,g,m))};
THREE.LatheGeometry=function(a,b,c,d){THREE.Geometry.call(this);b=b||12;c=c||0;d=d||2*Math.PI;for(var e=1/(a.length-1),f=1/b,g=0,h=b;g<=h;g++)for(var k=c+g*f*d,m=Math.cos(k),l=Math.sin(k),k=0,n=a.length;k<n;k++){var q=a[k],t=new THREE.Vector3;t.x=m*q.x-l*q.y;t.y=l*q.x+m*q.y;t.z=q.z;this.vertices.push(t)}c=a.length;g=0;for(h=b;g<h;g++)for(k=0,n=a.length-1;k<n;k++){b=l=k+c*g;d=l+c;var m=l+1+c,l=l+1,q=g*f,t=k*e,r=q+f,p=t+e;this.faces.push(new THREE.Face3(b,d,l));this.faceVertexUvs[0].push([new THREE.Vector2(q,
t),new THREE.Vector2(r,t),new THREE.Vector2(q,p)]);this.faces.push(new THREE.Face3(d,m,l));this.faceVertexUvs[0].push([new THREE.Vector2(r,t),new THREE.Vector2(r,p),new THREE.Vector2(q,p)])}this.mergeVertices();this.computeFaceNormals();this.computeVertexNormals()};THREE.LatheGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry=function(a,b,c,d){THREE.Geometry.call(this);this.parameters={width:a,height:b,widthSegments:c,heightSegments:d};var e=a/2,f=b/2;c=c||1;d=d||1;var g=c+1,h=d+1,k=a/c,m=b/d,l=new THREE.Vector3(0,0,1);for(a=0;a<h;a++){var n=a*m-f;for(b=0;b<g;b++)this.vertices.push(new THREE.Vector3(b*k-e,-n,0))}for(a=0;a<d;a++)for(b=0;b<c;b++){var q=b+g*a,e=b+g*(a+1),f=b+1+g*(a+1),h=b+1+g*a,k=new THREE.Vector2(b/c,1-a/d),m=new THREE.Vector2(b/c,1-(a+1)/d),n=new THREE.Vector2((b+1)/c,1-(a+1)/d),t=new THREE.Vector2((b+
1)/c,1-a/d),q=new THREE.Face3(q,e,h);q.normal.copy(l);q.vertexNormals.push(l.clone(),l.clone(),l.clone());this.faces.push(q);this.faceVertexUvs[0].push([k,m,t]);q=new THREE.Face3(e,f,h);q.normal.copy(l);q.vertexNormals.push(l.clone(),l.clone(),l.clone());this.faces.push(q);this.faceVertexUvs[0].push([m.clone(),n,t.clone()])}};THREE.PlaneGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.RingGeometry=function(a,b,c,d,e,f){THREE.Geometry.call(this);a=a||0;b=b||50;e=void 0!==e?e:0;f=void 0!==f?f:2*Math.PI;c=void 0!==c?Math.max(3,c):8;d=void 0!==d?Math.max(1,d):8;var g,h=[],k=a,m=(b-a)/d;for(a=0;a<d+1;a++){for(g=0;g<c+1;g++){var l=new THREE.Vector3,n=e+g/c*f;l.x=k*Math.cos(n);l.y=k*Math.sin(n);this.vertices.push(l);h.push(new THREE.Vector2((l.x/b+1)/2,(l.y/b+1)/2))}k+=m}b=new THREE.Vector3(0,0,1);for(a=0;a<d;a++)for(e=a*(c+1),g=0;g<c;g++)f=n=g+e,m=n+c+1,l=n+c+2,this.faces.push(new THREE.Face3(f,
m,l,[b.clone(),b.clone(),b.clone()])),this.faceVertexUvs[0].push([h[f].clone(),h[m].clone(),h[l].clone()]),f=n,m=n+c+2,l=n+1,this.faces.push(new THREE.Face3(f,m,l,[b.clone(),b.clone(),b.clone()])),this.faceVertexUvs[0].push([h[f].clone(),h[m].clone(),h[l].clone()]);this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,k)};THREE.RingGeometry.prototype=Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry=function(a,b,c,d,e,f,g){THREE.Geometry.call(this);this.parameters={radius:a,widthSegments:b,heightSegments:c,phiStart:d,phiLength:e,thetaStart:f,thetaLength:g};a=a||50;b=Math.max(3,Math.floor(b)||8);c=Math.max(2,Math.floor(c)||6);d=void 0!==d?d:0;e=void 0!==e?e:2*Math.PI;f=void 0!==f?f:0;g=void 0!==g?g:Math.PI;var h,k,m=[],l=[];for(k=0;k<=c;k++){var n=[],q=[];for(h=0;h<=b;h++){var t=h/b,r=k/c,p=new THREE.Vector3;p.x=-a*Math.cos(d+t*e)*Math.sin(f+r*g);p.y=a*Math.cos(f+r*g);p.z=
a*Math.sin(d+t*e)*Math.sin(f+r*g);this.vertices.push(p);n.push(this.vertices.length-1);q.push(new THREE.Vector2(t,1-r))}m.push(n);l.push(q)}for(k=0;k<c;k++)for(h=0;h<b;h++){d=m[k][h+1];e=m[k][h];f=m[k+1][h];g=m[k+1][h+1];var n=this.vertices[d].clone().normalize(),q=this.vertices[e].clone().normalize(),t=this.vertices[f].clone().normalize(),r=this.vertices[g].clone().normalize(),p=l[k][h+1].clone(),s=l[k][h].clone(),u=l[k+1][h].clone(),x=l[k+1][h+1].clone();Math.abs(this.vertices[d].y)===a?(p.x=(p.x+
s.x)/2,this.faces.push(new THREE.Face3(d,f,g,[n,t,r])),this.faceVertexUvs[0].push([p,u,x])):Math.abs(this.vertices[f].y)===a?(u.x=(u.x+x.x)/2,this.faces.push(new THREE.Face3(d,e,f,[n,q,t])),this.faceVertexUvs[0].push([p,s,u])):(this.faces.push(new THREE.Face3(d,e,g,[n,q,r])),this.faceVertexUvs[0].push([p,s,x]),this.faces.push(new THREE.Face3(e,f,g,[q.clone(),t,r.clone()])),this.faceVertexUvs[0].push([s.clone(),u,x.clone()]))}this.computeFaceNormals();this.boundingSphere=new THREE.Sphere(new THREE.Vector3,
a)};THREE.SphereGeometry.prototype=Object.create(THREE.Geometry.prototype);THREE.TextGeometry=function(a,b){b=b||{};var c=THREE.FontUtils.generateShapes(a,b);b.amount=void 0!==b.height?b.height:50;void 0===b.bevelThickness&&(b.bevelThickness=10);void 0===b.bevelSize&&(b.bevelSize=8);void 0===b.bevelEnabled&&(b.bevelEnabled=!1);THREE.ExtrudeGeometry.call(this,c,b)};THREE.TextGeometry.prototype=Object.create(THREE.ExtrudeGeometry.prototype);
THREE.AxisHelper=function(a){a=a||1;var b=new Float32Array([0,0,0,a,0,0,0,0,0,0,a,0,0,0,0,0,0,a]),c=new Float32Array([1,0,0,1,0.6,0,0,1,0,0.6,1,0,0,0,1,0,0.6,1]);a=new THREE.BufferGeometry;a.addAttribute("position",new THREE.BufferAttribute(b,3));a.addAttribute("color",new THREE.BufferAttribute(c,3));b=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});THREE.Line.call(this,a,b,THREE.LinePieces)};THREE.AxisHelper.prototype=Object.create(THREE.Line.prototype);
THREE.ArrowHelper=function(){var a=new THREE.Geometry;a.vertices.push(new THREE.Vector3(0,0,0),new THREE.Vector3(0,1,0));var b=new THREE.CylinderGeometry(0,0.5,1,5,1);b.applyMatrix((new THREE.Matrix4).makeTranslation(0,-0.5,0));return function(c,d,e,f,g,h){THREE.Object3D.call(this);void 0===f&&(f=16776960);void 0===e&&(e=1);void 0===g&&(g=0.2*e);void 0===h&&(h=0.2*g);this.position.copy(d);this.line=new THREE.Line(a,new THREE.LineBasicMaterial({color:f}));this.line.matrixAutoUpdate=!1;this.add(this.line);
this.cone=new THREE.Mesh(b,new THREE.MeshBasicMaterial({color:f}));this.cone.matrixAutoUpdate=!1;this.add(this.cone);this.setDirection(c);this.setLength(e,g,h)}}();THREE.ArrowHelper.prototype=Object.create(THREE.Object3D.prototype);THREE.ArrowHelper.prototype.setDirection=function(){var a=new THREE.Vector3,b;return function(c){0.99999<c.y?this.quaternion.set(0,0,0,1):-0.99999>c.y?this.quaternion.set(1,0,0,0):(a.set(c.z,0,-c.x).normalize(),b=Math.acos(c.y),this.quaternion.setFromAxisAngle(a,b))}}();
THREE.ArrowHelper.prototype.setLength=function(a,b,c){void 0===b&&(b=0.2*a);void 0===c&&(c=0.2*b);this.line.scale.set(1,a,1);this.line.updateMatrix();this.cone.scale.set(c,b,c);this.cone.position.y=a;this.cone.updateMatrix()};THREE.ArrowHelper.prototype.setColor=function(a){this.line.material.color.set(a);this.cone.material.color.set(a)};
THREE.BoxHelper=function(a){var b=new THREE.BufferGeometry;b.addAttribute("position",new THREE.BufferAttribute(new Float32Array(72),3));THREE.Line.call(this,b,new THREE.LineBasicMaterial({color:16776960}),THREE.LinePieces);void 0!==a&&this.update(a)};THREE.BoxHelper.prototype=Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update=function(a){var b=a.geometry;null===b.boundingBox&&b.computeBoundingBox();var c=b.boundingBox.min,b=b.boundingBox.max,d=this.geometry.attributes.position.array;d[0]=b.x;d[1]=b.y;d[2]=b.z;d[3]=c.x;d[4]=b.y;d[5]=b.z;d[6]=c.x;d[7]=b.y;d[8]=b.z;d[9]=c.x;d[10]=c.y;d[11]=b.z;d[12]=c.x;d[13]=c.y;d[14]=b.z;d[15]=b.x;d[16]=c.y;d[17]=b.z;d[18]=b.x;d[19]=c.y;d[20]=b.z;d[21]=b.x;d[22]=b.y;d[23]=b.z;d[24]=b.x;d[25]=b.y;d[26]=c.z;d[27]=c.x;d[28]=b.y;d[29]=c.z;d[30]=c.x;d[31]=b.y;
d[32]=c.z;d[33]=c.x;d[34]=c.y;d[35]=c.z;d[36]=c.x;d[37]=c.y;d[38]=c.z;d[39]=b.x;d[40]=c.y;d[41]=c.z;d[42]=b.x;d[43]=c.y;d[44]=c.z;d[45]=b.x;d[46]=b.y;d[47]=c.z;d[48]=b.x;d[49]=b.y;d[50]=b.z;d[51]=b.x;d[52]=b.y;d[53]=c.z;d[54]=c.x;d[55]=b.y;d[56]=b.z;d[57]=c.x;d[58]=b.y;d[59]=c.z;d[60]=c.x;d[61]=c.y;d[62]=b.z;d[63]=c.x;d[64]=c.y;d[65]=c.z;d[66]=b.x;d[67]=c.y;d[68]=b.z;d[69]=b.x;d[70]=c.y;d[71]=c.z;this.geometry.attributes.position.needsUpdate=!0;this.geometry.computeBoundingSphere();this.matrixAutoUpdate=
!1;this.matrixWorld=a.matrixWorld};THREE.BoundingBoxHelper=function(a,b){var c=void 0!==b?b:8947848;this.object=a;this.box=new THREE.Box3;THREE.Mesh.call(this,new THREE.BoxGeometry(1,1,1),new THREE.MeshBasicMaterial({color:c,wireframe:!0}))};THREE.BoundingBoxHelper.prototype=Object.create(THREE.Mesh.prototype);THREE.BoundingBoxHelper.prototype.update=function(){this.box.setFromObject(this.object);this.box.size(this.scale);this.box.center(this.position)};
THREE.CameraHelper=function(a){function b(a,b,d){c(a,d);c(b,d)}function c(a,b){d.vertices.push(new THREE.Vector3);d.colors.push(new THREE.Color(b));void 0===f[a]&&(f[a]=[]);f[a].push(d.vertices.length-1)}var d=new THREE.Geometry,e=new THREE.LineBasicMaterial({color:16777215,vertexColors:THREE.FaceColors}),f={};b("n1","n2",16755200);b("n2","n4",16755200);b("n4","n3",16755200);b("n3","n1",16755200);b("f1","f2",16755200);b("f2","f4",16755200);b("f4","f3",16755200);b("f3","f1",16755200);b("n1","f1",16755200);
b("n2","f2",16755200);b("n3","f3",16755200);b("n4","f4",16755200);b("p","n1",16711680);b("p","n2",16711680);b("p","n3",16711680);b("p","n4",16711680);b("u1","u2",43775);b("u2","u3",43775);b("u3","u1",43775);b("c","t",16777215);b("p","c",3355443);b("cn1","cn2",3355443);b("cn3","cn4",3355443);b("cf1","cf2",3355443);b("cf3","cf4",3355443);THREE.Line.call(this,d,e,THREE.LinePieces);this.camera=a;this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;this.pointMap=f;this.update()};
THREE.CameraHelper.prototype=Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Camera,c=new THREE.Projector;return function(){function d(d,g,h,k){a.set(g,h,k);c.unprojectVector(a,b);d=e.pointMap[d];if(void 0!==d)for(g=0,h=d.length;g<h;g++)e.geometry.vertices[d[g]].copy(a)}var e=this;b.projectionMatrix.copy(this.camera.projectionMatrix);d("c",0,0,-1);d("t",0,0,1);d("n1",-1,-1,-1);d("n2",1,-1,-1);d("n3",-1,1,-1);d("n4",1,1,-1);d("f1",-1,-1,1);d("f2",1,-1,1);d("f3",-1,1,1);d("f4",1,1,1);d("u1",0.7,
1.1,-1);d("u2",-0.7,1.1,-1);d("u3",0,2,-1);d("cf1",-1,0,1);d("cf2",1,0,1);d("cf3",0,-1,1);d("cf4",0,1,1);d("cn1",-1,0,-1);d("cn2",1,0,-1);d("cn3",0,-1,-1);d("cn4",0,1,-1);this.geometry.verticesNeedUpdate=!0}}();
THREE.DirectionalLightHelper=function(a,b){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;b=b||1;var c=new THREE.Geometry;c.vertices.push(new THREE.Vector3(-b,b,0),new THREE.Vector3(b,b,0),new THREE.Vector3(b,-b,0),new THREE.Vector3(-b,-b,0),new THREE.Vector3(-b,b,0));var d=new THREE.LineBasicMaterial({fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.lightPlane=new THREE.Line(c,d);this.add(this.lightPlane);
c=new THREE.Geometry;c.vertices.push(new THREE.Vector3,new THREE.Vector3);d=new THREE.LineBasicMaterial({fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine=new THREE.Line(c,d);this.add(this.targetLine);this.update()};THREE.DirectionalLightHelper.prototype=Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose()};
THREE.DirectionalLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3,c=new THREE.Vector3;return function(){a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);c.subVectors(b,a);this.lightPlane.lookAt(c);this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);this.targetLine.geometry.vertices[1].copy(c);this.targetLine.geometry.verticesNeedUpdate=!0;this.targetLine.material.color.copy(this.lightPlane.material.color)}}();
THREE.EdgesHelper=function(a,b){var c=void 0!==b?b:16777215,d=[0,0],e={},f=function(a,b){return a-b},g=["a","b","c"],h=new THREE.BufferGeometry,k=a.geometry.clone();k.mergeVertices();k.computeFaceNormals();for(var m=k.vertices,k=k.faces,l=0,n=0,q=k.length;n<q;n++)for(var t=k[n],r=0;3>r;r++){d[0]=t[g[r]];d[1]=t[g[(r+1)%3]];d.sort(f);var p=d.toString();void 0===e[p]?(e[p]={vert1:d[0],vert2:d[1],face1:n,face2:void 0},l++):e[p].face2=n}h.addAttribute("position",new THREE.Float32Attribute(6*l,3));d=h.attributes.position.array;
f=0;for(p in e)if(g=e[p],void 0===g.face2||0.9999>k[g.face1].normal.dot(k[g.face2].normal))l=m[g.vert1],d[f++]=l.x,d[f++]=l.y,d[f++]=l.z,l=m[g.vert2],d[f++]=l.x,d[f++]=l.y,d[f++]=l.z;THREE.Line.call(this,h,new THREE.LineBasicMaterial({color:c}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.EdgesHelper.prototype=Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;a=void 0!==c?c:16776960;d=void 0!==d?d:1;b=new THREE.Geometry;c=0;for(var e=this.object.geometry.faces.length;c<e;c++)b.vertices.push(new THREE.Vector3,new THREE.Vector3);THREE.Line.call(this,b,new THREE.LineBasicMaterial({color:a,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};THREE.FaceNormalsHelper.prototype=Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update=function(){var a=this.geometry.vertices,b=this.object,c=b.geometry.vertices,d=b.geometry.faces,e=b.matrixWorld;b.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(e);for(var f=b=0,g=d.length;b<g;b++,f+=2){var h=d[b];a[f].copy(c[h.a]).add(c[h.b]).add(c[h.c]).divideScalar(3).applyMatrix4(e);a[f+1].copy(h.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size).add(a[f])}this.geometry.verticesNeedUpdate=!0;return this};
THREE.GridHelper=function(a,b){var c=new THREE.Geometry,d=new THREE.LineBasicMaterial({vertexColors:THREE.VertexColors});this.color1=new THREE.Color(4473924);this.color2=new THREE.Color(8947848);for(var e=-a;e<=a;e+=b){c.vertices.push(new THREE.Vector3(-a,0,e),new THREE.Vector3(a,0,e),new THREE.Vector3(e,0,-a),new THREE.Vector3(e,0,a));var f=0===e?this.color1:this.color2;c.colors.push(f,f,f,f)}THREE.Line.call(this,c,d,THREE.LinePieces)};THREE.GridHelper.prototype=Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors=function(a,b){this.color1.set(a);this.color2.set(b);this.geometry.colorsNeedUpdate=!0};THREE.PointLightHelper=function(a,b){this.light=a;this.light.updateMatrixWorld();var c=new THREE.SphereGeometry(b,4,2),d=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});d.color.copy(this.light.color).multiplyScalar(this.light.intensity);THREE.Mesh.call(this,c,d);this.matrixWorld=this.light.matrixWorld;this.matrixAutoUpdate=!1};THREE.PointLightHelper.prototype=Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose()};THREE.PointLightHelper.prototype.update=function(){this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)};
THREE.SpotLightHelper=function(a){THREE.Object3D.call(this);this.light=a;this.light.updateMatrixWorld();this.matrixWorld=a.matrixWorld;this.matrixAutoUpdate=!1;a=new THREE.CylinderGeometry(0,1,1,8,1,!0);a.applyMatrix((new THREE.Matrix4).makeTranslation(0,-0.5,0));a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI/2));var b=new THREE.MeshBasicMaterial({wireframe:!0,fog:!1});this.cone=new THREE.Mesh(a,b);this.add(this.cone);this.update()};THREE.SpotLightHelper.prototype=Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose()};THREE.SpotLightHelper.prototype.update=function(){var a=new THREE.Vector3,b=new THREE.Vector3;return function(){var c=this.light.distance?this.light.distance:1E4,d=c*Math.tan(this.light.angle);this.cone.scale.set(d,d,c);a.setFromMatrixPosition(this.light.matrixWorld);b.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(b.sub(a));this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)}}();
THREE.VertexNormalsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;b=void 0!==c?c:16711680;d=void 0!==d?d:1;c=new THREE.Geometry;a=a.geometry.faces;for(var e=0,f=a.length;e<f;e++)for(var g=0,h=a[e].vertexNormals.length;g<h;g++)c.vertices.push(new THREE.Vector3,new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.normalMatrix=new THREE.Matrix3;this.update()};THREE.VertexNormalsHelper.prototype=Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update=function(a){var b=new THREE.Vector3;return function(a){a=["a","b","c","d"];this.object.updateMatrixWorld(!0);this.normalMatrix.getNormalMatrix(this.object.matrixWorld);for(var d=this.geometry.vertices,e=this.object.geometry.vertices,f=this.object.geometry.faces,g=this.object.matrixWorld,h=0,k=0,m=f.length;k<m;k++)for(var l=f[k],n=0,q=l.vertexNormals.length;n<q;n++){var t=l.vertexNormals[n];d[h].copy(e[l[a[n]]]).applyMatrix4(g);b.copy(t).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
b.add(d[h]);h+=1;d[h].copy(b);h+=1}this.geometry.verticesNeedUpdate=!0;return this}}();
THREE.VertexTangentsHelper=function(a,b,c,d){this.object=a;this.size=void 0!==b?b:1;b=void 0!==c?c:255;d=void 0!==d?d:1;c=new THREE.Geometry;a=a.geometry.faces;for(var e=0,f=a.length;e<f;e++)for(var g=0,h=a[e].vertexTangents.length;g<h;g++)c.vertices.push(new THREE.Vector3),c.vertices.push(new THREE.Vector3);THREE.Line.call(this,c,new THREE.LineBasicMaterial({color:b,linewidth:d}),THREE.LinePieces);this.matrixAutoUpdate=!1;this.update()};THREE.VertexTangentsHelper.prototype=Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update=function(a){var b=new THREE.Vector3;return function(a){a=["a","b","c","d"];this.object.updateMatrixWorld(!0);for(var d=this.geometry.vertices,e=this.object.geometry.vertices,f=this.object.geometry.faces,g=this.object.matrixWorld,h=0,k=0,m=f.length;k<m;k++)for(var l=f[k],n=0,q=l.vertexTangents.length;n<q;n++){var t=l.vertexTangents[n];d[h].copy(e[l[a[n]]]).applyMatrix4(g);b.copy(t).transformDirection(g).multiplyScalar(this.size);b.add(d[h]);h+=1;d[h].copy(b);
h+=1}this.geometry.verticesNeedUpdate=!0;return this}}();
THREE.WireframeHelper=function(a,b){var c=void 0!==b?b:16777215,d=[0,0],e={},f=function(a,b){return a-b},g=["a","b","c"],h=new THREE.BufferGeometry;if(a.geometry instanceof THREE.Geometry){for(var k=a.geometry.vertices,m=a.geometry.faces,l=0,n=new Uint32Array(6*m.length),q=0,t=m.length;q<t;q++)for(var r=m[q],p=0;3>p;p++){d[0]=r[g[p]];d[1]=r[g[(p+1)%3]];d.sort(f);var s=d.toString();void 0===e[s]&&(n[2*l]=d[0],n[2*l+1]=d[1],e[s]=!0,l++)}d=new Float32Array(6*l);q=0;for(t=l;q<t;q++)for(p=0;2>p;p++)l=
k[n[2*q+p]],g=6*q+3*p,d[g+0]=l.x,d[g+1]=l.y,d[g+2]=l.z;h.addAttribute("position",new THREE.BufferAttribute(d,3))}else if(a.geometry instanceof THREE.BufferGeometry){if(void 0!==a.geometry.attributes.index){for(var k=a.geometry.attributes.position.array,t=a.geometry.attributes.index.array,m=a.geometry.offsets,l=0,n=new Uint32Array(2*t.length),r=0,u=m.length;r<u;++r)for(var p=m[r].start,s=m[r].count,g=m[r].index,q=p,x=p+s;q<x;q+=3)for(p=0;3>p;p++)d[0]=g+t[q+p],d[1]=g+t[q+(p+1)%3],d.sort(f),s=d.toString(),
void 0===e[s]&&(n[2*l]=d[0],n[2*l+1]=d[1],e[s]=!0,l++);d=new Float32Array(6*l);q=0;for(t=l;q<t;q++)for(p=0;2>p;p++)g=6*q+3*p,l=3*n[2*q+p],d[g+0]=k[l],d[g+1]=k[l+1],d[g+2]=k[l+2]}else for(k=a.geometry.attributes.position.array,l=k.length/3,n=l/3,d=new Float32Array(6*l),q=0,t=n;q<t;q++)for(p=0;3>p;p++)g=18*q+6*p,n=9*q+3*p,d[g+0]=k[n],d[g+1]=k[n+1],d[g+2]=k[n+2],l=9*q+(p+1)%3*3,d[g+3]=k[l],d[g+4]=k[l+1],d[g+5]=k[l+2];h.addAttribute("position",new THREE.BufferAttribute(d,3))}THREE.Line.call(this,h,new THREE.LineBasicMaterial({color:c}),
THREE.LinePieces);this.matrixAutoUpdate=!1;this.matrixWorld=a.matrixWorld};THREE.WireframeHelper.prototype=Object.create(THREE.Line.prototype);
THREE.ShadowMapPlugin=function(){function a(b,c,d){if(c.visible){var e=b.__webglObjects[c.id];if(e&&c.castShadow&&(!1===c.frustumCulled||!0===h.intersectsObject(c)))for(var f=0,g=e.length;f<g;f++){var k=e[f];c._modelViewMatrix.multiplyMatrices(d.matrixWorldInverse,c.matrixWorld);q.push(k)}f=0;for(g=c.children.length;f<g;f++)a(b,c.children[f],d)}}var b,c,d,e,f,g,h=new THREE.Frustum,k=new THREE.Matrix4,m=new THREE.Vector3,l=new THREE.Vector3,n=new THREE.Vector3,q=[];this.init=function(a){b=a.context;
c=a;a=THREE.ShaderLib.depthRGBA;var h=THREE.UniformsUtils.clone(a.uniforms);d=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h});e=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h,morphTargets:!0});f=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h,skinning:!0});g=new THREE.ShaderMaterial({fragmentShader:a.fragmentShader,vertexShader:a.vertexShader,uniforms:h,
morphTargets:!0,skinning:!0});d._shadowPass=!0;e._shadowPass=!0;f._shadowPass=!0;g._shadowPass=!0};this.render=function(a,b){c.shadowMapEnabled&&c.shadowMapAutoUpdate&&this.update(a,b)};this.update=function(t,r){var p,s,u,x,A,w,v,z,F=[];x=0;b.clearColor(1,1,1,1);b.disable(b.BLEND);b.enable(b.CULL_FACE);b.frontFace(b.CCW);c.shadowMapCullFace===THREE.CullFaceFront?b.cullFace(b.FRONT):b.cullFace(b.BACK);c.setDepthTest(!0);p=0;for(s=t.__lights.length;p<s;p++)if(u=t.__lights[p],u.castShadow)if(u instanceof
THREE.DirectionalLight&&u.shadowCascade)for(A=0;A<u.shadowCascadeCount;A++){var B;if(u.shadowCascadeArray[A])B=u.shadowCascadeArray[A];else{v=u;var y=A;B=new THREE.DirectionalLight;B.isVirtual=!0;B.onlyShadow=!0;B.castShadow=!0;B.shadowCameraNear=v.shadowCameraNear;B.shadowCameraFar=v.shadowCameraFar;B.shadowCameraLeft=v.shadowCameraLeft;B.shadowCameraRight=v.shadowCameraRight;B.shadowCameraBottom=v.shadowCameraBottom;B.shadowCameraTop=v.shadowCameraTop;B.shadowCameraVisible=v.shadowCameraVisible;
B.shadowDarkness=v.shadowDarkness;B.shadowBias=v.shadowCascadeBias[y];B.shadowMapWidth=v.shadowCascadeWidth[y];B.shadowMapHeight=v.shadowCascadeHeight[y];B.pointsWorld=[];B.pointsFrustum=[];z=B.pointsWorld;w=B.pointsFrustum;for(var E=0;8>E;E++)z[E]=new THREE.Vector3,w[E]=new THREE.Vector3;z=v.shadowCascadeNearZ[y];v=v.shadowCascadeFarZ[y];w[0].set(-1,-1,z);w[1].set(1,-1,z);w[2].set(-1,1,z);w[3].set(1,1,z);w[4].set(-1,-1,v);w[5].set(1,-1,v);w[6].set(-1,1,v);w[7].set(1,1,v);B.originalCamera=r;w=new THREE.Gyroscope;
w.position.copy(u.shadowCascadeOffset);w.add(B);w.add(B.target);r.add(w);u.shadowCascadeArray[A]=B;console.log("Created virtualLight",B)}y=u;z=A;v=y.shadowCascadeArray[z];v.position.copy(y.position);v.target.position.copy(y.target.position);v.lookAt(v.target);v.shadowCameraVisible=y.shadowCameraVisible;v.shadowDarkness=y.shadowDarkness;v.shadowBias=y.shadowCascadeBias[z];w=y.shadowCascadeNearZ[z];y=y.shadowCascadeFarZ[z];v=v.pointsFrustum;v[0].z=w;v[1].z=w;v[2].z=w;v[3].z=w;v[4].z=y;v[5].z=y;v[6].z=
y;v[7].z=y;F[x]=B;x++}else F[x]=u,x++;p=0;for(s=F.length;p<s;p++){u=F[p];u.shadowMap||(A=THREE.LinearFilter,c.shadowMapType===THREE.PCFSoftShadowMap&&(A=THREE.NearestFilter),u.shadowMap=new THREE.WebGLRenderTarget(u.shadowMapWidth,u.shadowMapHeight,{minFilter:A,magFilter:A,format:THREE.RGBAFormat}),u.shadowMapSize=new THREE.Vector2(u.shadowMapWidth,u.shadowMapHeight),u.shadowMatrix=new THREE.Matrix4);if(!u.shadowCamera){if(u instanceof THREE.SpotLight)u.shadowCamera=new THREE.PerspectiveCamera(u.shadowCameraFov,
u.shadowMapWidth/u.shadowMapHeight,u.shadowCameraNear,u.shadowCameraFar);else if(u instanceof THREE.DirectionalLight)u.shadowCamera=new THREE.OrthographicCamera(u.shadowCameraLeft,u.shadowCameraRight,u.shadowCameraTop,u.shadowCameraBottom,u.shadowCameraNear,u.shadowCameraFar);else{console.error("Unsupported light type for shadow");continue}t.add(u.shadowCamera);!0===t.autoUpdate&&t.updateMatrixWorld()}u.shadowCameraVisible&&!u.cameraHelper&&(u.cameraHelper=new THREE.CameraHelper(u.shadowCamera),u.shadowCamera.add(u.cameraHelper));
if(u.isVirtual&&B.originalCamera==r){A=r;x=u.shadowCamera;w=u.pointsFrustum;v=u.pointsWorld;m.set(Infinity,Infinity,Infinity);l.set(-Infinity,-Infinity,-Infinity);for(y=0;8>y;y++)z=v[y],z.copy(w[y]),THREE.ShadowMapPlugin.__projector.unprojectVector(z,A),z.applyMatrix4(x.matrixWorldInverse),z.x<m.x&&(m.x=z.x),z.x>l.x&&(l.x=z.x),z.y<m.y&&(m.y=z.y),z.y>l.y&&(l.y=z.y),z.z<m.z&&(m.z=z.z),z.z>l.z&&(l.z=z.z);x.left=m.x;x.right=l.x;x.top=l.y;x.bottom=m.y;x.updateProjectionMatrix()}x=u.shadowMap;w=u.shadowMatrix;
A=u.shadowCamera;A.position.setFromMatrixPosition(u.matrixWorld);n.setFromMatrixPosition(u.target.matrixWorld);A.lookAt(n);A.updateMatrixWorld();A.matrixWorldInverse.getInverse(A.matrixWorld);u.cameraHelper&&(u.cameraHelper.visible=u.shadowCameraVisible);u.shadowCameraVisible&&u.cameraHelper.update();w.set(0.5,0,0,0.5,0,0.5,0,0.5,0,0,0.5,0.5,0,0,0,1);w.multiply(A.projectionMatrix);w.multiply(A.matrixWorldInverse);k.multiplyMatrices(A.projectionMatrix,A.matrixWorldInverse);h.setFromMatrix(k);c.setRenderTarget(x);
c.clear();q.length=0;a(t,t,A);u=0;for(x=q.length;u<x;u++)v=q[u],w=v.object,v=v.buffer,y=w.material instanceof THREE.MeshFaceMaterial?w.material.materials[0]:w.material,z=void 0!==w.geometry.morphTargets&&0<w.geometry.morphTargets.length&&y.morphTargets,E=w instanceof THREE.SkinnedMesh&&y.skinning,z=w.customDepthMaterial?w.customDepthMaterial:E?z?g:f:z?e:d,c.setMaterialFaces(y),v instanceof THREE.BufferGeometry?c.renderBufferDirect(A,t.__lights,null,z,v,w):c.renderBuffer(A,t.__lights,null,z,v,w);y=
t.__webglObjectsImmediate;u=0;for(x=y.length;u<x;u++)v=y[u],w=v.object,w.visible&&w.castShadow&&(w._modelViewMatrix.multiplyMatrices(A.matrixWorldInverse,w.matrixWorld),c.renderImmediateObject(A,t.__lights,null,d,w))}p=c.getClearColor();s=c.getClearAlpha();b.clearColor(p.r,p.g,p.b,s);b.enable(b.BLEND);c.shadowMapCullFace===THREE.CullFaceFront&&b.cullFace(b.BACK)}};THREE.ShadowMapPlugin.__projector=new THREE.Projector;THREE.DDSLoader=function(){};
THREE.DDSLoader.prototype={constructor:THREE.DDSLoader,load:function(a,b,c){var d=this,e=[],f=new THREE.CompressedTexture;f.image=e;f.flipY=!1;f.generateMipmaps=!1;if(a instanceof Array){var g=0,h=new THREE.XHRLoader;h.setResponseType("arraybuffer");c=function(c){h.load(a[c],function(a){a=d.parse(a,!0);e[c]={width:a.width,height:a.height,format:a.format,mipmaps:a.mipmaps};g+=1;6===g&&(1==a.mipmapCount&&(f.minFilter=THREE.LinearFilter),f.format=a.format,f.needsUpdate=!0,b&&b(f))})};for(var k=0,m=a.length;k<
m;++k)c(k)}else h=new THREE.XHRLoader,h.setResponseType("arraybuffer"),h.load(a,function(a){a=d.parse(a,!0);if(a.isCubemap)for(var c=a.mipmaps.length/a.mipmapCount,g=0;g<c;g++){e[g]={mipmaps:[]};for(var h=0;h<a.mipmapCount;h++)e[g].mipmaps.push(a.mipmaps[g*a.mipmapCount+h]),e[g].format=a.format,e[g].width=a.width,e[g].height=a.height}else f.image.width=a.width,f.image.height=a.height,f.mipmaps=a.mipmaps;1==a.mipmapCount&&(f.minFilter=THREE.LinearFilter);f.format=a.format;f.needsUpdate=!0;b&&b(f)});
return f},parse:function(a,b){function c(a){return a.charCodeAt(0)+(a.charCodeAt(1)<<8)+(a.charCodeAt(2)<<16)+(a.charCodeAt(3)<<24)}function d(a,b,c,d){var e=c*d*4;a=new Uint8Array(a,b,e);for(var e=new Uint8Array(e),f=b=0,g=0;g<d;g++)for(var h=0;h<c;h++){var k=a[f];f++;var l=a[f];f++;var m=a[f];f++;var n=a[f];f++;e[b]=m;b++;e[b]=l;b++;e[b]=k;b++;e[b]=n;b++}return e}var e={mipmaps:[],width:0,height:0,format:null,mipmapCount:1},f=c("DXT1"),g=c("DXT3"),h=c("DXT5");if(!a||31>a.byteLength)return console.error("THREE.DDSLoader.parse: Invalid DDS header."),
e;var k=new Int32Array(a,0,31);if(542327876!==k[0])return console.error("THREE.DDSLoader.parse: Invalid magic number in DDS header."),e;if(!k[20]&4)return console.error("THREE.DDSLoader.parse: Unsupported format, must contain a FourCC code."),e;var m=k[21],l=!1;switch(m){case f:f=8;e.format=THREE.RGB_S3TC_DXT1_Format;break;case g:f=16;e.format=THREE.RGBA_S3TC_DXT3_Format;break;case h:f=16;e.format=THREE.RGBA_S3TC_DXT5_Format;break;default:if(32==k[22]&&k[23]&16711680&&k[24]&65280&&k[25]&255&&k[26]&
4278190080)l=!0,f=64,e.format=THREE.RGBAFormat;else return console.error("THREE.DDSLoader.parse: Unsupported FourCC code ",String.fromCharCode(m&255,m>>8&255,m>>16&255,m>>24&255)),e}e.mipmapCount=1;k[2]&131072&&!1!==b&&(e.mipmapCount=Math.max(1,k[7]));e.isCubemap=k[28]&512?!0:!1;e.width=k[4];e.height=k[3];for(var k=k[1]+4,g=e.width,h=e.height,m=e.isCubemap?6:1,n=0;n<m;n++){for(var q=0;q<e.mipmapCount;q++){if(l)var t=d(a,k,g,h),r=t.length;else r=Math.max(4,g)/4*Math.max(4,h)/4*f,t=new Uint8Array(a,
k,r);e.mipmaps.push({data:t,width:g,height:h});k+=r;g=Math.max(0.5*g,1);h=Math.max(0.5*h,1)}g=e.width;h=e.height}return e}};
;/*
 Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
 (c) 2010-2013, Vladimir Agafonkin
 (c) 2010-2011, CloudMade
*/
if (typeof window !== 'undefined'){
!function(t,e,i){var n=t.L,o={};o.version="0.7.2",o.noConflict=function(){return t.L=n,this},t.L=o,o.Util={extend:function(t){var e,i,n,o,s=Array.prototype.slice.call(arguments,1);for(i=0,n=s.length;n>i;i++){o=s[i]||{};for(e in o)o.hasOwnProperty(e)&&(t[e]=o[e])}return t},bind:function(t,e){var i=arguments.length>2?Array.prototype.slice.call(arguments,2):null;return function(){return t.apply(e,i||arguments)}},stamp:function(){var t=0,e="_leaflet_id";return function(i){return i[e]=i[e]||++t,i[e]}}(),invokeEach:function(t,e,i){var n,o;if("object"==typeof t){o=Array.prototype.slice.call(arguments,3);for(n in t)e.apply(i,[n,t[n]].concat(o));return!0}return!1},limitExecByInterval:function(t,e,i){var n,o;return function s(){var a=arguments;return n?void(o=!0):(n=!0,setTimeout(function(){n=!1,o&&(s.apply(i,a),o=!1)},e),void t.apply(i,a))}},falseFn:function(){return!1},formatNum:function(t,e){var i=Math.pow(10,e||5);return Math.round(t*i)/i},trim:function(t){return t.trim?t.trim():t.replace(/^\s+|\s+$/g,"")},splitWords:function(t){return o.Util.trim(t).split(/\s+/)},setOptions:function(t,e){return t.options=o.extend({},t.options,e),t.options},getParamString:function(t,e,i){var n=[];for(var o in t)n.push(encodeURIComponent(i?o.toUpperCase():o)+"="+encodeURIComponent(t[o]));return(e&&-1!==e.indexOf("?")?"&":"?")+n.join("&")},template:function(t,e){return t.replace(/\{ *([\w_]+) *\}/g,function(t,n){var o=e[n];if(o===i)throw new Error("No value provided for variable "+t);return"function"==typeof o&&(o=o(e)),o})},isArray:Array.isArray||function(t){return"[object Array]"===Object.prototype.toString.call(t)},emptyImageUrl:"data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="},function(){function e(e){var i,n,o=["webkit","moz","o","ms"];for(i=0;i<o.length&&!n;i++)n=t[o[i]+e];return n}function i(e){var i=+new Date,o=Math.max(0,16-(i-n));return n=i+o,t.setTimeout(e,o)}var n=0,s=t.requestAnimationFrame||e("RequestAnimationFrame")||i,a=t.cancelAnimationFrame||e("CancelAnimationFrame")||e("CancelRequestAnimationFrame")||function(e){t.clearTimeout(e)};o.Util.requestAnimFrame=function(e,n,a,r){return e=o.bind(e,n),a&&s===i?void e():s.call(t,e,r)},o.Util.cancelAnimFrame=function(e){e&&a.call(t,e)}}(),o.extend=o.Util.extend,o.bind=o.Util.bind,o.stamp=o.Util.stamp,o.setOptions=o.Util.setOptions,o.Class=function(){},o.Class.extend=function(t){var e=function(){this.initialize&&this.initialize.apply(this,arguments),this._initHooks&&this.callInitHooks()},i=function(){};i.prototype=this.prototype;var n=new i;n.constructor=e,e.prototype=n;for(var s in this)this.hasOwnProperty(s)&&"prototype"!==s&&(e[s]=this[s]);t.statics&&(o.extend(e,t.statics),delete t.statics),t.includes&&(o.Util.extend.apply(null,[n].concat(t.includes)),delete t.includes),t.options&&n.options&&(t.options=o.extend({},n.options,t.options)),o.extend(n,t),n._initHooks=[];var a=this;return e.__super__=a.prototype,n.callInitHooks=function(){if(!this._initHooksCalled){a.prototype.callInitHooks&&a.prototype.callInitHooks.call(this),this._initHooksCalled=!0;for(var t=0,e=n._initHooks.length;e>t;t++)n._initHooks[t].call(this)}},e},o.Class.include=function(t){o.extend(this.prototype,t)},o.Class.mergeOptions=function(t){o.extend(this.prototype.options,t)},o.Class.addInitHook=function(t){var e=Array.prototype.slice.call(arguments,1),i="function"==typeof t?t:function(){this[t].apply(this,e)};this.prototype._initHooks=this.prototype._initHooks||[],this.prototype._initHooks.push(i)};var s="_leaflet_events";o.Mixin={},o.Mixin.Events={addEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d=this[s]=this[s]||{},p=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)r={action:e,context:i||this},h=t[n],p?(l=h+"_idx",u=l+"_len",c=d[l]=d[l]||{},c[p]||(c[p]=[],d[u]=(d[u]||0)+1),c[p].push(r)):(d[h]=d[h]||[],d[h].push(r));return this},hasEventListeners:function(t){var e=this[s];return!!e&&(t in e&&e[t].length>0||t+"_idx"in e&&e[t+"_idx_len"]>0)},removeEventListener:function(t,e,i){if(!this[s])return this;if(!t)return this.clearAllEventListeners();if(o.Util.invokeEach(t,this.removeEventListener,this,e,i))return this;var n,a,r,h,l,u,c,d,p,_=this[s],m=i&&i!==this&&o.stamp(i);for(t=o.Util.splitWords(t),n=0,a=t.length;a>n;n++)if(r=t[n],u=r+"_idx",c=u+"_len",d=_[u],e){if(h=m&&d?d[m]:_[r]){for(l=h.length-1;l>=0;l--)h[l].action!==e||i&&h[l].context!==i||(p=h.splice(l,1),p[0].action=o.Util.falseFn);i&&d&&0===h.length&&(delete d[m],_[c]--)}}else delete _[r],delete _[u],delete _[c];return this},clearAllEventListeners:function(){return delete this[s],this},fireEvent:function(t,e){if(!this.hasEventListeners(t))return this;var i,n,a,r,h,l=o.Util.extend({},e,{type:t,target:this}),u=this[s];if(u[t])for(i=u[t].slice(),n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);r=u[t+"_idx"];for(h in r)if(i=r[h].slice())for(n=0,a=i.length;a>n;n++)i[n].action.call(i[n].context,l);return this},addOneTimeEventListener:function(t,e,i){if(o.Util.invokeEach(t,this.addOneTimeEventListener,this,e,i))return this;var n=o.bind(function(){this.removeEventListener(t,e,i).removeEventListener(t,n,i)},this);return this.addEventListener(t,e,i).addEventListener(t,n,i)}},o.Mixin.Events.on=o.Mixin.Events.addEventListener,o.Mixin.Events.off=o.Mixin.Events.removeEventListener,o.Mixin.Events.once=o.Mixin.Events.addOneTimeEventListener,o.Mixin.Events.fire=o.Mixin.Events.fireEvent,function(){var n="ActiveXObject"in t,s=n&&!e.addEventListener,a=navigator.userAgent.toLowerCase(),r=-1!==a.indexOf("webkit"),h=-1!==a.indexOf("chrome"),l=-1!==a.indexOf("phantom"),u=-1!==a.indexOf("android"),c=-1!==a.search("android [23]"),d=-1!==a.indexOf("gecko"),p=typeof orientation!=i+"",_=t.navigator&&t.navigator.msPointerEnabled&&t.navigator.msMaxTouchPoints&&!t.PointerEvent,m=t.PointerEvent&&t.navigator.pointerEnabled&&t.navigator.maxTouchPoints||_,f="devicePixelRatio"in t&&t.devicePixelRatio>1||"matchMedia"in t&&t.matchMedia("(min-resolution:144dpi)")&&t.matchMedia("(min-resolution:144dpi)").matches,g=e.documentElement,v=n&&"transition"in g.style,y="WebKitCSSMatrix"in t&&"m11"in new t.WebKitCSSMatrix&&!c,P="MozPerspective"in g.style,L="OTransition"in g.style,x=!t.L_DISABLE_3D&&(v||y||P||L)&&!l,w=!t.L_NO_TOUCH&&!l&&function(){var t="ontouchstart";if(m||t in g)return!0;var i=e.createElement("div"),n=!1;return i.setAttribute?(i.setAttribute(t,"return;"),"function"==typeof i[t]&&(n=!0),i.removeAttribute(t),i=null,n):!1}();o.Browser={ie:n,ielt9:s,webkit:r,gecko:d&&!r&&!t.opera&&!n,android:u,android23:c,chrome:h,ie3d:v,webkit3d:y,gecko3d:P,opera3d:L,any3d:x,mobile:p,mobileWebkit:p&&r,mobileWebkit3d:p&&y,mobileOpera:p&&t.opera,touch:w,msPointer:_,pointer:m,retina:f}}(),o.Point=function(t,e,i){this.x=i?Math.round(t):t,this.y=i?Math.round(e):e},o.Point.prototype={clone:function(){return new o.Point(this.x,this.y)},add:function(t){return this.clone()._add(o.point(t))},_add:function(t){return this.x+=t.x,this.y+=t.y,this},subtract:function(t){return this.clone()._subtract(o.point(t))},_subtract:function(t){return this.x-=t.x,this.y-=t.y,this},divideBy:function(t){return this.clone()._divideBy(t)},_divideBy:function(t){return this.x/=t,this.y/=t,this},multiplyBy:function(t){return this.clone()._multiplyBy(t)},_multiplyBy:function(t){return this.x*=t,this.y*=t,this},round:function(){return this.clone()._round()},_round:function(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this},floor:function(){return this.clone()._floor()},_floor:function(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this},distanceTo:function(t){t=o.point(t);var e=t.x-this.x,i=t.y-this.y;return Math.sqrt(e*e+i*i)},equals:function(t){return t=o.point(t),t.x===this.x&&t.y===this.y},contains:function(t){return t=o.point(t),Math.abs(t.x)<=Math.abs(this.x)&&Math.abs(t.y)<=Math.abs(this.y)},toString:function(){return"Point("+o.Util.formatNum(this.x)+", "+o.Util.formatNum(this.y)+")"}},o.point=function(t,e,n){return t instanceof o.Point?t:o.Util.isArray(t)?new o.Point(t[0],t[1]):t===i||null===t?t:new o.Point(t,e,n)},o.Bounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.Bounds.prototype={extend:function(t){return t=o.point(t),this.min||this.max?(this.min.x=Math.min(t.x,this.min.x),this.max.x=Math.max(t.x,this.max.x),this.min.y=Math.min(t.y,this.min.y),this.max.y=Math.max(t.y,this.max.y)):(this.min=t.clone(),this.max=t.clone()),this},getCenter:function(t){return new o.Point((this.min.x+this.max.x)/2,(this.min.y+this.max.y)/2,t)},getBottomLeft:function(){return new o.Point(this.min.x,this.max.y)},getTopRight:function(){return new o.Point(this.max.x,this.min.y)},getSize:function(){return this.max.subtract(this.min)},contains:function(t){var e,i;return t="number"==typeof t[0]||t instanceof o.Point?o.point(t):o.bounds(t),t instanceof o.Bounds?(e=t.min,i=t.max):e=i=t,e.x>=this.min.x&&i.x<=this.max.x&&e.y>=this.min.y&&i.y<=this.max.y},intersects:function(t){t=o.bounds(t);var e=this.min,i=this.max,n=t.min,s=t.max,a=s.x>=e.x&&n.x<=i.x,r=s.y>=e.y&&n.y<=i.y;return a&&r},isValid:function(){return!(!this.min||!this.max)}},o.bounds=function(t,e){return!t||t instanceof o.Bounds?t:new o.Bounds(t,e)},o.Transformation=function(t,e,i,n){this._a=t,this._b=e,this._c=i,this._d=n},o.Transformation.prototype={transform:function(t,e){return this._transform(t.clone(),e)},_transform:function(t,e){return e=e||1,t.x=e*(this._a*t.x+this._b),t.y=e*(this._c*t.y+this._d),t},untransform:function(t,e){return e=e||1,new o.Point((t.x/e-this._b)/this._a,(t.y/e-this._d)/this._c)}},o.DomUtil={get:function(t){return"string"==typeof t?e.getElementById(t):t},getStyle:function(t,i){var n=t.style[i];if(!n&&t.currentStyle&&(n=t.currentStyle[i]),(!n||"auto"===n)&&e.defaultView){var o=e.defaultView.getComputedStyle(t,null);n=o?o[i]:null}return"auto"===n?null:n},getViewportOffset:function(t){var i,n=0,s=0,a=t,r=e.body,h=e.documentElement;do{if(n+=a.offsetTop||0,s+=a.offsetLeft||0,n+=parseInt(o.DomUtil.getStyle(a,"borderTopWidth"),10)||0,s+=parseInt(o.DomUtil.getStyle(a,"borderLeftWidth"),10)||0,i=o.DomUtil.getStyle(a,"position"),a.offsetParent===r&&"absolute"===i)break;if("fixed"===i){n+=r.scrollTop||h.scrollTop||0,s+=r.scrollLeft||h.scrollLeft||0;break}if("relative"===i&&!a.offsetLeft){var l=o.DomUtil.getStyle(a,"width"),u=o.DomUtil.getStyle(a,"max-width"),c=a.getBoundingClientRect();("none"!==l||"none"!==u)&&(s+=c.left+a.clientLeft),n+=c.top+(r.scrollTop||h.scrollTop||0);break}a=a.offsetParent}while(a);a=t;do{if(a===r)break;n-=a.scrollTop||0,s-=a.scrollLeft||0,a=a.parentNode}while(a);return new o.Point(s,n)},documentIsLtr:function(){return o.DomUtil._docIsLtrCached||(o.DomUtil._docIsLtrCached=!0,o.DomUtil._docIsLtr="ltr"===o.DomUtil.getStyle(e.body,"direction")),o.DomUtil._docIsLtr},create:function(t,i,n){var o=e.createElement(t);return o.className=i,n&&n.appendChild(o),o},hasClass:function(t,e){if(t.classList!==i)return t.classList.contains(e);var n=o.DomUtil._getClass(t);return n.length>0&&new RegExp("(^|\\s)"+e+"(\\s|$)").test(n)},addClass:function(t,e){if(t.classList!==i)for(var n=o.Util.splitWords(e),s=0,a=n.length;a>s;s++)t.classList.add(n[s]);else if(!o.DomUtil.hasClass(t,e)){var r=o.DomUtil._getClass(t);o.DomUtil._setClass(t,(r?r+" ":"")+e)}},removeClass:function(t,e){t.classList!==i?t.classList.remove(e):o.DomUtil._setClass(t,o.Util.trim((" "+o.DomUtil._getClass(t)+" ").replace(" "+e+" "," ")))},_setClass:function(t,e){t.className.baseVal===i?t.className=e:t.className.baseVal=e},_getClass:function(t){return t.className.baseVal===i?t.className:t.className.baseVal},setOpacity:function(t,e){if("opacity"in t.style)t.style.opacity=e;else if("filter"in t.style){var i=!1,n="DXImageTransform.Microsoft.Alpha";try{i=t.filters.item(n)}catch(o){if(1===e)return}e=Math.round(100*e),i?(i.Enabled=100!==e,i.Opacity=e):t.style.filter+=" progid:"+n+"(opacity="+e+")"}},testProp:function(t){for(var i=e.documentElement.style,n=0;n<t.length;n++)if(t[n]in i)return t[n];return!1},getTranslateString:function(t){var e=o.Browser.webkit3d,i="translate"+(e?"3d":"")+"(",n=(e?",0":"")+")";return i+t.x+"px,"+t.y+"px"+n},getScaleString:function(t,e){var i=o.DomUtil.getTranslateString(e.add(e.multiplyBy(-1*t))),n=" scale("+t+") ";return i+n},setPosition:function(t,e,i){t._leaflet_pos=e,!i&&o.Browser.any3d?t.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(e):(t.style.left=e.x+"px",t.style.top=e.y+"px")},getPosition:function(t){return t._leaflet_pos}},o.DomUtil.TRANSFORM=o.DomUtil.testProp(["transform","WebkitTransform","OTransform","MozTransform","msTransform"]),o.DomUtil.TRANSITION=o.DomUtil.testProp(["webkitTransition","transition","OTransition","MozTransition","msTransition"]),o.DomUtil.TRANSITION_END="webkitTransition"===o.DomUtil.TRANSITION||"OTransition"===o.DomUtil.TRANSITION?o.DomUtil.TRANSITION+"End":"transitionend",function(){if("onselectstart"in e)o.extend(o.DomUtil,{disableTextSelection:function(){o.DomEvent.on(t,"selectstart",o.DomEvent.preventDefault)},enableTextSelection:function(){o.DomEvent.off(t,"selectstart",o.DomEvent.preventDefault)}});else{var i=o.DomUtil.testProp(["userSelect","WebkitUserSelect","OUserSelect","MozUserSelect","msUserSelect"]);o.extend(o.DomUtil,{disableTextSelection:function(){if(i){var t=e.documentElement.style;this._userSelect=t[i],t[i]="none"}},enableTextSelection:function(){i&&(e.documentElement.style[i]=this._userSelect,delete this._userSelect)}})}o.extend(o.DomUtil,{disableImageDrag:function(){o.DomEvent.on(t,"dragstart",o.DomEvent.preventDefault)},enableImageDrag:function(){o.DomEvent.off(t,"dragstart",o.DomEvent.preventDefault)}})}(),o.LatLng=function(t,e,n){if(t=parseFloat(t),e=parseFloat(e),isNaN(t)||isNaN(e))throw new Error("Invalid LatLng object: ("+t+", "+e+")");this.lat=t,this.lng=e,n!==i&&(this.alt=parseFloat(n))},o.extend(o.LatLng,{DEG_TO_RAD:Math.PI/180,RAD_TO_DEG:180/Math.PI,MAX_MARGIN:1e-9}),o.LatLng.prototype={equals:function(t){if(!t)return!1;t=o.latLng(t);var e=Math.max(Math.abs(this.lat-t.lat),Math.abs(this.lng-t.lng));return e<=o.LatLng.MAX_MARGIN},toString:function(t){return"LatLng("+o.Util.formatNum(this.lat,t)+", "+o.Util.formatNum(this.lng,t)+")"},distanceTo:function(t){t=o.latLng(t);var e=6378137,i=o.LatLng.DEG_TO_RAD,n=(t.lat-this.lat)*i,s=(t.lng-this.lng)*i,a=this.lat*i,r=t.lat*i,h=Math.sin(n/2),l=Math.sin(s/2),u=h*h+l*l*Math.cos(a)*Math.cos(r);return 2*e*Math.atan2(Math.sqrt(u),Math.sqrt(1-u))},wrap:function(t,e){var i=this.lng;return t=t||-180,e=e||180,i=(i+e)%(e-t)+(t>i||i===e?e:t),new o.LatLng(this.lat,i)}},o.latLng=function(t,e){return t instanceof o.LatLng?t:o.Util.isArray(t)?"number"==typeof t[0]||"string"==typeof t[0]?new o.LatLng(t[0],t[1],t[2]):null:t===i||null===t?t:"object"==typeof t&&"lat"in t?new o.LatLng(t.lat,"lng"in t?t.lng:t.lon):e===i?null:new o.LatLng(t,e)},o.LatLngBounds=function(t,e){if(t)for(var i=e?[t,e]:t,n=0,o=i.length;o>n;n++)this.extend(i[n])},o.LatLngBounds.prototype={extend:function(t){if(!t)return this;var e=o.latLng(t);return t=null!==e?e:o.latLngBounds(t),t instanceof o.LatLng?this._southWest||this._northEast?(this._southWest.lat=Math.min(t.lat,this._southWest.lat),this._southWest.lng=Math.min(t.lng,this._southWest.lng),this._northEast.lat=Math.max(t.lat,this._northEast.lat),this._northEast.lng=Math.max(t.lng,this._northEast.lng)):(this._southWest=new o.LatLng(t.lat,t.lng),this._northEast=new o.LatLng(t.lat,t.lng)):t instanceof o.LatLngBounds&&(this.extend(t._southWest),this.extend(t._northEast)),this},pad:function(t){var e=this._southWest,i=this._northEast,n=Math.abs(e.lat-i.lat)*t,s=Math.abs(e.lng-i.lng)*t;return new o.LatLngBounds(new o.LatLng(e.lat-n,e.lng-s),new o.LatLng(i.lat+n,i.lng+s))},getCenter:function(){return new o.LatLng((this._southWest.lat+this._northEast.lat)/2,(this._southWest.lng+this._northEast.lng)/2)},getSouthWest:function(){return this._southWest},getNorthEast:function(){return this._northEast},getNorthWest:function(){return new o.LatLng(this.getNorth(),this.getWest())},getSouthEast:function(){return new o.LatLng(this.getSouth(),this.getEast())},getWest:function(){return this._southWest.lng},getSouth:function(){return this._southWest.lat},getEast:function(){return this._northEast.lng},getNorth:function(){return this._northEast.lat},contains:function(t){t="number"==typeof t[0]||t instanceof o.LatLng?o.latLng(t):o.latLngBounds(t);var e,i,n=this._southWest,s=this._northEast;return t instanceof o.LatLngBounds?(e=t.getSouthWest(),i=t.getNorthEast()):e=i=t,e.lat>=n.lat&&i.lat<=s.lat&&e.lng>=n.lng&&i.lng<=s.lng},intersects:function(t){t=o.latLngBounds(t);var e=this._southWest,i=this._northEast,n=t.getSouthWest(),s=t.getNorthEast(),a=s.lat>=e.lat&&n.lat<=i.lat,r=s.lng>=e.lng&&n.lng<=i.lng;return a&&r},toBBoxString:function(){return[this.getWest(),this.getSouth(),this.getEast(),this.getNorth()].join(",")},equals:function(t){return t?(t=o.latLngBounds(t),this._southWest.equals(t.getSouthWest())&&this._northEast.equals(t.getNorthEast())):!1},isValid:function(){return!(!this._southWest||!this._northEast)}},o.latLngBounds=function(t,e){return!t||t instanceof o.LatLngBounds?t:new o.LatLngBounds(t,e)},o.Projection={},o.Projection.SphericalMercator={MAX_LATITUDE:85.0511287798,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=t.lng*e,a=n*e;return a=Math.log(Math.tan(Math.PI/4+a/2)),new o.Point(s,a)},unproject:function(t){var e=o.LatLng.RAD_TO_DEG,i=t.x*e,n=(2*Math.atan(Math.exp(t.y))-Math.PI/2)*e;return new o.LatLng(n,i)}},o.Projection.LonLat={project:function(t){return new o.Point(t.lng,t.lat)},unproject:function(t){return new o.LatLng(t.y,t.x)}},o.CRS={latLngToPoint:function(t,e){var i=this.projection.project(t),n=this.scale(e);return this.transformation._transform(i,n)},pointToLatLng:function(t,e){var i=this.scale(e),n=this.transformation.untransform(t,i);return this.projection.unproject(n)},project:function(t){return this.projection.project(t)},scale:function(t){return 256*Math.pow(2,t)},getSize:function(t){var e=this.scale(t);return o.point(e,e)}},o.CRS.Simple=o.extend({},o.CRS,{projection:o.Projection.LonLat,transformation:new o.Transformation(1,0,-1,0),scale:function(t){return Math.pow(2,t)}}),o.CRS.EPSG3857=o.extend({},o.CRS,{code:"EPSG:3857",projection:o.Projection.SphericalMercator,transformation:new o.Transformation(.5/Math.PI,.5,-.5/Math.PI,.5),project:function(t){var e=this.projection.project(t),i=6378137;return e.multiplyBy(i)}}),o.CRS.EPSG900913=o.extend({},o.CRS.EPSG3857,{code:"EPSG:900913"}),o.CRS.EPSG4326=o.extend({},o.CRS,{code:"EPSG:4326",projection:o.Projection.LonLat,transformation:new o.Transformation(1/360,.5,-1/360,.5)}),o.Map=o.Class.extend({includes:o.Mixin.Events,options:{crs:o.CRS.EPSG3857,fadeAnimation:o.DomUtil.TRANSITION&&!o.Browser.android23,trackResize:!0,markerZoomAnimation:o.DomUtil.TRANSITION&&o.Browser.any3d},initialize:function(t,e){e=o.setOptions(this,e),this._initContainer(t),this._initLayout(),this._onResize=o.bind(this._onResize,this),this._initEvents(),e.maxBounds&&this.setMaxBounds(e.maxBounds),e.center&&e.zoom!==i&&this.setView(o.latLng(e.center),e.zoom,{reset:!0}),this._handlers=[],this._layers={},this._zoomBoundLayers={},this._tileLayersNum=0,this.callInitHooks(),this._addLayers(e.layers)},setView:function(t,e){return e=e===i?this.getZoom():e,this._resetView(o.latLng(t),this._limitZoom(e)),this},setZoom:function(t,e){return this._loaded?this.setView(this.getCenter(),t,{zoom:e}):(this._zoom=this._limitZoom(t),this)},zoomIn:function(t,e){return this.setZoom(this._zoom+(t||1),e)},zoomOut:function(t,e){return this.setZoom(this._zoom-(t||1),e)},setZoomAround:function(t,e,i){var n=this.getZoomScale(e),s=this.getSize().divideBy(2),a=t instanceof o.Point?t:this.latLngToContainerPoint(t),r=a.subtract(s).multiplyBy(1-1/n),h=this.containerPointToLatLng(s.add(r));return this.setView(h,e,{zoom:i})},fitBounds:function(t,e){e=e||{},t=t.getBounds?t.getBounds():o.latLngBounds(t);var i=o.point(e.paddingTopLeft||e.padding||[0,0]),n=o.point(e.paddingBottomRight||e.padding||[0,0]),s=this.getBoundsZoom(t,!1,i.add(n)),a=n.subtract(i).divideBy(2),r=this.project(t.getSouthWest(),s),h=this.project(t.getNorthEast(),s),l=this.unproject(r.add(h).divideBy(2).add(a),s);return s=e&&e.maxZoom?Math.min(e.maxZoom,s):s,this.setView(l,s,e)},fitWorld:function(t){return this.fitBounds([[-90,-180],[90,180]],t)},panTo:function(t,e){return this.setView(t,this._zoom,{pan:e})},panBy:function(t){return this.fire("movestart"),this._rawPanBy(o.point(t)),this.fire("move"),this.fire("moveend")},setMaxBounds:function(t){return t=o.latLngBounds(t),this.options.maxBounds=t,t?(this._loaded&&this._panInsideMaxBounds(),this.on("moveend",this._panInsideMaxBounds,this)):this.off("moveend",this._panInsideMaxBounds,this)},panInsideBounds:function(t,e){var i=this.getCenter(),n=this._limitCenter(i,this._zoom,t);return i.equals(n)?this:this.panTo(n,e)},addLayer:function(t){var e=o.stamp(t);return this._layers[e]?this:(this._layers[e]=t,!t.options||isNaN(t.options.maxZoom)&&isNaN(t.options.minZoom)||(this._zoomBoundLayers[e]=t,this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum++,this._tileLayersToLoad++,t.on("load",this._onTileLayerLoad,this)),this._loaded&&this._layerAdd(t),this)},removeLayer:function(t){var e=o.stamp(t);return this._layers[e]?(this._loaded&&t.onRemove(this),delete this._layers[e],this._loaded&&this.fire("layerremove",{layer:t}),this._zoomBoundLayers[e]&&(delete this._zoomBoundLayers[e],this._updateZoomLevels()),this.options.zoomAnimation&&o.TileLayer&&t instanceof o.TileLayer&&(this._tileLayersNum--,this._tileLayersToLoad--,t.off("load",this._onTileLayerLoad,this)),this):this},hasLayer:function(t){return t?o.stamp(t)in this._layers:!1},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},invalidateSize:function(t){if(!this._loaded)return this;t=o.extend({animate:!1,pan:!0},t===!0?{animate:!0}:t);var e=this.getSize();this._sizeChanged=!0,this._initialCenter=null;var i=this.getSize(),n=e.divideBy(2).round(),s=i.divideBy(2).round(),a=n.subtract(s);return a.x||a.y?(t.animate&&t.pan?this.panBy(a):(t.pan&&this._rawPanBy(a),this.fire("move"),t.debounceMoveend?(clearTimeout(this._sizeTimer),this._sizeTimer=setTimeout(o.bind(this.fire,this,"moveend"),200)):this.fire("moveend")),this.fire("resize",{oldSize:e,newSize:i})):this},addHandler:function(t,e){if(!e)return this;var i=this[t]=new e(this);return this._handlers.push(i),this.options[t]&&i.enable(),this},remove:function(){this._loaded&&this.fire("unload"),this._initEvents("off");try{delete this._container._leaflet}catch(t){this._container._leaflet=i}return this._clearPanes(),this._clearControlPos&&this._clearControlPos(),this._clearHandlers(),this},getCenter:function(){return this._checkIfLoaded(),this._initialCenter&&!this._moved()?this._initialCenter:this.layerPointToLatLng(this._getCenterLayerPoint())},getZoom:function(){return this._zoom},getBounds:function(){var t=this.getPixelBounds(),e=this.unproject(t.getBottomLeft()),i=this.unproject(t.getTopRight());return new o.LatLngBounds(e,i)},getMinZoom:function(){return this.options.minZoom===i?this._layersMinZoom===i?0:this._layersMinZoom:this.options.minZoom},getMaxZoom:function(){return this.options.maxZoom===i?this._layersMaxZoom===i?1/0:this._layersMaxZoom:this.options.maxZoom},getBoundsZoom:function(t,e,i){t=o.latLngBounds(t);var n,s=this.getMinZoom()-(e?1:0),a=this.getMaxZoom(),r=this.getSize(),h=t.getNorthWest(),l=t.getSouthEast(),u=!0;i=o.point(i||[0,0]);do s++,n=this.project(l,s).subtract(this.project(h,s)).add(i),u=e?n.x<r.x||n.y<r.y:r.contains(n);while(u&&a>=s);return u&&e?null:e?s:s-1},getSize:function(){return(!this._size||this._sizeChanged)&&(this._size=new o.Point(this._container.clientWidth,this._container.clientHeight),this._sizeChanged=!1),this._size.clone()},getPixelBounds:function(){var t=this._getTopLeftPoint();return new o.Bounds(t,t.add(this.getSize()))},getPixelOrigin:function(){return this._checkIfLoaded(),this._initialTopLeftPoint},getPanes:function(){return this._panes},getContainer:function(){return this._container},getZoomScale:function(t){var e=this.options.crs;return e.scale(t)/e.scale(this._zoom)},getScaleZoom:function(t){return this._zoom+Math.log(t)/Math.LN2},project:function(t,e){return e=e===i?this._zoom:e,this.options.crs.latLngToPoint(o.latLng(t),e)},unproject:function(t,e){return e=e===i?this._zoom:e,this.options.crs.pointToLatLng(o.point(t),e)},layerPointToLatLng:function(t){var e=o.point(t).add(this.getPixelOrigin());return this.unproject(e)},latLngToLayerPoint:function(t){var e=this.project(o.latLng(t))._round();return e._subtract(this.getPixelOrigin())},containerPointToLayerPoint:function(t){return o.point(t).subtract(this._getMapPanePos())},layerPointToContainerPoint:function(t){return o.point(t).add(this._getMapPanePos())},containerPointToLatLng:function(t){var e=this.containerPointToLayerPoint(o.point(t));return this.layerPointToLatLng(e)},latLngToContainerPoint:function(t){return this.layerPointToContainerPoint(this.latLngToLayerPoint(o.latLng(t)))},mouseEventToContainerPoint:function(t){return o.DomEvent.getMousePosition(t,this._container)},mouseEventToLayerPoint:function(t){return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))},mouseEventToLatLng:function(t){return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))},_initContainer:function(t){var e=this._container=o.DomUtil.get(t);if(!e)throw new Error("Map container not found.");if(e._leaflet)throw new Error("Map container is already initialized.");e._leaflet=!0},_initLayout:function(){var t=this._container;o.DomUtil.addClass(t,"leaflet-container"+(o.Browser.touch?" leaflet-touch":"")+(o.Browser.retina?" leaflet-retina":"")+(o.Browser.ielt9?" leaflet-oldie":"")+(this.options.fadeAnimation?" leaflet-fade-anim":""));var e=o.DomUtil.getStyle(t,"position");"absolute"!==e&&"relative"!==e&&"fixed"!==e&&(t.style.position="relative"),this._initPanes(),this._initControlPos&&this._initControlPos()},_initPanes:function(){var t=this._panes={};this._mapPane=t.mapPane=this._createPane("leaflet-map-pane",this._container),this._tilePane=t.tilePane=this._createPane("leaflet-tile-pane",this._mapPane),t.objectsPane=this._createPane("leaflet-objects-pane",this._mapPane),t.shadowPane=this._createPane("leaflet-shadow-pane"),t.overlayPane=this._createPane("leaflet-overlay-pane"),t.markerPane=this._createPane("leaflet-marker-pane"),t.popupPane=this._createPane("leaflet-popup-pane");var e=" leaflet-zoom-hide";this.options.markerZoomAnimation||(o.DomUtil.addClass(t.markerPane,e),o.DomUtil.addClass(t.shadowPane,e),o.DomUtil.addClass(t.popupPane,e))},_createPane:function(t,e){return o.DomUtil.create("div",t,e||this._panes.objectsPane)},_clearPanes:function(){this._container.removeChild(this._mapPane)},_addLayers:function(t){t=t?o.Util.isArray(t)?t:[t]:[];for(var e=0,i=t.length;i>e;e++)this.addLayer(t[e])},_resetView:function(t,e,i,n){var s=this._zoom!==e;n||(this.fire("movestart"),s&&this.fire("zoomstart")),this._zoom=e,this._initialCenter=t,this._initialTopLeftPoint=this._getNewTopLeftPoint(t),i?this._initialTopLeftPoint._add(this._getMapPanePos()):o.DomUtil.setPosition(this._mapPane,new o.Point(0,0)),this._tileLayersToLoad=this._tileLayersNum;var a=!this._loaded;this._loaded=!0,a&&(this.fire("load"),this.eachLayer(this._layerAdd,this)),this.fire("viewreset",{hard:!i}),this.fire("move"),(s||n)&&this.fire("zoomend"),this.fire("moveend",{hard:!i})},_rawPanBy:function(t){o.DomUtil.setPosition(this._mapPane,this._getMapPanePos().subtract(t))},_getZoomSpan:function(){return this.getMaxZoom()-this.getMinZoom()},_updateZoomLevels:function(){var t,e=1/0,n=-1/0,o=this._getZoomSpan();for(t in this._zoomBoundLayers){var s=this._zoomBoundLayers[t];isNaN(s.options.minZoom)||(e=Math.min(e,s.options.minZoom)),isNaN(s.options.maxZoom)||(n=Math.max(n,s.options.maxZoom))}t===i?this._layersMaxZoom=this._layersMinZoom=i:(this._layersMaxZoom=n,this._layersMinZoom=e),o!==this._getZoomSpan()&&this.fire("zoomlevelschange")},_panInsideMaxBounds:function(){this.panInsideBounds(this.options.maxBounds)},_checkIfLoaded:function(){if(!this._loaded)throw new Error("Set map center and zoom first.")},_initEvents:function(e){if(o.DomEvent){e=e||"on",o.DomEvent[e](this._container,"click",this._onMouseClick,this);var i,n,s=["dblclick","mousedown","mouseup","mouseenter","mouseleave","mousemove","contextmenu"];for(i=0,n=s.length;n>i;i++)o.DomEvent[e](this._container,s[i],this._fireMouseEvent,this);this.options.trackResize&&o.DomEvent[e](t,"resize",this._onResize,this)}},_onResize:function(){o.Util.cancelAnimFrame(this._resizeRequest),this._resizeRequest=o.Util.requestAnimFrame(function(){this.invalidateSize({debounceMoveend:!0})},this,!1,this._container)},_onMouseClick:function(t){!this._loaded||!t._simulated&&(this.dragging&&this.dragging.moved()||this.boxZoom&&this.boxZoom.moved())||o.DomEvent._skipped(t)||(this.fire("preclick"),this._fireMouseEvent(t))},_fireMouseEvent:function(t){if(this._loaded&&!o.DomEvent._skipped(t)){var e=t.type;if(e="mouseenter"===e?"mouseover":"mouseleave"===e?"mouseout":e,this.hasEventListeners(e)){"contextmenu"===e&&o.DomEvent.preventDefault(t);var i=this.mouseEventToContainerPoint(t),n=this.containerPointToLayerPoint(i),s=this.layerPointToLatLng(n);this.fire(e,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t})}}},_onTileLayerLoad:function(){this._tileLayersToLoad--,this._tileLayersNum&&!this._tileLayersToLoad&&this.fire("tilelayersload")},_clearHandlers:function(){for(var t=0,e=this._handlers.length;e>t;t++)this._handlers[t].disable()},whenReady:function(t,e){return this._loaded?t.call(e||this,this):this.on("load",t,e),this},_layerAdd:function(t){t.onAdd(this),this.fire("layeradd",{layer:t})},_getMapPanePos:function(){return o.DomUtil.getPosition(this._mapPane)},_moved:function(){var t=this._getMapPanePos();return t&&!t.equals([0,0])},_getTopLeftPoint:function(){return this.getPixelOrigin().subtract(this._getMapPanePos())},_getNewTopLeftPoint:function(t,e){var i=this.getSize()._divideBy(2);return this.project(t,e)._subtract(i)._round()},_latLngToNewLayerPoint:function(t,e,i){var n=this._getNewTopLeftPoint(i,e).add(this._getMapPanePos());return this.project(t,e)._subtract(n)},_getCenterLayerPoint:function(){return this.containerPointToLayerPoint(this.getSize()._divideBy(2))},_getCenterOffset:function(t){return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())},_limitCenter:function(t,e,i){if(!i)return t;var n=this.project(t,e),s=this.getSize().divideBy(2),a=new o.Bounds(n.subtract(s),n.add(s)),r=this._getBoundsOffset(a,i,e);return this.unproject(n.add(r),e)},_limitOffset:function(t,e){if(!e)return t;var i=this.getPixelBounds(),n=new o.Bounds(i.min.add(t),i.max.add(t));return t.add(this._getBoundsOffset(n,e))},_getBoundsOffset:function(t,e,i){var n=this.project(e.getNorthWest(),i).subtract(t.min),s=this.project(e.getSouthEast(),i).subtract(t.max),a=this._rebound(n.x,-s.x),r=this._rebound(n.y,-s.y);return new o.Point(a,r)},_rebound:function(t,e){return t+e>0?Math.round(t-e)/2:Math.max(0,Math.ceil(t))-Math.max(0,Math.floor(e))},_limitZoom:function(t){var e=this.getMinZoom(),i=this.getMaxZoom();return Math.max(e,Math.min(i,t))}}),o.map=function(t,e){return new o.Map(t,e)},o.Projection.Mercator={MAX_LATITUDE:85.0840591556,R_MINOR:6356752.314245179,R_MAJOR:6378137,project:function(t){var e=o.LatLng.DEG_TO_RAD,i=this.MAX_LATITUDE,n=Math.max(Math.min(i,t.lat),-i),s=this.R_MAJOR,a=this.R_MINOR,r=t.lng*e*s,h=n*e,l=a/s,u=Math.sqrt(1-l*l),c=u*Math.sin(h);c=Math.pow((1-c)/(1+c),.5*u);var d=Math.tan(.5*(.5*Math.PI-h))/c;return h=-s*Math.log(d),new o.Point(r,h)},unproject:function(t){for(var e,i=o.LatLng.RAD_TO_DEG,n=this.R_MAJOR,s=this.R_MINOR,a=t.x*i/n,r=s/n,h=Math.sqrt(1-r*r),l=Math.exp(-t.y/n),u=Math.PI/2-2*Math.atan(l),c=15,d=1e-7,p=c,_=.1;Math.abs(_)>d&&--p>0;)e=h*Math.sin(u),_=Math.PI/2-2*Math.atan(l*Math.pow((1-e)/(1+e),.5*h))-u,u+=_;
return new o.LatLng(u*i,a)}},o.CRS.EPSG3395=o.extend({},o.CRS,{code:"EPSG:3395",projection:o.Projection.Mercator,transformation:function(){var t=o.Projection.Mercator,e=t.R_MAJOR,i=.5/(Math.PI*e);return new o.Transformation(i,.5,-i,.5)}()}),o.TileLayer=o.Class.extend({includes:o.Mixin.Events,options:{minZoom:0,maxZoom:18,tileSize:256,subdomains:"abc",errorTileUrl:"",attribution:"",zoomOffset:0,opacity:1,unloadInvisibleTiles:o.Browser.mobile,updateWhenIdle:o.Browser.mobile},initialize:function(t,e){e=o.setOptions(this,e),e.detectRetina&&o.Browser.retina&&e.maxZoom>0&&(e.tileSize=Math.floor(e.tileSize/2),e.zoomOffset++,e.minZoom>0&&e.minZoom--,this.options.maxZoom--),e.bounds&&(e.bounds=o.latLngBounds(e.bounds)),this._url=t;var i=this.options.subdomains;"string"==typeof i&&(this.options.subdomains=i.split(""))},onAdd:function(t){this._map=t,this._animated=t._zoomAnimated,this._initContainer(),t.on({viewreset:this._reset,moveend:this._update},this),this._animated&&t.on({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||(this._limitedUpdate=o.Util.limitExecByInterval(this._update,150,this),t.on("move",this._limitedUpdate,this)),this._reset(),this._update()},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this._container.parentNode.removeChild(this._container),t.off({viewreset:this._reset,moveend:this._update},this),this._animated&&t.off({zoomanim:this._animateZoom,zoomend:this._endZoomAnim},this),this.options.updateWhenIdle||t.off("move",this._limitedUpdate,this),this._container=null,this._map=null},bringToFront:function(){var t=this._map._panes.tilePane;return this._container&&(t.appendChild(this._container),this._setAutoZIndex(t,Math.max)),this},bringToBack:function(){var t=this._map._panes.tilePane;return this._container&&(t.insertBefore(this._container,t.firstChild),this._setAutoZIndex(t,Math.min)),this},getAttribution:function(){return this.options.attribution},getContainer:function(){return this._container},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},setZIndex:function(t){return this.options.zIndex=t,this._updateZIndex(),this},setUrl:function(t,e){return this._url=t,e||this.redraw(),this},redraw:function(){return this._map&&(this._reset({hard:!0}),this._update()),this},_updateZIndex:function(){this._container&&this.options.zIndex!==i&&(this._container.style.zIndex=this.options.zIndex)},_setAutoZIndex:function(t,e){var i,n,o,s=t.children,a=-e(1/0,-1/0);for(n=0,o=s.length;o>n;n++)s[n]!==this._container&&(i=parseInt(s[n].style.zIndex,10),isNaN(i)||(a=e(a,i)));this.options.zIndex=this._container.style.zIndex=(isFinite(a)?a:0)+e(1,-1)},_updateOpacity:function(){var t,e=this._tiles;if(o.Browser.ielt9)for(t in e)o.DomUtil.setOpacity(e[t],this.options.opacity);else o.DomUtil.setOpacity(this._container,this.options.opacity)},_initContainer:function(){var t=this._map._panes.tilePane;if(!this._container){if(this._container=o.DomUtil.create("div","leaflet-layer"),this._updateZIndex(),this._animated){var e="leaflet-tile-container";this._bgBuffer=o.DomUtil.create("div",e,this._container),this._tileContainer=o.DomUtil.create("div",e,this._container)}else this._tileContainer=this._container;t.appendChild(this._container),this.options.opacity<1&&this._updateOpacity()}},_reset:function(t){for(var e in this._tiles)this.fire("tileunload",{tile:this._tiles[e]});this._tiles={},this._tilesToLoad=0,this.options.reuseTiles&&(this._unusedTiles=[]),this._tileContainer.innerHTML="",this._animated&&t&&t.hard&&this._clearBgBuffer(),this._initContainer()},_getTileSize:function(){var t=this._map,e=t.getZoom()+this.options.zoomOffset,i=this.options.maxNativeZoom,n=this.options.tileSize;return i&&e>i&&(n=Math.round(t.getZoomScale(e)/t.getZoomScale(i)*n)),n},_update:function(){if(this._map){var t=this._map,e=t.getPixelBounds(),i=t.getZoom(),n=this._getTileSize();if(!(i>this.options.maxZoom||i<this.options.minZoom)){var s=o.bounds(e.min.divideBy(n)._floor(),e.max.divideBy(n)._floor());this._addTilesFromCenterOut(s),(this.options.unloadInvisibleTiles||this.options.reuseTiles)&&this._removeOtherTiles(s)}}},_addTilesFromCenterOut:function(t){var i,n,s,a=[],r=t.getCenter();for(i=t.min.y;i<=t.max.y;i++)for(n=t.min.x;n<=t.max.x;n++)s=new o.Point(n,i),this._tileShouldBeLoaded(s)&&a.push(s);var h=a.length;if(0!==h){a.sort(function(t,e){return t.distanceTo(r)-e.distanceTo(r)});var l=e.createDocumentFragment();for(this._tilesToLoad||this.fire("loading"),this._tilesToLoad+=h,n=0;h>n;n++)this._addTile(a[n],l);this._tileContainer.appendChild(l)}},_tileShouldBeLoaded:function(t){if(t.x+":"+t.y in this._tiles)return!1;var e=this.options;if(!e.continuousWorld){var i=this._getWrapTileNum();if(e.noWrap&&(t.x<0||t.x>=i.x)||t.y<0||t.y>=i.y)return!1}if(e.bounds){var n=e.tileSize,o=t.multiplyBy(n),s=o.add([n,n]),a=this._map.unproject(o),r=this._map.unproject(s);if(e.continuousWorld||e.noWrap||(a=a.wrap(),r=r.wrap()),!e.bounds.intersects([a,r]))return!1}return!0},_removeOtherTiles:function(t){var e,i,n,o;for(o in this._tiles)e=o.split(":"),i=parseInt(e[0],10),n=parseInt(e[1],10),(i<t.min.x||i>t.max.x||n<t.min.y||n>t.max.y)&&this._removeTile(o)},_removeTile:function(t){var e=this._tiles[t];this.fire("tileunload",{tile:e,url:e.src}),this.options.reuseTiles?(o.DomUtil.removeClass(e,"leaflet-tile-loaded"),this._unusedTiles.push(e)):e.parentNode===this._tileContainer&&this._tileContainer.removeChild(e),o.Browser.android||(e.onload=null,e.src=o.Util.emptyImageUrl),delete this._tiles[t]},_addTile:function(t,e){var i=this._getTilePos(t),n=this._getTile();o.DomUtil.setPosition(n,i,o.Browser.chrome),this._tiles[t.x+":"+t.y]=n,this._loadTile(n,t),n.parentNode!==this._tileContainer&&e.appendChild(n)},_getZoomForUrl:function(){var t=this.options,e=this._map.getZoom();return t.zoomReverse&&(e=t.maxZoom-e),e+=t.zoomOffset,t.maxNativeZoom?Math.min(e,t.maxNativeZoom):e},_getTilePos:function(t){var e=this._map.getPixelOrigin(),i=this._getTileSize();return t.multiplyBy(i).subtract(e)},getTileUrl:function(t){return o.Util.template(this._url,o.extend({s:this._getSubdomain(t),z:t.z,x:t.x,y:t.y},this.options))},_getWrapTileNum:function(){var t=this._map.options.crs,e=t.getSize(this._map.getZoom());return e.divideBy(this._getTileSize())._floor()},_adjustTilePoint:function(t){var e=this._getWrapTileNum();this.options.continuousWorld||this.options.noWrap||(t.x=(t.x%e.x+e.x)%e.x),this.options.tms&&(t.y=e.y-t.y-1),t.z=this._getZoomForUrl()},_getSubdomain:function(t){var e=Math.abs(t.x+t.y)%this.options.subdomains.length;return this.options.subdomains[e]},_getTile:function(){if(this.options.reuseTiles&&this._unusedTiles.length>0){var t=this._unusedTiles.pop();return this._resetTile(t),t}return this._createTile()},_resetTile:function(){},_createTile:function(){var t=o.DomUtil.create("img","leaflet-tile");return t.style.width=t.style.height=this._getTileSize()+"px",t.galleryimg="no",t.onselectstart=t.onmousemove=o.Util.falseFn,o.Browser.ielt9&&this.options.opacity!==i&&o.DomUtil.setOpacity(t,this.options.opacity),o.Browser.mobileWebkit3d&&(t.style.WebkitBackfaceVisibility="hidden"),t},_loadTile:function(t,e){t._layer=this,t.onload=this._tileOnLoad,t.onerror=this._tileOnError,this._adjustTilePoint(e),t.src=this.getTileUrl(e),this.fire("tileloadstart",{tile:t,url:t.src})},_tileLoaded:function(){this._tilesToLoad--,this._animated&&o.DomUtil.addClass(this._tileContainer,"leaflet-zoom-animated"),this._tilesToLoad||(this.fire("load"),this._animated&&(clearTimeout(this._clearBgBufferTimer),this._clearBgBufferTimer=setTimeout(o.bind(this._clearBgBuffer,this),500)))},_tileOnLoad:function(){var t=this._layer;this.src!==o.Util.emptyImageUrl&&(o.DomUtil.addClass(this,"leaflet-tile-loaded"),t.fire("tileload",{tile:this,url:this.src})),t._tileLoaded()},_tileOnError:function(){var t=this._layer;t.fire("tileerror",{tile:this,url:this.src});var e=t.options.errorTileUrl;e&&(this.src=e),t._tileLoaded()}}),o.tileLayer=function(t,e){return new o.TileLayer(t,e)},o.TileLayer.WMS=o.TileLayer.extend({defaultWmsParams:{service:"WMS",request:"GetMap",version:"1.1.1",layers:"",styles:"",format:"image/jpeg",transparent:!1},initialize:function(t,e){this._url=t;var i=o.extend({},this.defaultWmsParams),n=e.tileSize||this.options.tileSize;i.width=i.height=e.detectRetina&&o.Browser.retina?2*n:n;for(var s in e)this.options.hasOwnProperty(s)||"crs"===s||(i[s]=e[s]);this.wmsParams=i,o.setOptions(this,e)},onAdd:function(t){this._crs=this.options.crs||t.options.crs,this._wmsVersion=parseFloat(this.wmsParams.version);var e=this._wmsVersion>=1.3?"crs":"srs";this.wmsParams[e]=this._crs.code,o.TileLayer.prototype.onAdd.call(this,t)},getTileUrl:function(t){var e=this._map,i=this.options.tileSize,n=t.multiplyBy(i),s=n.add([i,i]),a=this._crs.project(e.unproject(n,t.z)),r=this._crs.project(e.unproject(s,t.z)),h=this._wmsVersion>=1.3&&this._crs===o.CRS.EPSG4326?[r.y,a.x,a.y,r.x].join(","):[a.x,r.y,r.x,a.y].join(","),l=o.Util.template(this._url,{s:this._getSubdomain(t)});return l+o.Util.getParamString(this.wmsParams,l,!0)+"&BBOX="+h},setParams:function(t,e){return o.extend(this.wmsParams,t),e||this.redraw(),this}}),o.tileLayer.wms=function(t,e){return new o.TileLayer.WMS(t,e)},o.TileLayer.Canvas=o.TileLayer.extend({options:{async:!1},initialize:function(t){o.setOptions(this,t)},redraw:function(){this._map&&(this._reset({hard:!0}),this._update());for(var t in this._tiles)this._redrawTile(this._tiles[t]);return this},_redrawTile:function(t){this.drawTile(t,t._tilePoint,this._map._zoom)},_createTile:function(){var t=o.DomUtil.create("canvas","leaflet-tile");return t.width=t.height=this.options.tileSize,t.onselectstart=t.onmousemove=o.Util.falseFn,t},_loadTile:function(t,e){t._layer=this,t._tilePoint=e,this._redrawTile(t),this.options.async||this.tileDrawn(t)},drawTile:function(){},tileDrawn:function(t){this._tileOnLoad.call(t)}}),o.tileLayer.canvas=function(t){return new o.TileLayer.Canvas(t)},o.ImageOverlay=o.Class.extend({includes:o.Mixin.Events,options:{opacity:1},initialize:function(t,e,i){this._url=t,this._bounds=o.latLngBounds(e),o.setOptions(this,i)},onAdd:function(t){this._map=t,this._image||this._initImage(),t._panes.overlayPane.appendChild(this._image),t.on("viewreset",this._reset,this),t.options.zoomAnimation&&o.Browser.any3d&&t.on("zoomanim",this._animateZoom,this),this._reset()},onRemove:function(t){t.getPanes().overlayPane.removeChild(this._image),t.off("viewreset",this._reset,this),t.options.zoomAnimation&&t.off("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},setOpacity:function(t){return this.options.opacity=t,this._updateOpacity(),this},bringToFront:function(){return this._image&&this._map._panes.overlayPane.appendChild(this._image),this},bringToBack:function(){var t=this._map._panes.overlayPane;return this._image&&t.insertBefore(this._image,t.firstChild),this},setUrl:function(t){this._url=t,this._image.src=this._url},getAttribution:function(){return this.options.attribution},_initImage:function(){this._image=o.DomUtil.create("img","leaflet-image-layer"),this._map.options.zoomAnimation&&o.Browser.any3d?o.DomUtil.addClass(this._image,"leaflet-zoom-animated"):o.DomUtil.addClass(this._image,"leaflet-zoom-hide"),this._updateOpacity(),o.extend(this._image,{galleryimg:"no",onselectstart:o.Util.falseFn,onmousemove:o.Util.falseFn,onload:o.bind(this._onImageLoad,this),src:this._url})},_animateZoom:function(t){var e=this._map,i=this._image,n=e.getZoomScale(t.zoom),s=this._bounds.getNorthWest(),a=this._bounds.getSouthEast(),r=e._latLngToNewLayerPoint(s,t.zoom,t.center),h=e._latLngToNewLayerPoint(a,t.zoom,t.center)._subtract(r),l=r._add(h._multiplyBy(.5*(1-1/n)));i.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(l)+" scale("+n+") "},_reset:function(){var t=this._image,e=this._map.latLngToLayerPoint(this._bounds.getNorthWest()),i=this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(e);o.DomUtil.setPosition(t,e),t.style.width=i.x+"px",t.style.height=i.y+"px"},_onImageLoad:function(){this.fire("load")},_updateOpacity:function(){o.DomUtil.setOpacity(this._image,this.options.opacity)}}),o.imageOverlay=function(t,e,i){return new o.ImageOverlay(t,e,i)},o.Icon=o.Class.extend({options:{className:""},initialize:function(t){o.setOptions(this,t)},createIcon:function(t){return this._createIcon("icon",t)},createShadow:function(t){return this._createIcon("shadow",t)},_createIcon:function(t,e){var i=this._getIconUrl(t);if(!i){if("icon"===t)throw new Error("iconUrl not set in Icon options (see the docs).");return null}var n;return n=e&&"IMG"===e.tagName?this._createImg(i,e):this._createImg(i),this._setIconStyles(n,t),n},_setIconStyles:function(t,e){var i,n=this.options,s=o.point(n[e+"Size"]);i=o.point("shadow"===e?n.shadowAnchor||n.iconAnchor:n.iconAnchor),!i&&s&&(i=s.divideBy(2,!0)),t.className="leaflet-marker-"+e+" "+n.className,i&&(t.style.marginLeft=-i.x+"px",t.style.marginTop=-i.y+"px"),s&&(t.style.width=s.x+"px",t.style.height=s.y+"px")},_createImg:function(t,i){return i=i||e.createElement("img"),i.src=t,i},_getIconUrl:function(t){return o.Browser.retina&&this.options[t+"RetinaUrl"]?this.options[t+"RetinaUrl"]:this.options[t+"Url"]}}),o.icon=function(t){return new o.Icon(t)},o.Icon.Default=o.Icon.extend({options:{iconSize:[25,41],iconAnchor:[12,41],popupAnchor:[1,-34],shadowSize:[41,41]},_getIconUrl:function(t){var e=t+"Url";if(this.options[e])return this.options[e];o.Browser.retina&&"icon"===t&&(t+="-2x");var i=o.Icon.Default.imagePath;if(!i)throw new Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");return i+"/marker-"+t+".png"}}),o.Icon.Default.imagePath=function(){var t,i,n,o,s,a=e.getElementsByTagName("script"),r=/[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;for(t=0,i=a.length;i>t;t++)if(n=a[t].src,o=n.match(r))return s=n.split(r)[0],(s?s+"/":"")+"images"}(),o.Marker=o.Class.extend({includes:o.Mixin.Events,options:{icon:new o.Icon.Default,title:"",alt:"",clickable:!0,draggable:!1,keyboard:!0,zIndexOffset:0,opacity:1,riseOnHover:!1,riseOffset:250},initialize:function(t,e){o.setOptions(this,e),this._latlng=o.latLng(t)},onAdd:function(t){this._map=t,t.on("viewreset",this.update,this),this._initIcon(),this.update(),this.fire("add"),t.options.zoomAnimation&&t.options.markerZoomAnimation&&t.on("zoomanim",this._animateZoom,this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){this.dragging&&this.dragging.disable(),this._removeIcon(),this._removeShadow(),this.fire("remove"),t.off({viewreset:this.update,zoomanim:this._animateZoom},this),this._map=null},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this.update(),this.fire("move",{latlng:this._latlng})},setZIndexOffset:function(t){return this.options.zIndexOffset=t,this.update(),this},setIcon:function(t){return this.options.icon=t,this._map&&(this._initIcon(),this.update()),this._popup&&this.bindPopup(this._popup),this},update:function(){if(this._icon){var t=this._map.latLngToLayerPoint(this._latlng).round();this._setPos(t)}return this},_initIcon:function(){var t=this.options,e=this._map,i=e.options.zoomAnimation&&e.options.markerZoomAnimation,n=i?"leaflet-zoom-animated":"leaflet-zoom-hide",s=t.icon.createIcon(this._icon),a=!1;s!==this._icon&&(this._icon&&this._removeIcon(),a=!0,t.title&&(s.title=t.title),t.alt&&(s.alt=t.alt)),o.DomUtil.addClass(s,n),t.keyboard&&(s.tabIndex="0"),this._icon=s,this._initInteraction(),t.riseOnHover&&o.DomEvent.on(s,"mouseover",this._bringToFront,this).on(s,"mouseout",this._resetZIndex,this);var r=t.icon.createShadow(this._shadow),h=!1;r!==this._shadow&&(this._removeShadow(),h=!0),r&&o.DomUtil.addClass(r,n),this._shadow=r,t.opacity<1&&this._updateOpacity();var l=this._map._panes;a&&l.markerPane.appendChild(this._icon),r&&h&&l.shadowPane.appendChild(this._shadow)},_removeIcon:function(){this.options.riseOnHover&&o.DomEvent.off(this._icon,"mouseover",this._bringToFront).off(this._icon,"mouseout",this._resetZIndex),this._map._panes.markerPane.removeChild(this._icon),this._icon=null},_removeShadow:function(){this._shadow&&this._map._panes.shadowPane.removeChild(this._shadow),this._shadow=null},_setPos:function(t){o.DomUtil.setPosition(this._icon,t),this._shadow&&o.DomUtil.setPosition(this._shadow,t),this._zIndex=t.y+this.options.zIndexOffset,this._resetZIndex()},_updateZIndex:function(t){this._icon.style.zIndex=this._zIndex+t},_animateZoom:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center).round();this._setPos(e)},_initInteraction:function(){if(this.options.clickable){var t=this._icon,e=["dblclick","mousedown","mouseover","mouseout","contextmenu"];o.DomUtil.addClass(t,"leaflet-clickable"),o.DomEvent.on(t,"click",this._onMouseClick,this),o.DomEvent.on(t,"keypress",this._onKeyPress,this);for(var i=0;i<e.length;i++)o.DomEvent.on(t,e[i],this._fireMouseEvent,this);o.Handler.MarkerDrag&&(this.dragging=new o.Handler.MarkerDrag(this),this.options.draggable&&this.dragging.enable())}},_onMouseClick:function(t){var e=this.dragging&&this.dragging.moved();(this.hasEventListeners(t.type)||e)&&o.DomEvent.stopPropagation(t),e||(this.dragging&&this.dragging._enabled||!this._map.dragging||!this._map.dragging.moved())&&this.fire(t.type,{originalEvent:t,latlng:this._latlng})},_onKeyPress:function(t){13===t.keyCode&&this.fire("click",{originalEvent:t,latlng:this._latlng})},_fireMouseEvent:function(t){this.fire(t.type,{originalEvent:t,latlng:this._latlng}),"contextmenu"===t.type&&this.hasEventListeners(t.type)&&o.DomEvent.preventDefault(t),"mousedown"!==t.type?o.DomEvent.stopPropagation(t):o.DomEvent.preventDefault(t)},setOpacity:function(t){return this.options.opacity=t,this._map&&this._updateOpacity(),this},_updateOpacity:function(){o.DomUtil.setOpacity(this._icon,this.options.opacity),this._shadow&&o.DomUtil.setOpacity(this._shadow,this.options.opacity)},_bringToFront:function(){this._updateZIndex(this.options.riseOffset)},_resetZIndex:function(){this._updateZIndex(0)}}),o.marker=function(t,e){return new o.Marker(t,e)},o.DivIcon=o.Icon.extend({options:{iconSize:[12,12],className:"leaflet-div-icon",html:!1},createIcon:function(t){var i=t&&"DIV"===t.tagName?t:e.createElement("div"),n=this.options;return i.innerHTML=n.html!==!1?n.html:"",n.bgPos&&(i.style.backgroundPosition=-n.bgPos.x+"px "+-n.bgPos.y+"px"),this._setIconStyles(i,"icon"),i},createShadow:function(){return null}}),o.divIcon=function(t){return new o.DivIcon(t)},o.Map.mergeOptions({closePopupOnClick:!0}),o.Popup=o.Class.extend({includes:o.Mixin.Events,options:{minWidth:50,maxWidth:300,autoPan:!0,closeButton:!0,offset:[0,7],autoPanPadding:[5,5],keepInView:!1,className:"",zoomAnimation:!0},initialize:function(t,e){o.setOptions(this,t),this._source=e,this._animated=o.Browser.any3d&&this.options.zoomAnimation,this._isOpen=!1},onAdd:function(t){this._map=t,this._container||this._initLayout();var e=t.options.fadeAnimation;e&&o.DomUtil.setOpacity(this._container,0),t._panes.popupPane.appendChild(this._container),t.on(this._getEvents(),this),this.update(),e&&o.DomUtil.setOpacity(this._container,1),this.fire("open"),t.fire("popupopen",{popup:this}),this._source&&this._source.fire("popupopen",{popup:this})},addTo:function(t){return t.addLayer(this),this},openOn:function(t){return t.openPopup(this),this},onRemove:function(t){t._panes.popupPane.removeChild(this._container),o.Util.falseFn(this._container.offsetWidth),t.off(this._getEvents(),this),t.options.fadeAnimation&&o.DomUtil.setOpacity(this._container,0),this._map=null,this.fire("close"),t.fire("popupclose",{popup:this}),this._source&&this._source.fire("popupclose",{popup:this})},getLatLng:function(){return this._latlng},setLatLng:function(t){return this._latlng=o.latLng(t),this._map&&(this._updatePosition(),this._adjustPan()),this},getContent:function(){return this._content},setContent:function(t){return this._content=t,this.update(),this},update:function(){this._map&&(this._container.style.visibility="hidden",this._updateContent(),this._updateLayout(),this._updatePosition(),this._container.style.visibility="",this._adjustPan())},_getEvents:function(){var t={viewreset:this._updatePosition};return this._animated&&(t.zoomanim=this._zoomAnimation),("closeOnClick"in this.options?this.options.closeOnClick:this._map.options.closePopupOnClick)&&(t.preclick=this._close),this.options.keepInView&&(t.moveend=this._adjustPan),t},_close:function(){this._map&&this._map.closePopup(this)},_initLayout:function(){var t,e="leaflet-popup",i=e+" "+this.options.className+" leaflet-zoom-"+(this._animated?"animated":"hide"),n=this._container=o.DomUtil.create("div",i);this.options.closeButton&&(t=this._closeButton=o.DomUtil.create("a",e+"-close-button",n),t.href="#close",t.innerHTML="&#215;",o.DomEvent.disableClickPropagation(t),o.DomEvent.on(t,"click",this._onCloseButtonClick,this));var s=this._wrapper=o.DomUtil.create("div",e+"-content-wrapper",n);o.DomEvent.disableClickPropagation(s),this._contentNode=o.DomUtil.create("div",e+"-content",s),o.DomEvent.disableScrollPropagation(this._contentNode),o.DomEvent.on(s,"contextmenu",o.DomEvent.stopPropagation),this._tipContainer=o.DomUtil.create("div",e+"-tip-container",n),this._tip=o.DomUtil.create("div",e+"-tip",this._tipContainer)},_updateContent:function(){if(this._content){if("string"==typeof this._content)this._contentNode.innerHTML=this._content;else{for(;this._contentNode.hasChildNodes();)this._contentNode.removeChild(this._contentNode.firstChild);this._contentNode.appendChild(this._content)}this.fire("contentupdate")}},_updateLayout:function(){var t=this._contentNode,e=t.style;e.width="",e.whiteSpace="nowrap";var i=t.offsetWidth;i=Math.min(i,this.options.maxWidth),i=Math.max(i,this.options.minWidth),e.width=i+1+"px",e.whiteSpace="",e.height="";var n=t.offsetHeight,s=this.options.maxHeight,a="leaflet-popup-scrolled";s&&n>s?(e.height=s+"px",o.DomUtil.addClass(t,a)):o.DomUtil.removeClass(t,a),this._containerWidth=this._container.offsetWidth},_updatePosition:function(){if(this._map){var t=this._map.latLngToLayerPoint(this._latlng),e=this._animated,i=o.point(this.options.offset);e&&o.DomUtil.setPosition(this._container,t),this._containerBottom=-i.y-(e?0:t.y),this._containerLeft=-Math.round(this._containerWidth/2)+i.x+(e?0:t.x),this._container.style.bottom=this._containerBottom+"px",this._container.style.left=this._containerLeft+"px"}},_zoomAnimation:function(t){var e=this._map._latLngToNewLayerPoint(this._latlng,t.zoom,t.center);o.DomUtil.setPosition(this._container,e)},_adjustPan:function(){if(this.options.autoPan){var t=this._map,e=this._container.offsetHeight,i=this._containerWidth,n=new o.Point(this._containerLeft,-e-this._containerBottom);this._animated&&n._add(o.DomUtil.getPosition(this._container));var s=t.layerPointToContainerPoint(n),a=o.point(this.options.autoPanPadding),r=o.point(this.options.autoPanPaddingTopLeft||a),h=o.point(this.options.autoPanPaddingBottomRight||a),l=t.getSize(),u=0,c=0;s.x+i+h.x>l.x&&(u=s.x+i-l.x+h.x),s.x-u-r.x<0&&(u=s.x-r.x),s.y+e+h.y>l.y&&(c=s.y+e-l.y+h.y),s.y-c-r.y<0&&(c=s.y-r.y),(u||c)&&t.fire("autopanstart").panBy([u,c])}},_onCloseButtonClick:function(t){this._close(),o.DomEvent.stop(t)}}),o.popup=function(t,e){return new o.Popup(t,e)},o.Map.include({openPopup:function(t,e,i){if(this.closePopup(),!(t instanceof o.Popup)){var n=t;t=new o.Popup(i).setLatLng(e).setContent(n)}return t._isOpen=!0,this._popup=t,this.addLayer(t)},closePopup:function(t){return t&&t!==this._popup||(t=this._popup,this._popup=null),t&&(this.removeLayer(t),t._isOpen=!1),this}}),o.Marker.include({openPopup:function(){return this._popup&&this._map&&!this._map.hasLayer(this._popup)&&(this._popup.setLatLng(this._latlng),this._map.openPopup(this._popup)),this},closePopup:function(){return this._popup&&this._popup._close(),this},togglePopup:function(){return this._popup&&(this._popup._isOpen?this.closePopup():this.openPopup()),this},bindPopup:function(t,e){var i=o.point(this.options.icon.options.popupAnchor||[0,0]);return i=i.add(o.Popup.prototype.options.offset),e&&e.offset&&(i=i.add(e.offset)),e=o.extend({offset:i},e),this._popupHandlersAdded||(this.on("click",this.togglePopup,this).on("remove",this.closePopup,this).on("move",this._movePopup,this),this._popupHandlersAdded=!0),t instanceof o.Popup?(o.setOptions(t,e),this._popup=t):this._popup=new o.Popup(e,this).setContent(t),this},setPopupContent:function(t){return this._popup&&this._popup.setContent(t),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this.togglePopup,this).off("remove",this.closePopup,this).off("move",this._movePopup,this),this._popupHandlersAdded=!1),this},getPopup:function(){return this._popup},_movePopup:function(t){this._popup.setLatLng(t.latlng)}}),o.LayerGroup=o.Class.extend({initialize:function(t){this._layers={};var e,i;if(t)for(e=0,i=t.length;i>e;e++)this.addLayer(t[e])},addLayer:function(t){var e=this.getLayerId(t);return this._layers[e]=t,this._map&&this._map.addLayer(t),this},removeLayer:function(t){var e=t in this._layers?t:this.getLayerId(t);return this._map&&this._layers[e]&&this._map.removeLayer(this._layers[e]),delete this._layers[e],this},hasLayer:function(t){return t?t in this._layers||this.getLayerId(t)in this._layers:!1},clearLayers:function(){return this.eachLayer(this.removeLayer,this),this},invoke:function(t){var e,i,n=Array.prototype.slice.call(arguments,1);for(e in this._layers)i=this._layers[e],i[t]&&i[t].apply(i,n);return this},onAdd:function(t){this._map=t,this.eachLayer(t.addLayer,t)},onRemove:function(t){this.eachLayer(t.removeLayer,t),this._map=null},addTo:function(t){return t.addLayer(this),this},eachLayer:function(t,e){for(var i in this._layers)t.call(e,this._layers[i]);return this},getLayer:function(t){return this._layers[t]},getLayers:function(){var t=[];for(var e in this._layers)t.push(this._layers[e]);return t},setZIndex:function(t){return this.invoke("setZIndex",t)},getLayerId:function(t){return o.stamp(t)}}),o.layerGroup=function(t){return new o.LayerGroup(t)},o.FeatureGroup=o.LayerGroup.extend({includes:o.Mixin.Events,statics:{EVENTS:"click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"},addLayer:function(t){return this.hasLayer(t)?this:("on"in t&&t.on(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.addLayer.call(this,t),this._popupContent&&t.bindPopup&&t.bindPopup(this._popupContent,this._popupOptions),this.fire("layeradd",{layer:t}))},removeLayer:function(t){return this.hasLayer(t)?(t in this._layers&&(t=this._layers[t]),t.off(o.FeatureGroup.EVENTS,this._propagateEvent,this),o.LayerGroup.prototype.removeLayer.call(this,t),this._popupContent&&this.invoke("unbindPopup"),this.fire("layerremove",{layer:t})):this},bindPopup:function(t,e){return this._popupContent=t,this._popupOptions=e,this.invoke("bindPopup",t,e)},openPopup:function(t){for(var e in this._layers){this._layers[e].openPopup(t);break}return this},setStyle:function(t){return this.invoke("setStyle",t)},bringToFront:function(){return this.invoke("bringToFront")},bringToBack:function(){return this.invoke("bringToBack")},getBounds:function(){var t=new o.LatLngBounds;return this.eachLayer(function(e){t.extend(e instanceof o.Marker?e.getLatLng():e.getBounds())}),t},_propagateEvent:function(t){t=o.extend({layer:t.target,target:this},t),this.fire(t.type,t)}}),o.featureGroup=function(t){return new o.FeatureGroup(t)},o.Path=o.Class.extend({includes:[o.Mixin.Events],statics:{CLIP_PADDING:function(){var e=o.Browser.mobile?1280:2e3,i=(e/Math.max(t.outerWidth,t.outerHeight)-1)/2;return Math.max(0,Math.min(.5,i))}()},options:{stroke:!0,color:"#0033ff",dashArray:null,lineCap:null,lineJoin:null,weight:5,opacity:.5,fill:!1,fillColor:null,fillOpacity:.2,clickable:!0},initialize:function(t){o.setOptions(this,t)},onAdd:function(t){this._map=t,this._container||(this._initElements(),this._initEvents()),this.projectLatlngs(),this._updatePath(),this._container&&this._map._pathRoot.appendChild(this._container),this.fire("add"),t.on({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},addTo:function(t){return t.addLayer(this),this},onRemove:function(t){t._pathRoot.removeChild(this._container),this.fire("remove"),this._map=null,o.Browser.vml&&(this._container=null,this._stroke=null,this._fill=null),t.off({viewreset:this.projectLatlngs,moveend:this._updatePath},this)},projectLatlngs:function(){},setStyle:function(t){return o.setOptions(this,t),this._container&&this._updateStyle(),this},redraw:function(){return this._map&&(this.projectLatlngs(),this._updatePath()),this}}),o.Map.include({_updatePathViewport:function(){var t=o.Path.CLIP_PADDING,e=this.getSize(),i=o.DomUtil.getPosition(this._mapPane),n=i.multiplyBy(-1)._subtract(e.multiplyBy(t)._round()),s=n.add(e.multiplyBy(1+2*t)._round());this._pathViewport=new o.Bounds(n,s)}}),o.Path.SVG_NS="http://www.w3.org/2000/svg",o.Browser.svg=!(!e.createElementNS||!e.createElementNS(o.Path.SVG_NS,"svg").createSVGRect),o.Path=o.Path.extend({statics:{SVG:o.Browser.svg},bringToFront:function(){var t=this._map._pathRoot,e=this._container;return e&&t.lastChild!==e&&t.appendChild(e),this},bringToBack:function(){var t=this._map._pathRoot,e=this._container,i=t.firstChild;return e&&i!==e&&t.insertBefore(e,i),this},getPathString:function(){},_createElement:function(t){return e.createElementNS(o.Path.SVG_NS,t)},_initElements:function(){this._map._initPathRoot(),this._initPath(),this._initStyle()},_initPath:function(){this._container=this._createElement("g"),this._path=this._createElement("path"),this.options.className&&o.DomUtil.addClass(this._path,this.options.className),this._container.appendChild(this._path)},_initStyle:function(){this.options.stroke&&(this._path.setAttribute("stroke-linejoin","round"),this._path.setAttribute("stroke-linecap","round")),this.options.fill&&this._path.setAttribute("fill-rule","evenodd"),this.options.pointerEvents&&this._path.setAttribute("pointer-events",this.options.pointerEvents),this.options.clickable||this.options.pointerEvents||this._path.setAttribute("pointer-events","none"),this._updateStyle()},_updateStyle:function(){this.options.stroke?(this._path.setAttribute("stroke",this.options.color),this._path.setAttribute("stroke-opacity",this.options.opacity),this._path.setAttribute("stroke-width",this.options.weight),this.options.dashArray?this._path.setAttribute("stroke-dasharray",this.options.dashArray):this._path.removeAttribute("stroke-dasharray"),this.options.lineCap&&this._path.setAttribute("stroke-linecap",this.options.lineCap),this.options.lineJoin&&this._path.setAttribute("stroke-linejoin",this.options.lineJoin)):this._path.setAttribute("stroke","none"),this.options.fill?(this._path.setAttribute("fill",this.options.fillColor||this.options.color),this._path.setAttribute("fill-opacity",this.options.fillOpacity)):this._path.setAttribute("fill","none")},_updatePath:function(){var t=this.getPathString();t||(t="M0 0"),this._path.setAttribute("d",t)},_initEvents:function(){if(this.options.clickable){(o.Browser.svg||!o.Browser.vml)&&o.DomUtil.addClass(this._path,"leaflet-clickable"),o.DomEvent.on(this._container,"click",this._onMouseClick,this);for(var t=["dblclick","mousedown","mouseover","mouseout","mousemove","contextmenu"],e=0;e<t.length;e++)o.DomEvent.on(this._container,t[e],this._fireMouseEvent,this)}},_onMouseClick:function(t){this._map.dragging&&this._map.dragging.moved()||this._fireMouseEvent(t)},_fireMouseEvent:function(t){if(this.hasEventListeners(t.type)){var e=this._map,i=e.mouseEventToContainerPoint(t),n=e.containerPointToLayerPoint(i),s=e.layerPointToLatLng(n);this.fire(t.type,{latlng:s,layerPoint:n,containerPoint:i,originalEvent:t}),"contextmenu"===t.type&&o.DomEvent.preventDefault(t),"mousemove"!==t.type&&o.DomEvent.stopPropagation(t)}}}),o.Map.include({_initPathRoot:function(){this._pathRoot||(this._pathRoot=o.Path.prototype._createElement("svg"),this._panes.overlayPane.appendChild(this._pathRoot),this.options.zoomAnimation&&o.Browser.any3d?(o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-animated"),this.on({zoomanim:this._animatePathZoom,zoomend:this._endPathZoom})):o.DomUtil.addClass(this._pathRoot,"leaflet-zoom-hide"),this.on("moveend",this._updateSvgViewport),this._updateSvgViewport())
},_animatePathZoom:function(t){var e=this.getZoomScale(t.zoom),i=this._getCenterOffset(t.center)._multiplyBy(-e)._add(this._pathViewport.min);this._pathRoot.style[o.DomUtil.TRANSFORM]=o.DomUtil.getTranslateString(i)+" scale("+e+") ",this._pathZooming=!0},_endPathZoom:function(){this._pathZooming=!1},_updateSvgViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max,n=i.x-e.x,s=i.y-e.y,a=this._pathRoot,r=this._panes.overlayPane;o.Browser.mobileWebkit&&r.removeChild(a),o.DomUtil.setPosition(a,e),a.setAttribute("width",n),a.setAttribute("height",s),a.setAttribute("viewBox",[e.x,e.y,n,s].join(" ")),o.Browser.mobileWebkit&&r.appendChild(a)}}}),o.Path.include({bindPopup:function(t,e){return t instanceof o.Popup?this._popup=t:((!this._popup||e)&&(this._popup=new o.Popup(e,this)),this._popup.setContent(t)),this._popupHandlersAdded||(this.on("click",this._openPopup,this).on("remove",this.closePopup,this),this._popupHandlersAdded=!0),this},unbindPopup:function(){return this._popup&&(this._popup=null,this.off("click",this._openPopup).off("remove",this.closePopup),this._popupHandlersAdded=!1),this},openPopup:function(t){return this._popup&&(t=t||this._latlng||this._latlngs[Math.floor(this._latlngs.length/2)],this._openPopup({latlng:t})),this},closePopup:function(){return this._popup&&this._popup._close(),this},_openPopup:function(t){this._popup.setLatLng(t.latlng),this._map.openPopup(this._popup)}}),o.Browser.vml=!o.Browser.svg&&function(){try{var t=e.createElement("div");t.innerHTML='<v:shape adj="1"/>';var i=t.firstChild;return i.style.behavior="url(#default#VML)",i&&"object"==typeof i.adj}catch(n){return!1}}(),o.Path=o.Browser.svg||!o.Browser.vml?o.Path:o.Path.extend({statics:{VML:!0,CLIP_PADDING:.02},_createElement:function(){try{return e.namespaces.add("lvml","urn:schemas-microsoft-com:vml"),function(t){return e.createElement("<lvml:"+t+' class="lvml">')}}catch(t){return function(t){return e.createElement("<"+t+' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')}}}(),_initPath:function(){var t=this._container=this._createElement("shape");o.DomUtil.addClass(t,"leaflet-vml-shape"+(this.options.className?" "+this.options.className:"")),this.options.clickable&&o.DomUtil.addClass(t,"leaflet-clickable"),t.coordsize="1 1",this._path=this._createElement("path"),t.appendChild(this._path),this._map._pathRoot.appendChild(t)},_initStyle:function(){this._updateStyle()},_updateStyle:function(){var t=this._stroke,e=this._fill,i=this.options,n=this._container;n.stroked=i.stroke,n.filled=i.fill,i.stroke?(t||(t=this._stroke=this._createElement("stroke"),t.endcap="round",n.appendChild(t)),t.weight=i.weight+"px",t.color=i.color,t.opacity=i.opacity,t.dashStyle=i.dashArray?o.Util.isArray(i.dashArray)?i.dashArray.join(" "):i.dashArray.replace(/( *, *)/g," "):"",i.lineCap&&(t.endcap=i.lineCap.replace("butt","flat")),i.lineJoin&&(t.joinstyle=i.lineJoin)):t&&(n.removeChild(t),this._stroke=null),i.fill?(e||(e=this._fill=this._createElement("fill"),n.appendChild(e)),e.color=i.fillColor||i.color,e.opacity=i.fillOpacity):e&&(n.removeChild(e),this._fill=null)},_updatePath:function(){var t=this._container.style;t.display="none",this._path.v=this.getPathString()+" ",t.display=""}}),o.Map.include(o.Browser.svg||!o.Browser.vml?{}:{_initPathRoot:function(){if(!this._pathRoot){var t=this._pathRoot=e.createElement("div");t.className="leaflet-vml-container",this._panes.overlayPane.appendChild(t),this.on("moveend",this._updatePathViewport),this._updatePathViewport()}}}),o.Browser.canvas=function(){return!!e.createElement("canvas").getContext}(),o.Path=o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?o.Path:o.Path.extend({statics:{CANVAS:!0,SVG:!1},redraw:function(){return this._map&&(this.projectLatlngs(),this._requestUpdate()),this},setStyle:function(t){return o.setOptions(this,t),this._map&&(this._updateStyle(),this._requestUpdate()),this},onRemove:function(t){t.off("viewreset",this.projectLatlngs,this).off("moveend",this._updatePath,this),this.options.clickable&&(this._map.off("click",this._onClick,this),this._map.off("mousemove",this._onMouseMove,this)),this._requestUpdate(),this._map=null},_requestUpdate:function(){this._map&&!o.Path._updateRequest&&(o.Path._updateRequest=o.Util.requestAnimFrame(this._fireMapMoveEnd,this._map))},_fireMapMoveEnd:function(){o.Path._updateRequest=null,this.fire("moveend")},_initElements:function(){this._map._initPathRoot(),this._ctx=this._map._canvasCtx},_updateStyle:function(){var t=this.options;t.stroke&&(this._ctx.lineWidth=t.weight,this._ctx.strokeStyle=t.color),t.fill&&(this._ctx.fillStyle=t.fillColor||t.color)},_drawPath:function(){var t,e,i,n,s,a;for(this._ctx.beginPath(),t=0,i=this._parts.length;i>t;t++){for(e=0,n=this._parts[t].length;n>e;e++)s=this._parts[t][e],a=(0===e?"move":"line")+"To",this._ctx[a](s.x,s.y);this instanceof o.Polygon&&this._ctx.closePath()}},_checkIfEmpty:function(){return!this._parts.length},_updatePath:function(){if(!this._checkIfEmpty()){var t=this._ctx,e=this.options;this._drawPath(),t.save(),this._updateStyle(),e.fill&&(t.globalAlpha=e.fillOpacity,t.fill()),e.stroke&&(t.globalAlpha=e.opacity,t.stroke()),t.restore()}},_initEvents:function(){this.options.clickable&&(this._map.on("mousemove",this._onMouseMove,this),this._map.on("click",this._onClick,this))},_onClick:function(t){this._containsPoint(t.layerPoint)&&this.fire("click",t)},_onMouseMove:function(t){this._map&&!this._map._animatingZoom&&(this._containsPoint(t.layerPoint)?(this._ctx.canvas.style.cursor="pointer",this._mouseInside=!0,this.fire("mouseover",t)):this._mouseInside&&(this._ctx.canvas.style.cursor="",this._mouseInside=!1,this.fire("mouseout",t)))}}),o.Map.include(o.Path.SVG&&!t.L_PREFER_CANVAS||!o.Browser.canvas?{}:{_initPathRoot:function(){var t,i=this._pathRoot;i||(i=this._pathRoot=e.createElement("canvas"),i.style.position="absolute",t=this._canvasCtx=i.getContext("2d"),t.lineCap="round",t.lineJoin="round",this._panes.overlayPane.appendChild(i),this.options.zoomAnimation&&(this._pathRoot.className="leaflet-zoom-animated",this.on("zoomanim",this._animatePathZoom),this.on("zoomend",this._endPathZoom)),this.on("moveend",this._updateCanvasViewport),this._updateCanvasViewport())},_updateCanvasViewport:function(){if(!this._pathZooming){this._updatePathViewport();var t=this._pathViewport,e=t.min,i=t.max.subtract(e),n=this._pathRoot;o.DomUtil.setPosition(n,e),n.width=i.x,n.height=i.y,n.getContext("2d").translate(-e.x,-e.y)}}}),o.LineUtil={simplify:function(t,e){if(!e||!t.length)return t.slice();var i=e*e;return t=this._reducePoints(t,i),t=this._simplifyDP(t,i)},pointToSegmentDistance:function(t,e,i){return Math.sqrt(this._sqClosestPointOnSegment(t,e,i,!0))},closestPointOnSegment:function(t,e,i){return this._sqClosestPointOnSegment(t,e,i)},_simplifyDP:function(t,e){var n=t.length,o=typeof Uint8Array!=i+""?Uint8Array:Array,s=new o(n);s[0]=s[n-1]=1,this._simplifyDPStep(t,s,e,0,n-1);var a,r=[];for(a=0;n>a;a++)s[a]&&r.push(t[a]);return r},_simplifyDPStep:function(t,e,i,n,o){var s,a,r,h=0;for(a=n+1;o-1>=a;a++)r=this._sqClosestPointOnSegment(t[a],t[n],t[o],!0),r>h&&(s=a,h=r);h>i&&(e[s]=1,this._simplifyDPStep(t,e,i,n,s),this._simplifyDPStep(t,e,i,s,o))},_reducePoints:function(t,e){for(var i=[t[0]],n=1,o=0,s=t.length;s>n;n++)this._sqDist(t[n],t[o])>e&&(i.push(t[n]),o=n);return s-1>o&&i.push(t[s-1]),i},clipSegment:function(t,e,i,n){var o,s,a,r=n?this._lastCode:this._getBitCode(t,i),h=this._getBitCode(e,i);for(this._lastCode=h;;){if(!(r|h))return[t,e];if(r&h)return!1;o=r||h,s=this._getEdgeIntersection(t,e,o,i),a=this._getBitCode(s,i),o===r?(t=s,r=a):(e=s,h=a)}},_getEdgeIntersection:function(t,e,i,n){var s=e.x-t.x,a=e.y-t.y,r=n.min,h=n.max;return 8&i?new o.Point(t.x+s*(h.y-t.y)/a,h.y):4&i?new o.Point(t.x+s*(r.y-t.y)/a,r.y):2&i?new o.Point(h.x,t.y+a*(h.x-t.x)/s):1&i?new o.Point(r.x,t.y+a*(r.x-t.x)/s):void 0},_getBitCode:function(t,e){var i=0;return t.x<e.min.x?i|=1:t.x>e.max.x&&(i|=2),t.y<e.min.y?i|=4:t.y>e.max.y&&(i|=8),i},_sqDist:function(t,e){var i=e.x-t.x,n=e.y-t.y;return i*i+n*n},_sqClosestPointOnSegment:function(t,e,i,n){var s,a=e.x,r=e.y,h=i.x-a,l=i.y-r,u=h*h+l*l;return u>0&&(s=((t.x-a)*h+(t.y-r)*l)/u,s>1?(a=i.x,r=i.y):s>0&&(a+=h*s,r+=l*s)),h=t.x-a,l=t.y-r,n?h*h+l*l:new o.Point(a,r)}},o.Polyline=o.Path.extend({initialize:function(t,e){o.Path.prototype.initialize.call(this,e),this._latlngs=this._convertLatLngs(t)},options:{smoothFactor:1,noClip:!1},projectLatlngs:function(){this._originalPoints=[];for(var t=0,e=this._latlngs.length;e>t;t++)this._originalPoints[t]=this._map.latLngToLayerPoint(this._latlngs[t])},getPathString:function(){for(var t=0,e=this._parts.length,i="";e>t;t++)i+=this._getPathPartStr(this._parts[t]);return i},getLatLngs:function(){return this._latlngs},setLatLngs:function(t){return this._latlngs=this._convertLatLngs(t),this.redraw()},addLatLng:function(t){return this._latlngs.push(o.latLng(t)),this.redraw()},spliceLatLngs:function(){var t=[].splice.apply(this._latlngs,arguments);return this._convertLatLngs(this._latlngs,!0),this.redraw(),t},closestLayerPoint:function(t){for(var e,i,n=1/0,s=this._parts,a=null,r=0,h=s.length;h>r;r++)for(var l=s[r],u=1,c=l.length;c>u;u++){e=l[u-1],i=l[u];var d=o.LineUtil._sqClosestPointOnSegment(t,e,i,!0);n>d&&(n=d,a=o.LineUtil._sqClosestPointOnSegment(t,e,i))}return a&&(a.distance=Math.sqrt(n)),a},getBounds:function(){return new o.LatLngBounds(this.getLatLngs())},_convertLatLngs:function(t,e){var i,n,s=e?t:[];for(i=0,n=t.length;n>i;i++){if(o.Util.isArray(t[i])&&"number"!=typeof t[i][0])return;s[i]=o.latLng(t[i])}return s},_initEvents:function(){o.Path.prototype._initEvents.call(this)},_getPathPartStr:function(t){for(var e,i=o.Path.VML,n=0,s=t.length,a="";s>n;n++)e=t[n],i&&e._round(),a+=(n?"L":"M")+e.x+" "+e.y;return a},_clipPoints:function(){var t,e,i,n=this._originalPoints,s=n.length;if(this.options.noClip)return void(this._parts=[n]);this._parts=[];var a=this._parts,r=this._map._pathViewport,h=o.LineUtil;for(t=0,e=0;s-1>t;t++)i=h.clipSegment(n[t],n[t+1],r,t),i&&(a[e]=a[e]||[],a[e].push(i[0]),(i[1]!==n[t+1]||t===s-2)&&(a[e].push(i[1]),e++))},_simplifyPoints:function(){for(var t=this._parts,e=o.LineUtil,i=0,n=t.length;n>i;i++)t[i]=e.simplify(t[i],this.options.smoothFactor)},_updatePath:function(){this._map&&(this._clipPoints(),this._simplifyPoints(),o.Path.prototype._updatePath.call(this))}}),o.polyline=function(t,e){return new o.Polyline(t,e)},o.PolyUtil={},o.PolyUtil.clipPolygon=function(t,e){var i,n,s,a,r,h,l,u,c,d=[1,4,2,8],p=o.LineUtil;for(n=0,l=t.length;l>n;n++)t[n]._code=p._getBitCode(t[n],e);for(a=0;4>a;a++){for(u=d[a],i=[],n=0,l=t.length,s=l-1;l>n;s=n++)r=t[n],h=t[s],r._code&u?h._code&u||(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)):(h._code&u&&(c=p._getEdgeIntersection(h,r,u,e),c._code=p._getBitCode(c,e),i.push(c)),i.push(r));t=i}return t},o.Polygon=o.Polyline.extend({options:{fill:!0},initialize:function(t,e){o.Polyline.prototype.initialize.call(this,t,e),this._initWithHoles(t)},_initWithHoles:function(t){var e,i,n;if(t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0])for(this._latlngs=this._convertLatLngs(t[0]),this._holes=t.slice(1),e=0,i=this._holes.length;i>e;e++)n=this._holes[e]=this._convertLatLngs(this._holes[e]),n[0].equals(n[n.length-1])&&n.pop();t=this._latlngs,t.length>=2&&t[0].equals(t[t.length-1])&&t.pop()},projectLatlngs:function(){if(o.Polyline.prototype.projectLatlngs.call(this),this._holePoints=[],this._holes){var t,e,i,n;for(t=0,i=this._holes.length;i>t;t++)for(this._holePoints[t]=[],e=0,n=this._holes[t].length;n>e;e++)this._holePoints[t][e]=this._map.latLngToLayerPoint(this._holes[t][e])}},setLatLngs:function(t){return t&&o.Util.isArray(t[0])&&"number"!=typeof t[0][0]?(this._initWithHoles(t),this.redraw()):o.Polyline.prototype.setLatLngs.call(this,t)},_clipPoints:function(){var t=this._originalPoints,e=[];if(this._parts=[t].concat(this._holePoints),!this.options.noClip){for(var i=0,n=this._parts.length;n>i;i++){var s=o.PolyUtil.clipPolygon(this._parts[i],this._map._pathViewport);s.length&&e.push(s)}this._parts=e}},_getPathPartStr:function(t){var e=o.Polyline.prototype._getPathPartStr.call(this,t);return e+(o.Browser.svg?"z":"x")}}),o.polygon=function(t,e){return new o.Polygon(t,e)},function(){function t(t){return o.FeatureGroup.extend({initialize:function(t,e){this._layers={},this._options=e,this.setLatLngs(t)},setLatLngs:function(e){var i=0,n=e.length;for(this.eachLayer(function(t){n>i?t.setLatLngs(e[i++]):this.removeLayer(t)},this);n>i;)this.addLayer(new t(e[i++],this._options));return this},getLatLngs:function(){var t=[];return this.eachLayer(function(e){t.push(e.getLatLngs())}),t}})}o.MultiPolyline=t(o.Polyline),o.MultiPolygon=t(o.Polygon),o.multiPolyline=function(t,e){return new o.MultiPolyline(t,e)},o.multiPolygon=function(t,e){return new o.MultiPolygon(t,e)}}(),o.Rectangle=o.Polygon.extend({initialize:function(t,e){o.Polygon.prototype.initialize.call(this,this._boundsToLatLngs(t),e)},setBounds:function(t){this.setLatLngs(this._boundsToLatLngs(t))},_boundsToLatLngs:function(t){return t=o.latLngBounds(t),[t.getSouthWest(),t.getNorthWest(),t.getNorthEast(),t.getSouthEast()]}}),o.rectangle=function(t,e){return new o.Rectangle(t,e)},o.Circle=o.Path.extend({initialize:function(t,e,i){o.Path.prototype.initialize.call(this,i),this._latlng=o.latLng(t),this._mRadius=e},options:{fill:!0},setLatLng:function(t){return this._latlng=o.latLng(t),this.redraw()},setRadius:function(t){return this._mRadius=t,this.redraw()},projectLatlngs:function(){var t=this._getLngRadius(),e=this._latlng,i=this._map.latLngToLayerPoint([e.lat,e.lng-t]);this._point=this._map.latLngToLayerPoint(e),this._radius=Math.max(this._point.x-i.x,1)},getBounds:function(){var t=this._getLngRadius(),e=this._mRadius/40075017*360,i=this._latlng;return new o.LatLngBounds([i.lat-e,i.lng-t],[i.lat+e,i.lng+t])},getLatLng:function(){return this._latlng},getPathString:function(){var t=this._point,e=this._radius;return this._checkIfEmpty()?"":o.Browser.svg?"M"+t.x+","+(t.y-e)+"A"+e+","+e+",0,1,1,"+(t.x-.1)+","+(t.y-e)+" z":(t._round(),e=Math.round(e),"AL "+t.x+","+t.y+" "+e+","+e+" 0,23592600")},getRadius:function(){return this._mRadius},_getLatRadius:function(){return this._mRadius/40075017*360},_getLngRadius:function(){return this._getLatRadius()/Math.cos(o.LatLng.DEG_TO_RAD*this._latlng.lat)},_checkIfEmpty:function(){if(!this._map)return!1;var t=this._map._pathViewport,e=this._radius,i=this._point;return i.x-e>t.max.x||i.y-e>t.max.y||i.x+e<t.min.x||i.y+e<t.min.y}}),o.circle=function(t,e,i){return new o.Circle(t,e,i)},o.CircleMarker=o.Circle.extend({options:{radius:10,weight:2},initialize:function(t,e){o.Circle.prototype.initialize.call(this,t,null,e),this._radius=this.options.radius},projectLatlngs:function(){this._point=this._map.latLngToLayerPoint(this._latlng)},_updateStyle:function(){o.Circle.prototype._updateStyle.call(this),this.setRadius(this.options.radius)},setLatLng:function(t){return o.Circle.prototype.setLatLng.call(this,t),this._popup&&this._popup._isOpen&&this._popup.setLatLng(t),this},setRadius:function(t){return this.options.radius=this._radius=t,this.redraw()},getRadius:function(){return this._radius}}),o.circleMarker=function(t,e){return new o.CircleMarker(t,e)},o.Polyline.include(o.Path.CANVAS?{_containsPoint:function(t,e){var i,n,s,a,r,h,l,u=this.options.weight/2;for(o.Browser.touch&&(u+=10),i=0,a=this._parts.length;a>i;i++)for(l=this._parts[i],n=0,r=l.length,s=r-1;r>n;s=n++)if((e||0!==n)&&(h=o.LineUtil.pointToSegmentDistance(t,l[s],l[n]),u>=h))return!0;return!1}}:{}),o.Polygon.include(o.Path.CANVAS?{_containsPoint:function(t){var e,i,n,s,a,r,h,l,u=!1;if(o.Polyline.prototype._containsPoint.call(this,t,!0))return!0;for(s=0,h=this._parts.length;h>s;s++)for(e=this._parts[s],a=0,l=e.length,r=l-1;l>a;r=a++)i=e[a],n=e[r],i.y>t.y!=n.y>t.y&&t.x<(n.x-i.x)*(t.y-i.y)/(n.y-i.y)+i.x&&(u=!u);return u}}:{}),o.Circle.include(o.Path.CANVAS?{_drawPath:function(){var t=this._point;this._ctx.beginPath(),this._ctx.arc(t.x,t.y,this._radius,0,2*Math.PI,!1)},_containsPoint:function(t){var e=this._point,i=this.options.stroke?this.options.weight/2:0;return t.distanceTo(e)<=this._radius+i}}:{}),o.CircleMarker.include(o.Path.CANVAS?{_updateStyle:function(){o.Path.prototype._updateStyle.call(this)}}:{}),o.GeoJSON=o.FeatureGroup.extend({initialize:function(t,e){o.setOptions(this,e),this._layers={},t&&this.addData(t)},addData:function(t){var e,i,n,s=o.Util.isArray(t)?t:t.features;if(s){for(e=0,i=s.length;i>e;e++)n=s[e],(n.geometries||n.geometry||n.features||n.coordinates)&&this.addData(s[e]);return this}var a=this.options;if(!a.filter||a.filter(t)){var r=o.GeoJSON.geometryToLayer(t,a.pointToLayer,a.coordsToLatLng,a);return r.feature=o.GeoJSON.asFeature(t),r.defaultOptions=r.options,this.resetStyle(r),a.onEachFeature&&a.onEachFeature(t,r),this.addLayer(r)}},resetStyle:function(t){var e=this.options.style;e&&(o.Util.extend(t.options,t.defaultOptions),this._setLayerStyle(t,e))},setStyle:function(t){this.eachLayer(function(e){this._setLayerStyle(e,t)},this)},_setLayerStyle:function(t,e){"function"==typeof e&&(e=e(t.feature)),t.setStyle&&t.setStyle(e)}}),o.extend(o.GeoJSON,{geometryToLayer:function(t,e,i,n){var s,a,r,h,l="Feature"===t.type?t.geometry:t,u=l.coordinates,c=[];switch(i=i||this.coordsToLatLng,l.type){case"Point":return s=i(u),e?e(t,s):new o.Marker(s);case"MultiPoint":for(r=0,h=u.length;h>r;r++)s=i(u[r]),c.push(e?e(t,s):new o.Marker(s));return new o.FeatureGroup(c);case"LineString":return a=this.coordsToLatLngs(u,0,i),new o.Polyline(a,n);case"Polygon":if(2===u.length&&!u[1].length)throw new Error("Invalid GeoJSON object.");return a=this.coordsToLatLngs(u,1,i),new o.Polygon(a,n);case"MultiLineString":return a=this.coordsToLatLngs(u,1,i),new o.MultiPolyline(a,n);case"MultiPolygon":return a=this.coordsToLatLngs(u,2,i),new o.MultiPolygon(a,n);case"GeometryCollection":for(r=0,h=l.geometries.length;h>r;r++)c.push(this.geometryToLayer({geometry:l.geometries[r],type:"Feature",properties:t.properties},e,i,n));return new o.FeatureGroup(c);default:throw new Error("Invalid GeoJSON object.")}},coordsToLatLng:function(t){return new o.LatLng(t[1],t[0],t[2])},coordsToLatLngs:function(t,e,i){var n,o,s,a=[];for(o=0,s=t.length;s>o;o++)n=e?this.coordsToLatLngs(t[o],e-1,i):(i||this.coordsToLatLng)(t[o]),a.push(n);return a},latLngToCoords:function(t){var e=[t.lng,t.lat];return t.alt!==i&&e.push(t.alt),e},latLngsToCoords:function(t){for(var e=[],i=0,n=t.length;n>i;i++)e.push(o.GeoJSON.latLngToCoords(t[i]));return e},getFeature:function(t,e){return t.feature?o.extend({},t.feature,{geometry:e}):o.GeoJSON.asFeature(e)},asFeature:function(t){return"Feature"===t.type?t:{type:"Feature",properties:{},geometry:t}}});var a={toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"Point",coordinates:o.GeoJSON.latLngToCoords(this.getLatLng())})}};o.Marker.include(a),o.Circle.include(a),o.CircleMarker.include(a),o.Polyline.include({toGeoJSON:function(){return o.GeoJSON.getFeature(this,{type:"LineString",coordinates:o.GeoJSON.latLngsToCoords(this.getLatLngs())})}}),o.Polygon.include({toGeoJSON:function(){var t,e,i,n=[o.GeoJSON.latLngsToCoords(this.getLatLngs())];if(n[0].push(n[0][0]),this._holes)for(t=0,e=this._holes.length;e>t;t++)i=o.GeoJSON.latLngsToCoords(this._holes[t]),i.push(i[0]),n.push(i);return o.GeoJSON.getFeature(this,{type:"Polygon",coordinates:n})}}),function(){function t(t){return function(){var e=[];return this.eachLayer(function(t){e.push(t.toGeoJSON().geometry.coordinates)}),o.GeoJSON.getFeature(this,{type:t,coordinates:e})}}o.MultiPolyline.include({toGeoJSON:t("MultiLineString")}),o.MultiPolygon.include({toGeoJSON:t("MultiPolygon")}),o.LayerGroup.include({toGeoJSON:function(){var e,i=this.feature&&this.feature.geometry,n=[];if(i&&"MultiPoint"===i.type)return t("MultiPoint").call(this);var s=i&&"GeometryCollection"===i.type;return this.eachLayer(function(t){t.toGeoJSON&&(e=t.toGeoJSON(),n.push(s?e.geometry:o.GeoJSON.asFeature(e)))}),s?o.GeoJSON.getFeature(this,{geometries:n,type:"GeometryCollection"}):{type:"FeatureCollection",features:n}}})}(),o.geoJson=function(t,e){return new o.GeoJSON(t,e)},o.DomEvent={addListener:function(t,e,i,n){var s,a,r,h=o.stamp(i),l="_leaflet_"+e+h;return t[l]?this:(s=function(e){return i.call(n||t,e||o.DomEvent._getEvent())},o.Browser.pointer&&0===e.indexOf("touch")?this.addPointerListener(t,e,s,h):(o.Browser.touch&&"dblclick"===e&&this.addDoubleTapListener&&this.addDoubleTapListener(t,s,h),"addEventListener"in t?"mousewheel"===e?(t.addEventListener("DOMMouseScroll",s,!1),t.addEventListener(e,s,!1)):"mouseenter"===e||"mouseleave"===e?(a=s,r="mouseenter"===e?"mouseover":"mouseout",s=function(e){return o.DomEvent._checkMouse(t,e)?a(e):void 0},t.addEventListener(r,s,!1)):"click"===e&&o.Browser.android?(a=s,s=function(t){return o.DomEvent._filterClick(t,a)},t.addEventListener(e,s,!1)):t.addEventListener(e,s,!1):"attachEvent"in t&&t.attachEvent("on"+e,s),t[l]=s,this))},removeListener:function(t,e,i){var n=o.stamp(i),s="_leaflet_"+e+n,a=t[s];return a?(o.Browser.pointer&&0===e.indexOf("touch")?this.removePointerListener(t,e,n):o.Browser.touch&&"dblclick"===e&&this.removeDoubleTapListener?this.removeDoubleTapListener(t,n):"removeEventListener"in t?"mousewheel"===e?(t.removeEventListener("DOMMouseScroll",a,!1),t.removeEventListener(e,a,!1)):"mouseenter"===e||"mouseleave"===e?t.removeEventListener("mouseenter"===e?"mouseover":"mouseout",a,!1):t.removeEventListener(e,a,!1):"detachEvent"in t&&t.detachEvent("on"+e,a),t[s]=null,this):this},stopPropagation:function(t){return t.stopPropagation?t.stopPropagation():t.cancelBubble=!0,o.DomEvent._skipped(t),this},disableScrollPropagation:function(t){var e=o.DomEvent.stopPropagation;return o.DomEvent.on(t,"mousewheel",e).on(t,"MozMousePixelScroll",e)},disableClickPropagation:function(t){for(var e=o.DomEvent.stopPropagation,i=o.Draggable.START.length-1;i>=0;i--)o.DomEvent.on(t,o.Draggable.START[i],e);return o.DomEvent.on(t,"click",o.DomEvent._fakeStop).on(t,"dblclick",e)},preventDefault:function(t){return t.preventDefault?t.preventDefault():t.returnValue=!1,this},stop:function(t){return o.DomEvent.preventDefault(t).stopPropagation(t)},getMousePosition:function(t,e){if(!e)return new o.Point(t.clientX,t.clientY);var i=e.getBoundingClientRect();return new o.Point(t.clientX-i.left-e.clientLeft,t.clientY-i.top-e.clientTop)},getWheelDelta:function(t){var e=0;return t.wheelDelta&&(e=t.wheelDelta/120),t.detail&&(e=-t.detail/3),e},_skipEvents:{},_fakeStop:function(t){o.DomEvent._skipEvents[t.type]=!0},_skipped:function(t){var e=this._skipEvents[t.type];return this._skipEvents[t.type]=!1,e},_checkMouse:function(t,e){var i=e.relatedTarget;if(!i)return!0;try{for(;i&&i!==t;)i=i.parentNode}catch(n){return!1}return i!==t},_getEvent:function(){var e=t.event;if(!e)for(var i=arguments.callee.caller;i&&(e=i.arguments[0],!e||t.Event!==e.constructor);)i=i.caller;return e},_filterClick:function(t,e){var i=t.timeStamp||t.originalEvent.timeStamp,n=o.DomEvent._lastClick&&i-o.DomEvent._lastClick;return n&&n>100&&1e3>n||t.target._simulatedClick&&!t._simulated?void o.DomEvent.stop(t):(o.DomEvent._lastClick=i,e(t))}},o.DomEvent.on=o.DomEvent.addListener,o.DomEvent.off=o.DomEvent.removeListener,o.Draggable=o.Class.extend({includes:o.Mixin.Events,statics:{START:o.Browser.touch?["touchstart","mousedown"]:["mousedown"],END:{mousedown:"mouseup",touchstart:"touchend",pointerdown:"touchend",MSPointerDown:"touchend"},MOVE:{mousedown:"mousemove",touchstart:"touchmove",pointerdown:"touchmove",MSPointerDown:"touchmove"}},initialize:function(t,e){this._element=t,this._dragStartTarget=e||t},enable:function(){if(!this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.on(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!0}},disable:function(){if(this._enabled){for(var t=o.Draggable.START.length-1;t>=0;t--)o.DomEvent.off(this._dragStartTarget,o.Draggable.START[t],this._onDown,this);this._enabled=!1,this._moved=!1}},_onDown:function(t){if(this._moved=!1,!(t.shiftKey||1!==t.which&&1!==t.button&&!t.touches||(o.DomEvent.stopPropagation(t),o.Draggable._disabled||(o.DomUtil.disableImageDrag(),o.DomUtil.disableTextSelection(),this._moving)))){var i=t.touches?t.touches[0]:t;this._startPoint=new o.Point(i.clientX,i.clientY),this._startPos=this._newPos=o.DomUtil.getPosition(this._element),o.DomEvent.on(e,o.Draggable.MOVE[t.type],this._onMove,this).on(e,o.Draggable.END[t.type],this._onUp,this)}},_onMove:function(t){if(t.touches&&t.touches.length>1)return void(this._moved=!0);var i=t.touches&&1===t.touches.length?t.touches[0]:t,n=new o.Point(i.clientX,i.clientY),s=n.subtract(this._startPoint);(s.x||s.y)&&(o.DomEvent.preventDefault(t),this._moved||(this.fire("dragstart"),this._moved=!0,this._startPos=o.DomUtil.getPosition(this._element).subtract(s),o.DomUtil.addClass(e.body,"leaflet-dragging"),o.DomUtil.addClass(t.target||t.srcElement,"leaflet-drag-target")),this._newPos=this._startPos.add(s),this._moving=!0,o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updatePosition,this,!0,this._dragStartTarget))},_updatePosition:function(){this.fire("predrag"),o.DomUtil.setPosition(this._element,this._newPos),this.fire("drag")},_onUp:function(t){o.DomUtil.removeClass(e.body,"leaflet-dragging"),o.DomUtil.removeClass(t.target||t.srcElement,"leaflet-drag-target");for(var i in o.Draggable.MOVE)o.DomEvent.off(e,o.Draggable.MOVE[i],this._onMove).off(e,o.Draggable.END[i],this._onUp);o.DomUtil.enableImageDrag(),o.DomUtil.enableTextSelection(),this._moved&&this._moving&&(o.Util.cancelAnimFrame(this._animRequest),this.fire("dragend",{distance:this._newPos.distanceTo(this._startPos)})),this._moving=!1}}),o.Handler=o.Class.extend({initialize:function(t){this._map=t},enable:function(){this._enabled||(this._enabled=!0,this.addHooks())},disable:function(){this._enabled&&(this._enabled=!1,this.removeHooks())},enabled:function(){return!!this._enabled}}),o.Map.mergeOptions({dragging:!0,inertia:!o.Browser.android23,inertiaDeceleration:3400,inertiaMaxSpeed:1/0,inertiaThreshold:o.Browser.touch?32:18,easeLinearity:.25,worldCopyJump:!1}),o.Map.Drag=o.Handler.extend({addHooks:function(){if(!this._draggable){var t=this._map;this._draggable=new o.Draggable(t._mapPane,t._container),this._draggable.on({dragstart:this._onDragStart,drag:this._onDrag,dragend:this._onDragEnd},this),t.options.worldCopyJump&&(this._draggable.on("predrag",this._onPreDrag,this),t.on("viewreset",this._onViewReset,this),t.whenReady(this._onViewReset,this))}this._draggable.enable()},removeHooks:function(){this._draggable.disable()},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){var t=this._map;t._panAnim&&t._panAnim.stop(),t.fire("movestart").fire("dragstart"),t.options.inertia&&(this._positions=[],this._times=[])},_onDrag:function(){if(this._map.options.inertia){var t=this._lastTime=+new Date,e=this._lastPos=this._draggable._newPos;this._positions.push(e),this._times.push(t),t-this._times[0]>200&&(this._positions.shift(),this._times.shift())}this._map.fire("move").fire("drag")},_onViewReset:function(){var t=this._map.getSize()._divideBy(2),e=this._map.latLngToLayerPoint([0,0]);this._initialWorldOffset=e.subtract(t).x,this._worldWidth=this._map.project([0,180]).x},_onPreDrag:function(){var t=this._worldWidth,e=Math.round(t/2),i=this._initialWorldOffset,n=this._draggable._newPos.x,o=(n-e+i)%t+e-i,s=(n+e+i)%t-e-i,a=Math.abs(o+i)<Math.abs(s+i)?o:s;this._draggable._newPos.x=a},_onDragEnd:function(t){var e=this._map,i=e.options,n=+new Date-this._lastTime,s=!i.inertia||n>i.inertiaThreshold||!this._positions[0];if(e.fire("dragend",t),s)e.fire("moveend");else{var a=this._lastPos.subtract(this._positions[0]),r=(this._lastTime+n-this._times[0])/1e3,h=i.easeLinearity,l=a.multiplyBy(h/r),u=l.distanceTo([0,0]),c=Math.min(i.inertiaMaxSpeed,u),d=l.multiplyBy(c/u),p=c/(i.inertiaDeceleration*h),_=d.multiplyBy(-p/2).round();_.x&&_.y?(_=e._limitOffset(_,e.options.maxBounds),o.Util.requestAnimFrame(function(){e.panBy(_,{duration:p,easeLinearity:h,noMoveStart:!0})})):e.fire("moveend")}}}),o.Map.addInitHook("addHandler","dragging",o.Map.Drag),o.Map.mergeOptions({doubleClickZoom:!0}),o.Map.DoubleClickZoom=o.Handler.extend({addHooks:function(){this._map.on("dblclick",this._onDoubleClick,this)},removeHooks:function(){this._map.off("dblclick",this._onDoubleClick,this)},_onDoubleClick:function(t){var e=this._map,i=e.getZoom()+(t.originalEvent.shiftKey?-1:1);"center"===e.options.doubleClickZoom?e.setZoom(i):e.setZoomAround(t.containerPoint,i)}}),o.Map.addInitHook("addHandler","doubleClickZoom",o.Map.DoubleClickZoom),o.Map.mergeOptions({scrollWheelZoom:!0}),o.Map.ScrollWheelZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"mousewheel",this._onWheelScroll,this),o.DomEvent.on(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault),this._delta=0},removeHooks:function(){o.DomEvent.off(this._map._container,"mousewheel",this._onWheelScroll),o.DomEvent.off(this._map._container,"MozMousePixelScroll",o.DomEvent.preventDefault)},_onWheelScroll:function(t){var e=o.DomEvent.getWheelDelta(t);this._delta+=e,this._lastMousePos=this._map.mouseEventToContainerPoint(t),this._startTime||(this._startTime=+new Date);var i=Math.max(40-(+new Date-this._startTime),0);clearTimeout(this._timer),this._timer=setTimeout(o.bind(this._performZoom,this),i),o.DomEvent.preventDefault(t),o.DomEvent.stopPropagation(t)},_performZoom:function(){var t=this._map,e=this._delta,i=t.getZoom();e=e>0?Math.ceil(e):Math.floor(e),e=Math.max(Math.min(e,4),-4),e=t._limitZoom(i+e)-i,this._delta=0,this._startTime=null,e&&("center"===t.options.scrollWheelZoom?t.setZoom(i+e):t.setZoomAround(this._lastMousePos,i+e))}}),o.Map.addInitHook("addHandler","scrollWheelZoom",o.Map.ScrollWheelZoom),o.extend(o.DomEvent,{_touchstart:o.Browser.msPointer?"MSPointerDown":o.Browser.pointer?"pointerdown":"touchstart",_touchend:o.Browser.msPointer?"MSPointerUp":o.Browser.pointer?"pointerup":"touchend",addDoubleTapListener:function(t,i,n){function s(t){var e;if(o.Browser.pointer?(_.push(t.pointerId),e=_.length):e=t.touches.length,!(e>1)){var i=Date.now(),n=i-(r||i);h=t.touches?t.touches[0]:t,l=n>0&&u>=n,r=i}}function a(t){if(o.Browser.pointer){var e=_.indexOf(t.pointerId);if(-1===e)return;_.splice(e,1)}if(l){if(o.Browser.pointer){var n,s={};for(var a in h)n=h[a],s[a]="function"==typeof n?n.bind(h):n;h=s}h.type="dblclick",i(h),r=null}}var r,h,l=!1,u=250,c="_leaflet_",d=this._touchstart,p=this._touchend,_=[];t[c+d+n]=s,t[c+p+n]=a;var m=o.Browser.pointer?e.documentElement:t;return t.addEventListener(d,s,!1),m.addEventListener(p,a,!1),o.Browser.pointer&&m.addEventListener(o.DomEvent.POINTER_CANCEL,a,!1),this},removeDoubleTapListener:function(t,i){var n="_leaflet_";return t.removeEventListener(this._touchstart,t[n+this._touchstart+i],!1),(o.Browser.pointer?e.documentElement:t).removeEventListener(this._touchend,t[n+this._touchend+i],!1),o.Browser.pointer&&e.documentElement.removeEventListener(o.DomEvent.POINTER_CANCEL,t[n+this._touchend+i],!1),this}}),o.extend(o.DomEvent,{POINTER_DOWN:o.Browser.msPointer?"MSPointerDown":"pointerdown",POINTER_MOVE:o.Browser.msPointer?"MSPointerMove":"pointermove",POINTER_UP:o.Browser.msPointer?"MSPointerUp":"pointerup",POINTER_CANCEL:o.Browser.msPointer?"MSPointerCancel":"pointercancel",_pointers:[],_pointerDocumentListener:!1,addPointerListener:function(t,e,i,n){switch(e){case"touchstart":return this.addPointerListenerStart(t,e,i,n);case"touchend":return this.addPointerListenerEnd(t,e,i,n);case"touchmove":return this.addPointerListenerMove(t,e,i,n);default:throw"Unknown touch event type"}},addPointerListenerStart:function(t,i,n,s){var a="_leaflet_",r=this._pointers,h=function(t){o.DomEvent.preventDefault(t);for(var e=!1,i=0;i<r.length;i++)if(r[i].pointerId===t.pointerId){e=!0;break}e||r.push(t),t.touches=r.slice(),t.changedTouches=[t],n(t)};if(t[a+"touchstart"+s]=h,t.addEventListener(this.POINTER_DOWN,h,!1),!this._pointerDocumentListener){var l=function(t){for(var e=0;e<r.length;e++)if(r[e].pointerId===t.pointerId){r.splice(e,1);
break}};e.documentElement.addEventListener(this.POINTER_UP,l,!1),e.documentElement.addEventListener(this.POINTER_CANCEL,l,!1),this._pointerDocumentListener=!0}return this},addPointerListenerMove:function(t,e,i,n){function o(t){if(t.pointerType!==t.MSPOINTER_TYPE_MOUSE&&"mouse"!==t.pointerType||0!==t.buttons){for(var e=0;e<a.length;e++)if(a[e].pointerId===t.pointerId){a[e]=t;break}t.touches=a.slice(),t.changedTouches=[t],i(t)}}var s="_leaflet_",a=this._pointers;return t[s+"touchmove"+n]=o,t.addEventListener(this.POINTER_MOVE,o,!1),this},addPointerListenerEnd:function(t,e,i,n){var o="_leaflet_",s=this._pointers,a=function(t){for(var e=0;e<s.length;e++)if(s[e].pointerId===t.pointerId){s.splice(e,1);break}t.touches=s.slice(),t.changedTouches=[t],i(t)};return t[o+"touchend"+n]=a,t.addEventListener(this.POINTER_UP,a,!1),t.addEventListener(this.POINTER_CANCEL,a,!1),this},removePointerListener:function(t,e,i){var n="_leaflet_",o=t[n+e+i];switch(e){case"touchstart":t.removeEventListener(this.POINTER_DOWN,o,!1);break;case"touchmove":t.removeEventListener(this.POINTER_MOVE,o,!1);break;case"touchend":t.removeEventListener(this.POINTER_UP,o,!1),t.removeEventListener(this.POINTER_CANCEL,o,!1)}return this}}),o.Map.mergeOptions({touchZoom:o.Browser.touch&&!o.Browser.android23,bounceAtZoomLimits:!0}),o.Map.TouchZoom=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onTouchStart,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onTouchStart,this)},_onTouchStart:function(t){var i=this._map;if(t.touches&&2===t.touches.length&&!i._animatingZoom&&!this._zooming){var n=i.mouseEventToLayerPoint(t.touches[0]),s=i.mouseEventToLayerPoint(t.touches[1]),a=i._getCenterLayerPoint();this._startCenter=n.add(s)._divideBy(2),this._startDist=n.distanceTo(s),this._moved=!1,this._zooming=!0,this._centerOffset=a.subtract(this._startCenter),i._panAnim&&i._panAnim.stop(),o.DomEvent.on(e,"touchmove",this._onTouchMove,this).on(e,"touchend",this._onTouchEnd,this),o.DomEvent.preventDefault(t)}},_onTouchMove:function(t){var e=this._map;if(t.touches&&2===t.touches.length&&this._zooming){var i=e.mouseEventToLayerPoint(t.touches[0]),n=e.mouseEventToLayerPoint(t.touches[1]);this._scale=i.distanceTo(n)/this._startDist,this._delta=i._add(n)._divideBy(2)._subtract(this._startCenter),1!==this._scale&&(e.options.bounceAtZoomLimits||!(e.getZoom()===e.getMinZoom()&&this._scale<1||e.getZoom()===e.getMaxZoom()&&this._scale>1))&&(this._moved||(o.DomUtil.addClass(e._mapPane,"leaflet-touching"),e.fire("movestart").fire("zoomstart"),this._moved=!0),o.Util.cancelAnimFrame(this._animRequest),this._animRequest=o.Util.requestAnimFrame(this._updateOnMove,this,!0,this._map._container),o.DomEvent.preventDefault(t))}},_updateOnMove:function(){var t=this._map,e=this._getScaleOrigin(),i=t.layerPointToLatLng(e),n=t.getScaleZoom(this._scale);t._animateZoom(i,n,this._startCenter,this._scale,this._delta)},_onTouchEnd:function(){if(!this._moved||!this._zooming)return void(this._zooming=!1);var t=this._map;this._zooming=!1,o.DomUtil.removeClass(t._mapPane,"leaflet-touching"),o.Util.cancelAnimFrame(this._animRequest),o.DomEvent.off(e,"touchmove",this._onTouchMove).off(e,"touchend",this._onTouchEnd);var i=this._getScaleOrigin(),n=t.layerPointToLatLng(i),s=t.getZoom(),a=t.getScaleZoom(this._scale)-s,r=a>0?Math.ceil(a):Math.floor(a),h=t._limitZoom(s+r),l=t.getZoomScale(h)/this._scale;t._animateZoom(n,h,i,l)},_getScaleOrigin:function(){var t=this._centerOffset.subtract(this._delta).divideBy(this._scale);return this._startCenter.add(t)}}),o.Map.addInitHook("addHandler","touchZoom",o.Map.TouchZoom),o.Map.mergeOptions({tap:!0,tapTolerance:15}),o.Map.Tap=o.Handler.extend({addHooks:function(){o.DomEvent.on(this._map._container,"touchstart",this._onDown,this)},removeHooks:function(){o.DomEvent.off(this._map._container,"touchstart",this._onDown,this)},_onDown:function(t){if(t.touches){if(o.DomEvent.preventDefault(t),this._fireClick=!0,t.touches.length>1)return this._fireClick=!1,void clearTimeout(this._holdTimeout);var i=t.touches[0],n=i.target;this._startPos=this._newPos=new o.Point(i.clientX,i.clientY),n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.addClass(n,"leaflet-active"),this._holdTimeout=setTimeout(o.bind(function(){this._isTapValid()&&(this._fireClick=!1,this._onUp(),this._simulateEvent("contextmenu",i))},this),1e3),o.DomEvent.on(e,"touchmove",this._onMove,this).on(e,"touchend",this._onUp,this)}},_onUp:function(t){if(clearTimeout(this._holdTimeout),o.DomEvent.off(e,"touchmove",this._onMove,this).off(e,"touchend",this._onUp,this),this._fireClick&&t&&t.changedTouches){var i=t.changedTouches[0],n=i.target;n&&n.tagName&&"a"===n.tagName.toLowerCase()&&o.DomUtil.removeClass(n,"leaflet-active"),this._isTapValid()&&this._simulateEvent("click",i)}},_isTapValid:function(){return this._newPos.distanceTo(this._startPos)<=this._map.options.tapTolerance},_onMove:function(t){var e=t.touches[0];this._newPos=new o.Point(e.clientX,e.clientY)},_simulateEvent:function(i,n){var o=e.createEvent("MouseEvents");o._simulated=!0,n.target._simulatedClick=!0,o.initMouseEvent(i,!0,!0,t,1,n.screenX,n.screenY,n.clientX,n.clientY,!1,!1,!1,!1,0,null),n.target.dispatchEvent(o)}}),o.Browser.touch&&!o.Browser.pointer&&o.Map.addInitHook("addHandler","tap",o.Map.Tap),o.Map.mergeOptions({boxZoom:!0}),o.Map.BoxZoom=o.Handler.extend({initialize:function(t){this._map=t,this._container=t._container,this._pane=t._panes.overlayPane,this._moved=!1},addHooks:function(){o.DomEvent.on(this._container,"mousedown",this._onMouseDown,this)},removeHooks:function(){o.DomEvent.off(this._container,"mousedown",this._onMouseDown),this._moved=!1},moved:function(){return this._moved},_onMouseDown:function(t){return this._moved=!1,!t.shiftKey||1!==t.which&&1!==t.button?!1:(o.DomUtil.disableTextSelection(),o.DomUtil.disableImageDrag(),this._startLayerPoint=this._map.mouseEventToLayerPoint(t),void o.DomEvent.on(e,"mousemove",this._onMouseMove,this).on(e,"mouseup",this._onMouseUp,this).on(e,"keydown",this._onKeyDown,this))},_onMouseMove:function(t){this._moved||(this._box=o.DomUtil.create("div","leaflet-zoom-box",this._pane),o.DomUtil.setPosition(this._box,this._startLayerPoint),this._container.style.cursor="crosshair",this._map.fire("boxzoomstart"));var e=this._startLayerPoint,i=this._box,n=this._map.mouseEventToLayerPoint(t),s=n.subtract(e),a=new o.Point(Math.min(n.x,e.x),Math.min(n.y,e.y));o.DomUtil.setPosition(i,a),this._moved=!0,i.style.width=Math.max(0,Math.abs(s.x)-4)+"px",i.style.height=Math.max(0,Math.abs(s.y)-4)+"px"},_finish:function(){this._moved&&(this._pane.removeChild(this._box),this._container.style.cursor=""),o.DomUtil.enableTextSelection(),o.DomUtil.enableImageDrag(),o.DomEvent.off(e,"mousemove",this._onMouseMove).off(e,"mouseup",this._onMouseUp).off(e,"keydown",this._onKeyDown)},_onMouseUp:function(t){this._finish();var e=this._map,i=e.mouseEventToLayerPoint(t);if(!this._startLayerPoint.equals(i)){var n=new o.LatLngBounds(e.layerPointToLatLng(this._startLayerPoint),e.layerPointToLatLng(i));e.fitBounds(n),e.fire("boxzoomend",{boxZoomBounds:n})}},_onKeyDown:function(t){27===t.keyCode&&this._finish()}}),o.Map.addInitHook("addHandler","boxZoom",o.Map.BoxZoom),o.Map.mergeOptions({keyboard:!0,keyboardPanOffset:80,keyboardZoomOffset:1}),o.Map.Keyboard=o.Handler.extend({keyCodes:{left:[37],right:[39],down:[40],up:[38],zoomIn:[187,107,61,171],zoomOut:[189,109,173]},initialize:function(t){this._map=t,this._setPanOffset(t.options.keyboardPanOffset),this._setZoomOffset(t.options.keyboardZoomOffset)},addHooks:function(){var t=this._map._container;-1===t.tabIndex&&(t.tabIndex="0"),o.DomEvent.on(t,"focus",this._onFocus,this).on(t,"blur",this._onBlur,this).on(t,"mousedown",this._onMouseDown,this),this._map.on("focus",this._addHooks,this).on("blur",this._removeHooks,this)},removeHooks:function(){this._removeHooks();var t=this._map._container;o.DomEvent.off(t,"focus",this._onFocus,this).off(t,"blur",this._onBlur,this).off(t,"mousedown",this._onMouseDown,this),this._map.off("focus",this._addHooks,this).off("blur",this._removeHooks,this)},_onMouseDown:function(){if(!this._focused){var i=e.body,n=e.documentElement,o=i.scrollTop||n.scrollTop,s=i.scrollLeft||n.scrollLeft;this._map._container.focus(),t.scrollTo(s,o)}},_onFocus:function(){this._focused=!0,this._map.fire("focus")},_onBlur:function(){this._focused=!1,this._map.fire("blur")},_setPanOffset:function(t){var e,i,n=this._panKeys={},o=this.keyCodes;for(e=0,i=o.left.length;i>e;e++)n[o.left[e]]=[-1*t,0];for(e=0,i=o.right.length;i>e;e++)n[o.right[e]]=[t,0];for(e=0,i=o.down.length;i>e;e++)n[o.down[e]]=[0,t];for(e=0,i=o.up.length;i>e;e++)n[o.up[e]]=[0,-1*t]},_setZoomOffset:function(t){var e,i,n=this._zoomKeys={},o=this.keyCodes;for(e=0,i=o.zoomIn.length;i>e;e++)n[o.zoomIn[e]]=t;for(e=0,i=o.zoomOut.length;i>e;e++)n[o.zoomOut[e]]=-t},_addHooks:function(){o.DomEvent.on(e,"keydown",this._onKeyDown,this)},_removeHooks:function(){o.DomEvent.off(e,"keydown",this._onKeyDown,this)},_onKeyDown:function(t){var e=t.keyCode,i=this._map;if(e in this._panKeys){if(i._panAnim&&i._panAnim._inProgress)return;i.panBy(this._panKeys[e]),i.options.maxBounds&&i.panInsideBounds(i.options.maxBounds)}else{if(!(e in this._zoomKeys))return;i.setZoom(i.getZoom()+this._zoomKeys[e])}o.DomEvent.stop(t)}}),o.Map.addInitHook("addHandler","keyboard",o.Map.Keyboard),o.Handler.MarkerDrag=o.Handler.extend({initialize:function(t){this._marker=t},addHooks:function(){var t=this._marker._icon;this._draggable||(this._draggable=new o.Draggable(t,t)),this._draggable.on("dragstart",this._onDragStart,this).on("drag",this._onDrag,this).on("dragend",this._onDragEnd,this),this._draggable.enable(),o.DomUtil.addClass(this._marker._icon,"leaflet-marker-draggable")},removeHooks:function(){this._draggable.off("dragstart",this._onDragStart,this).off("drag",this._onDrag,this).off("dragend",this._onDragEnd,this),this._draggable.disable(),o.DomUtil.removeClass(this._marker._icon,"leaflet-marker-draggable")},moved:function(){return this._draggable&&this._draggable._moved},_onDragStart:function(){this._marker.closePopup().fire("movestart").fire("dragstart")},_onDrag:function(){var t=this._marker,e=t._shadow,i=o.DomUtil.getPosition(t._icon),n=t._map.layerPointToLatLng(i);e&&o.DomUtil.setPosition(e,i),t._latlng=n,t.fire("move",{latlng:n}).fire("drag")},_onDragEnd:function(t){this._marker.fire("moveend").fire("dragend",t)}}),o.Control=o.Class.extend({options:{position:"topright"},initialize:function(t){o.setOptions(this,t)},getPosition:function(){return this.options.position},setPosition:function(t){var e=this._map;return e&&e.removeControl(this),this.options.position=t,e&&e.addControl(this),this},getContainer:function(){return this._container},addTo:function(t){this._map=t;var e=this._container=this.onAdd(t),i=this.getPosition(),n=t._controlCorners[i];return o.DomUtil.addClass(e,"leaflet-control"),-1!==i.indexOf("bottom")?n.insertBefore(e,n.firstChild):n.appendChild(e),this},removeFrom:function(t){var e=this.getPosition(),i=t._controlCorners[e];return i.removeChild(this._container),this._map=null,this.onRemove&&this.onRemove(t),this},_refocusOnMap:function(){this._map&&this._map.getContainer().focus()}}),o.control=function(t){return new o.Control(t)},o.Map.include({addControl:function(t){return t.addTo(this),this},removeControl:function(t){return t.removeFrom(this),this},_initControlPos:function(){function t(t,s){var a=i+t+" "+i+s;e[t+s]=o.DomUtil.create("div",a,n)}var e=this._controlCorners={},i="leaflet-",n=this._controlContainer=o.DomUtil.create("div",i+"control-container",this._container);t("top","left"),t("top","right"),t("bottom","left"),t("bottom","right")},_clearControlPos:function(){this._container.removeChild(this._controlContainer)}}),o.Control.Zoom=o.Control.extend({options:{position:"topleft",zoomInText:"+",zoomInTitle:"Zoom in",zoomOutText:"-",zoomOutTitle:"Zoom out"},onAdd:function(t){var e="leaflet-control-zoom",i=o.DomUtil.create("div",e+" leaflet-bar");return this._map=t,this._zoomInButton=this._createButton(this.options.zoomInText,this.options.zoomInTitle,e+"-in",i,this._zoomIn,this),this._zoomOutButton=this._createButton(this.options.zoomOutText,this.options.zoomOutTitle,e+"-out",i,this._zoomOut,this),this._updateDisabled(),t.on("zoomend zoomlevelschange",this._updateDisabled,this),i},onRemove:function(t){t.off("zoomend zoomlevelschange",this._updateDisabled,this)},_zoomIn:function(t){this._map.zoomIn(t.shiftKey?3:1)},_zoomOut:function(t){this._map.zoomOut(t.shiftKey?3:1)},_createButton:function(t,e,i,n,s,a){var r=o.DomUtil.create("a",i,n);r.innerHTML=t,r.href="#",r.title=e;var h=o.DomEvent.stopPropagation;return o.DomEvent.on(r,"click",h).on(r,"mousedown",h).on(r,"dblclick",h).on(r,"click",o.DomEvent.preventDefault).on(r,"click",s,a).on(r,"click",this._refocusOnMap,a),r},_updateDisabled:function(){var t=this._map,e="leaflet-disabled";o.DomUtil.removeClass(this._zoomInButton,e),o.DomUtil.removeClass(this._zoomOutButton,e),t._zoom===t.getMinZoom()&&o.DomUtil.addClass(this._zoomOutButton,e),t._zoom===t.getMaxZoom()&&o.DomUtil.addClass(this._zoomInButton,e)}}),o.Map.mergeOptions({zoomControl:!0}),o.Map.addInitHook(function(){this.options.zoomControl&&(this.zoomControl=new o.Control.Zoom,this.addControl(this.zoomControl))}),o.control.zoom=function(t){return new o.Control.Zoom(t)},o.Control.Attribution=o.Control.extend({options:{position:"bottomright",prefix:'<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'},initialize:function(t){o.setOptions(this,t),this._attributions={}},onAdd:function(t){this._container=o.DomUtil.create("div","leaflet-control-attribution"),o.DomEvent.disableClickPropagation(this._container);for(var e in t._layers)t._layers[e].getAttribution&&this.addAttribution(t._layers[e].getAttribution());return t.on("layeradd",this._onLayerAdd,this).on("layerremove",this._onLayerRemove,this),this._update(),this._container},onRemove:function(t){t.off("layeradd",this._onLayerAdd).off("layerremove",this._onLayerRemove)},setPrefix:function(t){return this.options.prefix=t,this._update(),this},addAttribution:function(t){return t?(this._attributions[t]||(this._attributions[t]=0),this._attributions[t]++,this._update(),this):void 0},removeAttribution:function(t){return t?(this._attributions[t]&&(this._attributions[t]--,this._update()),this):void 0},_update:function(){if(this._map){var t=[];for(var e in this._attributions)this._attributions[e]&&t.push(e);var i=[];this.options.prefix&&i.push(this.options.prefix),t.length&&i.push(t.join(", ")),this._container.innerHTML=i.join(" | ")}},_onLayerAdd:function(t){t.layer.getAttribution&&this.addAttribution(t.layer.getAttribution())},_onLayerRemove:function(t){t.layer.getAttribution&&this.removeAttribution(t.layer.getAttribution())}}),o.Map.mergeOptions({attributionControl:!0}),o.Map.addInitHook(function(){this.options.attributionControl&&(this.attributionControl=(new o.Control.Attribution).addTo(this))}),o.control.attribution=function(t){return new o.Control.Attribution(t)},o.Control.Scale=o.Control.extend({options:{position:"bottomleft",maxWidth:100,metric:!0,imperial:!0,updateWhenIdle:!1},onAdd:function(t){this._map=t;var e="leaflet-control-scale",i=o.DomUtil.create("div",e),n=this.options;return this._addScales(n,e,i),t.on(n.updateWhenIdle?"moveend":"move",this._update,this),t.whenReady(this._update,this),i},onRemove:function(t){t.off(this.options.updateWhenIdle?"moveend":"move",this._update,this)},_addScales:function(t,e,i){t.metric&&(this._mScale=o.DomUtil.create("div",e+"-line",i)),t.imperial&&(this._iScale=o.DomUtil.create("div",e+"-line",i))},_update:function(){var t=this._map.getBounds(),e=t.getCenter().lat,i=6378137*Math.PI*Math.cos(e*Math.PI/180),n=i*(t.getNorthEast().lng-t.getSouthWest().lng)/180,o=this._map.getSize(),s=this.options,a=0;o.x>0&&(a=n*(s.maxWidth/o.x)),this._updateScales(s,a)},_updateScales:function(t,e){t.metric&&e&&this._updateMetric(e),t.imperial&&e&&this._updateImperial(e)},_updateMetric:function(t){var e=this._getRoundNum(t);this._mScale.style.width=this._getScaleWidth(e/t)+"px",this._mScale.innerHTML=1e3>e?e+" m":e/1e3+" km"},_updateImperial:function(t){var e,i,n,o=3.2808399*t,s=this._iScale;o>5280?(e=o/5280,i=this._getRoundNum(e),s.style.width=this._getScaleWidth(i/e)+"px",s.innerHTML=i+" mi"):(n=this._getRoundNum(o),s.style.width=this._getScaleWidth(n/o)+"px",s.innerHTML=n+" ft")},_getScaleWidth:function(t){return Math.round(this.options.maxWidth*t)-10},_getRoundNum:function(t){var e=Math.pow(10,(Math.floor(t)+"").length-1),i=t/e;return i=i>=10?10:i>=5?5:i>=3?3:i>=2?2:1,e*i}}),o.control.scale=function(t){return new o.Control.Scale(t)},o.Control.Layers=o.Control.extend({options:{collapsed:!0,position:"topright",autoZIndex:!0},initialize:function(t,e,i){o.setOptions(this,i),this._layers={},this._lastZIndex=0,this._handlingClick=!1;for(var n in t)this._addLayer(t[n],n);for(n in e)this._addLayer(e[n],n,!0)},onAdd:function(t){return this._initLayout(),this._update(),t.on("layeradd",this._onLayerChange,this).on("layerremove",this._onLayerChange,this),this._container},onRemove:function(t){t.off("layeradd",this._onLayerChange).off("layerremove",this._onLayerChange)},addBaseLayer:function(t,e){return this._addLayer(t,e),this._update(),this},addOverlay:function(t,e){return this._addLayer(t,e,!0),this._update(),this},removeLayer:function(t){var e=o.stamp(t);return delete this._layers[e],this._update(),this},_initLayout:function(){var t="leaflet-control-layers",e=this._container=o.DomUtil.create("div",t);e.setAttribute("aria-haspopup",!0),o.Browser.touch?o.DomEvent.on(e,"click",o.DomEvent.stopPropagation):o.DomEvent.disableClickPropagation(e).disableScrollPropagation(e);var i=this._form=o.DomUtil.create("form",t+"-list");if(this.options.collapsed){o.Browser.android||o.DomEvent.on(e,"mouseover",this._expand,this).on(e,"mouseout",this._collapse,this);var n=this._layersLink=o.DomUtil.create("a",t+"-toggle",e);n.href="#",n.title="Layers",o.Browser.touch?o.DomEvent.on(n,"click",o.DomEvent.stop).on(n,"click",this._expand,this):o.DomEvent.on(n,"focus",this._expand,this),o.DomEvent.on(i,"click",function(){setTimeout(o.bind(this._onInputClick,this),0)},this),this._map.on("click",this._collapse,this)}else this._expand();this._baseLayersList=o.DomUtil.create("div",t+"-base",i),this._separator=o.DomUtil.create("div",t+"-separator",i),this._overlaysList=o.DomUtil.create("div",t+"-overlays",i),e.appendChild(i)},_addLayer:function(t,e,i){var n=o.stamp(t);this._layers[n]={layer:t,name:e,overlay:i},this.options.autoZIndex&&t.setZIndex&&(this._lastZIndex++,t.setZIndex(this._lastZIndex))},_update:function(){if(this._container){this._baseLayersList.innerHTML="",this._overlaysList.innerHTML="";var t,e,i=!1,n=!1;for(t in this._layers)e=this._layers[t],this._addItem(e),n=n||e.overlay,i=i||!e.overlay;this._separator.style.display=n&&i?"":"none"}},_onLayerChange:function(t){var e=this._layers[o.stamp(t.layer)];if(e){this._handlingClick||this._update();var i=e.overlay?"layeradd"===t.type?"overlayadd":"overlayremove":"layeradd"===t.type?"baselayerchange":null;i&&this._map.fire(i,e)}},_createRadioElement:function(t,i){var n='<input type="radio" class="leaflet-control-layers-selector" name="'+t+'"';i&&(n+=' checked="checked"'),n+="/>";var o=e.createElement("div");return o.innerHTML=n,o.firstChild},_addItem:function(t){var i,n=e.createElement("label"),s=this._map.hasLayer(t.layer);t.overlay?(i=e.createElement("input"),i.type="checkbox",i.className="leaflet-control-layers-selector",i.defaultChecked=s):i=this._createRadioElement("leaflet-base-layers",s),i.layerId=o.stamp(t.layer),o.DomEvent.on(i,"click",this._onInputClick,this);var a=e.createElement("span");a.innerHTML=" "+t.name,n.appendChild(i),n.appendChild(a);var r=t.overlay?this._overlaysList:this._baseLayersList;return r.appendChild(n),n},_onInputClick:function(){var t,e,i,n=this._form.getElementsByTagName("input"),o=n.length;for(this._handlingClick=!0,t=0;o>t;t++)e=n[t],i=this._layers[e.layerId],e.checked&&!this._map.hasLayer(i.layer)?this._map.addLayer(i.layer):!e.checked&&this._map.hasLayer(i.layer)&&this._map.removeLayer(i.layer);this._handlingClick=!1,this._refocusOnMap()},_expand:function(){o.DomUtil.addClass(this._container,"leaflet-control-layers-expanded")},_collapse:function(){this._container.className=this._container.className.replace(" leaflet-control-layers-expanded","")}}),o.control.layers=function(t,e,i){return new o.Control.Layers(t,e,i)},o.PosAnimation=o.Class.extend({includes:o.Mixin.Events,run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._newPos=e,this.fire("start"),t.style[o.DomUtil.TRANSITION]="all "+(i||.25)+"s cubic-bezier(0,0,"+(n||.5)+",1)",o.DomEvent.on(t,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),o.DomUtil.setPosition(t,e),o.Util.falseFn(t.offsetWidth),this._stepTimer=setInterval(o.bind(this._onStep,this),50)},stop:function(){this._inProgress&&(o.DomUtil.setPosition(this._el,this._getPos()),this._onTransitionEnd(),o.Util.falseFn(this._el.offsetWidth))},_onStep:function(){var t=this._getPos();return t?(this._el._leaflet_pos=t,void this.fire("step")):void this._onTransitionEnd()},_transformRe:/([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,_getPos:function(){var e,i,n,s=this._el,a=t.getComputedStyle(s);if(o.Browser.any3d){if(n=a[o.DomUtil.TRANSFORM].match(this._transformRe),!n)return;e=parseFloat(n[1]),i=parseFloat(n[2])}else e=parseFloat(a.left),i=parseFloat(a.top);return new o.Point(e,i,!0)},_onTransitionEnd:function(){o.DomEvent.off(this._el,o.DomUtil.TRANSITION_END,this._onTransitionEnd,this),this._inProgress&&(this._inProgress=!1,this._el.style[o.DomUtil.TRANSITION]="",this._el._leaflet_pos=this._newPos,clearInterval(this._stepTimer),this.fire("step").fire("end"))}}),o.Map.include({setView:function(t,e,n){if(e=e===i?this._zoom:this._limitZoom(e),t=this._limitCenter(o.latLng(t),e,this.options.maxBounds),n=n||{},this._panAnim&&this._panAnim.stop(),this._loaded&&!n.reset&&n!==!0){n.animate!==i&&(n.zoom=o.extend({animate:n.animate},n.zoom),n.pan=o.extend({animate:n.animate},n.pan));var s=this._zoom!==e?this._tryAnimatedZoom&&this._tryAnimatedZoom(t,e,n.zoom):this._tryAnimatedPan(t,n.pan);if(s)return clearTimeout(this._sizeTimer),this}return this._resetView(t,e),this},panBy:function(t,e){if(t=o.point(t).round(),e=e||{},!t.x&&!t.y)return this;if(this._panAnim||(this._panAnim=new o.PosAnimation,this._panAnim.on({step:this._onPanTransitionStep,end:this._onPanTransitionEnd},this)),e.noMoveStart||this.fire("movestart"),e.animate!==!1){o.DomUtil.addClass(this._mapPane,"leaflet-pan-anim");var i=this._getMapPanePos().subtract(t);this._panAnim.run(this._mapPane,i,e.duration||.25,e.easeLinearity)}else this._rawPanBy(t),this.fire("move").fire("moveend");return this},_onPanTransitionStep:function(){this.fire("move")},_onPanTransitionEnd:function(){o.DomUtil.removeClass(this._mapPane,"leaflet-pan-anim"),this.fire("moveend")},_tryAnimatedPan:function(t,e){var i=this._getCenterOffset(t)._floor();return(e&&e.animate)===!0||this.getSize().contains(i)?(this.panBy(i,e),!0):!1}}),o.PosAnimation=o.DomUtil.TRANSITION?o.PosAnimation:o.PosAnimation.extend({run:function(t,e,i,n){this.stop(),this._el=t,this._inProgress=!0,this._duration=i||.25,this._easeOutPower=1/Math.max(n||.5,.2),this._startPos=o.DomUtil.getPosition(t),this._offset=e.subtract(this._startPos),this._startTime=+new Date,this.fire("start"),this._animate()},stop:function(){this._inProgress&&(this._step(),this._complete())},_animate:function(){this._animId=o.Util.requestAnimFrame(this._animate,this),this._step()},_step:function(){var t=+new Date-this._startTime,e=1e3*this._duration;e>t?this._runFrame(this._easeOut(t/e)):(this._runFrame(1),this._complete())},_runFrame:function(t){var e=this._startPos.add(this._offset.multiplyBy(t));o.DomUtil.setPosition(this._el,e),this.fire("step")},_complete:function(){o.Util.cancelAnimFrame(this._animId),this._inProgress=!1,this.fire("end")},_easeOut:function(t){return 1-Math.pow(1-t,this._easeOutPower)}}),o.Map.mergeOptions({zoomAnimation:!0,zoomAnimationThreshold:4}),o.DomUtil.TRANSITION&&o.Map.addInitHook(function(){this._zoomAnimated=this.options.zoomAnimation&&o.DomUtil.TRANSITION&&o.Browser.any3d&&!o.Browser.android23&&!o.Browser.mobileOpera,this._zoomAnimated&&o.DomEvent.on(this._mapPane,o.DomUtil.TRANSITION_END,this._catchTransitionEnd,this)}),o.Map.include(o.DomUtil.TRANSITION?{_catchTransitionEnd:function(t){this._animatingZoom&&t.propertyName.indexOf("transform")>=0&&this._onZoomTransitionEnd()},_nothingToAnimate:function(){return!this._container.getElementsByClassName("leaflet-zoom-animated").length},_tryAnimatedZoom:function(t,e,i){if(this._animatingZoom)return!0;if(i=i||{},!this._zoomAnimated||i.animate===!1||this._nothingToAnimate()||Math.abs(e-this._zoom)>this.options.zoomAnimationThreshold)return!1;var n=this.getZoomScale(e),o=this._getCenterOffset(t)._divideBy(1-1/n),s=this._getCenterLayerPoint()._add(o);return i.animate===!0||this.getSize().contains(o)?(this.fire("movestart").fire("zoomstart"),this._animateZoom(t,e,s,n,null,!0),!0):!1},_animateZoom:function(t,e,i,n,s,a){this._animatingZoom=!0,o.DomUtil.addClass(this._mapPane,"leaflet-zoom-anim"),this._animateToCenter=t,this._animateToZoom=e,o.Draggable&&(o.Draggable._disabled=!0),this.fire("zoomanim",{center:t,zoom:e,origin:i,scale:n,delta:s,backwards:a})},_onZoomTransitionEnd:function(){this._animatingZoom=!1,o.DomUtil.removeClass(this._mapPane,"leaflet-zoom-anim"),this._resetView(this._animateToCenter,this._animateToZoom,!0,!0),o.Draggable&&(o.Draggable._disabled=!1)}}:{}),o.TileLayer.include({_animateZoom:function(t){this._animating||(this._animating=!0,this._prepareBgBuffer());var e=this._bgBuffer,i=o.DomUtil.TRANSFORM,n=t.delta?o.DomUtil.getTranslateString(t.delta):e.style[i],s=o.DomUtil.getScaleString(t.scale,t.origin);e.style[i]=t.backwards?s+" "+n:n+" "+s},_endZoomAnim:function(){var t=this._tileContainer,e=this._bgBuffer;t.style.visibility="",t.parentNode.appendChild(t),o.Util.falseFn(e.offsetWidth),this._animating=!1},_clearBgBuffer:function(){var t=this._map;!t||t._animatingZoom||t.touchZoom._zooming||(this._bgBuffer.innerHTML="",this._bgBuffer.style[o.DomUtil.TRANSFORM]="")},_prepareBgBuffer:function(){var t=this._tileContainer,e=this._bgBuffer,i=this._getLoadedTilesPercentage(e),n=this._getLoadedTilesPercentage(t);return e&&i>.5&&.5>n?(t.style.visibility="hidden",void this._stopLoadingImages(t)):(e.style.visibility="hidden",e.style[o.DomUtil.TRANSFORM]="",this._tileContainer=e,e=this._bgBuffer=t,this._stopLoadingImages(e),void clearTimeout(this._clearBgBufferTimer))},_getLoadedTilesPercentage:function(t){var e,i,n=t.getElementsByTagName("img"),o=0;for(e=0,i=n.length;i>e;e++)n[e].complete&&o++;return o/i},_stopLoadingImages:function(t){var e,i,n,s=Array.prototype.slice.call(t.getElementsByTagName("img"));for(e=0,i=s.length;i>e;e++)n=s[e],n.complete||(n.onload=o.Util.falseFn,n.onerror=o.Util.falseFn,n.src=o.Util.emptyImageUrl,n.parentNode.removeChild(n))}}),o.Map.include({_defaultLocateOptions:{watch:!1,setView:!1,maxZoom:1/0,timeout:1e4,maximumAge:0,enableHighAccuracy:!1},locate:function(t){if(t=this._locateOptions=o.extend(this._defaultLocateOptions,t),!navigator.geolocation)return this._handleGeolocationError({code:0,message:"Geolocation not supported."}),this;var e=o.bind(this._handleGeolocationResponse,this),i=o.bind(this._handleGeolocationError,this);return t.watch?this._locationWatchId=navigator.geolocation.watchPosition(e,i,t):navigator.geolocation.getCurrentPosition(e,i,t),this},stopLocate:function(){return navigator.geolocation&&navigator.geolocation.clearWatch(this._locationWatchId),this._locateOptions&&(this._locateOptions.setView=!1),this},_handleGeolocationError:function(t){var e=t.code,i=t.message||(1===e?"permission denied":2===e?"position unavailable":"timeout");this._locateOptions.setView&&!this._loaded&&this.fitWorld(),this.fire("locationerror",{code:e,message:"Geolocation error: "+i+"."})},_handleGeolocationResponse:function(t){var e=t.coords.latitude,i=t.coords.longitude,n=new o.LatLng(e,i),s=180*t.coords.accuracy/40075017,a=s/Math.cos(o.LatLng.DEG_TO_RAD*e),r=o.latLngBounds([e-s,i-a],[e+s,i+a]),h=this._locateOptions;if(h.setView){var l=Math.min(this.getBoundsZoom(r),h.maxZoom);this.setView(n,l)}var u={latlng:n,bounds:r,timestamp:t.timestamp};for(var c in t.coords)"number"==typeof t.coords[c]&&(u[c]=t.coords[c]);this.fire("locationfound",u)}})}(window,document);
};/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function() {'use strict';function m(a){throw a;}var p=void 0,t,aa=this;function v(a,b){var c=a.split("."),d=aa;!(c[0]in d)&&d.execScript&&d.execScript("var "+c[0]);for(var g;c.length&&(g=c.shift());)!c.length&&b!==p?d[g]=b:d=d[g]?d[g]:d[g]={}};var w="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array;new (w?Uint8Array:Array)(256);var x;for(x=0;256>x;++x)for(var y=x,ba=7,y=y>>>1;y;y>>>=1)--ba;var z=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,
2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,
2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,
2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,
3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,
936918E3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],A=w?new Uint32Array(z):z;function B(a){var b=a.length,c=0,d=Number.POSITIVE_INFINITY,g,f,h,e,k,l,q,s,r;for(s=0;s<b;++s)a[s]>c&&(c=a[s]),a[s]<d&&(d=a[s]);g=1<<c;f=new (w?Uint32Array:Array)(g);h=1;e=0;for(k=2;h<=c;){for(s=0;s<b;++s)if(a[s]===h){l=0;q=e;for(r=0;r<h;++r)l=l<<1|q&1,q>>=1;for(r=l;r<g;r+=k)f[r]=h<<16|s;++e}++h;e<<=1;k<<=1}return[f,c,d]};var C=[],D;for(D=0;288>D;D++)switch(!0){case 143>=D:C.push([D+48,8]);break;case 255>=D:C.push([D-144+400,9]);break;case 279>=D:C.push([D-256+0,7]);break;case 287>=D:C.push([D-280+192,8]);break;default:m("invalid literal: "+D)}
var ca=function(){function a(a){switch(!0){case 3===a:return[257,a-3,0];case 4===a:return[258,a-4,0];case 5===a:return[259,a-5,0];case 6===a:return[260,a-6,0];case 7===a:return[261,a-7,0];case 8===a:return[262,a-8,0];case 9===a:return[263,a-9,0];case 10===a:return[264,a-10,0];case 12>=a:return[265,a-11,1];case 14>=a:return[266,a-13,1];case 16>=a:return[267,a-15,1];case 18>=a:return[268,a-17,1];case 22>=a:return[269,a-19,2];case 26>=a:return[270,a-23,2];case 30>=a:return[271,a-27,2];case 34>=a:return[272,
a-31,2];case 42>=a:return[273,a-35,3];case 50>=a:return[274,a-43,3];case 58>=a:return[275,a-51,3];case 66>=a:return[276,a-59,3];case 82>=a:return[277,a-67,4];case 98>=a:return[278,a-83,4];case 114>=a:return[279,a-99,4];case 130>=a:return[280,a-115,4];case 162>=a:return[281,a-131,5];case 194>=a:return[282,a-163,5];case 226>=a:return[283,a-195,5];case 257>=a:return[284,a-227,5];case 258===a:return[285,a-258,0];default:m("invalid length: "+a)}}var b=[],c,d;for(c=3;258>=c;c++)d=a(c),b[c]=d[2]<<24|d[1]<<
16|d[0];return b}();w&&new Uint32Array(ca);function E(a,b){this.l=[];this.m=32768;this.d=this.f=this.c=this.t=0;this.input=w?new Uint8Array(a):a;this.u=!1;this.n=F;this.K=!1;if(b||!(b={}))b.index&&(this.c=b.index),b.bufferSize&&(this.m=b.bufferSize),b.bufferType&&(this.n=b.bufferType),b.resize&&(this.K=b.resize);switch(this.n){case G:this.a=32768;this.b=new (w?Uint8Array:Array)(32768+this.m+258);break;case F:this.a=0;this.b=new (w?Uint8Array:Array)(this.m);this.e=this.W;this.B=this.R;this.q=this.V;break;default:m(Error("invalid inflate mode"))}}
var G=0,F=1;
E.prototype.r=function(){for(;!this.u;){var a=H(this,3);a&1&&(this.u=!0);a>>>=1;switch(a){case 0:var b=this.input,c=this.c,d=this.b,g=this.a,f=p,h=p,e=p,k=d.length,l=p;this.d=this.f=0;f=b[c++];f===p&&m(Error("invalid uncompressed block header: LEN (first byte)"));h=f;f=b[c++];f===p&&m(Error("invalid uncompressed block header: LEN (second byte)"));h|=f<<8;f=b[c++];f===p&&m(Error("invalid uncompressed block header: NLEN (first byte)"));e=f;f=b[c++];f===p&&m(Error("invalid uncompressed block header: NLEN (second byte)"));e|=
f<<8;h===~e&&m(Error("invalid uncompressed block header: length verify"));c+h>b.length&&m(Error("input buffer is broken"));switch(this.n){case G:for(;g+h>d.length;){l=k-g;h-=l;if(w)d.set(b.subarray(c,c+l),g),g+=l,c+=l;else for(;l--;)d[g++]=b[c++];this.a=g;d=this.e();g=this.a}break;case F:for(;g+h>d.length;)d=this.e({H:2});break;default:m(Error("invalid inflate mode"))}if(w)d.set(b.subarray(c,c+h),g),g+=h,c+=h;else for(;h--;)d[g++]=b[c++];this.c=c;this.a=g;this.b=d;break;case 1:this.q(da,ea);break;
case 2:fa(this);break;default:m(Error("unknown BTYPE: "+a))}}return this.B()};
var I=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],J=w?new Uint16Array(I):I,K=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],L=w?new Uint16Array(K):K,ga=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],O=w?new Uint8Array(ga):ga,ha=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],ia=w?new Uint16Array(ha):ha,ja=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,
12,12,13,13],P=w?new Uint8Array(ja):ja,Q=new (w?Uint8Array:Array)(288),R,la;R=0;for(la=Q.length;R<la;++R)Q[R]=143>=R?8:255>=R?9:279>=R?7:8;var da=B(Q),S=new (w?Uint8Array:Array)(30),T,ma;T=0;for(ma=S.length;T<ma;++T)S[T]=5;var ea=B(S);function H(a,b){for(var c=a.f,d=a.d,g=a.input,f=a.c,h;d<b;)h=g[f++],h===p&&m(Error("input buffer is broken")),c|=h<<d,d+=8;h=c&(1<<b)-1;a.f=c>>>b;a.d=d-b;a.c=f;return h}
function U(a,b){for(var c=a.f,d=a.d,g=a.input,f=a.c,h=b[0],e=b[1],k,l,q;d<e;){k=g[f++];if(k===p)break;c|=k<<d;d+=8}l=h[c&(1<<e)-1];q=l>>>16;a.f=c>>q;a.d=d-q;a.c=f;return l&65535}
function fa(a){function b(a,b,c){var d,e,f,g;for(g=0;g<a;)switch(d=U(this,b),d){case 16:for(f=3+H(this,2);f--;)c[g++]=e;break;case 17:for(f=3+H(this,3);f--;)c[g++]=0;e=0;break;case 18:for(f=11+H(this,7);f--;)c[g++]=0;e=0;break;default:e=c[g++]=d}return c}var c=H(a,5)+257,d=H(a,5)+1,g=H(a,4)+4,f=new (w?Uint8Array:Array)(J.length),h,e,k,l;for(l=0;l<g;++l)f[J[l]]=H(a,3);h=B(f);e=new (w?Uint8Array:Array)(c);k=new (w?Uint8Array:Array)(d);a.q(B(b.call(a,c,h,e)),B(b.call(a,d,h,k)))}t=E.prototype;
t.q=function(a,b){var c=this.b,d=this.a;this.C=a;for(var g=c.length-258,f,h,e,k;256!==(f=U(this,a));)if(256>f)d>=g&&(this.a=d,c=this.e(),d=this.a),c[d++]=f;else{h=f-257;k=L[h];0<O[h]&&(k+=H(this,O[h]));f=U(this,b);e=ia[f];0<P[f]&&(e+=H(this,P[f]));d>=g&&(this.a=d,c=this.e(),d=this.a);for(;k--;)c[d]=c[d++-e]}for(;8<=this.d;)this.d-=8,this.c--;this.a=d};
t.V=function(a,b){var c=this.b,d=this.a;this.C=a;for(var g=c.length,f,h,e,k;256!==(f=U(this,a));)if(256>f)d>=g&&(c=this.e(),g=c.length),c[d++]=f;else{h=f-257;k=L[h];0<O[h]&&(k+=H(this,O[h]));f=U(this,b);e=ia[f];0<P[f]&&(e+=H(this,P[f]));d+k>g&&(c=this.e(),g=c.length);for(;k--;)c[d]=c[d++-e]}for(;8<=this.d;)this.d-=8,this.c--;this.a=d};
t.e=function(){var a=new (w?Uint8Array:Array)(this.a-32768),b=this.a-32768,c,d,g=this.b;if(w)a.set(g.subarray(32768,a.length));else{c=0;for(d=a.length;c<d;++c)a[c]=g[c+32768]}this.l.push(a);this.t+=a.length;if(w)g.set(g.subarray(b,b+32768));else for(c=0;32768>c;++c)g[c]=g[b+c];this.a=32768;return g};
t.W=function(a){var b,c=this.input.length/this.c+1|0,d,g,f,h=this.input,e=this.b;a&&("number"===typeof a.H&&(c=a.H),"number"===typeof a.P&&(c+=a.P));2>c?(d=(h.length-this.c)/this.C[2],f=258*(d/2)|0,g=f<e.length?e.length+f:e.length<<1):g=e.length*c;w?(b=new Uint8Array(g),b.set(e)):b=e;return this.b=b};
t.B=function(){var a=0,b=this.b,c=this.l,d,g=new (w?Uint8Array:Array)(this.t+(this.a-32768)),f,h,e,k;if(0===c.length)return w?this.b.subarray(32768,this.a):this.b.slice(32768,this.a);f=0;for(h=c.length;f<h;++f){d=c[f];e=0;for(k=d.length;e<k;++e)g[a++]=d[e]}f=32768;for(h=this.a;f<h;++f)g[a++]=b[f];this.l=[];return this.buffer=g};
t.R=function(){var a,b=this.a;w?this.K?(a=new Uint8Array(b),a.set(this.b.subarray(0,b))):a=this.b.subarray(0,b):(this.b.length>b&&(this.b.length=b),a=this.b);return this.buffer=a};function V(a){a=a||{};this.files=[];this.v=a.comment}V.prototype.L=function(a){this.j=a};V.prototype.s=function(a){var b=a[2]&65535|2;return b*(b^1)>>8&255};V.prototype.k=function(a,b){a[0]=(A[(a[0]^b)&255]^a[0]>>>8)>>>0;a[1]=(6681*(20173*(a[1]+(a[0]&255))>>>0)>>>0)+1>>>0;a[2]=(A[(a[2]^a[1]>>>24)&255]^a[2]>>>8)>>>0};V.prototype.T=function(a){var b=[305419896,591751049,878082192],c,d;w&&(b=new Uint32Array(b));c=0;for(d=a.length;c<d;++c)this.k(b,a[c]&255);return b};function W(a,b){b=b||{};this.input=w&&a instanceof Array?new Uint8Array(a):a;this.c=0;this.ba=b.verify||!1;this.j=b.password}var na={O:0,M:8},X=[80,75,1,2],Y=[80,75,3,4],Z=[80,75,5,6];function oa(a,b){this.input=a;this.offset=b}
oa.prototype.parse=function(){var a=this.input,b=this.offset;(a[b++]!==X[0]||a[b++]!==X[1]||a[b++]!==X[2]||a[b++]!==X[3])&&m(Error("invalid file header signature"));this.version=a[b++];this.ia=a[b++];this.Z=a[b++]|a[b++]<<8;this.I=a[b++]|a[b++]<<8;this.A=a[b++]|a[b++]<<8;this.time=a[b++]|a[b++]<<8;this.U=a[b++]|a[b++]<<8;this.p=(a[b++]|a[b++]<<8|a[b++]<<16|a[b++]<<24)>>>0;this.z=(a[b++]|a[b++]<<8|a[b++]<<16|a[b++]<<24)>>>0;this.J=(a[b++]|a[b++]<<8|a[b++]<<16|a[b++]<<24)>>>0;this.h=a[b++]|a[b++]<<
8;this.g=a[b++]|a[b++]<<8;this.F=a[b++]|a[b++]<<8;this.ea=a[b++]|a[b++]<<8;this.ga=a[b++]|a[b++]<<8;this.fa=a[b++]|a[b++]<<8|a[b++]<<16|a[b++]<<24;this.$=(a[b++]|a[b++]<<8|a[b++]<<16|a[b++]<<24)>>>0;this.filename=String.fromCharCode.apply(null,w?a.subarray(b,b+=this.h):a.slice(b,b+=this.h));this.X=w?a.subarray(b,b+=this.g):a.slice(b,b+=this.g);this.v=w?a.subarray(b,b+this.F):a.slice(b,b+this.F);this.length=b-this.offset};function pa(a,b){this.input=a;this.offset=b}var qa={N:1,ca:8,da:2048};
pa.prototype.parse=function(){var a=this.input,b=this.offset;(a[b++]!==Y[0]||a[b++]!==Y[1]||a[b++]!==Y[2]||a[b++]!==Y[3])&&m(Error("invalid local file header signature"));this.Z=a[b++]|a[b++]<<8;this.I=a[b++]|a[b++]<<8;this.A=a[b++]|a[b++]<<8;this.time=a[b++]|a[b++]<<8;this.U=a[b++]|a[b++]<<8;this.p=(a[b++]|a[b++]<<8|a[b++]<<16|a[b++]<<24)>>>0;this.z=(a[b++]|a[b++]<<8|a[b++]<<16|a[b++]<<24)>>>0;this.J=(a[b++]|a[b++]<<8|a[b++]<<16|a[b++]<<24)>>>0;this.h=a[b++]|a[b++]<<8;this.g=a[b++]|a[b++]<<8;this.filename=
String.fromCharCode.apply(null,w?a.subarray(b,b+=this.h):a.slice(b,b+=this.h));this.X=w?a.subarray(b,b+=this.g):a.slice(b,b+=this.g);this.length=b-this.offset};
function $(a){var b=[],c={},d,g,f,h;if(!a.i){if(a.o===p){var e=a.input,k;if(!a.D)a:{var l=a.input,q;for(q=l.length-12;0<q;--q)if(l[q]===Z[0]&&l[q+1]===Z[1]&&l[q+2]===Z[2]&&l[q+3]===Z[3]){a.D=q;break a}m(Error("End of Central Directory Record not found"))}k=a.D;(e[k++]!==Z[0]||e[k++]!==Z[1]||e[k++]!==Z[2]||e[k++]!==Z[3])&&m(Error("invalid signature"));a.ha=e[k++]|e[k++]<<8;a.ja=e[k++]|e[k++]<<8;a.ka=e[k++]|e[k++]<<8;a.aa=e[k++]|e[k++]<<8;a.Q=(e[k++]|e[k++]<<8|e[k++]<<16|e[k++]<<24)>>>0;a.o=(e[k++]|
e[k++]<<8|e[k++]<<16|e[k++]<<24)>>>0;a.w=e[k++]|e[k++]<<8;a.v=w?e.subarray(k,k+a.w):e.slice(k,k+a.w)}d=a.o;f=0;for(h=a.aa;f<h;++f)g=new oa(a.input,d),g.parse(),d+=g.length,b[f]=g,c[g.filename]=f;a.Q<d-a.o&&m(Error("invalid file header size"));a.i=b;a.G=c}}t=W.prototype;t.Y=function(){var a=[],b,c,d;this.i||$(this);d=this.i;b=0;for(c=d.length;b<c;++b)a[b]=d[b].filename;return a};
t.r=function(a,b){var c;this.G||$(this);c=this.G[a];c===p&&m(Error(a+" not found"));var d;d=b||{};var g=this.input,f=this.i,h,e,k,l,q,s,r,M;f||$(this);f[c]===p&&m(Error("wrong index"));e=f[c].$;h=new pa(this.input,e);h.parse();e+=h.length;k=h.z;if(0!==(h.I&qa.N)){!d.password&&!this.j&&m(Error("please set password"));s=this.S(d.password||this.j);r=e;for(M=e+12;r<M;++r)ra(this,s,g[r]);e+=12;k-=12;r=e;for(M=e+k;r<M;++r)g[r]=ra(this,s,g[r])}switch(h.A){case na.O:l=w?this.input.subarray(e,e+k):this.input.slice(e,
e+k);break;case na.M:l=(new E(this.input,{index:e,bufferSize:h.J})).r();break;default:m(Error("unknown compression type"))}if(this.ba){var u=p,n,N="number"===typeof u?u:u=0,ka=l.length;n=-1;for(N=ka&7;N--;++u)n=n>>>8^A[(n^l[u])&255];for(N=ka>>3;N--;u+=8)n=n>>>8^A[(n^l[u])&255],n=n>>>8^A[(n^l[u+1])&255],n=n>>>8^A[(n^l[u+2])&255],n=n>>>8^A[(n^l[u+3])&255],n=n>>>8^A[(n^l[u+4])&255],n=n>>>8^A[(n^l[u+5])&255],n=n>>>8^A[(n^l[u+6])&255],n=n>>>8^A[(n^l[u+7])&255];q=(n^4294967295)>>>0;h.p!==q&&m(Error("wrong crc: file=0x"+
h.p.toString(16)+", data=0x"+q.toString(16)))}return l};t.L=function(a){this.j=a};function ra(a,b,c){c^=a.s(b);a.k(b,c);return c}t.k=V.prototype.k;t.S=V.prototype.T;t.s=V.prototype.s;v("Zlib.Unzip",W);v("Zlib.Unzip.prototype.decompress",W.prototype.r);v("Zlib.Unzip.prototype.getFilenames",W.prototype.Y);v("Zlib.Unzip.prototype.setPassword",W.prototype.L);}).call(this); //@ sourceMappingURL=unzip.min.js.map
;/** @license zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */(function() {'use strict';function n(e){throw e;}var p=void 0,aa=this;function r(e,c){var d=e.split("."),b=aa;!(d[0]in b)&&b.execScript&&b.execScript("var "+d[0]);for(var a;d.length&&(a=d.shift());)!d.length&&c!==p?b[a]=c:b=b[a]?b[a]:b[a]={}};var u="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array;new (u?Uint8Array:Array)(256);var v;for(v=0;256>v;++v)for(var w=v,ba=7,w=w>>>1;w;w>>>=1)--ba;function x(e,c,d){var b,a="number"===typeof c?c:c=0,f="number"===typeof d?d:e.length;b=-1;for(a=f&7;a--;++c)b=b>>>8^y[(b^e[c])&255];for(a=f>>3;a--;c+=8)b=b>>>8^y[(b^e[c])&255],b=b>>>8^y[(b^e[c+1])&255],b=b>>>8^y[(b^e[c+2])&255],b=b>>>8^y[(b^e[c+3])&255],b=b>>>8^y[(b^e[c+4])&255],b=b>>>8^y[(b^e[c+5])&255],b=b>>>8^y[(b^e[c+6])&255],b=b>>>8^y[(b^e[c+7])&255];return(b^4294967295)>>>0}
var z=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,
2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,
2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,
2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,
3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,
936918E3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],y=u?new Uint32Array(z):z;function A(){}A.prototype.getName=function(){return this.name};A.prototype.getData=function(){return this.data};A.prototype.G=function(){return this.H};r("Zlib.GunzipMember",A);r("Zlib.GunzipMember.prototype.getName",A.prototype.getName);r("Zlib.GunzipMember.prototype.getData",A.prototype.getData);r("Zlib.GunzipMember.prototype.getMtime",A.prototype.G);function C(e){var c=e.length,d=0,b=Number.POSITIVE_INFINITY,a,f,g,k,m,q,t,h,l;for(h=0;h<c;++h)e[h]>d&&(d=e[h]),e[h]<b&&(b=e[h]);a=1<<d;f=new (u?Uint32Array:Array)(a);g=1;k=0;for(m=2;g<=d;){for(h=0;h<c;++h)if(e[h]===g){q=0;t=k;for(l=0;l<g;++l)q=q<<1|t&1,t>>=1;for(l=q;l<a;l+=m)f[l]=g<<16|h;++k}++g;k<<=1;m<<=1}return[f,d,b]};var D=[],E;for(E=0;288>E;E++)switch(!0){case 143>=E:D.push([E+48,8]);break;case 255>=E:D.push([E-144+400,9]);break;case 279>=E:D.push([E-256+0,7]);break;case 287>=E:D.push([E-280+192,8]);break;default:n("invalid literal: "+E)}
var ca=function(){function e(a){switch(!0){case 3===a:return[257,a-3,0];case 4===a:return[258,a-4,0];case 5===a:return[259,a-5,0];case 6===a:return[260,a-6,0];case 7===a:return[261,a-7,0];case 8===a:return[262,a-8,0];case 9===a:return[263,a-9,0];case 10===a:return[264,a-10,0];case 12>=a:return[265,a-11,1];case 14>=a:return[266,a-13,1];case 16>=a:return[267,a-15,1];case 18>=a:return[268,a-17,1];case 22>=a:return[269,a-19,2];case 26>=a:return[270,a-23,2];case 30>=a:return[271,a-27,2];case 34>=a:return[272,
a-31,2];case 42>=a:return[273,a-35,3];case 50>=a:return[274,a-43,3];case 58>=a:return[275,a-51,3];case 66>=a:return[276,a-59,3];case 82>=a:return[277,a-67,4];case 98>=a:return[278,a-83,4];case 114>=a:return[279,a-99,4];case 130>=a:return[280,a-115,4];case 162>=a:return[281,a-131,5];case 194>=a:return[282,a-163,5];case 226>=a:return[283,a-195,5];case 257>=a:return[284,a-227,5];case 258===a:return[285,a-258,0];default:n("invalid length: "+a)}}var c=[],d,b;for(d=3;258>=d;d++)b=e(d),c[d]=b[2]<<24|b[1]<<
16|b[0];return c}();u&&new Uint32Array(ca);function G(e,c){this.i=[];this.j=32768;this.d=this.f=this.c=this.n=0;this.input=u?new Uint8Array(e):e;this.o=!1;this.k=H;this.w=!1;if(c||!(c={}))c.index&&(this.c=c.index),c.bufferSize&&(this.j=c.bufferSize),c.bufferType&&(this.k=c.bufferType),c.resize&&(this.w=c.resize);switch(this.k){case I:this.a=32768;this.b=new (u?Uint8Array:Array)(32768+this.j+258);break;case H:this.a=0;this.b=new (u?Uint8Array:Array)(this.j);this.e=this.D;this.q=this.A;this.l=this.C;break;default:n(Error("invalid inflate mode"))}}
var I=0,H=1;
G.prototype.g=function(){for(;!this.o;){var e=J(this,3);e&1&&(this.o=!0);e>>>=1;switch(e){case 0:var c=this.input,d=this.c,b=this.b,a=this.a,f=p,g=p,k=p,m=b.length,q=p;this.d=this.f=0;f=c[d++];f===p&&n(Error("invalid uncompressed block header: LEN (first byte)"));g=f;f=c[d++];f===p&&n(Error("invalid uncompressed block header: LEN (second byte)"));g|=f<<8;f=c[d++];f===p&&n(Error("invalid uncompressed block header: NLEN (first byte)"));k=f;f=c[d++];f===p&&n(Error("invalid uncompressed block header: NLEN (second byte)"));k|=
f<<8;g===~k&&n(Error("invalid uncompressed block header: length verify"));d+g>c.length&&n(Error("input buffer is broken"));switch(this.k){case I:for(;a+g>b.length;){q=m-a;g-=q;if(u)b.set(c.subarray(d,d+q),a),a+=q,d+=q;else for(;q--;)b[a++]=c[d++];this.a=a;b=this.e();a=this.a}break;case H:for(;a+g>b.length;)b=this.e({t:2});break;default:n(Error("invalid inflate mode"))}if(u)b.set(c.subarray(d,d+g),a),a+=g,d+=g;else for(;g--;)b[a++]=c[d++];this.c=d;this.a=a;this.b=b;break;case 1:this.l(da,ea);break;
case 2:fa(this);break;default:n(Error("unknown BTYPE: "+e))}}return this.q()};
var K=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],L=u?new Uint16Array(K):K,N=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,258,258],O=u?new Uint16Array(N):N,P=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0],Q=u?new Uint8Array(P):P,T=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],ga=u?new Uint16Array(T):T,ha=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,
13,13],U=u?new Uint8Array(ha):ha,V=new (u?Uint8Array:Array)(288),W,ia;W=0;for(ia=V.length;W<ia;++W)V[W]=143>=W?8:255>=W?9:279>=W?7:8;var da=C(V),X=new (u?Uint8Array:Array)(30),Y,ja;Y=0;for(ja=X.length;Y<ja;++Y)X[Y]=5;var ea=C(X);function J(e,c){for(var d=e.f,b=e.d,a=e.input,f=e.c,g;b<c;)g=a[f++],g===p&&n(Error("input buffer is broken")),d|=g<<b,b+=8;g=d&(1<<c)-1;e.f=d>>>c;e.d=b-c;e.c=f;return g}
function Z(e,c){for(var d=e.f,b=e.d,a=e.input,f=e.c,g=c[0],k=c[1],m,q,t;b<k;){m=a[f++];if(m===p)break;d|=m<<b;b+=8}q=g[d&(1<<k)-1];t=q>>>16;e.f=d>>t;e.d=b-t;e.c=f;return q&65535}
function fa(e){function c(a,c,b){var d,e,f,g;for(g=0;g<a;)switch(d=Z(this,c),d){case 16:for(f=3+J(this,2);f--;)b[g++]=e;break;case 17:for(f=3+J(this,3);f--;)b[g++]=0;e=0;break;case 18:for(f=11+J(this,7);f--;)b[g++]=0;e=0;break;default:e=b[g++]=d}return b}var d=J(e,5)+257,b=J(e,5)+1,a=J(e,4)+4,f=new (u?Uint8Array:Array)(L.length),g,k,m,q;for(q=0;q<a;++q)f[L[q]]=J(e,3);g=C(f);k=new (u?Uint8Array:Array)(d);m=new (u?Uint8Array:Array)(b);e.l(C(c.call(e,d,g,k)),C(c.call(e,b,g,m)))}
G.prototype.l=function(e,c){var d=this.b,b=this.a;this.r=e;for(var a=d.length-258,f,g,k,m;256!==(f=Z(this,e));)if(256>f)b>=a&&(this.a=b,d=this.e(),b=this.a),d[b++]=f;else{g=f-257;m=O[g];0<Q[g]&&(m+=J(this,Q[g]));f=Z(this,c);k=ga[f];0<U[f]&&(k+=J(this,U[f]));b>=a&&(this.a=b,d=this.e(),b=this.a);for(;m--;)d[b]=d[b++-k]}for(;8<=this.d;)this.d-=8,this.c--;this.a=b};
G.prototype.C=function(e,c){var d=this.b,b=this.a;this.r=e;for(var a=d.length,f,g,k,m;256!==(f=Z(this,e));)if(256>f)b>=a&&(d=this.e(),a=d.length),d[b++]=f;else{g=f-257;m=O[g];0<Q[g]&&(m+=J(this,Q[g]));f=Z(this,c);k=ga[f];0<U[f]&&(k+=J(this,U[f]));b+m>a&&(d=this.e(),a=d.length);for(;m--;)d[b]=d[b++-k]}for(;8<=this.d;)this.d-=8,this.c--;this.a=b};
G.prototype.e=function(){var e=new (u?Uint8Array:Array)(this.a-32768),c=this.a-32768,d,b,a=this.b;if(u)e.set(a.subarray(32768,e.length));else{d=0;for(b=e.length;d<b;++d)e[d]=a[d+32768]}this.i.push(e);this.n+=e.length;if(u)a.set(a.subarray(c,c+32768));else for(d=0;32768>d;++d)a[d]=a[c+d];this.a=32768;return a};
G.prototype.D=function(e){var c,d=this.input.length/this.c+1|0,b,a,f,g=this.input,k=this.b;e&&("number"===typeof e.t&&(d=e.t),"number"===typeof e.z&&(d+=e.z));2>d?(b=(g.length-this.c)/this.r[2],f=258*(b/2)|0,a=f<k.length?k.length+f:k.length<<1):a=k.length*d;u?(c=new Uint8Array(a),c.set(k)):c=k;return this.b=c};
G.prototype.q=function(){var e=0,c=this.b,d=this.i,b,a=new (u?Uint8Array:Array)(this.n+(this.a-32768)),f,g,k,m;if(0===d.length)return u?this.b.subarray(32768,this.a):this.b.slice(32768,this.a);f=0;for(g=d.length;f<g;++f){b=d[f];k=0;for(m=b.length;k<m;++k)a[e++]=b[k]}f=32768;for(g=this.a;f<g;++f)a[e++]=c[f];this.i=[];return this.buffer=a};
G.prototype.A=function(){var e,c=this.a;u?this.w?(e=new Uint8Array(c),e.set(this.b.subarray(0,c))):e=this.b.subarray(0,c):(this.b.length>c&&(this.b.length=c),e=this.b);return this.buffer=e};function $(e){this.input=e;this.c=0;this.m=[];this.s=!1}$.prototype.F=function(){this.s||this.g();return this.m.slice()};
$.prototype.g=function(){for(var e=this.input.length;this.c<e;){var c=new A,d=p,b=p,a=p,f=p,g=p,k=p,m=p,q=p,t=p,h=this.input,l=this.c;c.u=h[l++];c.v=h[l++];(31!==c.u||139!==c.v)&&n(Error("invalid file signature:"+c.u+","+c.v));c.p=h[l++];switch(c.p){case 8:break;default:n(Error("unknown compression method: "+c.p))}c.h=h[l++];q=h[l++]|h[l++]<<8|h[l++]<<16|h[l++]<<24;c.H=new Date(1E3*q);c.N=h[l++];c.M=h[l++];0<(c.h&4)&&(c.I=h[l++]|h[l++]<<8,l+=c.I);if(0<(c.h&8)){m=[];for(k=0;0<(g=h[l++]);)m[k++]=String.fromCharCode(g);
c.name=m.join("")}if(0<(c.h&16)){m=[];for(k=0;0<(g=h[l++]);)m[k++]=String.fromCharCode(g);c.J=m.join("")}0<(c.h&2)&&(c.B=x(h,0,l)&65535,c.B!==(h[l++]|h[l++]<<8)&&n(Error("invalid header crc16")));d=h[h.length-4]|h[h.length-3]<<8|h[h.length-2]<<16|h[h.length-1]<<24;h.length-l-4-4<512*d&&(f=d);b=new G(h,{index:l,bufferSize:f});c.data=a=b.g();l=b.c;c.K=t=(h[l++]|h[l++]<<8|h[l++]<<16|h[l++]<<24)>>>0;x(a,p,p)!==t&&n(Error("invalid CRC-32 checksum: 0x"+x(a,p,p).toString(16)+" / 0x"+t.toString(16)));c.L=
d=(h[l++]|h[l++]<<8|h[l++]<<16|h[l++]<<24)>>>0;(a.length&4294967295)!==d&&n(Error("invalid input size: "+(a.length&4294967295)+" / "+d));this.m.push(c);this.c=l}this.s=!0;var F=this.m,s,M,R=0,S=0,B;s=0;for(M=F.length;s<M;++s)S+=F[s].data.length;if(u){B=new Uint8Array(S);for(s=0;s<M;++s)B.set(F[s].data,R),R+=F[s].data.length}else{B=[];for(s=0;s<M;++s)B[s]=F[s].data;B=Array.prototype.concat.apply([],B)}return B};r("Zlib.Gunzip",$);r("Zlib.Gunzip.prototype.decompress",$.prototype.g);r("Zlib.Gunzip.prototype.getMembers",$.prototype.F);}).call(this); //@ sourceMappingURL=gunzip.min.js.map
;
/** @constructor */
function InputStream(buf) {
    this.buffer = buf;
    this.offset = 0;
    this.byteLength = buf.length;

    //We will use these shared memory arrays to
    //convert from bytes to the desired data type.
    this.convBuf = new ArrayBuffer(8);
    this.convUint8 = new Uint8Array(this.convBuf);
    this.convUint16 = new Uint16Array(this.convBuf);
    this.convInt32 = new Int32Array(this.convBuf);
    this.convUint32 = new Uint32Array(this.convBuf);
    this.convFloat32 = new Float32Array(this.convBuf);
    this.convFloat64 = new Float64Array(this.convBuf);
}


InputStream.prototype.seek = function(off) {
    this.offset = off;
};

InputStream.prototype.getBytes = function(len) {
    var ret = new Uint8Array(this.buffer.buffer, this.offset, len);
    this.offset += len;
    return ret;
};

InputStream.prototype.getVarints = function () {
    var b;
    var value = 0;
    var shiftBy = 0;
    do {
        b = this.buffer[this.offset++];
        value |= (b & 0x7f) << shiftBy;
        shiftBy += 7;
    } while (b & 0x80);
    return value;
}

InputStream.prototype.getUint8 = function() {
    return this.buffer[this.offset++];
};

InputStream.prototype.getUint16 = function() {
    this.convUint8[0] = this.buffer[this.offset++];
    this.convUint8[1] = this.buffer[this.offset++];
    return this.convUint16[0];
};

InputStream.prototype.getInt16 = function() {
    var tmp = this.getUint16();
    //make negative integer if the ushort is negative
    if (tmp > 0x7fff)
        tmp = tmp | 0xffff0000;
    return tmp;
};

InputStream.prototype.getInt32 = function() {
    var src = this.buffer;
    var dst = this.convUint8;
    var off = this.offset;
    dst[0] = src[off];
    dst[1] = src[off+1];
    dst[2] = src[off+2];
    dst[3] = src[off+3];
    this.offset += 4;
    return this.convInt32[0];
};

InputStream.prototype.getUint32 = function() {
    var src = this.buffer;
    var dst = this.convUint8;
    var off = this.offset;
    dst[0] = src[off];
    dst[1] = src[off+1];
    dst[2] = src[off+2];
    dst[3] = src[off+3];
    this.offset += 4;
    return this.convUint32[0];
};

InputStream.prototype.getFloat32 = function() {
    var src = this.buffer;
    var dst = this.convUint8;
    var off = this.offset;
    dst[0] = src[off];
    dst[1] = src[off+1];
    dst[2] = src[off+2];
    dst[3] = src[off+3];
    this.offset += 4;
    return this.convFloat32[0];
};

InputStream.prototype.getFloat64 = function() {
    var src = this.buffer;
    var dst = this.convUint8;
    var off = this.offset;
    for (var i=0; i<8; i++)
        dst[i] = src[off+i];
    this.offset += 8;
    return this.convFloat64[0];
};

InputStream.prototype.getString = function(len) {
    var src = this.buffer;
    var dst = "";

    for (var i = this.offset, iEnd = this.offset + len; i < iEnd; i++) {
        dst += String.fromCharCode(src[i]);
    }

    this.offset += len;

    return decodeURIComponent(escape(dst));
};

InputStream.prototype.reset = function (buf) {
    this.buffer = buf;
    this.offset = 0;
    this.byteLength = buf.length;
};
;


VBUtils = {



    deduceUVRepetition: function(mesh) {

        for (var p in mesh.vblayout) {

            if (p.indexOf("uv") != 0)
                continue;

            var baseOffset = mesh.vblayout[p].offset;
            var floatStride = mesh.vbstride;
            var vbf = mesh.vb;
            var vcount = mesh.vb.length/floatStride;

            for (var i = 0, offset = baseOffset; i<vcount; i++, offset += floatStride)
            {
                var u = vbf[offset];
                var v = vbf[offset+1];
                if (u > 2 || u < 0 || v > 2 || v < 0) {
                    mesh.vblayout[p].isPattern = true;
                    break;
                }
            }
        }
    },


    //Calculate the 3D bounding box and bounding sphere
    //of a mesh containing an interleaved vertex buffer
    computeBounds3D : function(mesh) {

        var minx = Infinity, miny = Infinity, minz = Infinity;
        var maxx = -Infinity, maxy = -Infinity, maxz = -Infinity;
        var i, offset, x, y, z;

        var floatStride = mesh.vbstride;
        var baseOffset = mesh.vblayout.position.offset;
        var vbf = mesh.vb;
        var vcount = mesh.vb.length/floatStride;

        for (i = 0, offset = baseOffset; i<vcount; i++, offset += floatStride)
        {
            x = vbf[offset];
            y = vbf[offset+1];
            z = vbf[offset+2];

            if (minx > x) minx = x;
            if (miny > y) miny = y;
            if (minz > z) minz = z;

            if (maxx < x) maxx = x;
            if (maxy < y) maxy = y;
            if (maxz < z) maxz = z;
        }

        var bb = mesh.boundingBox = new THREE.Box3();
        bb.min.set(minx, miny, minz);
        bb.max.set(maxx, maxy, maxz);

        var cx = 0.5*(minx + maxx), cy = 0.5*(miny + maxy), cz = 0.5*(minz + maxz);

        var bs = mesh.boundingSphere = new THREE.Sphere();
        bs.center.set(cx, cy, cz);

        var maxRadiusSq = 0;
        for (i = 0, offset = baseOffset; i < vcount; i++, offset += floatStride) {

            x = vbf[offset];
            y = vbf[offset+1];
            z = vbf[offset+2];

            var dx = x - cx;
            var dy = y - cy;
            var dz = z - cz;
            var distsq = dx*dx + dy*dy + dz*dz;
            if (distsq > maxRadiusSq)
                maxRadiusSq = distsq;
        }

        bs.radius = Math.sqrt(maxRadiusSq);

    }

};
;

var VBB_LINE_SEGMENT = 0x10,
    VBB_ARC_CIRCULAR = 0x20,
    VBB_ARC_ELLIPTICAL = 0x30,
    VBB_TEX_QUAD = 0x40,
    VBB_ONE_TRIANGLE = 0x50,

    VBB_INSTANCED_FLAG = 0,
    VBB_SEG_START_RIGHT = 1,
    VBB_SEG_START_LEFT = 2,
    VBB_SEG_END_RIGHT = 3,
    VBB_SEG_END_LEFT = 4;

var TAU = Math.PI * 2;

var VBB_COLOR_OFFSET = 6,
    VBB_DBID_OFFSET = 7,
    VBB_FLAGS_OFFSET = 8;


function VertexBufferBuilder(useInstancing)
{
    var MAX_VCOUNT = 65536;

    this.useInstancing = useInstancing;

    this.stride = 9;
    this.vb = new ArrayBuffer(this.stride * 4 * (this.useInstancing ? MAX_VCOUNT / 4 : MAX_VCOUNT));
    this.vbf = new Float32Array(this.vb);
    this.vbi = new Int32Array(this.vb);
    this.vcount = 0;

    if (!this.useInstancing)
        this.ib = new Uint16Array(MAX_VCOUNT);
    else
        this.ib = null;

    this.icount = 0;

    this.minx = this.miny = Infinity;
    this.maxx = this.maxy = -Infinity;

    //Keeps track of objectIds referenced by geometry in the VB
    this.dbIds = {};

    this.numEllipticals = 0;
    this.numCirculars = 0;
    this.numTriangleGeoms = 0;
}

VertexBufferBuilder.prototype.expandStride = function()
{
    //Currently hardcoded to expand by 4 floats.
    var expandBy = 3;

    var stride = this.stride;

    if (stride >= 12)
        return;

    var nstride = this.stride + expandBy;

    var nvb = new ArrayBuffer(nstride * (this.vb.byteLength / stride));

    var src = new Uint8Array(this.vb);
    var dst = new Uint8Array(nvb);

    for (var i = 0, iEnd = this.vcount; i<iEnd; i++) {
        var os = i * stride * 4;
        var od = i * nstride * 4;

        for (var j=0; j<stride * 4; j++)
            dst[od+j] = src[os+j];
    }


    this.vb = nvb;
    this.vbf = new Float32Array(nvb);
    this.vbi = new Int32Array(nvb);
    this.stride = nstride;
};

VertexBufferBuilder.prototype.addToBounds = function(x, y)
{
    if (x < this.minx)
        this.minx = x;
    if (x > this.maxx)
        this.maxx = x;
    if (y < this.miny)
        this.miny = y;
    if (y > this.maxy)
        this.maxy = y;
};

VertexBufferBuilder.prototype.setVertexFlag = function(vindex, layer, vertexId, geomType) {

    var val = geomType | vertexId | (layer << 16);

    this.vbi[vindex * this.stride + VBB_FLAGS_OFFSET] = val;
};



//Creates a non-indexed triangle geometry vertex (triangle vertex coords stored in single vertex structure)
VertexBufferBuilder.prototype.addVertexTriangleGeom = function(x1, y1, x2, y2, x3, y3, color, dbId)
{
    var vi = this.vcount;

    var repeat = this.useInstancing ? 1 : 4;

    for (var i=0; i<repeat; i++) {

        var offset = (vi+i) * this.stride;
        var vbf = this.vbf;

        vbf[offset] = x1;
        vbf[offset+1] = y1;
        vbf[offset+2] = x2;

        vbf[offset+3] = y2;
        vbf[offset+4] = x3;
        vbf[offset+5] = y3;

        this.vbi[offset+VBB_COLOR_OFFSET] = color;
        this.vbi[offset+VBB_DBID_OFFSET] = dbId;

        this.vcount++;
        this.dbIds[dbId] = 1;
    }

    return vi;
};


VertexBufferBuilder.prototype.addVertexLine = function(x, y, angle, distanceAlong, lineWidthHalf, color, dbId)
{
    var vi = this.vcount;

    var repeat = this.useInstancing ? 1 : 4;

    for (var i=0; i<repeat; i++) {
        var offset = (vi + i) * this.stride;
        var vbf = this.vbf;

        vbf[offset] = x;
        vbf[offset+1] = y;
        vbf[offset+2] = angle;

        vbf[offset+3] = distanceAlong;
        vbf[offset+4] = lineWidthHalf;
        vbf[offset+5] = 0; //TODO: line pattern phase

        this.vbi[offset+VBB_COLOR_OFFSET] = color;
        this.vbi[offset+VBB_DBID_OFFSET] = dbId;

        this.dbIds[dbId] = 1;
        this.vcount++;
    }

    return vi;
};


VertexBufferBuilder.prototype.addVertexArc = function(x, y, startAngle, endAngle, major, minor, tilt, lineWidthHalf, color, dbId)
{
    var vi = this.vcount;

    var repeat = this.useInstancing ? 1 : 4;

    for (var i=0; i<repeat; i++) {
        var offset = (vi+i) * this.stride;
        var vbf = this.vbf;

        vbf[offset] = x;
        vbf[offset+1] = y;
        vbf[offset+2] = startAngle;

        vbf[offset+3] = endAngle;
        vbf[offset+4] = lineWidthHalf;
        vbf[offset+5] = major;

        this.vbi[offset+VBB_COLOR_OFFSET] = color;
        this.vbi[offset+VBB_DBID_OFFSET] = dbId;

        //In the non-instanced case, the vertex flag
        //is at offset 8, so do not use that.
        if (major != minor) {
            vbf[offset+9] = minor;
            vbf[offset+10] = tilt;
        }

        this.dbIds[dbId] = 1;
        this.vcount++;
    }

    return vi;
};




//====================================================================================================
//====================================================================================================
// Indexed triangle code path can only be used when hardware instancing is not in use.
// Otherwise, the addTriangleGeom operation should be used to add simple triangles to the buffer.
//====================================================================================================
//====================================================================================================

VertexBufferBuilder.prototype.addVertex = function(x, y, angle, distanceAlong, lineWidthHalf, color, dbId, layer)
{
    if (this.useInstancing)
        return;//not supported if instancing is used.

    var vi = this.vcount;
    var offset = vi * this.stride;
    var vbf = this.vbf;

    vbf[offset] = x;
    vbf[offset+1] = y;
    vbf[offset+2] = angle;

    vbf[offset+3] = distanceAlong;
    vbf[offset+4] = lineWidthHalf;
    vbf[offset+5] = 0;

    this.vbi[offset+VBB_COLOR_OFFSET] = color;
    this.vbi[offset+VBB_DBID_OFFSET] = dbId;

    this.setVertexFlag(vi, layer, 0, 0);

    this.vcount++;
    this.dbIds[dbId] = 1;

    return vi;
};


VertexBufferBuilder.prototype.addVertexPolytriangle = function(x, y, angle, distanceAlong, lineWidthHalf, color, dbId, layer)
{
    if (this.useInstancing)
        return;//not supported if instancing is used.

    this.addVertex(x, y, angle, distanceAlong, lineWidthHalf, color, dbId, layer);

    this.addToBounds(x, y);
};

VertexBufferBuilder.prototype.setVertexColor = function(i, color)
{
    if (this.useInstancing)
        return;//not supported if instancing is used.

    var offset = i * this.stride;
    this.vbi[offset + VBB_COLOR_OFFSET] = color;
};

VertexBufferBuilder.prototype.addTriangle = function(i0, i1, i2) {

    if (this.useInstancing)
        return; //not supported if instancing is used.

    var ib = this.ib;

    var ii = this.icount;

    if (ii + 3 >= ib.length) {
        var ibnew = new Uint16Array(ib.length * 2);
        for (var i=0; i<ii; i++) {
            ibnew[i] = ib[i];
        }
        this.ib = ib = ibnew;
    }

    ib[ii] = i0;
    ib[ii+1] = i1;
    ib[ii+2] = i2;

    this.icount += 3;
};

//====================================================================================================
//====================================================================================================
// End indexed triangle code path.
//====================================================================================================
//====================================================================================================


VertexBufferBuilder.prototype.finalizeQuad = function(v, geomType, layer) {

    if (!this.useInstancing) {
        this.addTriangle(v, v+1, v+2);
        this.addTriangle(v, v+2, v+3);

        //Set the flags specific to each vertex
        this.setVertexFlag(v,   layer, VBB_SEG_START_RIGHT, geomType);
        this.setVertexFlag(v+1, layer, VBB_SEG_END_RIGHT,   geomType);
        this.setVertexFlag(v+2, layer, VBB_SEG_END_LEFT,    geomType);
        this.setVertexFlag(v+3, layer, VBB_SEG_START_LEFT,  geomType);
    } else {
        //Set the flags specific to each vertex
        this.setVertexFlag(v,   layer, VBB_INSTANCED_FLAG, geomType);
    }
};


VertexBufferBuilder.prototype.addSegment = function(x1, y1, x2, y2, lineWidth, color, dbId, layer)
{
    var dx = x2 - x1;
    var dy = y2 - y1;
    var theta = 0;

    if (dx || dy )
        theta = Math.atan2(dy, dx);

    var segLen = Math.sqrt(dx*dx + dy*dy);

    //We store a radius value in the vertex, so halve it
    lineWidth *= 0.5;

    //Add four vertices for the bbox of this line segment
    //This call sets the stuff that's common for all four
    var v = this.addVertexLine(x1, y1, theta, segLen, lineWidth, color, dbId);

    this.finalizeQuad(v, VBB_LINE_SEGMENT, layer);

    this.addToBounds(x1, y1);
    this.addToBounds(x2, y2);
};


//Creates a non-indexed triangle geometry (triangle vertex coords stored in single vertex structure)
VertexBufferBuilder.prototype.addTriangleGeom = function(x1, y1, x2, y2, x3, y3, color, dbId, layer) {

    this.numTriangleGeoms++;

    var v = this.addVertexTriangleGeom(x1, y1, x2, y2, x3, y3, color, dbId, layer);

    this.finalizeQuad(v, VBB_ONE_TRIANGLE, layer);

    this.addToBounds(x1, y1);
    this.addToBounds(x2, y2);
    this.addToBounds(x3, y3);
};


VertexBufferBuilder.prototype.addCircularArc = function(cx, cy, start, end, radius, lineWidth, color, dbId, layer) {

    this.numCirculars++;

    //Add two zero length segments as round caps at the end points
    {
        //If it's a full ellipse, then we don't need caps
        //If it's a full ellipse, then we don't need caps
        var range = Math.abs(start - end);
        if (range > 0.0001 && Math.abs(range - TAU) > 0.0001)
        {
            var sx = cx + radius * Math.cos(start);
            var sy = cy + radius * Math.sin(start);

            this.addSegment(sx, sy, sx, sy, lineWidth, color, dbId, layer);

            var ex = cx + radius * Math.cos(end);
            var ey = cy + radius * Math.sin(end);

            this.addSegment(ex, ey, ex, ey, lineWidth, color, dbId, layer);

            //TODO: also must add all the vertices at all multiples of PI/2 in the start-end range
            //to get exact bounds
        }
        else
        {
            this.addToBounds(cx - radius, cy - radius);
            this.addToBounds(cx + radius, cy + radius);
        }
    }

    lineWidth *= 0.5;

    var v = this.addVertexArc(cx, cy, start, end, radius, radius, 0, lineWidth, color, dbId);

    this.finalizeQuad(v, VBB_ARC_CIRCULAR, layer);
};


VertexBufferBuilder.prototype.addEllipticalArc = function(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId, layer) {

    //color = 0xff00ffff;

    this.expandStride();
    this.numEllipticals++;

    //Add two zero length segments as round caps at the end points
    {
        //If it's a full ellipse, then we don't need caps
        var range = Math.abs(start - end);
        if (Math.abs(range - TAU) > 0.0001)
        {
            var sx = cx + major * Math.cos(start);
            var sy = cy + minor * Math.sin(start);

            this.addSegment(sx, sy, sx, sy, lineWidth, color, dbId, layer);

            var ex = cx + major * Math.cos(end);
            var ey = cy + minor * Math.sin(end);

            this.addSegment(ex, ey, ex, ey, lineWidth, color, dbId, layer);

            //TODO: also must add all the vertices at all multiples of PI/2 in the start-end range
            //to get exact bounds
        }
        else
        {
            this.addToBounds(cx - major, cy - minor);
            this.addToBounds(cx + major, cy + minor);
        }
    }


    lineWidth *= 0.5;

    var v = this.addVertexArc(cx, cy, start, end, major, minor, tilt, lineWidth, color, dbId);

    this.finalizeQuad(v, VBB_ARC_ELLIPTICAL, layer);

    //Testing caps
    if (0){
        //If it's a full ellipse, then we don't need caps
        var range = Math.abs(start - end);
        if (Math.abs(range - TAU) > 0.0001)
        {
            var sx = cx + major * Math.cos(start);
            var sy = cy + minor * Math.sin(start);

            this.addSegment(sx, sy, sx, sy, 2 * lineWidth, 0xff00ffff, dbId, layer);

            var ex = cx + major * Math.cos(end);
            var ey = cy + minor * Math.sin(end);

            this.addSegment(ex, ey, ex, ey, 2 * lineWidth, 0xff00ffff, dbId, layer);
        }
    }

};


VertexBufferBuilder.prototype.addTexturedQuad = function(x, y, w, h, dbId, layer)
{
    var hh = h * 0.5;

    //Height is specified using the line weight field.
    //This will result in height being clamped to at least one pixel
    //but that's ok (zero height for an image would be rare).
    var v = this.addVertexLine(x, y + hh, 0, w, hh, 0xff00ffff, dbId);

    this.finalizeQuad(v, VBB_TEX_QUAD, layer);

    this.addToBounds(x, y);
    this.addToBounds(x+w, y+h);
};

VertexBufferBuilder.prototype.isFull = function(addCount) {
    if (!addCount)
        addCount = 3;

    if (this.useInstancing)
        return (this.vcount*4 + addCount > 32767);
    else
        return (this.vcount + addCount > 32767);
};

VertexBufferBuilder.prototype.toMesh = function() {

    var mesh = {};

    mesh.vb = new Float32Array(this.vb.slice(0, this.vcount * this.stride * 4));
    mesh.vbstride = this.stride;

    var d = this.useInstancing ? 1 : 0;

    mesh.vblayout = {
        "fields1" :    {offset: 0,                  itemSize: 3, bytesPerItem: 4, divisor: d },
        "fields2" :    {offset: 3,                  itemSize: 3, bytesPerItem: 4, divisor: d },
        "color4b":     {offset: VBB_COLOR_OFFSET,   itemSize: 4, bytesPerItem: 1, divisor: d, normalize: true },
        "dbId4b":      {offset: VBB_DBID_OFFSET,    itemSize: 4, bytesPerItem: 1, divisor: d, normalize: true},
        "flags4b":     {offset: VBB_FLAGS_OFFSET,   itemSize: 4, bytesPerItem: 1, divisor: d, normalize: false}
    };

    //Are we using an expanded vertex layout -- then add the extra attribute to the layout
    if (this.stride > 9) {
        mesh.vblayout["extraParams"] = {offset: 9, itemSize: 3, bytesPerItem: 4, divisor: d, normalize: false};
    }

    if (this.useInstancing) {

        for (var attr in mesh.vblayout) {
            mesh.vblayout[attr].divisor = 1;
        }

        mesh.numInstances = this.vcount;

        //Set up trivial vertexId and index attributes

        var instFlags = new Int32Array(4);
        instFlags[0] = VBB_SEG_START_RIGHT;
        instFlags[1] = VBB_SEG_END_RIGHT;
        instFlags[2] = VBB_SEG_END_LEFT;
        instFlags[3] = VBB_SEG_START_LEFT;

        mesh.vblayout.instFlags4b = { offset:0, itemSize: 4, bytesPerItem: 1, normalize: false, divisor: 0 };
        mesh.vblayout.instFlags4b.array = instFlags.buffer;

        var idx = mesh.indices = new Uint16Array(6);
        idx[0] = 0; idx[1] = 1; idx[2] = 2;
        idx[3] = 0; idx[4] = 2; idx[5] = 3;
    }
    else {

        mesh.indices = new Uint16Array(this.ib.buffer.slice(0, this.icount*2));
    }

    mesh.dbIds = this.dbIds;

    var bb = mesh.boundingBox = new THREE.Box3();
    var sz = Math.max(this.maxx-this.minx, this.maxy - this.miny);
    bb.min.set(this.minx, this.miny, -sz * 1e-3);
    bb.max.set(this.maxx, this.maxy, sz * 1e-3);

    //Also compute a rough bounding sphere
    var bs = mesh.boundingSphere = new THREE.Sphere();
    bs.center.copy(mesh.boundingBox.center());
    bs.radius = 0.5 * mesh.boundingBox.size().length();

    return mesh;
};
;


//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================


function readOpenCTM_RAW(stream, mesh) {

    var readOpenCTMString = function() {
        return stream.getString(stream.getInt32());
    };

    //Now do the data reads
    var name = stream.getString(4);
    if (name != "INDX") return null;

    var vcount = mesh.vertexCount;
    var tcount = mesh.triangleCount;

    //We cannot use a straight memcopy for the indices
    //since we have to downcast from OCTM uint32
    //to uint16.
    var meshindices = mesh.indices = new Uint16Array(tcount*3);
    for (var i=0, iEnd=tcount*3; i<iEnd; i++)
        meshindices[i] = stream.getInt32();

    name = stream.getString(4);
    if (name != "VERT") return null;

    var stride = mesh.vbstride;
    var vbf = mesh.vb;

    //Read positions
    for (var i= 0, offset=mesh.vblayout['position'].offset;
         i<vcount;
         i++, offset += stride)
    {
        vbf[offset] =   stream.getFloat32();
        vbf[offset+1] = stream.getFloat32();
        vbf[offset+2] = stream.getFloat32();
    }

    //Read normals
    if (mesh.flags & 1) {
        name = stream.getString(4);
        if (name != "NORM") return null;

        for (var i=0, offset=mesh.vblayout['normal'].offset;
             i<vcount;
             i++, offset += stride)
         {
            vbf[offset] =   stream.getFloat32();
            vbf[offset+1] = stream.getFloat32();
            vbf[offset+2] = stream.getFloat32();
        }
    }

    //Read uv layers
    for (var t=0; t<mesh.texMapCount; t++) {
        name = stream.getString(4);
        if (name != "TEXC") return null;

        var uv = {
            name : readOpenCTMString(),
            file : readOpenCTMString()
        };
        mesh.uvs.push(uv);

        var uvname = "uv";
        if (t)
            uvname += (t+1).toString();

        for (var i=0, offset=mesh.vblayout[uvname].offset;
             i<vcount;
             i++, offset += stride)
        {
            vbf[offset] =   stream.getFloat32();
            vbf[offset+1] = stream.getFloat32();
        }
    }

    //Read vertex colors (and skip any other attributes that we don't know)
    for (var t=0; t<mesh.attribMapCount; t++) {
        name = stream.getString(4);
        if (name != "ATTR") return null;

        var attr = {
            name : readOpenCTMString()
        };

        //Special case of vertex colors
        if (attr.name.indexOf("Color") != -1) {

            for (var i=0, offset=mesh.vblayout['color'].offset;
                 i<vcount;
                 i++, offset += stride) {
                vbf[offset] = stream.getFloat32();
                vbf[offset+1] = stream.getFloat32();
                vbf[offset+2] = stream.getFloat32();
                stream.getFloat32(); //skip past alpha -- currently our shader expects a vec3 vertex color.
            }

        } else {
            //Other attributes, though we don't know what to do with those
            mesh.attrs.push(attr);
            stream.getBytes(vcount*16); //skip past
        }
    }
}


//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================
//=====================================================================


var readOpenCTM = function(stream) {

    var readOpenCTMString = function() {
        return stream.getString(stream.getInt32());
    };

    var fourcc = stream.getString(4);
    if (fourcc != "OCTM") return null;

    var version = stream.getInt32();
    if (version != 5) return null;

    var method = stream.getString(3);
    stream.getUint8(); //read the last 0 char of the RAW or MG2 fourCC.

    var mesh = {
        stream: null,
        vertices:   null,
        indices:    null,
        normals:    null,
        colors:     null,
        uvs:        [],
        attrs:      []
    };

    mesh.vertexCount = stream.getInt32();
    mesh.triangleCount = stream.getInt32();
    mesh.texMapCount = stream.getInt32();
    mesh.attribMapCount = stream.getInt32();
    mesh.flags = stream.getInt32();
    mesh.comment = readOpenCTMString();


    //Calculate stride of the interleaved buffer we need
    mesh.vbstride = 3; //position is always there
    if (mesh.flags & 1)
        mesh.vbstride += 3; //normal
    mesh.vbstride += 2 * (mesh.texMapCount || 0); //texture coords
    if (mesh.attribMapCount > 0)
        mesh.vbstride += 3; //we only interleave the color attribute, and we reduce that to RGB from ARGB.

    mesh.vblayout = {};
    var offset = 0;

    mesh.vblayout['position'] = { offset: offset, itemSize: 3 };

    offset += 3;
    if (mesh.flags & 1) {
        mesh.vblayout['normal'] = { offset : offset, itemSize : 3 };
        offset += 3;
    }
    if (mesh.texMapCount) {
        for (var i=0; i<mesh.texMapCount; i++) {
            var uvname = "uv";
            if (i)
                uvname += (i+1).toString();

            mesh.vblayout[uvname] = { offset : offset, itemSize: 2 };
            offset += 2;
        }
    }
    if (mesh.attribMapCount) {
        mesh.vblayout['color'] = { offset : offset, itemSize : 3};
    }

    mesh.vb = new Float32Array(mesh.vertexCount * mesh.vbstride);


    //Now read and populate the mesh data
    if (method == "RAW") {
        readOpenCTM_RAW(stream, mesh);
        VBUtils.deduceUVRepetition(mesh);
        VBUtils.computeBounds3D(mesh);
        return mesh;
    }
    else if (method == "MG2") {
        readOpenCTM_MG2(stream, mesh);
        VBUtils.deduceUVRepetition(mesh);
        VBUtils.computeBounds3D(mesh);
        return mesh;
    }
    else
        return null;
};


var readLines = function(pfr, tse) {

    // Initialize mesh
    var mesh = {
        isLines:    true,
        vertices:   null,
        indices:    null,
        colors:     null,
        normals:    null,
        uvs:        [],
        attrs:      []
    };

    // Read vertex count, index count, polyline bound count
    var indexCount;
    var polyLineBoundCount;
    if ( tse.version > 1 ) {
        mesh.vertexCount   = pfr.readU16();
        indexCount         = pfr.readU16();
        polyLineBoundCount = pfr.readU16();
    }
    else {
        mesh.vertexCount   = pfr.readU32V();
        indexCount         = pfr.readU32V();
        polyLineBoundCount = pfr.readU32V();
    }

    // Determine if color is defined
    var  hasColor = (pfr.stream.getUint8() != 0);


    //Calculate stride of the interleaved buffer we need
    mesh.vbstride = 3; //position is always there
    if (hasColor)
        mesh.vbstride += 3; //we only interleave the color attribute, and we reduce that to RGB from ARGB.

    mesh.vblayout = {};
    var offset = 0;

    mesh.vblayout['position'] = { offset: offset, itemSize: 3 };

    offset += 3;
    if (hasColor) {
        mesh.vblayout['color'] = { offset : offset, itemSize : 3};
    }

    mesh.vb = new Float32Array(mesh.vertexCount * mesh.vbstride);


    // Read vertices
    var vbf = mesh.vb;
    var stride = mesh.vbstride;
    var stream = pfr.stream;
    for (var i= 0, offset = mesh.vblayout['position'].offset, iEnd=mesh.vertexCount;
         i<iEnd;
         i++, offset += stride)
    {
        vbf[offset] = stream.getFloat32();
        vbf[offset+1] = stream.getFloat32();
        vbf[offset+2] = stream.getFloat32();
    }

    // Determine color if specified
    if (hasColor) {
        for (var c=0, offset=mesh.vblayout['color'].offset, cEnd=mesh.vertexCount;
             c<cEnd;
             c++, offset += stride)
        {
            vbf[offset] = stream.getFloat32();
            vbf[offset+1] = stream.getFloat32();
            vbf[offset+2] = stream.getFloat32();
            stream.getFloat32(); //skip alpha -- TODO: convert color to ARGB 32 bit integer in the vertex layout and shader
        }
    }

    // Copies bytes from buffer
    var forceCopy = function(b) {
        return b.buffer.slice(b.byteOffset, b.byteOffset + b.length);
    };

    // Read indices and polyline bound buffer
    var indices;
    var polyLineBoundBuffer;
    if ( tse.version > 1 ) {
        // 16 bit format
        indices = new Uint16Array(forceCopy(stream.getBytes(indexCount*2)));
        polyLineBoundBuffer = new Uint16Array(forceCopy(stream.getBytes(polyLineBoundCount*2)));
    }
    else {
        // 32 bit format
        indices = new Int32Array(forceCopy(stream.getBytes(indexCount*4)));
        polyLineBoundBuffer = new Int32Array(forceCopy(stream.getBytes(polyLineBoundCount*4)));
    }

    // three.js uses GL-style index pairs in its index buffer. We need one pair
    // per segment in each polyline
    var indexPairs = polyLineBoundBuffer[polyLineBoundCount-1] - polyLineBoundCount + 1;

    mesh.indices = new Uint16Array(2*indexPairs);

    // Extract the individual line segment index pairs
    var meshIndex = 0;
    for (var i=0; i+1 < polyLineBoundCount; i++){
        for(var j = polyLineBoundBuffer[i]; j+1 < polyLineBoundBuffer[i+1]; j++){
            mesh.indices[meshIndex++] = indices[j];
            mesh.indices[meshIndex++] = indices[j+1];
        }
    }

    VBUtils.computeBounds3D(mesh);

    return mesh;
};



function readGeometry(pfr, entry, format) {
    var tse = pfr.seekToEntry(entry);
    if (!tse)
        return null;

    if (tse.entryType == "Autodesk.CloudPlatform.OpenCTM") {
        return readOpenCTM(pfr.stream);
    }
    else if (tse.entryType == "Autodesk.CloudPlatform.Lines") {
        return readLines(pfr, tse);
    }

    return null;
}
;//Convert from LMV materials json to THREE.js materials
function convertMaterials(svf)
{
    var parseMaterialColor = function (props, name) {
        var ret = new THREE.Color();
        if (!props || !props["colors"])
            return ret.setRGB(1,0,0); //error -- return red

        var cobj = props["colors"][name];
        if (!cobj)
            return ret.setRGB(0,0,0); //ok -- color is not defined

        var vals = cobj["values"];
        if (!vals || !vals.length)
            return ret.setRGB(1,0,0); //error

        var rgb = vals[0];
        return ret.setRGB(rgb["r"], rgb["g"], rgb["b"]);
    }

    var parseMaterialScalar = function(props, name) {
        if (!props || !props["scalars"])
            return 0;

        var vobj = props["scalars"][name];
        if (!vobj)
            return undefined;

        return vobj["values"][0];
    };

    var parseMaterialBoolean = function(props, name) {
        if (!props || !props["booleans"])
            return 0;

        var vobj = props["booleans"];
        if (!vobj)
            return undefined;

        return vobj[name];
    };

    //get outer Protein materials block
    var prmats = svf.materials["materials"];
    svf.simplemats = {};

    for (var p in prmats)
    {
        var matObj = prmats[p];

        var userAssets = matObj["userassets"];
        var innerMats = matObj["materials"];

        var innerMat = innerMats[userAssets[0]];
        if (innerMat && innerMat["definition"] == "SimplePhong")
        {
            var props = innerMat["properties"];

            var tm = {};

            tm.tag = innerMat["tag"];
            tm.proteinType = innerMat["proteinType"];
            if (tm.proteinType === undefined)
                tm.proteinType = null;

            tm.ambient =  parseMaterialColor(props, "generic_ambient");
            tm.color =    parseMaterialColor(props, "generic_diffuse");
            tm.specular = parseMaterialColor(props, "generic_specular");
            tm.emissive = parseMaterialColor(props, "generic_emissive");

            var shiny = parseMaterialScalar(props, "generic_glossiness");
            if (!shiny)
                shiny = 30;

            tm.shininess = shiny;

            var transparency = parseMaterialScalar(props, "generic_transparency");
            if (!transparency)
                transparency = 0.0;
            tm.opacity = 1.0 - transparency;

            var reflectivity = parseMaterialScalar(props, "generic_reflectivity_at_0deg");
            if (!reflectivity)
                reflectivity = 0.0;
            tm.reflectivity = reflectivity;

            var isMetal = parseMaterialBoolean(props, "generic_is_metal");
            if (isMetal !== undefined)
                tm.metal = isMetal;

            var backfaceCulling = parseMaterialBoolean(props, "generic_backface_cull");
            if (backfaceCulling !== undefined)
                tm.doubleSided = !backfaceCulling;

            tm.transparent = innerMat["transparent"];

            var textures = innerMat["textures"];
            for (var texType in textures)
            {
                var texDef = textures[texType];
                var connection = texDef["connections"][0];

                var innerTex = innerMats[connection];
                var texProps = innerTex["properties"];
                var uri = texProps["uris"]["unifiedbitmap_Bitmap"]["values"][0];
                var texField = null;
                if (uri)
                {
                    //Store texture URI as string here,
                    //but will have to convert to THREE.Texture once 
                    //we are on the other side of the loader thread.
                    if (texType == "generic_diffuse") {
                        texField = "map";

                        if (!tm.color || (tm.color.r == 0 && tm.color.g == 0 && tm.color.b == 0)) {
                            tm.color = new THREE.Color(1,1,1);
                        }
                    }
                    else if (texType == "generic_bump") {
                        var isNormal = parseMaterialBoolean(props, "generic_bump_is_normal");

                        if (isNormal)
                            texField = "normalMap";
                        else
                            texField = "bumpMap";

                        tm.bumpScale = parseMaterialScalar(props, "generic_bump_amount");
                    }
                    else if (texType == "generic_specular") {
                        texField = "specularMap";
                    }
                    else if (texType == "generic_reflection") {
                        //Environment maps from SVF turned off since we have better defaults
                        //texField = "envMap";
                    }
                    else if (texType == "generic_alpha")
                        texField = "alphaMap";
                }

                if (texField)
                {
                    tm["uri_"+texField] = uri;
                    var tmp = parseMaterialScalar(texProps, "texture_UScale");
                    if (tmp)tm["uscale_"+texField] = tmp;

                    tmp = parseMaterialScalar(texProps, "texture_VScale");
                    if (tmp) tm["vscale_"+texField] = tmp;
                }
            }

            svf.simplemats[p] = tm;
        }
        else
        {
            //We can't handle anything other than Simple mat.
        }
    }
}
;function readLightDefinition(pfr, entry) {
    var tse = pfr.seekToEntry(entry);
    if (!tse)
        return null;
    if (tse.version > 1 /*Constants::LightDefinitionVersion*/)
        return null;

    var s = pfr.stream;

    var light = {
        position:   pfr.readVector3f(),
        dir:        pfr.readVector3f(),
        r:          s.getFloat32(),
        g:          s.getFloat32(),
        b:          s.getFloat32(),
        intensity:  s.getFloat32(),
        spotAngle:  s.getFloat32(),
        size:       s.getFloat32(),
        type:       s.getUint8()
    };

    //TODO: create the THREE.js camera here, instead of returning this object.
    return light;
}
;
function readCameraDefinition(pfr, inst) {
    var entry = inst.definition;
    var tse = pfr.seekToEntry(entry);
    if (!tse)
        return null;
    if (tse.version > 2 /*Constants::CameraDefinitionVersion*/)
        return null;

    var s = pfr.stream;
    var cam = {
        isPerspective : !s.getUint8(), /* 0 = perspective, 1 = ortho */
        position : pfr.readVector3f(),
        target: pfr.readVector3f(),
        up: pfr.readVector3f(),
        aspect: s.getFloat32(),
        fov: THREE.Math.radToDeg(s.getFloat32())
    };
    if (tse.version < 2) {
        // Skip the clip planes for old files.
        s.getFloat32();
        s.getFloat32();
    }

    cam.orthoScale = s.getFloat32();

    return cam;
};
//FragList represents an array of fragments, stored in Structure of Arrays form
//which allows us to free some parts easily and transfer the fragment information in large chunks.

/** @constructor */
function FragList() {
    this.length = 0;
    this.numLoaded = 0;

    this.boxes = null;
    this.transforms = null;
    this.materials = null;

    this.packIds = null;
    this.entityIndexes = null;

    this.fragId2dbId = null;
    this.mesh2frag = null;
}


function readGeometryMetadata(pfr, geoms)
{
    var numGeoms = pfr.getEntryCounts();
    var stream = pfr.stream;

    geoms.length = numGeoms;
    var fragTypes = geoms.fragTypes = new Uint8Array(numGeoms);
    var primCounts = geoms.primCounts = new Uint16Array(numGeoms);
    var packIds = geoms.packIds = new Int32Array(numGeoms);
    var entityIndexes = geoms.entityIndexes = new Int32Array(numGeoms);

    for (var g = 0, gEnd = numGeoms; g<gEnd; g++) {
        var tse = pfr.seekToEntry(g);
        if (!tse)
            return;
        //No version check needed yet
        /*
         if (tse.version > 0)
         return;
         */

        fragTypes[g] = stream.getUint8();
        //skip past object space bbox -- we don't use that
        stream.seek(stream.offset + 24);
        primCounts[g] = stream.getUint16();
        packIds[g] = parseInt(pfr.readString());
        entityIndexes[g] = pfr.readU32V();
    }
}


function readFragments(pfr, frags) {

    //Initialize all the fragments structures
    //once we know how many fragments we have.
    var numFrags = pfr.getEntryCounts();
    var stream = pfr.stream;

    frags.length = numFrags;
    frags.numLoaded = 0;

    //Allocate flat array per fragment property
    var fragBoxes       = frags.boxes =                 new Float32Array(6*numFrags);
    var transforms      = frags.transforms =            new Float32Array(16*numFrags);
    var materials       = frags.materials =             new Int32Array(numFrags);
    var packIds         = frags.packIds =               new Int32Array(numFrags);
    var entityIndexes   = frags.entityIndexes =         new Int32Array(numFrags);
    var geomDataIndexes = frags.geomDataIndexes =       new Int32Array(numFrags);
    var fragId2dbId     = frags.fragId2dbId =           new Int32Array(numFrags); //NOTE: this potentially truncates IDs bigger than 4 billion -- can be converted to array if needed.

    //Helper functions used by the main fragment read loop.

    function readBoundingBox(entry) {
        var offset = entry * 6;
        for (var i=0; i<6; i++)
            fragBoxes[offset++] = stream.getFloat32();
    }

    function readBoundingBoxOffset(entry, transforms, index) {
        var offset = entry * 6;
        for (var i=0; i<6; i++)
            fragBoxes[offset++] = stream.getFloat32() + transforms[index + (i % 3)];
    }

    //Spin through all the fragments now
    for (var entry=0, eEnd=frags.length; entry<eEnd; entry++) {
        var tse = pfr.seekToEntry(entry);
        if (!tse)
            return;
        if (tse.version > 5)
            return;

        var isVisible = true;
        if ( tse.version > 4 ) {
            // Fragments v5+ include a flag byte, the LSB of which denotes
            // visibility
            var flags = pfr.readU8();
            isVisible = (flags & 0x01) != 0;
        }

        materials[entry] = pfr.readU32V();

        if (tse.version > 2) {
            //In case it's new style fragment that
            //points to a geometry metadata entry
            geomDataIndexes[entry] = pfr.readU32V();
        }
        else {
            //Old style fragment, pack reference is directly
            //encoded in the fragment entry
            packIds[entry] = parseInt(pfr.readString());
            entityIndexes[entry] = pfr.readU32V();
        }

        pfr.readTransform(entry, transforms, 16*entry);

        if (tse.version > 3) {
            // With this version the transforms translations is subtracted from the BB
            readBoundingBoxOffset(entry, transforms, 16*entry + 12);
        }
        else
            readBoundingBox(entry);

        if (tse.version > 1) {
            fragId2dbId[entry] = pfr.readU32V();
        }
        // Skip reading path ID which is not in use now.
        // pfr.readPathID();
    }
}

// Filter fragments based on specified object id list, by picking
// up fragment whose id is in the specified id list, and dropping others.
// This is used to produce a list of fragments that matches a search hit.
function filterFragments(frags, ids) {
    frags.length = ids.length;
    frags.numLoaded = 0;
    var numFrags = frags.length;
    var bb = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];

    var fragBoxes       = new Float32Array(6 * numFrags);
    var transforms      = new Float32Array(16 * numFrags);
    var materials       = new Int32Array(numFrags);
    var packIds         = new Int32Array(numFrags);
    var entityIndexes   = new Int32Array(numFrags);
    var mesh2frag = {};

    for (var i = 0; i < ids.length; ++i) {
        var index = ids[i];

        var idxOld = index * 6;
        var idxNew = i * 6;
        for (var j = 0; j < 6; ++j)
            fragBoxes[idxNew++] = frags.boxes[idxOld++];

        idxOld = index * 16;
        idxNew = i * 16;
        for (var j = 0; j < 16; ++j)
            transforms[idxNew++] = frags.transforms[idxOld++];

        materials[i] = frags.materials[index];
        packIds[i] = frags.packIds[index];
        entityIndexes[i] = frags.entityIndexes[index];

        // TODO: consolidate this with addToMeshMap.
        var meshID = frags.packIds[index] + ":" + frags.entityIndexes[index];
        var meshRefs = mesh2frag[meshID];
        if (meshRefs == undefined) {
            mesh2frag[meshID] = i;
        }
        else if (!Array.isArray(meshRefs)) {
            mesh2frag[meshID] = [meshRefs, i];
        }
        else {
            meshRefs.push(i);
        }

        var bbIndex = i * 6;
        for (var j = 0; j < 3; ++j)
            if (fragBoxes[bbIndex + j] < bb[j])
                bb[j] = fragBoxes[bbIndex + j];
        for (var j = 3; j < 6; ++j)
            if (fragBoxes[bbIndex + j] > bb[j])
                bb[j] = fragBoxes[bbIndex + j];
    }

    frags.boxes = fragBoxes;
    frags.transforms = transforms;
    frags.materials = materials;
    frags.packIds = packIds;
    frags.entityIndexes = entityIndexes;
    frags.mesh2frag = mesh2frag;

    return bb;
}

;function readInstance(pfr, entry) {
    var tse = pfr.seekToEntry(entry);
    if (!tse)
        return null;
    if (tse.version > 2 /*Constants::InstanceVersion*/)
        return null;

    var isVisible = true;
    if ( tse.version > 1 ) {
        // Instances v2+ include a flag byte, the LSB of which denotes visibility
        var flags = pfr.readU8();
        isVisible = (flags & 0x01) != 0;
    }

    return {
        definition: pfr.stream.getUint32(),
        transform: pfr.readTransform(),
        instanceNodePath: pfr.readPathID()
    }
}

;/** @constructor */
function Package() {
    this.manifest = null;

    this.materials = null; //The materials json as it came from the SVF
    this.simplemats = null; //parsed simple phong materials

    this.metadata = null; //metadata json

    this.fragments = null; //will be a FragList

    this.geompacks = [];

    //TODO:
    //Those will not be parsed immediately
    //but we will remember the raw arrays
    //and fire off async workers to parse 
    //them later, once we are loading geometry packs
    this.instances = [];

    this.cameras = [];
    this.lights = [];

    this.propertydb = {
        attrs : [],
        avs: [],
        ids: [],
        values: [],
        offsets: []
    };

    this.bbox = null; //Overall scene bounds

    this.animations = null; // animations json

    this.pendingRequests = 0;
}



Package.prototype.loadAsyncResource = function(loadContext, resourcePath, contents, callback) {

    //Data is immediately available from the SVF zip
    if (contents) {
        callback(contents);
        return;
    }

    //Launch an XHR to load the data from external file
    var svf = this;

    this.pendingRequests ++;

    function xhrCB(e) {
        svf.pendingRequests--;

        if (this.response) {
            var data = new Uint8Array(this.response);

            if (data[0] == 31 && data[1] == 139) {
                var gunzip = new Zlib.Gunzip(data);
                data = gunzip.decompress();
            }

            callback(data);
        }

        if (svf.pendingRequests == 0)
            svf.postLoad(loadContext);
    }

    var xhr = new Xhr(loadContext.errorHandler, loadContext.auth, loadContext.viewing_url);
    xhr.get(loadContext.basePath + resourcePath, loadContext.headers, "arraybuffer", xhrCB, '', loadContext.queryParams);
};


Package.prototype.load = function(loadContext, zipPack) {
    var svf = this;

    var unzip = new Zlib.Unzip(zipPack);

    //var filenames = unzip.getFilenames();

    // TODO: zlib.js throws exceptions on failure;
    // it doesn't return null as this code seems to assume.
    var manifestJson = unzip.decompress("manifest.json");
    if (!manifestJson)
        return false;

    var jdr = new InputStream(manifestJson);
    var manifest = JSON.parse(jdr.getString(manifestJson.byteLength));

    var metadataJson = unzip.decompress("metadata.json");
    var jdr = new InputStream(metadataJson);

    // Test to see if this is json (not a binary header)
    // Done by verifying that there is no 0 (Hence ASCII)
    if(metadataJson.byteLength > 3 && metadataJson[3] !== 0) {
        this.metadata = JSON.parse(jdr.getString(metadataJson.byteLength)).metadata;

        //Retrieve world bounding box
        if ( this.metadata ) {
            var bbox = this.metadata["world bounding box"];
            var min = { x: bbox.minXYZ[0], y: bbox.minXYZ[1], z: bbox.minXYZ[2] };
            var max = { x: bbox.maxXYZ[0], y: bbox.maxXYZ[1], z: bbox.maxXYZ[2] };
            this.bbox = new THREE.Box3(min, max);

            if (this.metadata.hasOwnProperty("double sided geometry")
                && this.metadata["double sided geometry"]["value"]) //TODO: do we want to check the global flag or drop that and rely on material only?
            {
                this.doubleSided = true;
            }
        }
    }

    var manifestVersion = manifest["manifestversion"];
    //Version strings seem to be variable at the moment.
    //if (   manifest["name"] != "LMV Manifest" 
    //    || manifest["manifestversion"] != 1)
    //    return false;

    this.manifest = manifest;
    this.packFileTotalSize = 0;
    this.primitiveCount = 0;

    var typesetsList = manifest["typesets"];
    var typesets = {};
    for (var i=0; i<typesetsList.length; i++) {
        var ts = typesetsList[i];
        typesets[ts['id']] = ts['types'];
    }

    //Loop through the assets, and schedule non-embedded
    //ones for later loading.
    //TODO: currently only geometry pack files are stored for later
    //load and other assets will be loaded by this worker thread before
    //we return to the SvfLoader in the main thread.
    var assets = manifest["assets"];
    for (var i=0; i<assets.length; i++)
    {
        var asset = assets[i];
        var type = asset["type"];
        if (type.indexOf("Autodesk.CloudPlatform.") == 0)
            type = type.substr(23);
        var uri = asset["URI"];
        var typeset = asset["typeset"] ? typesets[asset["typeset"]] : null;

        //If the asset is a geometry pack or property pack
        //just remember it for later demand loading
        if (uri.indexOf("embed:/") != 0) {
            if (type == "PackFile") {
                var typeclass = typeset ? typeset[0]["class"] : null;

                if (typeclass == "Autodesk.CloudPlatform.Geometry") {

                    this.packFileTotalSize += asset["usize"] || 0;

                    this.geompacks.push({ id: asset["id"], uri: uri });
                }
            }
            else if (type == "PropertyAttributes") {
                this.propertydb.attrs.push(uri);
            }
            else if (type == "PropertyAVs") {
                this.propertydb.avs.push(uri);
            }
            else if (type == "PropertyIDs") {
                this.propertydb.ids.push(uri);
            }
            else if (type == "PropertyOffsets") {
                this.propertydb.offsets.push(uri);
            }
            else if (type == "PropertyValues") {
                this.propertydb.values.push(uri);
            }
        }

        //parse assets which we will need immediately when
        // setting up the scene (whether embedded or not)
        var path = asset["URI"];
        var contents; //if the data was in the zip, this will contain it
        if (path.indexOf("embed:/") == 0) {
            path = path.substr(7);
            contents = unzip.decompress(path);
        }

        if (type == "ProteinMaterials") {
            //For simple materials, we want the file named "Materials.json" and not "ProteinMaterials.json"
            if (path.indexOf("Protein") == -1) {
                this.loadAsyncResource(loadContext, path, contents, function(data) {
                    var jdr = new InputStream(data);
                    var byteLength = data.byteLength;
                    if (0 < byteLength) {
                        svf.materials = JSON.parse(jdr.getString(byteLength));
                        convertMaterials(svf);
                    } else {
                        svf.materials = null;
                    }
                });
            } else {
                //Also parse the Protein materials -- at the moment this helps
                //With some Prism materials that have properties we can handle, but
                //are not in the Simple variant.
                this.loadAsyncResource(loadContext, path, contents, function(data) {
                    var jdr = new InputStream(data);
                    var byteLength = data.byteLength;
                    if (0 < byteLength) {
                        svf.proteinMaterials = JSON.parse(jdr.getString(byteLength));
                    } else {
                        svf.proteinMaterials = null;
                    }
                });
            }
        }
        else if (type == "FragmentList") {

            this.loadAsyncResource(loadContext, path, contents, function(data) {
                var pfr = new PackFileReader(data);

                //Use a single large blocks to store all fragment elements
                //TODO: perhaps have a FragList per pack file to keep block size down?
                var frags = svf.fragments = new FragList();

                readFragments(pfr, frags);
            });

        }
        else if (type == "GeometryMetadataList") {

            this.loadAsyncResource(loadContext, path, contents, function(data) {
                var pfr = new PackFileReader(data);

                svf.geomMetadata = {};

                readGeometryMetadata(pfr, svf.geomMetadata);
            });
        }
        else if (type == "PackFile") {

            if (path.indexOf("CameraDefinitions.bin") != -1) {
                this.loadAsyncResource(loadContext, path, contents, function(data) {
                    svf.camDefPack = new PackFileReader(data);
                });
            }

            else if (path.indexOf("CameraList.bin") != -1) {
                this.loadAsyncResource(loadContext, path, contents, function(data) {
                    svf.camInstPack = new PackFileReader(data);
                });
            }

            else if (path.indexOf("LightDefinitions.bin") != -1) {
                this.loadAsyncResource(loadContext, path, contents, function(data) {
                    svf.lightDefPack = new PackFileReader(data);
                });
            }

            else if (path.indexOf("LightList.bin") != -1) {
                this.loadAsyncResource(loadContext, path, contents, function(data) {
                    svf.lightInstPack = new PackFileReader(data);
                });
            }
        }
        else if (type == "Animations") {
            this.loadAsyncResource(loadContext, path, contents, function(data) {
                var jdr = new InputStream(data);
                var byteLength = data.byteLength;
                if (0 < byteLength) {
                    svf.animations = JSON.parse(jdr.getString(byteLength));
                } else {
                    svf.animations = null;
                }
            });
        }
        /*
         else if (type == "Autodesk.CloudPlatform.InstanceTree") {
         //TODO: instance tree, will be needed for selection
         //but let's skip the performance hit now -- we can
         //parse that in a worker thread after loading the rest.
         }
         */
    }


    if (this.pendingRequests == 0)
        this.postLoad(loadContext);
};



Package.prototype.postLoad = function(loadContext) {

    //Combine camera instances and camera definitions -- we need
    //both to be loaded to get the camera list
    if (this.camDefPack && this.camInstPack) {
        for (var k = 0, kEnd = this.camInstPack.getEntryCounts(); k < kEnd; k++) {
            var inst = readInstance(this.camInstPack, k);
            var cam = readCameraDefinition(this.camDefPack, inst);

            //Apply any instance transform to get the camera to world space.
            if (inst.transform) {
                var transform = new THREE.Matrix4().copy(inst.transform);

                // Apply any transformations associated with the camera
                // to put it into world space
                cam.position.applyMatrix4(transform);
                cam.target.applyMatrix4(transform);
                cam.up.transformDirection(transform);
            }

            this.cameras.push(cam);
        }

        delete this.camDefPack;
        delete this.camInstPack;
    }


    //Lights need the same thing as the cameras
    if (this.lightDefPack && this.lightInstPack) {
        for (var k = 0, kEnd = this.lightInstPack.getEntryCounts(); k < kEnd; k++) {
            var inst = readInstance(this.lightInstPack, k);
            this.lights.push(readLightDefinition(this.lightDefPack, inst.definition));
        }

        delete this.lightInstPack;
        delete this.lightDefPack;
    }

    //Post processing step -- splice geometry metadata information
    //into the fragments list, in case it was given separately
    //TODO: consider keeping the geom metadata as is instead of splicing
    //into the fragments, as it would be more efficient --
    //but that would require special handling on the viewer side,
    //changing the fragment filter code, etc.
    var frags = this.fragments;

    if (this.geomMetadata) {

        var gm = this.geomMetadata;
        for (var i= 0, iEnd=frags.length; i<iEnd; i++) {
            var geomIndex = frags.geomDataIndexes[i];
            frags.entityIndexes[i] = gm.entityIndexes[geomIndex];
            frags.packIds[i] = gm.packIds[geomIndex];
            this.primitiveCount += gm.primCounts[geomIndex];
        }

        delete this.geomMetadata;
    }

    //Build a map from mesh to its referencing fragment(s)
    //So that we can quickly find them once meshes begin loading
    //incrementally. This requires the packIds and entityIndexes
    //to be known per fragment, so it happens after geometry metadata
    //is resolved above
    {
        var mesh2frag = frags.mesh2frag = {};
        var packIds = frags.packIds;
        var entityIndexes = frags.entityIndexes;

        for (var i= 0, iEnd=frags.length; i<iEnd; i++) {
            var meshid = packIds[i] + ":" + entityIndexes[i];

            var meshRefs = mesh2frag[meshid];
            if (meshRefs === undefined) {
                //If it's the first fragments for this mesh,
                //store the index directly -- most common case.
                mesh2frag[meshid] = i;
            }
            else if (!Array.isArray(meshRefs)) {
                //otherwise put the fragments that
                //reference the mesh into an array
                mesh2frag[meshid] = [meshRefs, i];
            }
            else {
                //already is an array
                meshRefs.push(i);
            }
        }
    }

    //if we don't know the overall scene bounds, compute them from the
    //fragment boxes
    if (!this.bbox) {
        var totalbox = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
        var fragBoxes = frags.boxes;

        for (var f= 0, fEnd=frags.length; f<fEnd; f++) {
            var bboff = f*6;
            var i;
            for (i=0; i<3; i++)
                if (fragBoxes[bboff+i] < totalbox[i])
                    totalbox[i] = fragBoxes[bboff+i];

            for (i=3; i<6; i++)
                if (fragBoxes[bboff+i] > totalbox[i])
                    totalbox[i] = fragBoxes[bboff+i];
        }

        this.bbox = new THREE.Box3(new THREE.Vector3(totalbox[0], totalbox[1], totalbox[2]),
            new THREE.Vector3(totalbox[3], totalbox[4], totalbox[5]));
    }


    // If object ids are specified, clean up pack file list by only keeping the packs that's
    // we intended to load.
    var ids = loadContext.objectIds;
    if (ids != null) {
        var packIds = [];
        var fragIndexes = [];
        // Pick out pack ids that referenced by fragments with specified db ids.
        for (var i = 0; i < ids.length; ++i) {
            for (var j = 0; j < this.fragments.length; ++j) {
                if (this.fragments.fragId2dbId[j] == ids[i]) {
                    packIds.push(this.fragments.packIds[j]);
                    fragIndexes.push(j);
                }
            }
        }

        // Two fragments could reference same pack file, so packIds may contain duplicates.
        // Remove any duplicates here.
        var end = 1, n = packIds.length; // end is the length of reduced array.
        for (var i = 1; i < n;) {
            while (i < n && packIds[i] == packIds[i - 1])
                ++i;
            if (n == i)
                break;
            packIds[end++] = packIds[i++];
        }
        packIds.splice(end - 1, n - end);

        // Reduce pack files based on selected pack ids.
        var packs = [];
        for (var i = 0; i < this.geompacks.length; ++i) {
            for (var j = 0; j < packIds.length; ++j) {
                // LMVTK pre-2.0 release uses integers for pack file id.
                // LMVTK 2.0 release uses integer + .pf as id.
                // We just drop the suffix here as we did in SVFLoader.
                // More info: https://git.autodesk.com/A360/LMVTK/commit/68b8c07a643a7ac39ecd5651d031d170e3a325be
                if (parseInt(this.geompacks[i].id) == packIds[j])
                    packs.push(this.geompacks[i]);
            }
        }
        this.geompacks = packs;

        var bb = filterFragments(this.fragments, fragIndexes);
        this.bbox = new THREE.Box3(new THREE.Vector3(bb[0], bb[1], bb[2]),
            new THREE.Vector3(bb[3], bb[4], bb[5]));
    }

    loadContext.loadDoneCB(true);
};
;
/** @constructor */
function PackFileReader(data)
{
    //When server side (S3 and viewing service) is configured properly,
    //browser can decompress the pack file for us.
    //Here the check is for backward compatibility purpose.
    if (data[0] == 31 && data[1] == 139) {
        var gunzip = new Zlib.Gunzip(data);
        data = gunzip.decompress();
    }

    //We will try to avoid allocating transient
    //objects of these types by reusing these
    //when reading transforms
    this.tempQuat = new THREE.Quaternion();
    this.tempTrans = new THREE.Vector3();
    this.tempScale = new THREE.Vector3();
    this.tempMat = new THREE.Matrix4();

    var stream = this.stream = new InputStream(data);

    var len = stream.getInt32();
    this.type = stream.getString(len);
    this.version = stream.getInt32();

    this.types = null;
    this.entryOffsets = [];

    //read the table of contents
    {
        // Jump to file footer.
        stream.seek(stream.byteLength - 8);

        // Jump to toc.
        var tocOffset = stream.getUint32();
        this.typesOffset = stream.getUint32();

        // Populate type sets.
        stream.seek(this.typesOffset);
        var typesCount = this.readU32V();
        this.types = [];
        for (var i = 0; i < typesCount; ++i)
            this.types.push({
                "entryClass": this.readString(),
                "entryType": this.readString(),
                "version": this.readU32V()
            });

        // Populate data offset list.
        stream.seek(tocOffset);
        var entryCount = this.readU32V();
        var dso = this.entryOffsets;
        for (var i = 0; i < entryCount; ++i)
            dso.push(stream.getUint32());

        // Restore sanity of the world.
        stream.seek(0);
    }
};

PackFileReader.prototype.readVarint = function() {
    var b;
    var value = 0;
    var shiftBy = 0;
    do {
        b = this.stream.getUint8();
        value |= (b & 0x7f) << shiftBy;
        shiftBy += 7;
    } while (b & 0x80);
    return value;
};
PackFileReader.prototype.readU32V = PackFileReader.prototype.readVarint;

PackFileReader.prototype.readU16 = function () {
    return this.stream.getUint16();
};

PackFileReader.prototype.readU8 = function () {
    return this.stream.getUint8();
};

PackFileReader.prototype.readString = function() {
    return this.stream.getString(this.readU32V());
};

PackFileReader.prototype.readVector3f = function () {
    var s = this.stream;
    return new THREE.Vector3(s.getFloat32(), s.getFloat32(), s.getFloat32());
};


PackFileReader.prototype.readTransform = function(entityIndex, buffer, offset)
{
    var stream = this.stream;
    var t = this.tempTrans;
    var q = this.tempQuat;
    var s = this.tempScale;
    var m = this.tempMat;

    function readQuaternionf(q) {
        q.set(stream.getFloat32(), stream.getFloat32(), stream.getFloat32(), stream.getFloat32());
    }
    function readVector3d(v) {
        v.set(stream.getFloat64(), stream.getFloat64(), stream.getFloat64());
    }
    function readMatrix3f() {
        m.identity();
        //TODO: make sure we do not need a transpose here.
        for (var i = 0; i < 3; ++i)
            for (var j = 0; j < 3; ++j)
                m.elements[4*i+j] = stream.getFloat32();
    }

    var transformType = stream.getUint8();
    var xform = null;

    switch (transformType)
    {
        case 4/*TransformType.Identity*/: {
            m.identity();
        } break;
        case 0/*TransformType.Translation*/: {
            readVector3d(t);
            m.makeTranslation(t.x, t.y, t.z);
        } break;
        case 1/*TransformType.RotationTranslation*/: {
            readQuaternionf(q);
            readVector3d(t);
            m.compose(t, q, s.set(1,1,1));
        } break;
        case 2/*TransformType.UniformScaleRotationTranslation*/: {
            var scale = stream.getFloat32();
            readQuaternionf(q);
            readVector3d(t);
            m.compose(t, q, s.set(scale, scale, scale));
        } break;
        case 3/*TransformType.AffineMatrix*/: {
            readMatrix3f();
            readVector3d(t);
            m.setPosition(t);
        } break;
        default:
            break; //ERROR
    }

    if (entityIndex !== undefined) {
        var src = m.elements;
        for (var i=0; i<16; i++)
            buffer[offset++] = src[i];
    }
    else {
        return new THREE.Matrix4().copy(m);
    }
};

PackFileReader.prototype.getEntryCounts = function() {
    return this.entryOffsets.length;
};

PackFileReader.prototype.seekToEntry = function(entryIndex) {
    var count = this.getEntryCounts();
    if (entryIndex >= count)
        return null;

    // Read the type index and populate the entry data
    this.stream.seek(this.entryOffsets[entryIndex]);
    var typeIndex = this.stream.getUint32();
    if (typeIndex >= this.types.length)
        return null;

    return this.types[typeIndex];
};


PackFileReader.prototype.readPathID = function() {
    var s = this.stream;

    //Construct a /-delimited string as the path to a node
    //TODO: in case we need a split representation (e.g. to follow paths), then
    //an array of numbers might be better to return from here.
    if (this.version < 2) {
        var pathLength = s.getUint16();
        if (!pathLength)
            return null;

        //The first number in a path ID is always zero (root)
        //so we skip adding it to the path string here.
        //Remove this section if that is not the case in the future.
        s.getUint16();
        if (pathLength == 1)
            return "";

        var path = s.getUint16();
        for (var i = 2; i < pathLength; ++i) {
            path += "/" + s.getUint16();
        }
    }
    else {
        var pathLength = this.readU32V();
        if (!pathLength)
            return null;

        //The first number in a path ID is always zero (root)
        //so we skip adding it to the path string here.
        //Remove this section if that is not the case in the future.
        this.readU32V();
        if (pathLength == 1)
            return "";

        var path = this.readU32V();
        for (var i = 2; i < pathLength; ++i) {
            path += "/" + this.readU32V();
        }
    }
    return path;
};
;

/** @constructor */
function PropertyDatabase(dbjsons) {

    //The property db json arrays.
    //Some of them are held unparsed in blob form
    //with helper arrays containing offsets into the blobs for each value to be parsed on demand
    var _attrs;
    var _offsets;
    var _avs;
    var _valuesBlob;
    var _valuesOffsets;
    var _idsBlob;
    var _idsOffsets;

    //Cached ids of commonly used well known attributes (child, parent, name)
    var _childAttrId;
    var _parentAttrId;
    var _nameAttrId;
    var _instanceOfAttrId;
    var _viewableInAttrId;
    var _externalRefAttrId;

    //dbjsons is expected to be of the form
    //{ attrs: {filename1:x, filename2:y}, ids: {filename1:x... }, values: {... }, offsets: {... }, avs: {... } }
    //where each of the elements of each array is a pair of the original name and the unzipped *raw* byte
    //array buffer corresponding to the respective property database constituent. In the current implementation
    //each array is expected to only have one name-value element.

    function blobToJson(blob) {
        var encodedString = "";
        for (var i=0; i<blob.length; i++)
            encodedString += String.fromCharCode(blob[i]);

        var decodedString = decodeURIComponent(escape(encodedString));

        return JSON.parse(decodedString);
    }

    //parses a piece of json from a given blob (representing an array of json values)
    //up to the next comma+newline combo (i.e. array delimiter).
    function subBlobToJson(blob, startIndex) {
        var i = startIndex;
        var encodedString = "";

        while (i<blob.length-1) {
            var c = blob[i];
            if (c == 44 && (blob[i+1] == 10 || blob[i+1] == 13))
                break;
            if (c == 10 || c == 13)
                break;
            encodedString += String.fromCharCode(c);
            i++;
        }

        var decodedString = decodeURIComponent(escape(encodedString));

        return JSON.parse(decodedString);
    }

    function subBlobToJsonInt(blob, startIndex) {
        var val = 0;
        var i = startIndex;

        //Check for integers that were serialized as strings.
        //This should not happen, ever, but hey, it does.
        if (blob[i] == 34)
            i++;

        while (i<blob.length-1) {
            var c = blob[i];
            if (c == 44 && (blob[i+1] == 10 || blob[i+1] == 13))
                break;
            if (c == 10 || c == 13 || c == 34)
                break;
            if (c >= 48 && c <= 57)
                val += val * 10 + (c - 48);

            i++;
        }

        return val;
    }

    //Simple integer array parse -- expects the array in property database
    //format, where the array is packed with possibly newline separator,
    //but no other white space. Does not do extensive error checking
    function parseIntArray(blob, wantSentinel) {

        //find out how many items we have
        var count = 0;
        for (var i= 0, iEnd=blob.length; i<iEnd; i++)
            if (blob[i] == 44) //44 = ','
                count++;

        count++; //last item has no comma after it

        var items = new Uint32Array(count + (wantSentinel ? 1 : 0));

        i=0;
        var end = blob.length;

        while (blob[i] != 91 && i<end) //91 = '['
            i++;

        if (i == blob.length)
            return null;

        i++;

        var seenDigit = false;
        count = 0;
        var curInt = 0;
        while (i<end) {
            var c = blob[i];
            if (c >= 48 && c <= 57) { //digit
                curInt = 10 * curInt + (c - 48);
                seenDigit = true;
            }
            else if (c == 44 || c == 93) { //',' or ']'
                if (seenDigit) {
                    items[count++] = curInt;
                    seenDigit = false;
                    curInt = 0;
                }
            } else {
                seenDigit = false; //most likely a newline (the only other thing we have in our arrays
                curInt = 0;
            }
            i++;
        }

        return items;
    }

    //Scans an array of json values (strings, integers, doubles) and finds the
    //offset of each value in the array, so that we can later pick off that
    //specific value, without parsing the whole (potentially huge) json array up front.
    //This expects the input blob to be in the form serialized by the property database
    //C++ component -- one value per line. A more sophisticated parser would be needed
    //in case the format changes and this assumption is not true anymore.
    function findValueOffsets(blob) {

        //first, count how many items we have
        var count = 0;
        var end = blob.length-1;

        for (var i= 0; i<end; i++) {
            if ( blob[i] == 44 && (blob[i+1] == 10 || blob[i+1] == 13)) // ',' + newline is the item delimiter
                count++;
        }

        if (!count)
            return null;

        count++; //one for the last item

        var items = new Uint32Array(count);

        i=0;
        count = 0;

        //find opening [
        while (blob[i] != 91 && i<end) //91 = '['
            i++;

        i++;

        items[count++] = i;
        var seenEol = false;
        while (i<end) {
            if (blob[i] == 10 || blob[i] == 13)
                seenEol = true;
            else if (seenEol) {
                seenEol = false;
                items[count++] = i;
            }

            i++;
        }

        return items;
    }

    //=========================================================================

    //The attribute definitions blob is considered small enough
    //to parse using regular APIs
    for (var p in dbjsons.attrs) {
        _attrs = blobToJson(dbjsons.attrs[p]);

        for (var i = 0; i<_attrs.length; i++) {
            var category = _attrs[i][1];

            switch (category) {
                case "__parent__":      _parentAttrId = i; break;
                case "__child__":       _childAttrId = i; break;
                case "__name__":        _nameAttrId = i; break;
                case "__instanceof__":  _instanceOfAttrId = i; break;
                case "__viewable_in__": _viewableInAttrId = i; break;
                case "__externalref__": _externalRefAttrId = i; break;
                default: break;
            }
        }

        break; //currently we can only handle single property file (no chunking)
    }

    //manual parse of the attribute-value index pairs array
    for (var p in dbjsons.avs) {
        _avs = parseIntArray(dbjsons.avs[p], 0);

        delete dbjsons.avs; //don't need thi blob anymore

        break; //currently we can only handle single property file (no chunking)

    }


    //manual parse of the offsets array
    for (var p in dbjsons.offsets) {
        _offsets = parseIntArray(dbjsons.offsets[p], 1); //passing in 1 to reserve a spot for the sentinel value

        //just a sentinel value to make lookups for the last item easier
        _offsets[_offsets.length-1] = _avs.length / 2;

        delete dbjsons.offsets; //don't need this

        break; //currently we can only handle single property file (no chunking)

    }

    //Instead of parsing the values and ids arrays, find the
    //offset of each json item in the blob, and then we can
    //pick and parse specific items later on demand, without
    //parsing the potentially large json blob up front.
    for (var p in dbjsons.values) {
        _valuesBlob = dbjsons.values[p];
        _valuesOffsets = findValueOffsets(_valuesBlob);

        break; //currently we can only handle single property file (no chunking)

    }

    //Do the same for the ids array -- find the offset to each
    //value but skip the full parse. Note that the ids array is
    //optional as we don't currently use it anywhere
    for (var p in dbjsons.ids) {
        _idsBlob = dbjsons.ids[p];
        _idsOffsets = findValueOffsets(_idsBlob);

        break; //currently we can only handle single property file (no chunking)

    }



    //=========================================================================

    this.getObjectCount = function() {
        return _offsets.length-1;
    };

    this.getValueAt = function(valId) {
        return subBlobToJson(_valuesBlob, _valuesOffsets[valId]);
    };

    //faster variant used for traversing the object hierarchy where
    //we know the data type of the value to be an integer
    this.getIntValueAt = function(valId) {
        return subBlobToJsonInt(_valuesBlob, _valuesOffsets[valId]);
    };


    this.getIdAt = function(entId) {
        return subBlobToJson(_idsBlob, _idsOffsets[entId]);
    };

    this.getObjectProperties = function(dbId) {
        var result = {"dbId":dbId, "name":"", "properties":[] };
        var parentProps = null;

        //Start offset of this object's properties in the Attribute-Values table
        var propStart = 2 * _offsets[dbId];

        //End offset of this object's properties in the Attribute-Values table
        var propEnd = 2 * _offsets[dbId+1];

        //Loop over the attribute index - value index pairs for the objects
        //and for each one look up the attribute and the value in their
        //respective arrays.
        for (var i=propStart; i<propEnd; i+=2) {
            var attrId = _avs[i];

            if (attrId == _nameAttrId) {
                var val = this.getValueAt(_avs[i+1]);
                result.name = val;
            }
            else if (attrId == _instanceOfAttrId) {
                //Recursively resolve any common properties from the parent of this instance
                var res = this.getObjectProperties(this.getValueAt(_avs[i+1]));
                if (res && res.properties) {
                    parentProps = res;
                }
            }
            else if (   attrId == _parentAttrId
                      || attrId == _childAttrId
                      || attrId == _viewableInAttrId
                      || attrId == _externalRefAttrId) {
                //skip structural attributes, we don't want those to display
                //NOTE: The list of structural attributes that we check explicitly is not marked
                //as hidden in older versions of the property database, so if we ever want to
                //add them to the result list, we have to explicitly set the hidden flag for those.
            }
            else {
                var attr = _attrs[attrId];
                var flags = (attr[6]) ? attr[6] : 0;
                var displayName = (attr[5]) ? attr[5] : attr[0];

                result.properties.push({
                    displayName: displayName,
                    displayValue: this.getValueAt(_avs[i+1]),
                    displayCategory: attr[1],
                    type: attr[2],
                    units: attr[3],
                    hidden: (flags & 1 /*afHidden*/)
                });
            }
        }

        //Combine instance properties with any parent object properties
        if (parentProps) {
            var myProps = {};
            var rp = result.properties;
            for (var i=0; i<rp.length; i++) {
                myProps[rp[i].displayName] = 1;
            }

            if (!result.name)
                result.name = parentProps.name;

            var pp = parentProps.properties;
            for (var i=0; i<pp.length; i++) {
                if (!myProps.hasOwnProperty(pp[i].displayName)) {
                    rp.push(pp[i]);
                }
            }
        }

        return result;
    };

    //Heuristically find the root node(s) of a scene
    //A root is a node that has children, has no (or null) parent and has a name.
    //There can be multiple nodes at the top level (e.g. Revit DWF), which is why
    //we should get the scene root with absolute certainty from the SVF instance tree,
    //but we would have to uncompress and parse that in -- something that is
    //not currently done. This is good enough for now (if pretty slow).
    this.findRootNodes = function() {
        var idroots = [];
        for (var id = 1, idend=_offsets.length; id<idend; id++) {
            var hasChild = false;
            var hasParent = false;
            var hasName = false;

            var propStart = 2 * _offsets[id];

            var propEnd = 2 * _offsets[id+1];

            for (var i=propStart; i<propEnd; i+=2) {
                var attrId = _avs[i];

                if (attrId == _parentAttrId) {
                    if (this.getIntValueAt(_avs[i+1])) //checks for null or zero parent id, in which case it's considered non-parent
                        hasParent = true;
                } else if (attrId == _childAttrId) {
                    hasChild = true;
                }
                else if (attrId == _nameAttrId) {
                    hasName = true;
                }
            }

            if (hasChild && hasName && !hasParent) {
                idroots.push(id);
            }
        }

        return idroots;
    };

    //Gets the immediate children of a node with the given dbId
    this.getNodeNameAndChildren = function(node /* {dbId:X, name:""} */, skipChildren) {

        var id = node.dbId;

        var propStart = 2 * _offsets[id];
        var propEnd = 2 * _offsets[id+1];

        var children;

        for (var i=propStart; i<propEnd; i+=2) {
            var attrId = _avs[i];
            var val;

            if (attrId == _parentAttrId) {

            } else if (attrId == _childAttrId && !skipChildren) {
                val = this.getValueAt(_avs[i+1]);
                var child = {dbId:val,parent:node};
                if (!children)
                    children = [child];
                else
                    children.push(child);

            } else if (attrId == _nameAttrId) {
                val = this.getValueAt(_avs[i+1]);
                node.name = val;
            } else if (attrId == _instanceOfAttrId) {
                //If this is an instance of another object,
                //try to get the object name from there.
                var tmp = { dbId:this.getValueAt(_avs[i+1]), name:null };
                this.getNodeNameAndChildren(tmp, true);
                if (tmp && tmp.name && !node.name)
                    node.name = tmp.name;
            }
        }

        return children;
    };


    //Builds a tree of nodes according to the parent/child hierarchy
    //stored in the property database, starting at the node with the given dbId
    this.buildObjectTree = function(node, //current node = { dbId:XXX }
                                    dbToFrag, //map of dbId to fragmentIds
                                    depth /* start at 0 */, maxDepth /* returns max tree depth */) {

        if (depth > maxDepth[0])
            maxDepth[0] = depth;

        var children = this.getNodeNameAndChildren(node);

        if (children) {
            for (var j=0; j<children.length; j++) {
                this.buildObjectTree(children[j], dbToFrag, depth+1, maxDepth);
            }

            //Prune children that are leafs without graphics
            //and add the rest to the node
            for (j=0; j<children.length; j++) {
                if (children[j].children || (children[j].fragIds !== undefined)) {
                    if (!node.children)
                        node.children = [ children[j] ];
                    else
                        node.children.push(children[j]);
                }
            }
        }
        else {
            //leaf node
            var frags = dbToFrag[node.dbId];
            if (frags !== undefined) {
                node.fragIds = frags;
            }
        }
    };


    this.bruteForceSearch = function(searchText) {

        //var regex = new RegExp(e.data.searchText, "i");
        searchText = searchText.toLowerCase();

        var result = [];

        //Find all values that match the search text
        //Hopefully this is a small number, otherwise
        //we need a sorted array or an object with properties instead of array
        var matching_vals = [];

        for (var i=0, iEnd=_valuesOffsets.length; i<iEnd; i++) {
            var val = this.getValueAt(i);
            if (typeof val == "string") {
                if (val.toLowerCase().indexOf(searchText) != -1)
                    matching_vals.push(i);
            }
            else {
                if (val.toString().toLowerCase().indexOf(searchText) != -1)
                    matching_vals.push(i);
            }
        }

        //Collect database IDs of objects that contain the found property values
        for (var id = 1, idend=_offsets.length; id<idend; id++) {
            var propStart = 2 * _offsets[id];
            var propEnd = 2 * _offsets[id+1];

            for (var i=propStart; i<propEnd; i+=2) {
                if (matching_vals.indexOf(_avs[i+1]) != -1) {
                    result.push(id);
                    break;
                }
            }
        }

        return result;

    };
}
;function F2D(metadata, manifest, basePath, options) {
    this.metadata = metadata;
    this.scaleX = 1;
    this.scaleY = 1;
    this.bbox = new THREE.Box3();
    this.is2d = true;
    this.layersMap = {};
    this.layersRoot = {name: 'root', id: 'root', children: [], isLayer: false, childCount: 0};
    this.fontDefs = {};
    this.fontCount = 0;
    this.fontId = 0;
    this.manifestAvailable = false;

    this.objectMemberQueue = [];

    this.propertydb = {
        attrs : [],
        avs: [],
        ids: [],
        values: [],
        offsets: [],
        rcv_offsets: [],
        rcvs : [],
        viewables: []
    };

    if (metadata) {

        var dims = metadata.page_dimensions;

        this.paperWidth = dims.page_width;
        this.paperHeight = dims.page_height;

        // TODO: scale parsing.
        this.scaleX = this.paperWidth / dims.plot_width;
        this.scaleY = this.paperHeight / dims.plot_height;

        this.hidePaper = dims.hide_paper;

        this.bbox.min.set(0,0,0);
        this.bbox.max.set(this.paperWidth, this.paperHeight, 0);

        // Temporary: build the layers tree. Eventually the extractor
        // should be the one doing this; we're incompletely faking it
        // by looking at the layer names.
        //
        var layersRoot = this.layersRoot,
            groupId = 0,
            layerId = 0;

        function findChild(item, name) {
            var children = item.children;
            for (var i = 0; i < children.length; ++i) {
                var child = children[i];
                if (child.name === name) {
                    return child;
                }
            }
            return null;
        }

        function insertLayer(path, name, index) {
            var parent = layersRoot,
                pathLength = path.length;

            if (1 < pathLength) {
                for (var i = 0; i < pathLength - 1; ++i) {
                    var pathComponent = path[i];
                    var item = findChild(parent, pathComponent);
                    if (!item) {
                        item = {
                            name: pathComponent,
                            id: 'group-' + groupId++,
                            children: [],
                            isLayer: false,
                            childCount: 0};
                        parent.children.push(item);
                    }
                    parent = item;
                }
            }

            parent.children.push({
                name: name,
                index: index,
                id: layerId++,
                isLayer: true
            });
        }

        var count = 0;
        //Some geometry comes on null layer, and we reserve a spot for that one.
        //For example, Revit plots have no layers at all.
        this.layersMap[0] = count++;

        for (var l in metadata.layers) {

            var index = parseInt(l);
            var layerDef = metadata.layers[l];

            var name = (typeof layerDef === "string") ? layerDef : layerDef.name;

            if (!name)
                name = l; //won't get here...

            insertLayer(name.split('|'), name, index);

            //We store in a map in order to allow non-consecutive layer numbers,
            //which does happen.
            this.layersMap[index] = count++;
        }

        this.layerCount = count;
    }

    this.hidePaper = this.hidePaper || (options && options.modelSpace);



    function sortLayers(parent) {
        var children = parent.children;
        if (children !== undefined) {
            for (var i = 0; i < children.length; ++i) {
                sortLayers(children[i]);
            }
            children.sort(function (a, b) {
                var aIsLayer = a.isLayer,
                    bIsLayer = b.isLayer;

                if (aIsLayer && !bIsLayer) {
                    return -1; // Layers before groups
                } else if (!aIsLayer && bIsLayer) {
                    return 1;
                }
                return a.name.localeCompare(b.name, undefined, {sensitivity: 'base', numeric: true}); // Sort layers and groups by name
            });
        }
    }
    sortLayers(this.layersRoot);

    function countChildren(parent) {
        var childCount = 0;

        if (parent.isLayer) {
            childCount = 1;
        } else {
            var children = parent.children;
            for (var i = 0; i < children.length; ++i) {
                var child = children[i];
                childCount += countChildren(child);
            }
            parent.childCount = childCount;
        }

        return childCount;
    }
    countChildren(this.layersRoot);

    // For debugging only. Could be removed.
    this.opCount = 0;


    this.fontFaces = [];
    this.fontFamilies = [];
    this.clip = null;
    this.objectNumber = 0;
    this.imageNumber = 0;
    this.maxObjectNumber = 0;

    this.objectStack = [];
    this.objectNameStack = [];
    this.parseObjState = {
        polyTriangle : {},
        clip : {},
        raster : {},
        text: {},
        fontDef: {},
        uknown: {}
    };

    this.layer = 0;

    this.bgColor = options.bgColor? options.bgColor : 0xffffffff;
    this.contrastColor = this.color = this.fillColor = 0xff000000;

    this.currentVbb = new VertexBufferBuilder(false);
    this.meshes = [];

    this.numCircles = this.numEllipses = this.numPolylines = this.numLineSegs = 0;
    this.numPolytriangles = this.numTriangles = 0;

    // Newly added f2d pasing stuff.
    this.error = false;

    // Last absolute positions of point parsed so far.
    // Used to decode relative positions parsed from points array.
    this.offsetX = 0;
    this.offsetY = 0;

    // Parse manifest, do stuff.
    // 1. Build image id to raster URI map used to assign values to texture path.
    // 2. Acquire names of property database json streams.
    if (manifest) {
        this.manifestAvailable = true;
        this.imageId2URI = {};
        var assets = manifest.assets;
        for (var i = 0, e = assets.length; i < e; ++i) {
            var entry = assets[i];
            var mime = entry.mime;
            if (mime.indexOf('image/') != -1) {
                var id = entry.id;
                id = id.substr(0, id.indexOf('.'));
                this.imageId2URI[id] = basePath + entry.URI;
            }

            if (entry.type == "Autodesk.CloudPlatform.PropertyAttributes")
                this.propertydb.attrs.push(entry.URI);
            if (entry.type == "Autodesk.CloudPlatform.PropertyValues")
                this.propertydb.values.push(entry.URI);
            if (entry.type == "Autodesk.CloudPlatform.PropertyIDs")
                this.propertydb.ids.push(entry.URI);
            if (entry.type == "Autodesk.CloudPlatform.PropertyViewables")
                this.propertydb.viewables.push(entry.URI);
            if (entry.type == "Autodesk.CloudPlatform.PropertyOffsets") {
                if (entry.id.indexOf('rcv') != -1)
                    this.propertydb.rcv_offsets.push(entry.URI);
                else
                    this.propertydb.offsets.push(entry.URI);
            }
            if (entry.type == "Autodesk.CloudPlatform.PropertyAVs")
                this.propertydb.avs.push(entry.URI);
            if (entry.type == "Autodesk.CloudPlatform.PropertyRCVs")
                this.propertydb.rcvs.push(entry.URI);
        }

        debug(JSON.stringify(this.propertydb));
    }
}

F2D.prototype.load = function(loadContext, fydoPack) {

    if (fydoPack[0] == 31 && fydoPack[1] == 139) {
        var gunzip = new Zlib.Gunzip(fydoPack);
        fydoPack = gunzip.decompress();
    }

    this.data = fydoPack;
    this.parse();

    loadContext.loadDoneCB(true);
};

F2D.prototype.loadFrames = function(loadContext) {

    if (loadContext.data) {
        this.data = new Uint8Array(loadContext.data);
    } else if (loadContext.finalFrame) {
        this.data = null;
    }

    this.parseFrames(loadContext.finalFrame);

    loadContext.loadDoneCB(true);
};

var F2dDataType = {
    //Fixed size types
    dt_object : 0,
    dt_void : 1,
    dt_byte : 2,
    dt_int : 3,
    dt_float : 4,
    dt_double : 5,
    dt_varint : 6,
    dt_point_varint : 7,

    //Variable size types
    //Data bytes are prefixed by an integer
    //representing the number of elements in the array.
    dt_byte_array : 32,
    dt_int_array : 33,
    dt_float_array : 34,
    dt_double_drray : 35,
    dt_varint_array : 36,
    //Special variable int encoding for point data
    dt_point_varint_array : 37,

    //Well-known data types that help reduce output size for commonly
    //encountered simple geometries
    dt_arc : 38,
    dt_circle : 39,
    dt_circular_arc : 40,

    dt_string : 63,
    //do not want to go into varint range
    dt_last_data_type : 127
};

var F2dSemanticType = {
    //For objects with fixed serialization (arc, raster) we don't bother having dedicated semantic for each member
    //and assume the parsing application knows the order they appear. There is still an end-object tag of course
    //which shows where the object ends.
    st_object_member : 0,

    //Simple / fixed size attributes
    st_fill : 1,
    st_fill_off : 2,
    st_clip_off : 3,
    st_layer : 4,
    st_link : 5,
    st_line_weight : 6,
    st_miter_angle : 7,
    st_miter_length : 8,
    st_line_pattern_ref : 9,
    st_back_color : 10,
    st_color : 11,
    st_markup : 12,
    st_object_id : 13,
    st_markup_id : 14,
    st_reset_rel_offset : 15,
    st_font_ref : 16,

    //Compound object opcodes

    //Begin a generic object opcode
    st_begin_object : 32,

    //Style attribute related opcodes. Those are compound objects
    st_clip : 33,
    st_line_caps : 34,
    st_line_join : 35,
    st_line_pattern_def : 36,
    st_font_def : 37,

    //Drawables are all objects-typed bounded by begin/end object opcodes

    //Root level document begin
    st_sheet : 42,
    //Circle, Ellipse, Arcs
    st_arc : 43,
    //The grandfather of them all
    st_polyline : 44,
    st_raster : 45,
    st_text : 46,
    st_polytriangle : 47,
    st_dot : 48,
    //end object -- could be ending a generic object or drawable, etc.
    st_end_object : 63,

    st_last_semantic_type : 127
};


F2D.prototype.flushBuffer = function(addCount, force)
{
    if (!this.currentVbb.vcount)
    {
        return;
    }

    var flush = force;
    flush = flush || this.currentVbb.isFull(addCount);

    if (flush) {
        var mesh = this.currentVbb.toMesh();
        this.bbox.union(mesh.boundingBox);
        this.meshes.push(mesh);

        mesh.material = {
                            skipEllipticals : !this.currentVbb.numEllipses,
                            skipCircles: !this.currentVbb.numCirculars,
                            skipTriangleGeoms : !this.currentVbb.numTriangleGeoms
                        };

        if (this.currentImage) {
            mesh.material.image = this.currentImage;
            mesh.material.image.name = this.imageNumber++;
            this.currentImage = null;
        }

        this.currentVbb = new VertexBufferBuilder();
    }
};

F2D.prototype.tx = function(x) {
    return this.sx(x);
};

F2D.prototype.ty = function(y) {
    return this.sy(y);
};

F2D.prototype.sx = function(x) {
    //TODO: The hardcoded scale is used to get the integer coords from FYDO
    //into something normal and close to page coordinates
    return x * this.scaleX;
};

F2D.prototype.sy = function(y) {
    //TODO: The hardcoded scale is used to get the integer coords from FYDO
    //into something normal and close to page coordinates
    return y * this.scaleY;
};

F2D.prototype.invertColor = function(c) {
    var a = ((c >> 24) & 0xff);
    var b = ((c >> 16) & 0xff);
    var g = ((c >>  8) & 0xff);
    var r = ((c)       & 0xff);

    b = 255 - b;
    g = 255 - g;
    r = 255 - r;

    return (a << 24) | (b << 16) | (g << 8) | r;
};

F2D.prototype.mapColor = function(c) {
    //This makes certain Revit drawings that send outlines
    //for internal triangulation edges look bad, because the outline
    //no longer matches the fill.
    //if ((c & 0xffffff) == (this.bgColor & 0xffffff))
    //    return this.contrastColor;

    return c;
};

// ====================== F2D Parser ================================= //

// Restore sign bit from LSB of an encoded integer which has the sign bit
// moved from MSB to LSB.
// The decoding process is the reverse by restoring the sign bit from LSB to MSB.
F2D.prototype.restoreSignBitFromLSB = function(integer) {
    return (integer & 1) ? -(integer >>> 1) : (integer >>> 1);
};

// Convert relative positions to absolute positions, and update global offsets.
F2D.prototype.parsePointPositions = function() {
    var x = this.stream.getVarints();
    var y = this.stream.getVarints();

    x = this.restoreSignBitFromLSB(x);
    y = this.restoreSignBitFromLSB(y);

    x += this.offsetX;
    y += this.offsetY;

    this.offsetX = x;
    this.offsetY = y;

    return [this.tx(x), this.ty(y)];
};

F2D.prototype.parserAssert = function(actualType, expectedType, functionName) {
    if (actualType != expectedType) {
        debug("Expect " + expectedType + "; actual type is " +
            actualType + "; in function " + functionName);
        this.error = true;
        return true;
    } else {
        return false;
    }
};

F2D.prototype.unhandledTypeWarning = function(inFunction, semanticType) {
    debug("Unhandled semantic type : " + semanticType + " in function " + inFunction);
};

F2D.prototype.parseObject = function() {
    var semantic_type = this.stream.getVarints();
    this.objectStack.push(semantic_type);
    //debug(semantic_type);
    switch (semantic_type) {
        case F2dSemanticType.st_sheet :
            this.objectNameStack.push("sheet");
            this.objectMemberQueue.unshift("paperColor");
            break;
        case F2dSemanticType.st_clip :
            this.objectNameStack.push("clip");
            this.objectMemberQueue.unshift("contourCounts", "points");
            break;
        case F2dSemanticType.st_polytriangle :
            this.objectNameStack.push("polyTriangle");
            this.objectMemberQueue.unshift("points", "indices", "colors");
            break;
        case F2dSemanticType.st_raster:
            this.objectNameStack.push("raster");
            this.objectMemberQueue.unshift("position", "width", "height", "imageId");
            break;
        case F2dSemanticType.st_text:
            this.objectNameStack.push("text");
            this.objectMemberQueue.unshift("string", "position", "height", "widthScale", "rotation", "oblique", "charWidths");
            break;
        case F2dSemanticType.st_font_def:
            this.objectNameStack.push("fontDef");
            this.objectMemberQueue.unshift("name", "fullName", "flags", "spacing", "panose");
            break;
        case F2dSemanticType.st_end_object : {
                this.objectStack.pop(); //pop the end_object we pushed at the beginning of the function

                if (!this.objectStack.length)
                    this.parserAssert(0,1, "parseEndObject (Stack Empty)");
                else {
                    //Do any end-of-object post processing depending on object type
                    var objType = this.objectStack.pop(); //pop the start object

                    switch (objType) {
                        case F2dSemanticType.st_polytriangle:   this.actOnPolyTriangle(); break;
                        case F2dSemanticType.st_clip:           this.actOnClip(); break;
                        case F2dSemanticType.st_raster:         this.actOnRaster(); break;
                        case F2dSemanticType.st_text:           this.actOnText(); break;
                        case F2dSemanticType.st_font_def:       this.actOnFontDef(); break;
                    }

                    //Zero out the state of the object we just finished processing
                    var name = this.objectNameStack.pop();
                    var state = this.parseObjState[name];
                    for (var p in state)
                        state[p] = null;
                }

                this.objectMemberQueue.length = 0;
            }
            break;
        default:
            this.objectNameStack.push("unknown");
            this.error = true;
            this.unhandledTypeWarning('parseObject', semantic_type);
            break;
    }
};


F2D.prototype.initSheet = function(paperColor) {

    this.bgColor = paperColor;

    if (this.hidePaper)
        return;

    if (this.metadata) {

        var pw = this.paperWidth;
        var ph = this.paperHeight;

        var vbb = this.currentVbb;

        //Put the paper the null layer so it won't
        //get turned off.
        var paperLayer = 0;
        var ss = pw * 0.0075;
        var shadowColor = 0xff555555;

        var points = [0,0, pw,0, pw,ph, 0,ph,
                      ss,-ss, pw+ss,-ss, pw+ss,0, ss,0,
                      pw,0, pw+ss,0, pw+ss,ph-ss, pw, ph-ss];
        var colors = [paperColor, paperColor, paperColor, paperColor,
                      shadowColor, shadowColor, shadowColor,shadowColor,
                      shadowColor, shadowColor, shadowColor,shadowColor];

        var indices = [0,1,2,0,2,3,
                       4,5,6,4,6,7,
                       8,9,10,8,10,11];

        this.addPolyTriangle(points, colors, indices, 0xffffffff, paperLayer, 0, false);

        //Page outline
        vbb.addSegment(0,0,pw,0,  1e-6, 0xff000000, 0, 0);
        vbb.addSegment(pw,0,pw,ph,1e-6, 0xff000000, 0, 0);
        vbb.addSegment(pw,ph,0,ph,1e-6, 0xff000000, 0, 0);
        vbb.addSegment(0,ph,0,0,  1e-6, 0xff000000, 0, 0);
    }
};

F2D.prototype.setObjectMember = function(val) {
    if (!this.objectMemberQueue.length) {
        debug("Unexpected object member. " + val);
        return false;
    }

    var propName = this.objectMemberQueue.shift();
    var curObjName = this.objectNameStack[this.objectNameStack.length-1];

    //The paper color needs to be processed as soon as it comes in
    //because we want to initialize the page geometry first, before
    //adding any other geometry
    if (curObjName == "sheet" && propName == "paperColor") {
        this.initSheet(val);
        return true;
    }
    else if (curObjName) {
        this.parseObjState[curObjName][propName] = val;
        return true;
    }

    return false;
};


F2D.prototype.parseString = function() {
    var s = this.stream;
    var sema = s.getVarints();

    var len = s.getVarints();
    var ret = s.getString(len);

    switch (sema) {
        case F2dSemanticType.st_object_member:
            if (this.setObjectMember(ret))
                return;
            break;
        default: debug("Unexpected opcode semantic type for string.");  break;
    }

    return ret;
};


F2D.prototype.actOnFontDef = function() {
    var fontDef = this.parseObjState.fontDef;
    this.fontDefs[++this.fontCount] = fontDef;
    this.fontId = this.fontCount;
};


F2D.prototype.parsePoint = function() {
    var s = this.stream;
    var sema = s.getVarints(); //skip past the semantics
    var ret = this.parsePointPositions();

    switch (sema) {
        case F2dSemanticType.st_object_member:
            if (this.setObjectMember(ret))
                return;
            break;
        default: debug("Unexpected opcode semantic type for point.");  break;
    }

    return ret;
};


F2D.prototype.parsePointsArray = function() {

    var s = this.stream;

    var sema = s.getVarints();

    var count = s.getVarints(); // number of coordinates * 2
    if (!count) return;
    count = count / 2;

    var ret = [];
    var position;

    for (var i = 0; i < count; ++i) {
        position = this.parsePointPositions();
        ret.push(position[0]);
        ret.push(position[1]);
    }

    switch (sema) {
        case F2dSemanticType.st_polyline :
            this.actOnPolylinePointsArray(ret);
            return;
        case F2dSemanticType.st_dot:
            this.actOnDot(ret);
            return;
        case F2dSemanticType.st_object_member:
            if (this.setObjectMember(ret))
                return;
            break;
        default: debug("Unexpected opcode semantic type for points array.");  break;
    }

    return ret;
};

F2D.prototype.parseIntArray = function() {
    var s = this.stream;
    var sema = s.getVarints();
    var count = s.getVarints(); // total number of elements in integer array.
    var retVal = [];
    for (var i = 0; i < count; ++i) {
        retVal.push(s.getUint32());
    }

    switch (sema) {
        case F2dSemanticType.st_object_member:
            if (this.setObjectMember(retVal))
                return;
            break;
        default:
            this.unhandledTypeWarning('parseIntArray', sema);
            break;
    }

    return retVal;
};

F2D.prototype.parseByteArray = function() {
    var s = this.stream;
    var sema = s.getVarints();
    var count = s.getVarints(); // total number of elements in byte array.
    var retVal = [];
    for (var i = 0; i < count; ++i) {
        retVal.push(s.getUint8());
    }

    switch (sema) {
        case F2dSemanticType.st_object_member:
            if (this.setObjectMember(retVal))
                return;
            break;
        default:
            this.unhandledTypeWarning('parseByteArray', sema);
            break;
    }

    return retVal;
};


F2D.prototype.parseVarintArray = function() {
    var s = this.stream;
    var sema = s.getVarints();

    var ret = [];

    // Total number of integers in array, not the total number of bytes.
    var count = s.getVarints();

    for (var i = 0; i < count; ++i) {
        ret.push(s.getVarints());
    }

    switch (sema) {
        case F2dSemanticType.st_object_member:
            if (this.setObjectMember(ret))
                return;
            break;
        default:
            this.unhandledTypeWarning('parseVarIntArray', sema);
            break;
    }

    return ret;
};


F2D.prototype.parseInt = function() {
    var s = this.stream;
    var sema = s.getVarints();
    var val = s.getUint32();

    switch (sema) {
        case F2dSemanticType.st_color:
            this.color = val;
            break;
        case F2dSemanticType.st_fill:
            this.fill = true;
            this.fillColor = val;
            break;
        case F2dSemanticType.st_object_member:
            if (this.setObjectMember(val))
                return;
        default:
            this.unhandledTypeWarning('parseInt', sema);
            break;
    }

    return val;
};

F2D.prototype.parseVoid = function() {
  var sema = this.stream.getVarints();
  switch (sema) {
      case F2dSemanticType.st_fill_off:
          this.fill = false;
          break;
      default:
          this.unhandledTypeWarning('parseVoid', sema);
          break;
  }
};

F2D.prototype.parseVarint = function() {
    var s = this.stream;
    var semantic_type = s.getVarints();
    var val = s.getVarints();

    switch (semantic_type) {
        case F2dSemanticType.st_line_weight:
            this.lineWeight = this.tx(val);
            break;
        case F2dSemanticType.st_object_id:
        case F2dSemanticType.st_markup_id:
            this.objectNumber = val;
            this.maxObjectNumber = Math.max(this.maxObjectNumber, val);
            break;
        case F2dSemanticType.st_layer:
            this.layer = this.layersMap[val];
            break;
        case F2dSemanticType.st_font_ref:
            this.fontId = val;
            break;
        case F2dSemanticType.st_object_member:
            if (this.setObjectMember(val))
                return;
            break;
        default:
            break;
    }

    return val;
};

F2D.prototype.parseFloat = function() {
    var s = this.stream;
    var semantic_type = s.getVarints();
    var val = s.getFloat32();

    switch (semantic_type) {
        case F2dSemanticType.st_miter_angle:
            break;
        case F2dSemanticType.st_miter_length:
            break;
        case F2dSemanticType.st_object_member:
            if (this.setObjectMember(val)) {
                return;
            }
            break;
        default:
            break;
    }

    return val;
};

F2D.prototype.parseCircularArc = function() {
    var s = this.stream;
    var sema = s.getVarints();
    if (this.parserAssert(sema, F2dSemanticType.st_arc, 'parseCircularArc')) return;

    var point = this.parsePointPositions();
    var major = s.getVarints(), /*rotation = s.getFloat32(),*/ start = s.getFloat32(), end = s.getFloat32();

    this.actOnCircularArc(point[0], point[1], start, end, this.sx(major));
};

F2D.prototype.parseCircle = function() {
    var s = this.stream;
    var sema = s.getVarints();
    if (this.parserAssert(sema, F2dSemanticType.st_arc, 'parseCircle')) return;

    var point = this.parsePointPositions();
    var major = s.getVarints();

    this.actOnCompleteCircle(point[0], point[1], this.sx(major));
};

F2D.prototype.parseArc = function() {
    var s = this.stream;
    var sema = s.getVarints();
    if (this.parserAssert(sema, F2dSemanticType.st_arc, 'parseArc')) return;

    // Relative positions.
    var point = this.parsePointPositions();

    var major = s.getVarints();
    var minor = s.getVarints();

    var rotation = s.getFloat32();
    var start = s.getFloat32();
    var end = s.getFloat32();

    this.actOnArc(point[0], point[1], start, end, this.sx(major), this.sy(minor), rotation);
};

F2D.prototype.parseDataType = function() {
    var data_type = this.stream.getVarints();

    switch (data_type) {
        case F2dDataType.dt_void:
            this.parseVoid();
            break;
        case F2dDataType.dt_int :
            this.parseInt();
            break;
        case F2dDataType.dt_object :
            this.parseObject();
            break;
        case F2dDataType.dt_varint :
            this.parseVarint();
            break;
        case F2dDataType.dt_point_varint :
            this.parsePoint();
            break;
        case F2dDataType.dt_float :
            this.parseFloat();
            break;
        case F2dDataType.dt_point_varint_array :
            this.parsePointsArray();
            break;
        case F2dDataType.dt_circular_arc :
            this.parseCircularArc();
            break;
        case F2dDataType.dt_circle :
            this.parseCircle();
            break;
        case F2dDataType.dt_arc :
            this.parseArc();
            break;
        case F2dDataType.dt_int_array:
            this.parseIntArray();
            break;
        case F2dDataType.dt_varint_array:
            this.parseVarintArray();
            break;
        case F2dDataType.dt_byte_array:
            this.parseByteArray();
            break;
        case F2dDataType.dt_string:
            this.parseString();
            break;
        default:
            this.error = true;
            debug("Data type not supported yet: " + data_type);
            break;
    }
};

F2D.prototype.parse = function() {
    var stream = this.stream = new InputStream(this.data);

    // "F2D"
    var header = stream.getString(3);

    if (header != "F2D") {
        debug("Invalid F2D header : " + header);
        return;
    }

    var versionMajor = stream.getString(2);
    if (versionMajor != "01") {
        debug("Only support f2d major version 1; actual version is : " + versionMajor);
        return;
    }

    var dot = stream.getString(1);
    if (dot != ".") {
        debug("Invalid version delimiter.");
        return;
    }

    var versionMinor = stream.getString(2);

    while (stream.offset < stream.byteLength) {
        this.parseDataType();
        if (this.error)
            break;
        this.opCount++;
    }

    this.flushBuffer(0, true);
    this.currentVbb = null;

    this.stream = null;
    this.data = null;

    debug("F2d parse: data types count : " + this.opCount);
};

F2D.prototype.parseFrames = function(flush) {

    if (this.data) {
        var stream = this.stream = new InputStream(this.data);
        while (stream.offset < stream.byteLength) {
            this.parseDataType();
            if (this.error)
                break;
            this.opCount++;
        }
    } else if (!flush) {
        debug("Unexpected F2D parse state: If there is no data, we only expect a flush command, but flush was false.");
    }

    if (flush) {
        this.flushBuffer(0, true);
    }

    this.stream = null;
    this.data = null;
};

// ================= Semantic Analysis Pass ======================//

F2D.prototype.actOnPolylinePointsArray = function(points) {

    this.flushBuffer();
    this.numPolylines ++;

    // For now only consider this.fill == false case.
    // TODO: handle fill case.

    var count = points.length / 2;

    var x0 = points[0];
    var y0 = points[1];
    for (var i = 1; i < count; ++i) {
        var x1 = points[2*i];
        var y1 = points[2*i+1];

        // TODO: make sure this function can be reused as is.
        this.currentVbb.addSegment(x0, y0, x1, y1, this.lineWeight, this.color, this.objectNumber, this.layer);

        x0 = x1;
        y0 = y1;
    }

    this.numLineSegs += count - 1;
};

F2D.prototype.actOnDot = function(points) {

    var x0 = points[0];
    var y0 = points[1];

    this.actOnCompleteCircle(x0, y0, this.sx(1));
};


F2D.prototype.actOnCompleteCircle = function(cx, cy, major) {
    // Relative positions.
    this.flushBuffer();
    this.numCircles++;

    if (this.fill) {
        //A simple filled circle can be handled
        //as degenerate thick line segment -- lots of these
        //in line style grass clippings
        this.currentVbb.addSegment(cx, cy, cx, cy, major * 2, this.color, this.objectNumber,
            this.layer, true, false, true);
    } else {
        this.currentVbb.addCircularArc(cx, cy, 0, Math.PI * 2, major,
            this.lineWeight, this.color, this.objectNumber, this.layer);
    }
};

F2D.prototype.actOnCircularArc = function(cx, cy, start, end, major) {
    this.numCircles++;
    this.flushBuffer();

//    debug("circle " + start + " " + end + " c " + this.color.toString(16));

    this.currentVbb.addCircularArc(cx, cy, start, end, major,
        this.lineWeight, this.color, this.objectNumber, this.layer);
};

F2D.prototype.actOnArc = function(cx, cy, start, end, major, minor, rotation) {
    this.numEllipses++;
    // TODO: need this?
    this.flushBuffer();
    this.currentVbb.addEllipticalArc(cx, cy, start, end, major, minor, rotation,
        this.lineWeight, this.color, this.objectNumber, this.layer);
};

F2D.prototype.actOnRaster = function() {

    if (!this.manifestAvailable)
        return;

    this.flushBuffer(4, true);

    var ps = this.parseObjState.raster;

    var position = ps.position,
        width = ps.width,
        height = ps.height,
        imageId = ps.imageId;

    var x = position[0],
        y = position[1],
        w = this.sx(width),
        h = this.sy(height);

    var texture = {
        dataURI : this.imageId2URI[imageId],
        width : w,
        height: h
    };

    this.currentVbb.addTexturedQuad(x, y - h, w, h, this.objectNumber, this.layer);
    this.currentImage = texture;

    //We can do one image per Vertex Buffer, so flush the quad
    this.flushBuffer(0, true);
};


F2D.prototype.actOnClip = function() {
    //TODO: clip not implemented yet.
};

F2D.prototype.actOnText = function() {
    //TODO: text not currently used
};


//Polytriangle processing differs depending on whether
//we want edge antialiasing and whether the renderer is using
//hardware instancing or not, so it require a lot more
//work than other geometries before sending raw primitives to the
//vertex buffer.
F2D.prototype.addPolyTriangle = function(points, colors, inds, color, layer, dbId, antialiasEdges) {
    var me = this;
    var edgeMap = null;

    //For non-text geometry we get good looking results with
    //1 pixel outlines. For text, which is generally small and highly detailed,
    //a 0.5 pixel AA outline does better.
    var aaLineWeight = -1.0; //negative = in pixel units
    if (this.objectStack[this.objectStack.length-1] == F2dSemanticType.st_text)
        aaLineWeight = -0.5;


    function processEdge(iFrom, iTo) {
        if (iFrom > iTo) {
            var tmp = iFrom;
            iFrom = iTo;
            iTo = tmp;
        }

        if (!edgeMap[iFrom])
            edgeMap[iFrom] = [iTo];
        else {
            var adjacentVerts = edgeMap[iFrom];
            var idx = adjacentVerts.lastIndexOf(iTo);
            if (idx == -1)
                adjacentVerts.push(iTo); //first time we see this edge, so remember it as exterior edge
            else
                adjacentVerts[idx] = -1; //the second time we see an edge mark it as interior edge
        }
    }


    function addAllAntialiasEdges() {

        for (var i = 0, iEnd = edgeMap.length; i<iEnd; i++) {

            var adjacentVerts = edgeMap[i];
            if (!adjacentVerts)
                continue;

            for (var j=0; j<adjacentVerts.length; j++) {
                var iTo = adjacentVerts[j];
                if (iTo == -1)
                    continue; //an interior edge was here -- skip
                else {
                    //exterior edge -- add an antialiasing line for it
                    me.flushBuffer(4);
                    me.currentVbb.addSegment(points[2*i], points[2*i+1],
                                             points[2*iTo], points[2*iTo+1],
                                             aaLineWeight,
                                             colors ? colors[i] : me.color,
                                             me.objectNumber, me.layer);

                    if (colors && (colors[i] != colors[iTo]))
                        debug("Gouraud triangle encountered. Will have incorrect antialiasing.");
                }
            }
        }
    }

    function antialiasOneEdge(iFrom, iTo) {
        if (iFrom > iTo) {
            var tmp = iFrom;
            iFrom = iTo;
            iTo = tmp;
        }

        var adjacentVerts = edgeMap[iFrom];
        if (!adjacentVerts)
            return;

        var idx = adjacentVerts.indexOf(iTo);
        if (idx != -1) {
            //exterior edge -- add an antialiasing line for it
            me.flushBuffer(4);
            me.currentVbb.addSegment(points[2*iFrom], points[2*iFrom+1],
                                     points[2*iTo], points[2*iTo+1],
                                     aaLineWeight,
                                     colors ? colors[iFrom] : me.color,
                                     me.objectNumber, me.layer);

            if (colors && (colors[iFrom] != colors[iTo]))
                debug("Gouraud triangle encountered. Will have incorrect antialiasing.");
        }
    }

    if (antialiasEdges) {
        edgeMap = new Array(points.length/2);

        for (var i= 0, iEnd = inds.length; i<iEnd; i+= 3) {
            var i0 = inds[i];
            var i1 = inds[i+1];
            var i2 = inds[i+2];

            processEdge(i0, i1);
            processEdge(i1, i2);
            processEdge(i2, i0);
        }
    }

    if (this.currentVbb.useInstancing) {
        var count = inds.length;
        for (var i = 0; i < count; i+=3) {
            var i0 = inds[i];
            var i1 = inds[i+1];
            var i2 = inds[i+2];

            this.flushBuffer(4);

            this.currentVbb.addTriangleGeom(points[2*i0], points[2*i0+1],
                                            points[2*i1], points[2*i1+1],
                                            points[2*i2], points[2*i2+1],
                                            colors ? colors[i0] : this.color, this.objectNumber, this.layer);

            if (antialiasEdges) {
                antialiasOneEdge(i0, i1);
                antialiasOneEdge(i1, i2);
                antialiasOneEdge(i2, i0);
            }
        }
    }
    else {
        var count = points.length / 2; // number of vertices

        this.flushBuffer(count);
        var vbb = this.currentVbb;
        var vbase = vbb.vcount;

        for (var i = 0; i < count; ++i) {
            var x = points[2*i];
            var y = points[2*i+1];
            vbb.addVertexPolytriangle(x, y, 0, 0, 0, colors ? colors[i] : this.color, this.objectNumber, this.layer);
        }

        count = inds.length;
        for (var i = 0; i < count; i+=3) {
            vbb.addTriangle(vbase + inds[i], vbase + inds[i+1], vbase + inds[i+2]);
        }

        if (antialiasEdges) {
            addAllAntialiasEdges();
        }

    }
};

F2D.prototype.actOnPolyTriangle = function() {

    var ptri = this.parseObjState.polyTriangle;
    this.parseObjState.polyTriangle = {};

    //if (this.objectStack[this.objectStack.length-1] == F2dSemanticType.st_text)
    //    return;

    var points = ptri.points;
    var inds = ptri.indices;
    var colors = ptri.colors;

    if (!points || !inds) {
        debug("Malformed polytriangle.");
        return;
    }

    this.numPolytriangles++;
    this.numTriangles += inds.length / 3;

    this.addPolyTriangle(points, colors, inds, this.color, this.layer, this.objectNumber, true);
};
;function F2DProbe() {
    this.data = null;
    this.frameStart = 0;
    this.frameEnd = 0;
    this.stream = null;
    this.opCount = 0;
    this.marker = {frameStart : this.frameStart,
                   frameEnd : this.frameEnd};
}

F2DProbe.prototype.load = function(data) {
    this.data = data;
    this.frameStart = 0;

    if (!this.stream) {
        this.stream = new CheckedInputStream(this.data);
        // Skip headers.
        this.stream.seek(8);
        this.frameStart = 8;
        this.frameEnd = 8;
    }
    else {
        this.stream.reset(this.data);
        this.stream.seek(0);
        this.frameEnd = 0;
    }

    this.probe();
    this.marker.frameStart = this.frameStart;
    this.marker.frameEnd = this.frameEnd;
    return this.marker;
};

var F2dProbeDataType = {
    //Fixed size types
    dt_object : 0,
    dt_void : 1,
    dt_byte : 2,
    dt_int : 3,
    dt_float : 4,
    dt_double : 5,
    dt_varint : 6,
    dt_point_varint : 7,

    //Variable size types
    //Data bytes are prefixed by an integer
    //representing the number of elements in the array.
    dt_byte_array : 32,
    dt_int_array : 33,
    dt_float_array : 34,
    dt_double_drray : 35,
    dt_varint_array : 36,
    //Special variable int encoding for point data
    dt_point_varint_array : 37,

    //Well-known data types that help reduce output size for commonly
    //encountered simple geometries
    dt_arc : 38,
    dt_circle : 39,
    dt_circular_arc : 40,

    dt_string : 63,
    //do not want to go into varint range
    dt_last_data_type : 127
};

var F2dProbeSemanticType = {
    //For objects with fixed serialization (arc, raster) we don't bother having dedicated semantic for each member
    //and assume the parsing application knows the order they appear. There is still an end-object tag of course
    //which shows where the object ends.
    st_object_member : 0,

    //Simple / fixed size attributes
    st_fill : 1,
    st_fill_off : 2,
    st_clip_off : 3,
    st_layer : 4,
    st_link : 5,
    st_line_weight : 6,
    st_miter_angle : 7,
    st_miter_length : 8,
    st_line_pattern_ref : 9,
    st_back_color : 10,
    st_color : 11,
    st_markup : 12,
    st_object_id : 13,
    st_markup_id : 14,
    st_reset_rel_offset : 15,
    st_font_ref : 16,

    //Compound object opcodes

    //Begin a generic object opcode
    st_begin_object : 32,

    //Style attribute related opcodes. Those are compound objects
    st_clip : 33,
    st_line_caps : 34,
    st_line_join : 35,
    st_line_pattern_def : 36,
    st_font_def : 37,

    //Drawables are all objects-typed bounded by begin/end object opcodes

    //Root level document begin
    st_sheet : 42,
    //Circle, Ellipse, Arcs
    st_arc : 43,
    //The grandfather of them all
    st_polyline : 44,
    st_raster : 45,
    st_text : 46,
    st_polytriangle : 47,
    st_dot : 48,
    //end object -- could be ending a generic object or drawable, etc.
    st_end_object : 63,

    st_last_semantic_type : 127
};

F2DProbe.prototype.readColor = function() {
    var s = this.stream;
    s.getVarints();// data type : dt_int 3
    s.getVarints(); // semantic type : st_object_member 0
    s.skipUint32(); // color
};

F2DProbe.prototype.parsePointPositions = function() {
    this.stream.getVarints();
    this.stream.getVarints();
};

F2DProbe.prototype.unhandledTypeWarning = function(inFunction, semanticType) {
    debug("Unhandled semantic type when probing F2d : " + semanticType + " in function " + inFunction);
};

F2DProbe.prototype.parseObject = function() {
    /*var semantic_type =*/ this.stream.getVarints();
    //debug("object parsing : type" + semantic_type);
};


F2DProbe.prototype.parseString = function() {
    var s = this.stream;
    s.getVarints();
    var len = s.getVarints();
    s.skipBytes(len);
};

F2DProbe.prototype.parsePoint = function() {
    this.stream.getVarints();
    this.parsePointPositions();
};

F2DProbe.prototype.parseVarintArray = function() {
    var s = this.stream;
    s.getVarints();

    var count = s.getVarints();
    for (var i = 0; i < count; ++i)
        s.getVarints();
};

F2DProbe.prototype.parseByteArray = function() {
    var s = this.stream;
    s.getVarints();
    var count = s.getVarints();
    s.skipBytes(count);
};

F2DProbe.prototype.parseEndOfObject = function() {
    var s = this.stream;
    s.getVarints();
    s.getVarints();
};

F2DProbe.prototype.parsePointsArray = function(context) {
    var s = this.stream;
    var sema = s.getVarints();
    var count = s.getVarints(); // number of coordinates * 2
    if (!count) return;
    count = count / 2;
    for (var i = 0; i < count; ++i)
        this.parsePointPositions();
};

F2DProbe.prototype.parsePoint = function(context) {
    var s = this.stream;
    var sema = s.getVarints();
    this.parsePointPositions();
};

F2DProbe.prototype.parseInt = function() {
    var s = this.stream;
    var sema = s.getVarints();

    switch (sema) {
        case F2dProbeSemanticType.st_color:
            s.skipUint32();
            break;
        case F2dProbeSemanticType.st_fill: {
            s.skipUint32();
            break;
        }
        default:
            s.skipUint32();
            this.unhandledTypeWarning('parseInt', sema);
            break;
    }
};

F2DProbe.prototype.parseVoid = function() {
    var sema = this.stream.getVarints();
    switch (sema) {
        case F2dProbeSemanticType.st_fill_off:
            break;
        default:
            this.unhandledTypeWarning('parseVoid', sema);
            break;
    }
};

F2DProbe.prototype.parseVarint = function() {
    this.stream.getVarints();
    this.stream.getVarints();
};

F2DProbe.prototype.parseIntArray = function() {
    var s = this.stream;
    s.getVarints();
    var count = s.getVarints();
    for (var i = 0; i < count; ++i)
        s.skipUint32();
};

F2DProbe.prototype.parseFloat = function() {
    var s = this.stream;
    s.getVarints();
    s.getFloat32();
};

F2DProbe.prototype.parseCircularArc = function() {
    var s = this.stream;
    s.getVarints();
    this.parsePointPositions();
    s.getVarints();
    s.getFloat32();
    s.getFloat32();
};

F2DProbe.prototype.parseCircle = function() {
    var s = this.stream;
    s.getVarints();
    this.parsePointPositions();
    s.getVarints();
};

F2DProbe.prototype.parseArc = function() {
    var s = this.stream;
    s.getVarints();
    this.parsePointPositions();
    s.getVarints();
    s.getVarints();
    s.getFloat32();
    s.getFloat32();
    s.getFloat32();
};

F2DProbe.prototype.parseDataType = function() {
    var data_type = this.stream.getVarints();

    switch (data_type) {
        case F2dProbeDataType.dt_void:
            this.parseVoid();
            break;
        case F2dProbeDataType.dt_int :
            this.parseInt();
            break;
        case F2dProbeDataType.dt_object :
            this.parseObject();
            break;
        case F2dProbeDataType.dt_varint :
            this.parseVarint();
            break;
        case F2dProbeDataType.dt_float :
            this.parseFloat();
            break;
        case F2dProbeDataType.dt_point_varint :
            this.parsePoint();
            break;
        case F2dProbeDataType.dt_point_varint_array :
            this.parsePointsArray();
            break;
        case F2dProbeDataType.dt_circular_arc :
            this.parseCircularArc();
            break;
        case F2dProbeDataType.dt_circle :
            this.parseCircle();
            break;
        case F2dProbeDataType.dt_arc :
            this.parseArc();
            break;
        case F2dProbeDataType.dt_varint_array:
            this.parseVarintArray();
            break;
        case F2dProbeDataType.dt_int_array:
            this.parseIntArray();
            break;
        case F2dProbeDataType.dt_byte_array:
            this.parseByteArray();
            break;
        case F2dProbeDataType.dt_string:
            this.parseString();
            break;
        default:
            this.error = true;
            debug("Bad op code encountered : " + data_type + " , bail out.");
            break;
    }

    if (!this.error)
        this.frameEnd = this.stream.offset;
};

F2DProbe.prototype.probe = function() {
    var stream = this.stream;
    var error = false;

    try {
        while (stream.offset < stream.byteLength) {
            this.parseDataType();
            if (this.error) {
                break;
            }
            this.opCount++;
        }
    } catch (exc) {
        // Typically caused by out of bounds access of data.
        var message = exc.toString();
        var stack = exc.stack ? exc.stack.toString() : "...";

        // Don't panic with this - we are supposed to hit out of bounds a couple of times when probing.
        //debug("Error in F2DProbe.prototype.probe : " + message + " with stack : " + stack);
    }
};;
// Similar as InputStream but with bounds checking.
// Throw exception when out of bounds access is / to be made.
function CheckedInputStream(buf) {
    this.buffer = buf;
    this.offset = 0;
    this.byteLength = buf.length;

    //We will use these shared memory arrays to
    //convert from bytes to the desired data type.
    this.convBuf = new ArrayBuffer(8);
    this.convUint8 = new Uint8Array(this.convBuf);
    this.convUint16 = new Uint16Array(this.convBuf);
    this.convInt32 = new Int32Array(this.convBuf);
    this.convUint32 = new Uint32Array(this.convBuf);
}

function OutOfBoundsBufferAccessException(offset) {
    this.offset = offset;
    this.message = "try to access an offset that is out of bounds: " + this.offset;
    this.toString = function() {
        return this.message;
    };
}

CheckedInputStream.prototype.boundsCheck = function(offset) {
    if (offset >= this.byteLength) {
        throw new OutOfBoundsBufferAccessException(offset);
    }
}

CheckedInputStream.prototype.seek = function(off) {
    this.boundsCheck(off);
    this.offset = off;
};

CheckedInputStream.prototype.getBytes = function(len) {
    this.boundsCheck(this.offset + len);
    var ret = new Uint8Array(this.buffer.buffer, this.offset, len);
    this.offset += len;
    return ret;
};

CheckedInputStream.prototype.skipBytes = function(len) {
    this.boundsCheck(this.offset + len);
    this.offset += len;
};


CheckedInputStream.prototype.getVarints = function () {
    var b;
    var value = 0;
    var shiftBy = 0;
    do {
        this.boundsCheck(this.offset);
        b = this.buffer[this.offset++];
        value |= (b & 0x7f) << shiftBy;
        shiftBy += 7;
    } while (b & 0x80);
    return value;
};

CheckedInputStream.prototype.getUint8 = function() {
    this.boundsCheck(this.offset + 1);
    return this.buffer[this.offset++];
};

CheckedInputStream.prototype.getUint16 = function() {
    this.boundsCheck(this.offset + 2);
    this.convUint8[0] = this.buffer[this.offset++];
    this.convUint8[1] = this.buffer[this.offset++];
    return this.convUint16[0];
};

CheckedInputStream.prototype.getInt16 = function() {
    var tmp = this.getUint16();
    //make negative integer if the ushort is negative
    if (tmp > 0x7fff)
        tmp = tmp | 0xffff0000;
    return tmp;
};

CheckedInputStream.prototype.getInt32 = function() {
    this.boundsCheck(this.offset + 4);
    var src = this.buffer;
    var dst = this.convUint8;
    var off = this.offset;
    dst[0] = src[off];
    dst[1] = src[off+1];
    dst[2] = src[off+2];
    dst[3] = src[off+3];
    this.offset += 4;
    return this.convInt32[0];
};

CheckedInputStream.prototype.getUint32 = function() {
    this.boundsCheck(this.offset + 4);
    var src = this.buffer;
    var dst = this.convUint8;
    var off = this.offset;
    dst[0] = src[off];
    dst[1] = src[off+1];
    dst[2] = src[off+2];
    dst[3] = src[off+3];
    this.offset += 4;
    return this.convUint32[0];
};

CheckedInputStream.prototype.skipUint32 = function() {
    this.boundsCheck(this.offset + 4);
    this.offset += 4;
};

CheckedInputStream.prototype.getFloat32 = function() {
    this.boundsCheck(this.offset + 4);
    this.offset += 4;
    return 0;
};

CheckedInputStream.prototype.getFloat64 = function() {
    this.boundsCheck(this.offset + 8);
    this.offset += 8;
    return 0;
};

CheckedInputStream.prototype.reset = function (buf) {
    this.buffer = buf;
    this.offset = 0;
    this.byteLength = buf.length;
};

;AutodeskNamespace('Autodesk.Viewing.Private');

var VIEWER2D_NAVIGATION_MODE = {PAN: 1, ZOOM: 2};

/** @constructor */
Autodesk.Viewing.Private.Viewer2DImpl = function (api, config)
{
    this.api = api;

    this.config = config;
    this.parent = config.domElement;

    this.navigationMode = null;
};

Autodesk.Viewing.Private.Viewer2DImpl.prototype.constructor = Autodesk.Viewing.Private.Viewer2DImpl;

Autodesk.Viewing.Private.Viewer2DImpl.prototype.initialize = function()
{
    //Think of this as the Heidi selection renderer -- a one pixel canvas
    //where we draw ids.
    var selectionCanvas = document.createElement('canvas');
    selectionCanvas.width = 1;
    selectionCanvas.height = 1;
    this.selCtx = selectionCanvas.getContext('2d');
    this.selCtx.globalCompositeOperation="copy";
    this.selCtx.imageSmoothingEnabled = false;

    // Create another div for leaflet to operate in.  The library adds CSS
    // classes that we don't want added to the parent element.
    //
    this.container = document.createElement('div');
    this.container.style.width = "100%";
    this.container.style.height = "100%";

    this.parent.appendChild(this.container);

    return 0; // No errors initializing.
};

Autodesk.Viewing.Private.Viewer2DImpl.prototype.load = function(sheetUrn)
{
    var rolloverColor = [-1,-1,-1,-1];
    var rolloverId = -1;

    //TODO: how can we know these up front -- hopefully they are in the document metadata?
    var tileSize = this.config.tileSize ? this.config.tileSize : 1024;
    var maxZoom = this.config.maxZoom ? this.config.maxZoom : 5;
    var colorExt = "png";

    // URL encode the 'urn:foo' part of the sheetUrn which might contain URL hostile chars.
    var index = sheetUrn.indexOf('urn:');
    // This will always be true unless someday we take 'urn:' out of the urn. So plan for that day.
    if (index != -1) {
        sheetUrn = sheetUrn.substr(0, index) + encodeURIComponent(sheetUrn.substr(index));
    }

    var layerNames = [sheetUrn];
    var layers = [];
    for (var i=0; i<layerNames.length; i++) {
        //The main color layer
        var l = L.tileLayer(layerNames[i] + '/{z}/{x}/c{y}.'+colorExt, {
            maxZoom: maxZoom,
            noWrap: true,
            continuousWorld:false,
            detectRetina:true,
            //reuseTiles: true,
            tileSize: tileSize
        });
        layers.push(l);

         //ID tiles / highghlighting disabled for now
        /*
        //The ID tiles layer
        var idl = L.tileLayer(layerNames[i] + '/{z}/{x}/i{y}.png', {
            maxZoom: maxZoom,
            noWrap: true,
            continuousWorld:false,
            detectRetina:true,
            //reuseTiles: true,
            tileSize: tileSize
        });
        layers.push(idl);

        //The overlay selection highlight canvas layer
        var cl = L.tileLayer.canvas(
            {
                maxZoom: maxZoom,
                noWrap: true,
                continuousWorld:false,
                tileSize: tileSize,
                //reuseTiles: true,
                zIndex : (layerNames.length * 2) + i //must be set explicitly for canvas layers
            });

        cl.idTileLayer = idl;
        idl.canvasLayer = cl;
        l.canvasLayer = cl;
        l.idTileLayer = idl;
        */

        //idl.on("tileload", function(e) {
        //console.log(e);
        //this.canvasLayer.redraw();
        //});

        /*
        cl.drawTile = function(canvas, tilePoint, zoom) {
            //find the id image from the id layer
            var tile = null;
            var container = this.idTileLayer.getContainer();
            if (container) {
                var tiles = container.children[1].getElementsByTagName('img');
                var urlPart = zoom + "/" + tilePoint.x + "/i" + tilePoint.y;
                for (var i=0; i<tiles.length; i++) {
                    if (tiles[i].src.indexOf(urlPart) != -1) {
                        tile = tiles[i];
                        break;
                    }
                }
            }

            //Make sure the tile is currently visible before we do slow things with it
            var left = parseInt(canvas.style.left);
            var top = parseInt(canvas.style.top);

            //Convert layer point to container point for the clipping
            if (map !== undefined) {
                var pt = map.containerPointToLayerPoint([left, top]);
                left -= pt.x-left;
                top -= pt.y-top;
            }

            var w = canvas.width;
            var h = canvas.height;

            //the canvas element has no parent here, so
            //we do the clipping in document space. Not sure
            //if this is correct.
            if (   (left >= document.body.offsetWidth)
                || (left + w < 0)
                || (top >= document.body.offsetHeight)
                || (top + h < 0))
            {
                //console.log("clipped out");
                return;
            }

            var ctx = canvas.getContext('2d');

            if (!tile || rolloverId == -1) {

                //We don't have the ID tile -- just clear with
                //fully transparent
                ctx.fillStyle="rgba(0, 0, 0, 0.0)";
                ctx.fillRect(0,0,tileSize,tileSize);
                canvas.currentPixelSrc = null;
            }
            else if (canvas.currentPixelSrc != tile.src) {
                ctx.globalCompositeOperation="copy";

                //TODO: check why this doesn't respect the
                //alpha blending op we told it to use.
                ctx.drawImage(tile,0,0,tileSize,tileSize);

                var imgData=ctx.getImageData(0,0,tileSize,tileSize);
                var pixels = imgData.data;
                for (var ptr=0, pEnd=pixels.length; ptr<pEnd; ptr+=4) {
                    if (   pixels[ptr] == rolloverColor[0]
                        && pixels[ptr+1] == rolloverColor[1]
                        && pixels[ptr+2] == rolloverColor[2]
                        && pixels[ptr+3] == rolloverColor[3])
                    {
                        //Highlighted pixel
                        pixels[ptr] = 255;
                        pixels[ptr+1] = 255;
                        pixels[ptr+2] = 0;
                        pixels[ptr+3] = 127;
                    }
                    else
                    {
                        //Non-highlighted pixel
                        pixels[ptr] = 0;
                        pixels[ptr+1] = 0;
                        pixels[ptr+2] = 0;
                        pixels[ptr+3] = 0;
                    }
                }
                ctx.putImageData(imgData,0,0);

                canvas.currentPixelSrc = tile.src;
                //console.log(tilePoint.x + " " + tilePoint.y);
            }
        };
        layers.push(cl);

        */
    }

    var map = this.map = L.map(this.container,
                                {
                                    center : new L.LatLng(0,0),
                                    zoom : 0,
                                    //zoomAnimation:false,
                                    zoomControl:false,
                                    attributionControl: false,
                                    layers : [layers[0]/*, layers[1], layers[2]*/]  //ID tiles / highghlighting disabled for now
                                });

    //Work around hardcoded 256 tile size in this function
    //by replacing the function.
    map.options.crs.scale = function(zoom) {
        return tileSize * Math.pow(2, zoom);
    };

    //Set up GUI for sheet switching
    var baseMaps = {};
    for (var i=0; i<layerNames.length; i++) {
        baseMaps[layerNames[i]] = layers[3*i];
    }

    var overlayMaps;

    L.control.layers(baseMaps, overlayMaps).addTo(map);

    var elements = document.getElementsByClassName("leaflet-control-layers");

    for (var i = 0; i < elements.length; i++) {
        elements[i].style.visibility="hidden";
    }

    map.on('baselayerchange', function(e) {
        console.log(e);
        var toRemove = [];
        for (var p in map._layers) {
            var layer = map._layers[p];
            if (layer != e.layer)
                toRemove.push(layer);
        }
        for (var i=0; i<toRemove.length; i++)
            map.removeLayer(toRemove[i]);

        if (e.layer.idTileLayer) {
            map.addLayer(e.layer.idTileLayer);
            map.addLayer(e.layer.canvasLayer);
        }
    });

    var self = this;

    // Mouse event handler state.
    //
    var isMouseDown = false;
    var mouseDownClientX, mouseDownClientY, mouseDownZoom, mouseDownCenter, pixelsPerZoomStep;

    this.mousemove = function (event) {
        if (!isMouseDown || (self.navigationMode !== VIEWER2D_NAVIGATION_MODE.ZOOM)) {
            return;
        }

        var deltaX = event.clientX - mouseDownClientX;
        var deltaY = event.clientY - mouseDownClientY;
        deltaY = -deltaY;

        if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
            var delta = (Math.abs(deltaX) > Math.abs(deltaY)) ? deltaX : deltaY;
            var newZoom = Math.round(mouseDownZoom + (delta / pixelsPerZoomStep));
            newZoom = Math.max(map.getMinZoom(), Math.min(newZoom, map.getMaxZoom()));
            map.setZoomAround(mouseDownCenter, newZoom, {animate: true});

            event.preventDefault();
            event.stopPropagation();
        }
    };

    map.on("mousedown", function (event) {
        isMouseDown = true;
        if (self.navigationMode === VIEWER2D_NAVIGATION_MODE.ZOOM) {
            mouseDownClientX = event.originalEvent.clientX;
            mouseDownClientY = event.originalEvent.clientY;
            mouseDownZoom = map.getZoom();
            mouseDownCenter = map.getCenter();

            var mapSize = map.getSize();
            var width = (mapSize.x < mapSize.y) ? mapSize.x : mapSize.y;
            var zoomRange = map.getMaxZoom() - map.getMinZoom();
            pixelsPerZoomStep = width / (2 * zoomRange);

            map.scrollWheelZoom.disable();
            window.addEventListener("mousemove", self.mousemove, false);

            event.originalEvent.preventDefault();
            event.originalEvent.stopPropagation();
        }
    });

    map.on("mouseup", function (event) {
        isMouseDown = false;
        if (self.navigationMode === VIEWER2D_NAVIGATION_MODE.ZOOM) {
            map.scrollWheelZoom.enable();
            window.removeEventListener("mousemove", self.mousemove, false);

            event.originalEvent.preventDefault();
            event.originalEvent.stopPropagation();
        }
    });

    this.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN);
/*
    var viewer = this;

    //ID tiles / highghlighting disabled for now
    map.on("mousemove", function (e) {

        if (isMouseDown)
            return;

        var layer;
        for (var p in map._layers) {
            var l = map._layers[p];
            if (l.idTileLayer && l.canvasLayer) {
                layer = l;
                break;
            }
        }

        if (!layer)
            return;

        var container = layer.idTileLayer.getContainer();
        var tiles = container.children[1].getElementsByTagName('img');
        var pt = map.containerPointToLayerPoint(e.containerPoint);
        var ex = pt.x;
        var ey = pt.y;
        //console.log("point " + ex + "," + ey);
        for (var i=0; i<tiles.length; i++) {
            var tile = tiles[i];
            var x = parseInt(tile.style.left);
            var y = parseInt(tile.style.top);
            var w = parseInt(tile.style.width);
            var h = parseInt(tile.style.height);

            if (ex < x || ex >= x+w || ey < y || ey >= y+h)
                continue;

            viewer.selCtx.drawImage(tile, x-ex, y-ey);
            var pData = viewer.selCtx.getImageData(0,0,1,1).data;

            var id = (pData[3] << 24) | (pData[0] << 16) | (pData[1] << 8) | pData[2];
            if (id != rolloverId) {
                rolloverId = id;

                rolloverColor[0] = pData[0];
                rolloverColor[1] = pData[1];
                rolloverColor[2] = pData[2];
                rolloverColor[3] = pData[3];

                layer.canvasLayer.redraw();
            }

            //console.log("tile intersection: " + id);
        }
    });
      */

    this.keyup = function (event) {
        var activeElementName = document.activeElement.nodeName;
        if (activeElementName === 'INPUT' || activeElementName === 'TEXTAREA') {
            return;
        }

        // TODO: define constants for keycodes
        // See ViewController.js
        //
        var handled = false;
        if (event.keyCode === 27) { // ESCAPE
            self.api.fireEvent({type: Autodesk.Viewing.ESCAPE_EVENT});
            handled = true;
        } else if ( event.keyCode === 36 || event.keyCode === 70 || event.keyCode === 72) { // HOME or f or h
            self.goHome();
            handled = true;
        }

        if (handled) {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    window.addEventListener('keyup', this.keyup, false);

    map.fitWorld();
    return true;
};

Autodesk.Viewing.Private.Viewer2DImpl.prototype.uninitialize = function()
{
    window.removeEventListener('mousemove', this.mousemove, false);
    window.removeEventListener('keyup', this.keyup, false);

    this.map.remove();
};

Autodesk.Viewing.Private.Viewer2DImpl.prototype.resize = function() {
    this.map.invalidateSize(false);
};

Autodesk.Viewing.Private.Viewer2DImpl.prototype.setNavigationMode = function(mode) {
    var changed = false;

    if (this.navigationMode !== mode) {
        this.navigationMode = mode;
        if (this.map) {
            if (mode === VIEWER2D_NAVIGATION_MODE.PAN) {
                this.map.dragging.enable();
                window.removeEventListener('mousemove', this.mousemove, false);

            } else if (mode === VIEWER2D_NAVIGATION_MODE.ZOOM) {
                this.map.dragging.disable();
            }
        }
        this.api.fireEvent({type: Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, value: mode});
        changed = true;
    }
    return changed;
};

Autodesk.Viewing.Private.Viewer2DImpl.prototype.goHome = function () {
    this.map.setView([0, 0], 0, {reset: true});
};
;AutodeskNamespace('Autodesk.Viewing.Private');

Autodesk.Viewing.Private.inWorkerThread = (typeof self !== 'undefined') && (typeof window === 'undefined');

/**
 * RefreshTokenHandler is used to request a new authentication token.
 * @constructor
 */
Autodesk.Viewing.Private.RefreshTokenHandler = function () {
};

/**
 * Override this to return a boolean indicating whether the token should
 * be refreshed based on the given request information.
 *
 * @param {int} statusCode - The status code of the failed http request.
 * @param {string} statusText - The status text of the failed http request.
 * @param {string} responseText - The response text of the failed http request.
 * @returns {boolean} - true if the token should be requested.
 */
Autodesk.Viewing.Private.RefreshTokenHandler.prototype.shouldRefreshToken = function (statusCode, statusText, responseText) {
    return statusCode === 401;
};

/**
 * Override this to call onTokenRefresh when the token has been refreshed
 * or onTokenRefreshFail if the token refresh has failed.
 *
 * @param {function} onTokenRefresh - A function taking an XmlHttpRequestProgressEvent which will be called
 *                                    if the token has been refreshed.
 * @param {function} onTokenRefreshFail - A function taking an XmlHttpRequestProgressEvent which will be called
 *                                        if the token refresh has failed.
 */
Autodesk.Viewing.Private.RefreshTokenHandler.prototype.refreshToken = function (onTokenRefresh, onTokenRefreshFail) {
};

/**
 * ViewingServiceRefreshTokenHandler is a token refresh handler for the viewing service.
 * @constructor
 */
Autodesk.Viewing.Private.ViewingServiceRefreshTokenHandler = function () {
    Autodesk.Viewing.Private.RefreshTokenHandler.call(this);
};
Autodesk.Viewing.Private.ViewingServiceRefreshTokenHandler.prototype = Object.create(Autodesk.Viewing.Private.RefreshTokenHandler.prototype);
Autodesk.Viewing.Private.ViewingServiceRefreshTokenHandler.prototype.constructor = Autodesk.Viewing.Private.ViewingServiceRefreshTokenHandler;

/**
 * Refresh the token when we see a 403 or 401 status code.
 *
 * @param statusCode
 * @param statusText
 * @param responseText
 * @returns {boolean}
 */
Autodesk.Viewing.Private.ViewingServiceRefreshTokenHandler.prototype.shouldRefreshToken = function (statusCode, statusText, responseText) {
    // For Apigee endpoints, we handle the 401 status code with an error code of AUTH-006,
    // meaning that the token is invalid or has expired.
    //
    var shouldRefreshToken = false;
    if (statusCode === 401) {
        var response = (typeof responseText === 'string') && (responseText !== '') ? JSON.parse(responseText) : responseText;
        shouldRefreshToken = responseText === '' || (response.hasOwnProperty('errorCode') && response.errorCode === 'AUTH-006');
    // For local testing, handle 403.
    //
    } else {
        shouldRefreshToken = (statusCode === 403);
    }
    return shouldRefreshToken;
};

/**
 * Refresh the token using the callback found in globalinit.js.
 *
 * @param onTokenRefresh
 * @param onTokenRefreshFail
 */
Autodesk.Viewing.Private.ViewingServiceRefreshTokenHandler.prototype.refreshToken = function (onTokenRefresh, onTokenRefreshFail) {
    var token = null;
    if (Autodesk.Viewing.Private.refreshToken) {
        token = Autodesk.Viewing.Private.refreshToken();
    }

    if (token) {
        if (Autodesk.Viewing.Private.env.indexOf('Autodesk') === 0) {
            Autodesk.Viewing.Private.setApigeeTokenInCookie(token, onTokenRefresh, onTokenRefreshFail);
        }
        else {
            Autodesk.Viewing.Private.setAuthTokenInCookie(token, onTokenRefresh, onTokenRefreshFail);
        }
    }
    else {
        if (onTokenRefreshFail) {
            onTokenRefreshFail(null);
        }
    }
};

/**
 * WorkerViewingServiceRefreshTokenHandler is a token refresh handler for the viewing service used in
 * a worker thread.
 *
 * Note, this just sends a message to the main thread to refresh the token, and continues when it
 * receives a message saying the token refresh is complete (whether successful or failed).
 *
 * To use this:
 * 1) Create this in a worker thread
 * 2) Ensure that the main thread has a token refresh handler and is listening for a message
 *    with the data {refreshToken: true}, and sends a message back with {tokenRefreshed: true} or false
 *    when the token refresh operation is complete.
 *
 * @constructor
 */
Autodesk.Viewing.Private.WorkerViewingServiceRefreshTokenHandler = function () {
    Autodesk.Viewing.Private.ViewingServiceRefreshTokenHandler.call(this);
};
Autodesk.Viewing.Private.WorkerViewingServiceRefreshTokenHandler.prototype = Object.create(Autodesk.Viewing.Private.ViewingServiceRefreshTokenHandler.prototype);
Autodesk.Viewing.Private.WorkerViewingServiceRefreshTokenHandler.prototype.constructor = Autodesk.Viewing.Private.WorkerViewingServiceRefreshTokenHandler;

Autodesk.Viewing.Private.WorkerViewingServiceRefreshTokenHandler.prototype.refreshToken = function (onTokenRefresh, onTokenRefreshFail) {
    if (Autodesk.Viewing.Private.inWorkerThread) {
        self.addEventListener('message', function (e) {
            if (e.data && e.data.tokenRefreshed) {
                onTokenRefresh(e);
            } else {
                onTokenRefreshFail(e);
            }
        });
        self.postMessage({refreshToken: true});
    } else {
        Autodesk.Viewing.Private.ViewingServiceRefreshTokenHandler.prototype.refreshToken.call(this, onTokenRefresh, onTokenRefreshFail);
    }
};

/**
 *  Xhr represents a generic xml http request.
 *
 *  @param {boolean} withCredentials - Set to true if the request should be made with credentials.
 *  @param {RefreshTokenHandler} refreshTokenHandler - The handler to refresh the token if authentication fails.
 *  @constructor
 */
Autodesk.Viewing.Private.Xhr = function (withCredentials, refreshTokenHandler) {
    this.request = new XMLHttpRequest();
    this.withCredentials = withCredentials;
    this.refreshTokenHandler = refreshTokenHandler;
};

/**
 *  Generates a full url given the base url, with query parameters appended.
 *  Override this to manipulate the url based on the service.
 #
 *  @param {string} url - The starting url
 *  @param {queryParams} queryParams - A string representing the query parameters in the
 *                                     form 'param1=value1&param2=value2&...&paramN=valueN'
 */
Autodesk.Viewing.Private.Xhr.prototype.generateUrl = function (url, queryParams) {
    var queryParametersToAdd = this.getDefaultQueryParameters();
    if(queryParams) {
        queryParametersToAdd += '&' + queryParams;
    }

    if (queryParametersToAdd) {
        url = url + "?" + queryParametersToAdd;
    }
    return url;
};

/**
 *  Returns the default headers to set for this request.
 *  Override this to return different default headers depending on the service.
 *
 *  @returns {Object=} The dictionary representing the default headers.
 */
Autodesk.Viewing.Private.Xhr.prototype.getDefaultHeaders = function () {
    return {};
};

/**
 *  Returns the default query parameters to append to the url for this request.
 *  Override this to return different default query parameters depending on the service.
 *
 *  @returns {string} - A string representing the default query parameters in the
 *                      form 'param1=value1&param2=value2&...&paramN=valueN'
 */
Autodesk.Viewing.Private.Xhr.prototype.getDefaultQueryParameters = function () {
    return '';
};

/**
 *  Adds the default headers along with the given headers to this request.
 *
 *  @param {Object=} headers - The dictionary representing the additional headers to add.
 */
Autodesk.Viewing.Private.Xhr.prototype.addHeaders = function (headers) {
    var headersToAdd = this.getDefaultHeaders();
    if (headers && headers.length > 0) {
        headersToAdd.push.apply(headersToAdd, headers);
    }

    for (var header in headersToAdd) {
        this.request.setRequestHeader(header, headersToAdd[header]);
    }
};

/**
 *  Performs a GET request.
 *
 *  @param {string} url - The url for the request.
 *  @param {function} onSuccess - A function that takes a single parameter that represents the response
 *                                returned if the request is successful.
 *  @param {function} onFailure - A function that takes an integer status code, and a string status, which together represent
 *                                the response returned if the request is unsuccessful, and a third data argument, which
 *                                has more information about the failure.  The data is a dictionary that minimally includes
 *                                the url, and an exception if one was raised.
 *  @param {Object=} [options] - A dictionary of options that can include:
 *                               retryOnAuthenticationFail - Use true if the token should be refreshed and this request
 *                                                           retried if the original request failed due to authentication.
 *                               headers - A dictionary representing the additional headers to add.
 *                               queryParams - A string representing the query parameters
 *                               responseType - A string representing the response type for this request.
 */
Autodesk.Viewing.Private.Xhr.prototype.get = function (url, onSuccess, onFailure, options) {
    var that = this;
    var options = options ? options : {};
    var url = that.generateUrl(url, options ? options.queryParams : null);

    try {
        var asynchronous = options.hasOwnProperty('asynchronous') ? options.asynchronous : true;
        that.request.open('GET', url, asynchronous);
        if (options.hasOwnProperty('responseType')) {
            that.request.responseType = options.responseType;
        }
        that.request.withCredentials = that.withCredentials;
        that.addHeaders(options.hasOwnProperty('headers') ? options.headers : []);

        function onError(e) {
            var retryRequest = options.hasOwnProperty('retryOnAuthenticationFail') ? options.retryOnAuthenticationFail : true;
            if (retryRequest && that.refreshTokenHandler && that.refreshTokenHandler.shouldRefreshToken(that.request.status, that.request.statusText, (that.request.responseType === 'text' || that.request.responseType === '') ? that.request.responseText : '')) {
                function onTokenRefresh(e) {
                    that.request = new XMLHttpRequest();
                    options.retryOnAuthenticationFail = false;
                    that.get(url, onSuccess, onFailure, options);
                }

                function onTokenRefreshFail(e) {
                    onFailure(that.request.status, that.request.statusText, {url: url});
                }

                that.refreshTokenHandler.refreshToken(onTokenRefresh, onTokenRefreshFail);
            }
            else {
                onFailure(that.request.status, that.request.statusText, {url: url});
            }
        }

        function onLoad(e) {
            if (that.request.status === 200) {
                onSuccess(that.request.response ? that.request.response : that.request.responseText);
            }
            else {
                onError(e);
            }
        }

        if (asynchronous) {
            that.request.onload = onLoad;
            that.request.onerror = onError;
            that.request.ontimeout = onError;
        }

        that.request.send();

        if (!asynchronous) {
            onLoad(null);
        }
    }
    catch (e) {
        onFailure(that.request.status, that.request.statusText, {url: url, exception: e});
    }
};

/**
 * ViewingServiceXhr is represents an xml http request to the viewing service.
 *
 * @param {string} viewingServiceBaseUrl - The base url for the viewing service.
 * @param {string} api - The api to call in the viewing service.
 * @param {Object=} [options] - An optional dictionary of options.  Current parameters:
 *                              {RefreshTokenHandler} [refreshTokenHandler] - the refresh token handler.  By default, it is a ViewingServiceRefreshTokenHandler.
 *                              {boolean} [encodeUrn] - when true, encodes the document urn if found.
 * @constructor
 */
Autodesk.Viewing.Private.ViewingServiceXhr = function (viewingServiceBaseUrl, api, options) {
    // Create a default refresh token handler if one was not provided.
    //
    var tokenHandler = (options && options.hasOwnProperty('refreshTokenHandler')) ? options.refreshTokenHandler : new Autodesk.Viewing.Private.WorkerViewingServiceRefreshTokenHandler();

    this.withCredentials = true;
    if (options && options.hasOwnProperty("withCredentials"))
        this.withCredentials = options.withCredentials;

    Autodesk.Viewing.Private.Xhr.call(this, this.withCredentials, tokenHandler);

    this.api = api;
    this.baseUrl = viewingServiceBaseUrl;
    this.options = options;
};

Autodesk.Viewing.Private.ViewingServiceXhr.prototype = Object.create(Autodesk.Viewing.Private.Xhr.prototype);
Autodesk.Viewing.Private.ViewingServiceXhr.prototype.constructor = Autodesk.Viewing.Private.ViewingServiceXhr;

/**
 * Overrides generateUrl to form the proper viewing service url given the base url and requested api.
 *
 * @param url
 * @param queryParams
 * @returns {string}
 */
Autodesk.Viewing.Private.ViewingServiceXhr.prototype.generateUrl = function (url, queryParams) {
    if (url.indexOf('urn:') === 0) {
        // For the 'items' api, the 'urn:' prefix is included.  For all others, strip it off.
        //
        if (this.api !== 'items') {
            url = url.substr(4);
        }

        // Explicitly handle the Apigee endpoint for retrieving bubbles.
        //
        var encodeUrn = this.options && this.options.hasOwnProperty('encodeUrn') ? this.options.encodeUrn : true;
        if (this.api === 'bubbles' && Autodesk.Viewing.Private.env.indexOf('Autodesk') == 0) {
            url = this.baseUrl + '/' + (encodeUrn ? encodeURIComponent(url) : url);
        } else {
            url = this.baseUrl + "/" + this.api + "/" + (encodeUrn ? encodeURIComponent(url) : url);
        }
    }
    return Autodesk.Viewing.Private.Xhr.prototype.generateUrl.call(this, url, queryParams);
};

/**
 * Returns the default headers for the viewing service.
 *
 * @returns {Object}
 */
Autodesk.Viewing.Private.ViewingServiceXhr.prototype.getDefaultHeaders = function () {
    var headers = {};
    //headers["Access-Control-Allow-Credentials"] = true;
    //headers["Access-Control-Allow-Origin"] = "*";
    return headers;
};

/**
 * Returns the default query parameters for the viewing service.
 * 
 * @returns {string}
 */
Autodesk.Viewing.Private.ViewingServiceXhr.prototype.getDefaultQueryParameters = function () {
    return (!this.withCredentials) ? "" : 'domain=' + (Autodesk.Viewing.Private.inWorkerThread ? self.location.hostname : window.location.hostname);  // For CORS caching issue.
};

var Xhr = (function () {
    var Xhr = function(errorHandler, auth, viewing_url) {
        this.xhr = new XMLHttpRequest();
        this.errorHandler = errorHandler;
        this.success = false;
        this.viewing_url = viewing_url;
        this.auth = auth;
    };

    Xhr.prototype.generateUrl = function(url, queryParams, options) {
        var index = url.indexOf('urn:');
        if (index === 0 && this.viewing_url) {
            var feature = (options && options.feature) ? options.feature : null;
            if (feature) {
                if (feature == 'render') {
                    // remove urn: prefix. We probably want to fix this on server side to avoid
                    // such UGLY code on client side.
                    url = url.substr(4);
                    url = this.viewing_url + "/" + feature + "/" + encodeURIComponent(url);
                } else if (feature == 'bubbles') {
                    url = url.substr(4);
                    url = this.viewing_url + "/" + feature + "/" + encodeURIComponent(url);
                } else if (feature == 'comments') {
                    url = url.substr(4);
                    url = this.viewing_url + "/" + feature + "/file/" + encodeURIComponent(url);
                } else {
                    url = this.viewing_url + "/" + feature + "/" + encodeURIComponent(url.substr(index));
                }
            } else {
                url = this.viewing_url + "/items/" + encodeURIComponent(url.substr(index));
            }
        }

        if (queryParams) {
            url = url + "?" + queryParams;
        }
        return url;
    };

    Xhr.prototype.addHeaders = function(headers) {
        // Add the defaults.
        //
        //headers["Access-Control-Allow-Credentials"] = true;
        //headers["Access-Control-Allow-Origin"] = "*";

        // Add the rest.
        //
        for(var header in headers) {
            this.xhr.setRequestHeader(header, headers[header]);
        }
    };

    // Perform a synchronous get.
    Xhr.prototype.get = function(path, headers, responseType, loadCB, feature, queryParams) {
        var url = this.generateUrl(path, queryParams, {feature: feature});

        try {
            this.xhr.open('GET', url, !!loadCB);
            this.xhr.responseType = responseType;
            this.success = false;
            if (this.auth)
                this.xhr.withCredentials = true;
            if (loadCB)
                this.xhr.onload = loadCB;

            this.addHeaders(headers);

            this.xhr.send();
        }
        catch (e) {
            if (this.errorHandler) {
                this.errorHandler.networkFailure(url, e);
            }
            return null;
        }

        this.errorCheck(url, 200);
        return this.xhr.response;
    };

    // Perform a synchronous post.
    Xhr.prototype.post = function(path, headers, body, responseType, loadCB, feature) {
        var url = this.generateUrl(path, null, {feature: feature});

        if (!headers["Content-Type"])
            headers["Content-Type"] = "application/json";

        try {
            this.xhr.open('POST', url, !!loadCB);
            this.xhr.responseType = responseType;
            this.success = false;
            if (this.auth)
                this.xhr.withCredentials = true;
            if (loadCB)
                this.xhr.onload = loadCB;

            this.addHeaders(headers);

            this.xhr.send(body);
        }
        catch (e) {
            if (this.errorHandler) {
                this.errorHandler.networkFailure(url, e);
            }
            return null;
        }

        this.errorCheck(url, 200, 201);
        return this.xhr.response;
    };

    // Perform a synchronous ranged get.
    // rangeBegin and rangeEnd are inclusive bounds that mark the start / end of the range.
    // Require server side support of ranged get. Caller's job to make sure this invariant holds.
    // http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html
    Xhr.prototype.getRange = function(url, headers, responseType, rangeBegin, rangeEnd, loadCB) {
        var url = this.generateUrl(path);

        headers["Range"] = "bytes=" + rangeBegin + "-" + rangeEnd;

        try {
            this.xhr.open('GET', url, !!loadCB);
            this.xhr.responseType = responseType;
            this.success = false;
            if (this.auth)
                this.xhr.withCredentials = true;
            if (loadCB)
                this.xhr.onload = loadCB;

            this.addHeaders(headers);

            this.xhr.send();
        }
        catch (e) {
            if (this.errorHandler) {
                this.errorHandler.networkFailure(url, e);
            }
            return null;
        }

        this.errorCheck(url, 206);
        return this.xhr.response;
    };

    // Perform a synchronous head request.
    // Return the headers of response.
    Xhr.prototype.head = function(url) {
        var url = this.generateUrl(path);

        try {
            this.xhr.open('GET', url, false);
            this.success = false;
            if (this.auth)
                this.xhr.withCredentials = true;

            this.addHeaders([]);

            this.xhr.send();
        }
        catch (e) {
            if (this.errorHandler) {
                this.errorHandler.networkFailure(url, e);
            }
            return null;
        }

        this.errorCheck(url, 200);

        var responseHeaders = [];
        responseHeaders["Accept-Ranges"] = this.xhr.getResponseHeader("Accept-Ranges");
        responseHeaders["Content-Length"] = this.xhr.getResponseHeader("Content-Length");
        return responseHeaders;
    };

    // Changed it to support more than one status code
    Xhr.prototype.errorCheck = function(url, expectedStatusCode) {
        if (this.xhr.readyState === 4 && this.xhr.status) {
            var i;
            for (i = 1; i < arguments.length; i++) {
                if (this.xhr.status === arguments[i])
                    break;
            }
            if (i === arguments.length && this.errorHandler) {
                this.errorHandler.unsuccessfulResponse(url, this.xhr.status, this.xhr.statusText);
            } else {
                this.success = true;
            }
        } else {
            this.success = true;
        }
    };

    return Xhr;
})();

// A default Xhr error handler that will pass errors to raiseError
var XhrErrorHandler = (function() {
    // host will be whatever object is hosting the raiseError function,
    // usually Viewer3DImpl from the main thread or "self" from a worker
    var XhrErrorHandler = function(host) {
        this.host = host;
        this.ignoreFileNotFound = false;
    }

    // Xhr failed outright (timeout, host unreachable, etc.)
    XhrErrorHandler.prototype.networkFailure = function(url, exc) {
        this.host.raiseError(
            Autodesk.Viewing.ErrorCodes.NETWORK_FAILURE,
            "Network failure",
            { "url": url, "exception": exc.toString(), "stack": exc.stack });
    };

    // Response to Xhr was "unsuccessful" (non-200 status code)
    XhrErrorHandler.prototype.unsuccessfulResponse = function(url, httpStatus, httpStatusText) {
        if (httpStatus == 403) {
            this.host.raiseError(
                Autodesk.Viewing.ErrorCodes.NETWORK_ACCESS_DENIED,
                "Access denied to remote resource",
                { "url": url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
        }
        else if (httpStatus == 404) {
            if (!this.ignoreFileNotFound) {
                this.host.raiseError(
                    Autodesk.Viewing.ErrorCodes.NETWORK_FILE_NOT_FOUND,
                    "Remote resource not found",
                    { "url": url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
            }
        }
        else if (httpStatus >= 500 && httpStatus < 600) {
            this.host.raiseError(
                Autodesk.Viewing.ErrorCodes.NETWORK_SERVER_ERROR,
                "Server error when accessing resource",
                { "url": url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
        }
        else {
            this.host.raiseError(
                Autodesk.Viewing.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE,
                "Unhandled response code from server",
                { "url": url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
        }
    };

    return XhrErrorHandler;
})();;AutodeskNamespace('Autodesk.Viewing.Private');

Autodesk.Viewing.Private.Logger = function (options) {
    this.queue = [];
    // Sinks.
    this.console = options.console;
    this.viewingservice = options.viewingservice;
    this.webstorage = options.webstorage;

    this.endpoint = options.endpoint + "/logs/";
    this.flushThreshold = options.flushThreshold;

    if (this.viewingservice) {
        this.xhr = new XMLHttpRequest();
    }

    this.lastFlushTime = Date.now();
};

Autodesk.Viewing.Private.Logger.prototype.bindURN = function (urn) {
    this.urn = urn;
};

Autodesk.Viewing.Private.Logger.prototype.flush = function () {
    if (!this.queue.length) return;
    
    var log = JSON.stringify(this.queue);
    if (this.viewingservice) {
        try {
            var xhr = this.xhr;
            xhr.open('POST', this.endpoint + encodeURIComponent(this.urn), true);
            xhr.setRequestHeader("Access-Control-Allow-Credentials", "true");
            xhr.setRequestHeader("Access-Control-Allow-Origin", "*");
            xhr.setRequestHeader("Content-Type", "text/plain");
            xhr.withCredentials = true;
            xhr.send(log);
        } catch (e) {} // Just ignore log post errors for now.
    }

    this.queue = [];
    this.lastFlushTime = Date.now();
};

Autodesk.Viewing.Private.Logger.prototype.log = function (entry, forceFlush) {
    this.queue.push(entry);

    if (this.queue.length > this.flushThreshold || forceFlush) {
        this.flush();
    }
};
;
//The property database instance
var propdb = null;
var propdbFailed = false;

function loadPropertyPacks(loadContext, dbId, onPropertyPackLoadComplete) {
    if (propdb) {
        onPropertyPackLoadComplete(propdb);
        return;
    }

    if (propdbFailed) {
        onPropertyPackLoadComplete(null);
        return;
    }

    var dbfiles = loadContext.propertydb;
    if (!dbfiles) {
        propdbFailed = true;
        onPropertyPackLoadComplete(null);
        return;
    }

    var loadedDbFiles = {
        ids : {},
        attrs : {},
        offsets : {},
        values: {},
        avs: {}
    };

    //Get the property files
    //TODO: If we start sharding, this has to fetch property file chunk corresponding to the database ID
    //we need the properties for
    var filesToRequest = [];
    filesToRequest.push({filename: dbfiles.attrs.length ? dbfiles.attrs[0] : "objects_attrs.json.gz", storage: loadedDbFiles.attrs});
    filesToRequest.push({filename: dbfiles.values.length ? dbfiles.values[0] : "objects_vals.json.gz", storage: loadedDbFiles.values});
    filesToRequest.push({filename: dbfiles.avs.length ? dbfiles.avs[0] : "objects_avs.json.gz", storage: loadedDbFiles.avs});
    filesToRequest.push({filename: dbfiles.offsets.length ? dbfiles.offsets[0] : "objects_offs.json.gz", storage: loadedDbFiles.offsets});

    //TODO: The section below is temporarily there for AutoCAD, which
    //neither lists property db files in a manifest anywhere, nor compresses
    //them to .gz format so that the code above works... So we do a last
    //attempt to request non-compressed json files.
    var triedUncompressed = false;
    function getUncompressedFiles() {
        var uncompressedFilesToRequest = [];
        uncompressedFilesToRequest.push({filename: "objects_attrs.json", storage: loadedDbFiles.attrs});
        uncompressedFilesToRequest.push({filename: "objects_vals.json", storage: loadedDbFiles.values});
        uncompressedFilesToRequest.push({filename: "objects_avs.json", storage: loadedDbFiles.avs});
        uncompressedFilesToRequest.push({filename: "objects_offs.json", storage: loadedDbFiles.offsets});
        return uncompressedFilesToRequest;
    }

    function onRequestCompletion(data) {
        // When the file request is complete and there's no data, this means
        // that it failed.  Try requesting the uncompressed files, if we haven't
        // already.  If we have, remember that it failed and don't request any
        // more files.
        //
        if (!data) {
            if (triedUncompressed) {
                propdbFailed = true;
                onPropertyPackLoadComplete(null);
                return;
            } else {
                triedUncompressed = true;
                filesToRequest = getUncompressedFiles();
            }
        }

        // If all of the files we've requested have been retrieved, create the
        // property database.  Otherwise, request the next required file.
        //
        if (filesToRequest.length === 0) {
            propdb = new PropertyDatabase(loadedDbFiles);
            onPropertyPackLoadComplete(propdb);
            propdbFailed = false;
        } else {
            var nextFile = filesToRequest.shift();
            requestFile(nextFile.filename, loadContext, onRequestCompletion, nextFile.storage);
        }
    }

    // Request the first file.
    //
    var nextFile = filesToRequest.shift();
    requestFile(nextFile.filename, loadContext, onRequestCompletion, nextFile.storage);
};

function doPropertyGet(_this, loadContext) {
    var dbId = loadContext.dbId;
    function onPropertyPackLoadComplete(propertyDb) {
        if (propertyDb) {
            var result = propertyDb.getObjectProperties(dbId);
            _this.postMessage({result: result, dbId: dbId});
        }
    }

    loadPropertyPacks(loadContext, dbId, onPropertyPackLoadComplete);
};

function computeTreeBBoxes(node, nodeBoxes, fragBoxes) {

    var box_offset = node.dbId * 6;
    nodeBoxes[box_offset]   = nodeBoxes[box_offset+1] = nodeBoxes[box_offset+2] =  Infinity;
    nodeBoxes[box_offset+3] = nodeBoxes[box_offset+4] = nodeBoxes[box_offset+5] = -Infinity;

    var children = node.children;
    if (children) {
        //Recurse, then add all child boxes to make this node's box
        for (var i= 0, iEnd=children.length; i<iEnd; i++) {

            computeTreeBBoxes(children[i], nodeBoxes, fragBoxes);

            var child_box_offset = (children[i].dbId | 0) * 6;
            for (var k=0; k<3; k++) {
                if (nodeBoxes[box_offset+k] > nodeBoxes[child_box_offset+k])
                    nodeBoxes[box_offset+k] = nodeBoxes[child_box_offset+k];
                if (nodeBoxes[box_offset+k+3] < nodeBoxes[child_box_offset+k+3])
                    nodeBoxes[box_offset+k+3] = nodeBoxes[child_box_offset+k+3];
            }
        }
    }

    //Leaf node -- don't know if it's possible for a node to have
    //both children and leaf fragments, but we do handle that here.
    if (node.fragIds !== undefined) {
        if (!Array.isArray(node.fragIds)) {
            //Common case where the node only has one fragment
            var frag_box_offset = (node.fragIds | 0) * 6;
            for (var k=0; k<3; k++) {
                if (nodeBoxes[box_offset+k] > fragBoxes[frag_box_offset+k])
                    nodeBoxes[box_offset+k] = fragBoxes[frag_box_offset+k];
                if (nodeBoxes[box_offset+k+3] < fragBoxes[frag_box_offset+k+3])
                    nodeBoxes[box_offset+k+3] = fragBoxes[frag_box_offset+k+3];
            }
        }
        else if (node.fragIds.length) {
            //Case where the node has multiple fragments
            //In LMV this only happens when a mesh was too big
            //and was split, otherwise at the leaf level it is
            //one node per one mesh instance.

            for (var j=0; j<node.fragIds.length; j++) {
                frag_box_offset = (node.fragIds[j] | 0) * 6;
                for (var k=0; k<3; k++) {
                    if (nodeBoxes[box_offset+k] > fragBoxes[frag_box_offset+k])
                        nodeBoxes[box_offset+k] = fragBoxes[frag_box_offset+k];
                    if (nodeBoxes[box_offset+k+3] < fragBoxes[frag_box_offset+k+3])
                        nodeBoxes[box_offset+k+3] = fragBoxes[frag_box_offset+k+3];
                }
            }
        }
    }
};


function buildDbIdToFragMap(fragToDbId) {
    var ret = {};
    for (var i= 0, iEnd=fragToDbId.length; i<iEnd; i++) {

        var dbId = fragToDbId[i];
        var frags = ret[dbId];
        if (frags === undefined) {
            //If it's the first fragments for this dbid,
            //store the index directly -- most common case.
            ret[dbId] = i;
        }
        else if (!Array.isArray(frags)) {
            //otherwise put the fragments that
            //reference the dbid into an array
            ret[dbId] = [frags, i];
        }
        else {
            //already is an array
            frags.push(i);
        }
    }

    return ret;
};

function doObjectTreeParse(_this, loadContext) {
    function onPropertyPackLoadComplete(propertyDb) {
        if(!propertyDb) {
            _this.postMessage({instanceTree:null, maxTreeDepth:0});
            return;
        }

        var dbToFrag;
        if (loadContext.fragToDbId)
            dbToFrag = buildDbIdToFragMap(loadContext.fragToDbId);

        //TODO: we should get the root node from the instance
        //tree in the SVF, and go from there, so this logic
        //is a temporary thing to get work on the tree view moving
        //Find the root object:
        var idroots = propertyDb.findRootNodes();
        var root;
        var maxDepth = [0];
        var objCount = propertyDb.getObjectCount();

        //In the cases of 2D drawings, there is no meaningful
        //object hierarchy, so we don't build a tree.
        if (idroots && idroots.length)
        {
            if (idroots.length == 1) {
                //Case of a single root in the property database,
                //use that as the document root.
                root = { dbId: idroots[0] };
                propertyDb.buildObjectTree(root, dbToFrag, 0, maxDepth);
            }
            else {
                //Case of multiple nodes at the root level
                //This happens in DWFs coming from Revit.
                //Create a dummy root and add all the other roots
                //as its children.
                root = { dbId: 0, children:[] };
                for (var i=0; i<idroots.length; i++) {
                    var child = {dbId:idroots[i]};
                    root.children.push(child);
                    propertyDb.buildObjectTree(child, dbToFrag, 0, maxDepth);
                }
            }
        }

        _this.postMessage({instanceTree:root, maxTreeDepth:maxDepth[0], objectCount:objCount});

        //Now compute the bounding boxes for instance tree nodes
        if (loadContext.fragBoxes) {
            var nodeBoxes = new Float32Array(6 * propertyDb.getObjectCount());

            computeTreeBBoxes(root, nodeBoxes, loadContext.fragBoxes);

            _this.postMessage({instanceBoxes:nodeBoxes});
        }
    }

    loadPropertyPacks(loadContext, null, onPropertyPackLoadComplete);
};

function requestFile(filename, loadContext, onRequestCompletion, storage) {
    function onFailure(status, statusText, data) {
        // We're explicitly ignoring missing property files.
        if (status !== 404) {
            loadContext.onFailureCallback(status, statusText, data);
        }
        onRequestCompletion(null);
    }

    var url = loadContext.url + filename;
    var onSuccess = null;

    if (url.indexOf(".gz", url.length - 3) !== -1) {
        onSuccess = function(gzbuf)
        {
            try {
                var rawbuf = new Uint8Array(gzbuf);
                //It's possible that if the Content-Encoding header is set,
                //the browser unzips the file by itself, so let's check if it did.
                if (rawbuf[0] == 31 && rawbuf[1] == 139) {
                    rawbuf = new Zlib.Gunzip(rawbuf).decompress();
                }

                storage[filename] = rawbuf;
                onRequestCompletion(rawbuf);
            }
            catch (e) {
                self.raiseError(
                    Autodesk.Viewing.ErrorCodes.BAD_DATA,
                    "Malformed data received when requesting file",
                    { "url": url, "exception": e.toString(), "stack": e.stack });
                onRequestCompletion(null);
            }
        };
    }
    else {
        //NOTE: For property database requests, we do not want to
        //parse the JSON up front, because it may be too big. The
        //property database does its own parsing.

        onSuccess = function(json)
        {
            storage[filename] = rawbuf;
            onRequestCompletion(new Uint8Array(json));
        };
    }

    var xhr = new Autodesk.Viewing.Private.ViewingServiceXhr(loadContext.viewing_url, 'items', {withCredentials:!!loadContext.auth});
    xhr.get(url, onSuccess, onFailure, {responseType:'arraybuffer', asynchronous:false, headers:loadContext.headers, queryParams:loadContext.queryParams});
};

function doPropertySearch(_this, loadContext) {
    function onPropertyPackLoadComplete(propertyDb) {
        if (propertyDb) {
            var result = propertyDb.bruteForceSearch(loadContext.searchText);
            _this.postMessage(result);
        }
    }

    loadPropertyPacks(loadContext, null, onPropertyPackLoadComplete);
};;
function doGeomLoad(_this, loadContext) {

    //Make a blocking request -- it's ok, because
    //we are in a worker thread.

    function onSuccess(arrayBuffer) {
        _this.postMessage({
            url: loadContext.url,
            workerId: loadContext.workerId,
            progress: 0.5
        }); //rough progress reporting -- can do better

        try {
            var pfr = new PackFileReader(new Uint8Array(arrayBuffer));
        }
        catch (exc) {
            _this.raiseError(
                Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unhandled exception while reading pack file",
                { "url": loadContext.url, "exception": exc.toString(), "stack": exc.stack });
            _this.postMessage(null);
            return;
        }

        var raisedError = false;
        var raisedException = false;

        var msg = { "packId": loadContext.packId,
            "meshIndex" : 0,
            "mesh": null,
            "workerId" : loadContext.workerId,
            "progress": 0
        };

        for (var i = 0, iEnd = pfr.getEntryCounts(); i<iEnd; i++)
        {
            try {
                var mesh = readGeometry(pfr, i, null /*TODO geom type*/);
            }
            catch (exc) {
                if (!raisedException) {
                    _this.raiseError(
                        Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unhandled exception while reading geometry",
                        { "url": loadContext.url, "exception": exc.toString(), "stack": exc.stack });
                    raisedException = true;
                    raisedError = true;
                }

                var mesh = null;
            }

            msg.meshIndex = i;
            msg.mesh = mesh;
            msg.progress = 0.5 + 0.5 * ((i+1)/iEnd);

            if (mesh) {
                // Otherwise, use transferable objects as we can.
                var transferList = [];
                transferList.push(mesh.vb.buffer);
                _this.postMessage(msg, transferList);
            } else {
                // it doesn't make much sense to raise an error for each entry that can't
                // be read, because chances are they will all be unreadable after the
                // first bad one.
                if (!raisedError) {
                    _this.raiseError(
                        Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unable to load geometry",
                        { "url": loadContext.url });
                    raisedError = true;
                }

                // in this case, we still post the full message instead of just null;
                // the mesh itself will be null, of course.
                _this.postMessage(msg);
            }
        }
    }

    var xhr = new Autodesk.Viewing.Private.ViewingServiceXhr(loadContext.viewing_url, 'items', {withCredentials:!!loadContext.auth});
    xhr.get(loadContext.url, onSuccess, loadContext.onFailureCallback, {responseType:'arraybuffer', asynchronous:false, headers:loadContext.headers, queryParams:loadContext.queryParams});
}
;

function doLoadSvf(_this, loadContext) {

    function onSuccess(arrayBuffer) {

        _this.postMessage({progress:0.5}); //rough progress reporting -- can do better

        var svf = new Package();

        function loadDoneCallback(success) {
            if (success) {
                var msg = { "svf" : svf };
                //var frags = svf.fragments;
                _this.postMessage(msg /*,
                 [
                 frags.boxes.buffer,
                 frags.transforms.buffer,
                 frags.materials.buffer,
                 frags.packIds.buffer,
                 frags.entityIndexes.buffer,
                 frags.groupIndexes.buffer
                 ]*/
                );
            }
            else {
                _this.raiseError(
                    Autodesk.Viewing.ErrorCodes.BAD_DATA, "Failure while loading SVF",
                    { "url": loadContext.url });
                _this.postMessage(null);
            }
        }

        loadContext.loadDoneCB = loadDoneCallback;

        try {
            svf.load(loadContext, new Uint8Array(arrayBuffer));
        }
        catch (exc) {
            _this.raiseError(
                Autodesk.Viewing.ErrorCodes.BAD_DATA, "Unhandled exception while loading SVF",
                { "url": loadContext.url, "exception": exc.toString(), "stack": exc.stack });
            _this.postMessage(null);
            return;
        }

    }

    var xhr = new Autodesk.Viewing.Private.ViewingServiceXhr(loadContext.viewing_url, 'items', {withCredentials:!!loadContext.auth});
    xhr.get(loadContext.url, onSuccess, loadContext.onFailureCallback, {responseType:'arraybuffer', asynchronous:false, headers:loadContext.headers, queryParams:loadContext.queryParams});
}
;
/** @define {boolean} */
var ENABLE_OCTM_MG2 = false;

//This magic defines the worker stuff only
//if this javascript is executed in a worker.
//This way we can use a single compacted javascript file
//as both the main viewer and its workers.
//I think of it as fork() on Unix.
var IS_WORKER = (typeof self !== 'undefined') && (typeof window === 'undefined');
if (IS_WORKER)
{

var IS_CONCAT_BUILD;

var f2d = null;

if (!IS_CONCAT_BUILD)
{
    //Everything below will get compiled into the worker JS during build

    importScripts("../AutodeskNamespace.js");
    importScripts("../compatibility.js"); //browser compatibility polyfills, etc.

    importScripts("../render/adsk_three.js"); //Vector math

    //TODO: This means two copies of the inflate algorithm
    //will get included -- we can do a custom build of zlib
    //to avoid this.
    importScripts("../lmvtk/gunzip.min.js"); //For RAW compressed pack files
    importScripts("../lmvtk/unzip.min.js"); //for SVF packages

    //MG2 compression -- disabled by default.
    if (ENABLE_OCTM_MG2) {
        importScripts("../lmvtk/inflate.min.js"); //for OCTM MG2 compression
        importScripts("../lmvtk/octm_mg2.js"); //for OCTM MG2 compression
    }

    importScripts("../lmvtk/InputStream.js");
    importScripts("../lmvtk/VbUtils.js");
    importScripts("../lmvtk/VertexBufferBuilder.js");
    importScripts("../lmvtk/PackReader.js");
    importScripts("../lmvtk/Geoms.js");
    importScripts("../lmvtk/Materials.js");
    importScripts("../lmvtk/Lights.js");
    importScripts("../lmvtk/Cameras.js");
    importScripts("../lmvtk/Fragments.js");
    importScripts("../lmvtk/Instances.js");
    importScripts("../lmvtk/Package.js");
    importScripts("../lmvtk/PackReader.js");
    importScripts("../lmvtk/Propdb.js");
    importScripts("../lmvtk/F2d.js");
    importScripts("../lmvtk/F2dProbe.js");
    importScripts("../lmvtk/CheckedInputStream.js");
    importScripts("../net/Xhr.js");
    importScripts("GeomWorker.js");
    importScripts("SvfWorker.js");
    importScripts("PropWorker.js");
    importScripts("F2dParseWorker.js");
    importScripts("F2dStreamWorker.js");
    importScripts("CloudRenderingWorker.js");

    // TODO: Look into moving these out
    importScripts("../application/Viewer.js");
    importScripts("../ErrorCodes.js");

}


//Web worker dispatcher function -- received a message
//from the main thread and calls the appropriate handler
self.addEventListener('message', function(e) {

    var loadContext = e.data;
    if(!loadContext.hasOwnProperty('operation')) {
        return;
    }

    //Initialize the path that contains the requested
    //file. It's the root for other relative paths referenced
    //by the base file.
    loadContext.basePath = "";
    if (loadContext.url) {
        var lastSlash = loadContext.url.lastIndexOf("/");
        if (lastSlash != -1)
            loadContext.basePath = loadContext.url.substr(0, lastSlash+1);
    }


    // Create the default failure callback.
    //
    loadContext.onFailureCallback = function (httpStatus, httpStatusText, data) {
        if (httpStatus == 403) {
            self.raiseError(
                Autodesk.Viewing.ErrorCodes.NETWORK_ACCESS_DENIED,
                "Access denied to remote resource",
                { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
        }
        else if (httpStatus == 404) {
            self.raiseError(
                Autodesk.Viewing.ErrorCodes.NETWORK_FILE_NOT_FOUND,
                "Remote resource not found",
                { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
        }
        else if (httpStatus >= 500 && httpStatus < 600) {
            self.raiseError(
                Autodesk.Viewing.ErrorCodes.NETWORK_SERVER_ERROR,
                "Server error when accessing resource",
                { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
        }
        else if (data.exception) {
            self.raiseError(
                Autodesk.Viewing.ErrorCodes.NETWORK_FAILURE,
                "Network failure",
                { "url": data.url, "exception": data.exception.toString(), "stack": data.exception.stack});
        }
        else {
            self.raiseError(
                Autodesk.Viewing.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE,
                "Unhandled response code from server",
                { "url": data.url, "httpStatus": httpStatus, "httpStatusText": httpStatusText });
        }
    };

    // Create the XhrErrorHandler for backwards compatibility until all
    // of the Xhr calls are through the ViewingServiceXhr.
    //
    loadContext.errorHandler = new XhrErrorHandler(self);

    var op = e.data.operation;
    if (op == "LOAD_GEOMETRY")
        doGeomLoad(self, loadContext);
    else if (op == "LOAD_SVF")
        doLoadSvf(self, loadContext);
    else if (op == "GET_PROPERTIES")
        doPropertyGet(self, loadContext);
    else if (op == "SEARCH_PROPERTIES")
        doPropertySearch(self, loadContext);
    else if (op == "GET_OBJECT_TREE")
        doObjectTreeParse(self, loadContext);
    else if (op == "PARSE_F2D")
        doParseF2D(self, loadContext);
    else if (op == "PARSE_F2D_FRAME")
        doParseF2DFrame(self, loadContext);
    else if (op == "STREAM_F2D")
        doStreamF2D(self, loadContext);
    else if (op == "CLOUD_RENDERING")
        doCloudRendering(self, loadContext);
    else if (op == "SVF_TO_SPD")
        doSvfToSpd(self, loadContext);
}, false);


self.raiseError = function(code, msg, args) {
    self.postMessage({ "error": { "code": code, "msg": msg, "args": args }});
};

// Shared by all workers to output debug message on console of main thread.
function debug(msg) {
    self.postMessage({debug : 1, message : msg});
}

} //IS_WORKER
;
function doParseF2D(_this, loadContext) {

    if (loadContext.data) {

        _this.postMessage({progress:0.5}); //rough progress reporting -- can do better

        var f2d = new F2D(loadContext.metadata, loadContext.manifest, loadContext.basePath, loadContext.f2dLoadOptions);

        function loadDoneCallback(success) {
            if (success) {
                var msg = { "f2d" : f2d };
                _this.postMessage(msg );
            }
            else {
                _this.raiseError(
                    Autodesk.Viewing.ErrorCodes.BAD_DATA, "",
                    {});
                _this.postMessage(null);
            }
        }

        loadContext.loadDoneCB = loadDoneCallback;

        try {
            f2d.load(loadContext, new Uint8Array(loadContext.data));
        }
        catch (exc) {
            _this.raiseError(
                Autodesk.Viewing.ErrorCodes.BAD_DATA, "",
                { "exception": exc.toString(), "stack": exc.stack });
            _this.postMessage(null);
            return;
        }
    }
    else {
        _this.postMessage(null);
    }
}

function doParseF2DFrame(_this, loadContext) {

    if (!f2d) {
        _this.postMessage({progress:0.5}); //rough progress reporting -- can do better

        f2d = new F2D(loadContext.metadata, loadContext.manifest, loadContext.basePath, loadContext.f2dLoadOptions);

        f2d.F2D_MESH_COUNT_OLD = 0;

        // First post needs to post entire F2D so we can set up bounding boxes, etc.
        var msg = { "f2dframe" : f2d };
        _this.postMessage(msg);
    }

    function loadDoneCallback(success) {
        if (success) {

            if (!f2d.meshes.length) {
                // No new data coming in.
                // debug("F2D streaming : no new data coming in.");
                return;
            } else {

                var msg = { "f2dframe" : true,
                    "meshes" : f2d.meshes,
                    "baseIndex" : f2d.F2D_MESH_COUNT_OLD,
                    "maxObjectNumber" : f2d.maxObjectNumber,
                    "bbox" : f2d.bbox};

                if (loadContext.finalFrame)
                    msg.finalFrame = true;

                // User transferable objects to pass the array buffers used by mesh without deep copying.
                var transferList = [];
                for (var i = 0, e = f2d.meshes.length; i < e; ++i) {
                    transferList.push(f2d.meshes[i].vb.buffer);
                    transferList.push(f2d.meshes[i].indices.buffer);
                }
                _this.postMessage(msg, transferList);

                f2d.F2D_MESH_COUNT_OLD += f2d.meshes.length;
                f2d.meshes = [];
            }
        }
        else {
            _this.raiseError(
                Autodesk.Viewing.ErrorCodes.BAD_DATA, "",
                {});
            _this.postMessage(null);
        }
    }

    loadContext.loadDoneCB = loadDoneCallback;

    try {

        f2d.loadFrames(loadContext);

    }
    catch (exc) {
        _this.raiseError(
            Autodesk.Viewing.ErrorCodes.BAD_DATA, "",
            { "exception": exc.toString(), "stack": exc.stack });
        _this.postMessage(null);
        return;
    }

}
;var ENABLE_F2D_STREAMING_MODE = true;


// TODO: Change this to use the same load startegy as the property and svf workers.
function requestFileF2D(url, loadContext) {

    loadContext.errorHandler.ignoreFileNotFound = true;
    var xhr = new Xhr(loadContext.errorHandler, loadContext.auth, loadContext.viewing_url);

    if (url.indexOf(".gz", url.length - 3) !== -1) {

        var gzbuf = xhr.get(url, loadContext.headers, "arraybuffer");

        if (xhr.success) {
            // Catch errors from Gunzip, JSON.parse, etc.
            try {
                var rawbuf = new Uint8Array(gzbuf);
                //It's possible that if the Content-Encoding header is set,
                //the browser unzips the file by itself, so let's check if it did.
                if (rawbuf[0] == 31 && rawbuf[1] == 139) {
                    rawbuf = new Zlib.Gunzip(rawbuf).decompress();
                }

                return rawbuf;
            }
            catch (e) {
                self.raiseError(
                    Autodesk.Viewing.ErrorCodes.BAD_DATA,
                    "Malformed data received when requesting file",
                    { "url": url, "exception": e.toString(), "stack": e.stack });
                return null;
            }
        }
        else {
            // xhr already raised an error; no need to raise another
            return null;
        }
    }
    else {
        //NOTE: For property database requests, we do not want to
        //parse the JSON up front, because it may be too big. The
        //property database does its own parsing.
        var json = xhr.get(url, loadContext.headers, "arraybuffer");
        if (xhr.success) {
            return new Uint8Array(json);
        }
        else {
            // xhr already raised an error; no need to raise another
            return null;
        }
    }
}

// Stream loading f2d data and prepare parseable data frames.
function doStreamF2D(worker, loadContext) {
    var url = loadContext.url;


    function blobToJson(blob) {
        var encodedString = "";
        for (var i=0; i<blob.length; i++)
            encodedString += String.fromCharCode(blob[i]);
        var decodedString = decodeURIComponent(escape(encodedString));
        return JSON.parse(decodedString);
    }

    function textToArrayBuffer(textBuffer, startOffset) {
        var len = textBuffer.length - startOffset;
        var arrayBuffer = new ArrayBuffer(len);
        var ui8a = new Uint8Array(arrayBuffer, 0);
        for (var i = 0, j = startOffset; i < len; i++, j++)
            ui8a[i] = (textBuffer.charCodeAt(j) & 0xff);
        return arrayBuffer;
    }

    //Get the metadata and manifest.
    var metadata = requestFileF2D(loadContext.basePath + "metadata.json.gz", loadContext);
    var manifest = requestFileF2D(loadContext.basePath + "manifest.json.gz", loadContext);

    if (metadata)
        metadata = blobToJson(metadata);
    if (manifest)
        manifest = blobToJson(manifest);

    if (!metadata) {
        self.raiseError(
            Autodesk.Viewing.ErrorCodes.BAD_DATA,
            "" /* does not matter what strings we put here since the final user facing error message is solely decided
            by ErrorCodes. Invent another code if we want a specific error message for this error. */);
    }


    var f2dSize;
    if (manifest && manifest.assets) {
        var a = manifest.assets;
        for (var i=0; i<a.length; i++) {
            if (url.indexOf(a[i].URI) != -1) {
                f2dSize = a[i].usize || 0;
                break;
            }
        }
    }

    // TODO: reuse Xhr abstraction.
    var xhr = new XMLHttpRequest();
    xhr.withCredentials = !!loadContext.auth;
    var probe = new F2DProbe();

    var counter = 0;
    var globalOffset = 0;
    var sentMetadata = false;

    xhr.onreadystatechange = function () {

        try {
            if (xhr.readyState == 4) {
                if (ENABLE_F2D_STREAMING_MODE && globalOffset > 0) {

                    var textBuffer = xhr.responseText;

                    var  msg = {
                        "type" : "F2DSTREAM",
                        "finalFrame" : true,
                        "finished" : true,
                        "progress" : 1
                    };

                    var transferList = [];

                    if (!sentMetadata) {
                        msg.manifest = manifest;
                        msg.metadata = metadata;
                        msg.basePath = loadContext.basePath;
                        sentMetadata = true;
                    }

                    if (textBuffer.length > globalOffset)
                    {
                        var arrayBuffer = textToArrayBuffer(textBuffer, globalOffset);
                        var view = new Uint8Array(arrayBuffer);

                        var marker = probe.load(view);

                        var frames = arrayBuffer.slice(marker.frameStart, marker.frameEnd);

                        if (marker.frameEnd > marker.frameStart) {

                            //globalOffset += marker.frameEnd;

                            transferList.push(frames);

                            msg.frames = frames;
                        }
                    }

                    debug("Total text bytes count : " + xhr.responseText.length);

                    worker.postMessage(msg, transferList);

                    //Streaming code path ends here
                    return;
                }

                //Non-streaming code path here
                var textBuffer = xhr.responseText;
                var arrayBuffer = textToArrayBuffer(textBuffer, 0);

                //var view = new Uint8Array(arrayBuffer);
                //var marker = probe.load(view);


                var msg = { "type" : "F2DBLOB",
                    "metadata" : metadata,
                    "manifest" : manifest,
                    "basePath" : loadContext.basePath, // TODO: we might be able to infer this elsewhere.
                    "progress" : 1,
                    "buffer" : arrayBuffer};
                var transferList = [];
                transferList.push(arrayBuffer);
                worker.postMessage(msg, transferList);

            }

            if (xhr.readyState > 2) {
                if (!ENABLE_F2D_STREAMING_MODE) return;

                var textBuffer = xhr.responseText;

                // No new data coming in.
                if (globalOffset + 65536 > textBuffer.length)
                    return;

                var arrayBuffer = textToArrayBuffer(textBuffer, globalOffset);

                if (!counter) {
                    ++counter;

                    // If the very first two bytes of the entire stream is GZIP magic number,
                    // then we fall back on none streaming mode, because streaming mode only
                    // work with browser decompression, and the presence of such magic number
                    // implies browser decompression fails, for whatever reasons.
                    var byteView = new Uint8Array(arrayBuffer);
                    if (byteView[0] == 31 && byteView[1] == 139) {
                        ENABLE_F2D_STREAMING_MODE = false;
                        return;
                    }
                }

                var view = new Uint8Array(arrayBuffer);
                var marker = probe.load(view);

                if (marker.frameEnd > marker.frameStart) {
                    var frames = arrayBuffer.slice(marker.frameStart, marker.frameEnd);
                    globalOffset += marker.frameEnd;

                    var transferList = [];
                    transferList.push(frames);

                    var msg = { "type" : "F2DSTREAM",
                        "frames" : frames,
                        "finalFrame" : false
                    };

                    if (f2dSize)
                        msg.progress = globalOffset / f2dSize;

                    if (!sentMetadata) {
                        msg.manifest = manifest;
                        msg.metadata = metadata;
                        msg.basePath = loadContext.basePath;
                        sentMetadata = true;
                    }

                    worker.postMessage(msg, transferList);

                }
            }

        } catch (e) {
            debug(e.message);
        }
    };

    //Send the request now
    try {

        xhr.open("GET", url, true);
        xhr.overrideMimeType('text/plain; charset=x-user-defined');
        xhr.send();
    } catch (e) {
        debug(e.message);
    }
}

;// Base render config template.
var defaultCloudRenderConfig = {
    "ConsumerServiceKey":"Viewing",
    "ProductVersion":"2014",
    "UserInfo":{
        "UserID":"",
        "EmailFlag":"true"
    },
    "Scenes":[
        {
            "SceneInfo":{
                "SourceFileInfo":{
                    "Type":"S3",
                    "AccessLevel":"Private"
                },
                "FileUri":"",
                "SceneId":"FireflyJSDefaultSceneId"
            },
            "Renderings":[
                {
                    "ImageInfo":{
                        // It is used to tell Renderer to do rendering and tone mapping.
                        // Allowed actions are ["Render", "ToneMap"] The list of actions can contain a single or multiple actions.
                        "Actions":["Render", "ToneMap"],
                        // The text is the version of product that can be used to track the
                        // rendering request is submitted from which version of product.
                        "ProductionVersion":"SparkViewer",
                        "ImageParams":{
                            // Height of Rendered image. It must be integer in range [108,2000].
                            "RenderResolutionY":1500,
                            // Width of Rendered image. It must be integer in range [108,2000].
                            "RenderResolutionX":2000,
                            // The text is used to specify the format of rendered image.
                            // The text must be one of "JEPG", "JPG", "PNG", "TIFF", "TIF". Others texts are not valid.
                            "RenderImageFormat":"PNG"
                        },
                        "Render":{
                            // The quality of rendering. Must be one of "best", "high", "standard", "draft".
                            "RenderQuality":"standard",
                            // The name of the camera that will be rendered.
                            // If a camera is not specified, then the renderer picks the first camera it encounters
                            // while parsing the scene file from SPD.
                            "RenderCameraName":"",
                            // The type of the rendering.
                            // Must be one of "image", "panorama", "ss_preview", "solarstudy", "illuminance".
                            // "image" - rendered as still image.
                            // "panorama"  rendered as panorama.
                            // "ss_preview"  rendered as solar study preview (9 frame)
                            "RenderingType":"image",
                            // The type of Exposure processing. Must be one of "Native", "Advanced", "Customized".
                            // "Native"  tone map setting in "ToneMap" will be used for exposure processing.
                            // "Advanced"  default tone map setting in RaaS service will be used.
                            "ExposureType":"Customized"
                        },
                        // If the "ExposureType" has been set to "Advance" and in SPD there is no Tone map parameter values,
                        // it will be mandatory.

                        "ToneMap":{
                            // The type must be one of "photometric","canon" or "cameraresponse".
                            // If none, is provided, and ExpsosureType is "customized", then "photometric" is used as default.
                            "BaseExposure":-9.5,  // must be between -32 and 32
                            "OffsetExposure":0.0, // must be between -32 and 32
                            // When set "Type" as "Canon", no matter what value you set for the parameters below, RaaS will use default value.
                            "ExposureValue":14.0,  // must be between -6 and 16
                            "Shadows":0.2,  // must be between 0.1 and 4
                            "Midtones":1.0,   // must be in range [0.1, 4]
                            "Highlights":0.25,  // must be in range [0, 1]
                            "WhitePoint":6500.0,  // must be in range [1800, 15000]
                            "Saturation":1.0,  // must be between 0 and 5
                            "Type":"Cameraresponse"
                        },
                        "EnvironmentOverridePreset": "studio_01",
                        "CameraOverride":{
                            // Typically, cameras sent to RaaS define the root of a scene graph. Since the scene contains a unit length parameter,
                            // it's rightly assumed that the root camera shares the same units as the scene.
                            // The unit length definition varies across different implementations; for those including strings the list is below:
                            // "METER" "FOOT" "INCH" "MILE" "CENTIMETER" "MILLIMETER" "KILOMETER"
                            "Units":"MILLIMETER",
                            // The world space distance of the focal plane as measured from the view eye.
                            "FocalDistance":0,
                            // The lens aperture diameter in world space units. A zero value is a perfect pinhole camera with infinite depth of field.
                            "Aperture":0,
                            "View":{
                                // 3-vector for camera eye position
                                "Eye":[
                                    -4026.55,
                                    2722.32,
                                    -527.835
                                ],
                                // 3-vector for the camera look at direction
                                "At":[
                                    0.834734,
                                    -0.454954,
                                    -0.310218
                                ],
                                // 3-vector for the camera up direction
                                "Up":[
                                    0.233914,
                                    -0.0868021,
                                    0.968375
                                ]
                            },
                            "Projection":{
                                // Boolean flag that specifies orthographic (true) or perspective (false)
                                "isOrthographic":false,
                                // The view extent of the projection. For orthographic projection, the extent is a size in world space units.
                                // For perspective projection, the extent is a field of view in radians. extent is always specified in the horizontal direction.
                                // In fact, it's just the FOV!
                                "Extent":1,
                                // The image plane shift in normalized screen coordinates. This parameter controls perspective modification by shifting the view frustum.
                                // For example, an imageShift of [1,1] shifts the bottom left corner of the frame to the position of the top right corner,
                                // effectively shifting the frustum by the world space image size in X and Y.
                                // Likewise, an imageShift of  [2,3] will produce a view frustum shifted up by 2 image sizes and to the right by 3 image sizes.
                                "ImageShift":[
                                    0,
                                    0
                                ],
                                // Camera native aspect ratio.
                                // To disable auto scaling of the aspect ratio, set this parameter to 0.
                                // A value of 1 tells RaaS to automatically fit the requested render resolution.
                                "NativeAspect":1
                            }
                        }
                    }
                }
            ]
        }
    ]
};

function doCloudRendering(worker, loadContext) {
    var xhr = new Xhr(loadContext.errorHandler, loadContext.auth, loadContext.viewing_url);
    var renderConfig = defaultCloudRenderConfig;
    var camera = loadContext.camera;
    var canvas = loadContext.canvas;
    var imageNo = loadContext.imageNo;
    var exposureBias = loadContext.exposureBias;
    var currentLightPreset = loadContext.currentLightPreset;

    //Override the camera transform
    var eyeDir = new THREE.Vector3();
    eyeDir.x = camera.target.x - camera.position.x;
    eyeDir.y = camera.target.y - camera.position.y;
    eyeDir.z = camera.target.z - camera.position.z;
    eyeDir.normalize();
    var xDir = new THREE.Vector3();
    xDir.crossVectors(eyeDir, camera.up);
    xDir.normalize();

    debug('Transform: ' +
        xDir.x + " " + xDir.y + " " + xDir.z + " " + 0
        + " " + camera.up.x + " " + camera.up.y + " " + camera.up.z + " " + 0
        + " " + eyeDir.x + " " + eyeDir.y + " " + eyeDir.z + " " + 0
        + " " + camera.position.x + " " + camera.position.y + " " + camera.position.z + " " + 1);

    // We only support one rendering per render request for now.
    // convert different axis Up to Z axis Up which is used by RaaS
    var eyePosition, lookAtDirection, upDirection;
    if (loadContext.upVector[0] === 1) { // X axis Up, (x,y,z) to (z,y,x)
        eyePosition = [camera.position.z, camera.position.y, camera.position.x];
        lookAtDirection = [eyeDir.z, eyeDir.y, eyeDir.x];
        upDirection = [camera.up.z, camera.up.y, camera.up.x];
    } else if (loadContext.upVector[1] === 1) { // Y axis Up, (x,y,z) to (x,-z,y)
        eyePosition = [camera.position.x, -camera.position.z, camera.position.y];
        lookAtDirection = [eyeDir.x, -eyeDir.z, eyeDir.y];
        upDirection = [camera.up.x, -camera.up.z, camera.up.y];
    } else if (loadContext.upVector[0] === -1) { // -X axis Up, (x,y,z) to (z,-y,-x)
        eyePosition = [camera.position.z, -camera.position.y, -camera.position.x];
        lookAtDirection = [eyeDir.z, -eyeDir.y, -eyeDir.x];
        upDirection = [camera.up.z, -camera.up.y, -camera.up.x];
    } else if (loadContext.upVector[1] === -1) { // -Y axis Up, (x,y,z) to (-x,-z,-y)
        eyePosition = [-camera.position.x, -camera.position.z, -camera.position.y];
        lookAtDirection = [-eyeDir.x, -eyeDir.z, -eyeDir.y];
        upDirection = [-camera.up.x, -camera.up.z, -camera.up.y];
    } else if (loadContext.upVector[2] === -1) { // -Z axis Up, (x,y,z) to (-x,y,-z)
        eyePosition = [-camera.position.x, camera.position.y, -camera.position.z];
        lookAtDirection = [-eyeDir.x, eyeDir.y, -eyeDir.z];
        upDirection = [-camera.up.x, camera.up.y, -camera.up.z];
    } else { // Z axis Up
        eyePosition = [camera.position.x, camera.position.y, camera.position.z];
        lookAtDirection = [eyeDir.x, eyeDir.y, eyeDir.z];
        upDirection = [camera.up.x, camera.up.y, camera.up.z];
    }
    renderConfig.Scenes[0].Renderings[0].ImageInfo.CameraOverride.View.Eye = eyePosition;
    renderConfig.Scenes[0].Renderings[0].ImageInfo.CameraOverride.View.At = lookAtDirection;
    renderConfig.Scenes[0].Renderings[0].ImageInfo.CameraOverride.View.Up = upDirection;

    // Override image size with canvas size
    renderConfig.Scenes[0].Renderings[0].ImageInfo.ImageParams.RenderResolutionX = canvas.width;
    renderConfig.Scenes[0].Renderings[0].ImageInfo.ImageParams.RenderResolutionY = canvas.height;

    // Override ToneMap
    renderConfig.Scenes[0].Renderings[0].ImageInfo.ToneMap.BaseExposure = exposureBias;

    // Override Environment
    // For now we only have these ten environment types which are matched with RaaS
    debug("currentLightPreset = " + currentLightPreset);
    var environmentOverridePreset;
    if (currentLightPreset === 1) { // Sharp Highlights
        environmentOverridePreset = "studio_01";
    } else if (currentLightPreset === 3) {
        environmentOverridePreset = "grey_room";
    } else if (currentLightPreset === 4) {
        environmentOverridePreset = "photobooth";
    } else if (currentLightPreset === 8) {
        environmentOverridePreset = "riverbank";
    } else if (currentLightPreset === 10) { // Plaza
        environmentOverridePreset = "mi360_Plaza";
    } else if (currentLightPreset === 11) {
        environmentOverridePreset = "field";
    } else if (currentLightPreset === 12) {
        environmentOverridePreset = "crossroads";
    } else if (currentLightPreset === 13) {
        environmentOverridePreset = "seaport";
    } else if (currentLightPreset === 14) { // Glacier
        environmentOverridePreset = "mi360_Snow";
    } else if (currentLightPreset === 15) {
        environmentOverridePreset = "boardwalk";
    }
    renderConfig.Scenes[0].Renderings[0].ImageInfo.EnvironmentOverridePreset = environmentOverridePreset;

    debug("Render config is : " + JSON.stringify(renderConfig));

    // Override Extent, which is FOV!
    var rads = THREE.Math.degToRad(camera.fov);
    if (rads <= 0.0)
        rads = 0.0001;
    renderConfig.Scenes[0].Renderings[0].ImageInfo.CameraOverride.Projection.Extent = rads;
    debug('fov in radius = ' + rads);

    debug('CameraOverrides: ' + JSON.stringify(renderConfig.Scenes[0].Renderings[0].ImageInfo.CameraOverride));

    // Tell viewing service to pass through render config JSON through instead of using default one.
    loadContext.headers['x-ads-mode'] = 'verbatim';


    var response = xhr.post(loadContext.url, loadContext.headers,
                            JSON.stringify(renderConfig), 'text', null, 'render');
    debug(response);
    var jobId = JSON.parse(response)[0].JobId;
    debug("rendering job kicked off with render job id: " + jobId);

    var msg = { "progress" : "progress"};
    worker.postMessage(msg);

    var query = setInterval(function () {
        var response = xhr.get(loadContext.url, loadContext.headers, 'text', null,
            'render', loadContext.queryParams ? loadContext.queryParams + '&jobid=' + jobId : 'jobid=' + jobId);
        debug("from rendering worker : " + response);

        var result = JSON.parse(response).renderings[0];
        var jobStatus = result.JobInfo.JobStatus;
        if (jobStatus == 'Complete') {
            debug("rendering job :" + jobId + " finished.");

            var renderings = {
                'thumbnail' : result.Storage.Output.Thumbnail,
                'preview' : result.Storage.Output.Preview,
                'image' : result.Storage.Output.Image,
                'renderResolutionX' : result.ImageParams.RenderResolutionX,
                'renderResolutionY' : result.ImageParams.RenderResolutionY,
                'imageNo' : imageNo
            };

            var msg = { "renderings" : renderings};
            worker.postMessage(msg);

            clearInterval(query);
        }
        else if (jobStatus == 'Error') {
            var error = {
                'imageNo' : imageNo
            };
            var msg = { "error" : error};
            worker.postMessage(msg);

            clearInterval(query);
        }
    }, 10 * 1000);
}

function doSvfToSpd(worker, loadContext) {
    var xhr = new Xhr(loadContext.errorHandler, loadContext.auth, loadContext.viewing_url);

    var config = {
        "urn": "dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbmAvQVZFTlRBRE9SIExQNzAwLmYzZA",
        "registerType": {
            "rendering": {}
        }
    };

    // Load the true SVF urn
    config.urn = loadContext.svfUrn;

    debug("svf to spd config : " + JSON.stringify(config));

    var response = xhr.post(loadContext.url, loadContext.headers,
        JSON.stringify(config), 'text', null, 'bubbles');

    debug(response);

    var msg = { "translationProgress" : "progress"};
    worker.postMessage(msg);

    var spdUrn;

    var query = setInterval(function () {
        var response = xhr.get(loadContext.url + config.urn, loadContext.headers, 'text', null,
            'bubbles', null);
        debug("from Svf to Spd worker : " + response);

        var result = JSON.parse(response);

        var urns = getValues(result, "urn");

        //debug(urns);

        for (var i in urns) {
            var index = urns[i].indexOf('.spd');
            if (index != -1) {
                spdUrn = urns[i];
                break;
            }
        }

        if (spdUrn != undefined) {
            var translation = {
                'spdUrn' : spdUrn,
                'camera' : loadContext.camera,
                'imageNo' : loadContext.imageNo
            };
            var msg = { "translation" : translation};
            worker.postMessage(msg);

            clearInterval(query);
        }

    }, 1000);

    // Now we cannot check the status of svf to spd translation on viewing service
    // So for now just wait 30 seconds and check if the spd file has been created
    // if not, return translation error
    setTimeout(function(){
        if (spdUrn === undefined) {
            var translationError = {
                'imageNo' : loadContext.imageNo
            };
            var msg = { "translationError" : translationError};
            worker.postMessage(msg);

            clearInterval(query);
        }
    }, 30 * 1000);

}

//return an array of values that match on a certain key
function getValues(obj, key) {
    var objects = [];
    for (var i in obj) {
        if (!obj.hasOwnProperty(i)) continue;
        if (typeof obj[i] == 'object') {
            objects = objects.concat(getValues(obj[i], key));
        } else if (i == key) {
            objects.push(obj[i]);
        }
    }
    return objects;
};/**
 * Autocam is the container for the view cube and steering wheel classes.
 * It contains math for camera transformations and most of the functions are retrieved from SampleCAM.
 * Refer to their documentation for explanation.
 */
var Autocam = Autocam || function(camera, navApi, canvas, cameraChangedCallback, pivotDisplayCallback) {

    var cam = this;
    var cube = null;
    var dropDownMenu = null;
    var cubeContainer = null;
    var _changing = false;

    this.camera = camera;
    this.renderer = 'WEBGL';
    this.startState = {};
    this.navApi = navApi;   // TODO: use this for camera sync.
    this.orthographicFaces = false;

    //delta Time
    var startTime = Date.now();
    var deltaTime;
    var setHomeDeferred = false;

    function changed(worldUpChanged)
    {
        _changing = true;
        camera.target.copy(cam.center);
        camera.pivot.copy(cam.pivot);

        if( camera.worldup )
            camera.worldup.copy(cam.sceneUpDirection);
        else
            camera.up.copy(cam.sceneUpDirection);

        // stderr("CHANGE: " + cam.center.x.toFixed(3) + ", " + cam.center.y.toFixed(3) + ", " + cam.center.z.toFixed(3));

        if( cameraChangedCallback )
            cameraChangedCallback(worldUpChanged);

        _changing = false;
    }

    this.showPivot = function(state)
    {
        if( pivotDisplayCallback )
            pivotDisplayCallback(state);
    };

    this.setViewCubeContainer = function( div )
    {
        cubeContainer = div;
    };

    this.setWorldUpVector = function( newUp )
    {
        if( _changing )
            return;

        if( newUp && (newUp.lengthSq() > 0) && !newUp.normalize().equals(this.sceneUpDirection) )
        {
            // stderr("AUTOCAM UP: " + newUp.x.toFixed(3) + ", " + newUp.y.toFixed(3) + ", " + newUp.z.toFixed(3));
            //
            // Changing up resets the front face:
            this.sceneUpDirection.copy( newUp );
            this.sceneFrontDirection.copy( this.getWorldFrontVector() );
            this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
            if( cube )
                requestAnimationFrame(cube.render);
        }
    };

    this.getWorldUpVector = function()
    {
        return this.sceneUpDirection.clone();
    };

    // Assumes sceneUpDirection is set.
    this.getWorldRightVector = function()
    {
        var vec = this.sceneUpDirection.clone();

        if (Math.abs(vec.z) <= Math.abs(vec.y))
        {
            // Cross(Vertical, ZAxis)
            vec.set(vec.y, -vec.x, 0);
        }
        else if (vec.z >= 0)
        {
            // Cross(YAxis, Vertical)
            vec.set(vec.z, 0, -vec.x);
        }
        else
        {
            // Cross(Vertical, YAxis)
            vec.set(-vec.z, 0, vec.x);
        }
        return vec.normalize();
    };

    // Assumes sceneUpDirection is set.
    this.getWorldFrontVector = function()
    {
        var up = this.getWorldUpVector();
        return up.cross(this.getWorldRightVector()).normalize();
    };

    this.goToView = function( viewVector ) {
        if( !this.navApi.getIsLocked() ) {
            var destination = {
                position: viewVector.position.clone(),
                      up: viewVector.up.clone(),
                  center: viewVector.center.clone(),
                   pivot: viewVector.pivot.clone(),
                     fov: viewVector.fov,
                 worldUp: viewVector.worldUp.clone(),
                 isOrtho: viewVector.isOrtho
            };
            cam.elapsedTime = 0;
            this.animateTransition(destination);
        }
    };

    this.getCurrentView = function () {
        return {
            position: camera.position.clone(),
            up: camera.up.clone(),
            center: this.center.clone(),
            pivot: this.pivot.clone(),
            fov: camera.fov,
            worldUp: this.sceneUpDirection.clone(),
            isOrtho: (camera.isPerspective === false)
        };
    };

    this.setCurrentViewAsHome = function( focusFirst ) {
        if( focusFirst ) {
            this.navApi.setRequestFitToView(true);
            setHomeDeferred = true;
        }
        else {
            this.homeVector = this.getCurrentView();
        }
    };

    // This method sets both the "current" home and the "original" home.
    // The latter is used for the "reset home" function.
    this.setHomeViewFrom = function(camera) {
        var pivot   = camera.pivot   ? camera.pivot   : this.center;
        var center  = camera.target  ? camera.target  : this.pivot;
        var worldup = camera.worldup ? camera.worldup : this.sceneUpDirection;

        this.homeVector = {
            position: camera.position.clone(),
                  up: camera.up.clone(),
              center: center.clone(),
               pivot: pivot.clone(),
                 fov: camera.fov,
             worldUp: worldup.clone(),
             isOrtho: (camera.isPerspective === false)
        };

        this.originalHomeVector = {
            position: camera.position.clone(),
                  up: camera.up.clone(),
              center: center.clone(),
               pivot: pivot.clone(),
                 fov: camera.fov,
             worldUp: worldup.clone(),
          worldFront: this.sceneFrontDirection.clone(),  // Extra for reset orientation
             isOrtho: (camera.isPerspective === false)
        };
    };

    this.toPerspective = function() {
        if( !camera.isPerspective ) {
            camera.toPerspective();
            changed(false);
        }
    };

    this.toOrthographic = function() {
        if( camera.isPerspective ) {
            camera.toOrthographic();
            changed(false);
        }
    };

    this.setOrthographicFaces = function(state) {
         this.orthographicFaces = state;
    };

    this.goHome = function() {
        if( !this.navApi.getIsLocked() ) {
            this.navApi.setPivotSetFlag(false);
            this.goToView( this.homeVector );
        }
    };

    this.resetHome = function() {
        this.homeVector.position.copy(this.originalHomeVector.position);
        this.homeVector.up.copy(this.originalHomeVector.up);
        this.homeVector.center.copy(this.originalHomeVector.center);
        this.homeVector.pivot.copy(this.originalHomeVector.pivot);
        this.homeVector.fov = this.originalHomeVector.fov;
        this.homeVector.worldUp.copy(this.originalHomeVector.worldUp);
        this.homeVector.isOrtho = this.originalHomeVector.isOrtho;
        this.goHome();
    };

    this.getView = function() {
        return this.center.clone().sub(camera.position);
    };

    this.setCameraUp = function(up) {
        var view = this.dir.clone();
        var right = view.cross(up).normalize();
        if( right.lengthSq() === 0 )
        {
            // Try again after perturbing eye direction:
            view.copy(this.dir);
            if( up.z > up.y )
                view.y += 0.0001;
            else
                view.z += 0.0001;

            right = view.cross(up).normalize();
        }
        // Orthogonal camera up direction:
        camera.up.copy(right).cross(this.dir).normalize();
    };

    /***
    this.render = function(){
        //renderer.render( scene, camera );
        //We need to remove all calls to this render
        console.log("Unrequired call to render within Autocam.js:17")
    };
    ***/

    (function animate() {
        requestAnimationFrame(animate);
        // Is there an assumption here about the order of animation frame callbacks?
        var now = Date.now();
        deltaTime = now - startTime;
        startTime = now;
        // stderr("ANIMATE: delta = " + deltaTime.toFixed(4));
    }());

    //Control variables
    this.ortho = false;
    this.center = camera.target ? camera.target.clone() : new THREE.Vector3(0,0,0);
    this.pivot = camera.pivot ? camera.pivot.clone() : this.center.clone();

    this.sceneUpDirection    = camera.worldup ? camera.worldup.clone() : camera.up.clone();
    this.sceneFrontDirection = this.getWorldFrontVector();

    //
    //dir, up, left vector
    this.dir = this.getView();

    // Compute "real" camera up:
    this.setCameraUp(camera.up);

    this.saveCenter = this.center.clone();
    this.savePivot  = this.pivot.clone();
    this.saveEye    = camera.position.clone();
    this.saveUp     = camera.up.clone();
    var prevEye, prevCenter, prevUp, prevPivot;

    this.cubeFront = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();

    this.setHomeViewFrom(camera);

    var rotInitial = new THREE.Quaternion();
    var rotFinal   = new THREE.Quaternion();
    var rotTwist   = new THREE.Quaternion();
    var rotSpin    = new THREE.Quaternion();
    var distInitial;
    var distFinal;

    /**
     * Holds the default pan speed multiplier of 0.5
     * @type {number}
     */
    this.userPanSpeed = 0.5;

    /**
     * Holds the default look speed multiplier of 2.0
     * @type {number}
     */
    this.userLookSpeed = 2.0;

    /**
     * Holds the default height speed multiplier of 5.0 (used in updown function)
     * @type {number}
     */
    this.userHeightSpeed = 5.0;

    /**
     * Holds the current walk speed multiplier, which can be altered in the steering wheel drop down menu (between 0.24 and 8)
     * @type {number}
     */
    this.walkMultiplier = 1.0;

    /**
     * Holds the default zoom speed multiplier of 1.015
     * @type {number}
     */
    this.userZoomSpeed = 1.015;

    /**
     * Holds the orbit multiplier of 5.0
     * @type {number}
     */
    this.orbitMultiplier = 5.0;
    this.currentlyAnimating = false;

    //look
    camera.keepSceneUpright = true;

    //orbit
    this.preserveOrbitUpDirection = true;
    this.alignOrbitUpDirection = true;
    this.constrainOrbitHorizontal = false;
    this.constrainOrbitVertical = false;
    this.doCustomOrbit = false;
    this.snapOrbitDeadZone = 0.045;
    this.snapOrbitThresholdH = this.snapOrbitThresholdV = THREE.Math.degToRad(15.0);
    this.snapOrbitAccelerationAX = this.snapOrbitAccelerationAY = 1.5;
    this.snapOrbitAccelerationBX = this.snapOrbitAccelerationBY = 2.0;
    this.snapOrbitAccelerationPointX = this.snapOrbitAccelerationPointY = 0.5;
    this.alignDirTable = new Array(26);
    this.alignDirTable[0] = new THREE.Vector3(-1,0,0);
    this.alignDirTable[1] = new THREE.Vector3(1,0,0);
    this.alignDirTable[2] = new THREE.Vector3(0,-1,0);
    this.alignDirTable[3] = new THREE.Vector3(0,1,0);
    this.alignDirTable[4] = new THREE.Vector3(0,0,-1);
    this.alignDirTable[5] = new THREE.Vector3(0,0,1);

    // fill edges
    this.alignDirTable[6] = new THREE.Vector3(-1,-1,0);
    this.alignDirTable[7] = new THREE.Vector3(-1,1,0);
    this.alignDirTable[8] = new THREE.Vector3(1,-1,0);
    this.alignDirTable[9] = new THREE.Vector3(1,1,0);
    this.alignDirTable[10] = new THREE.Vector3(0,-1,-1);
    this.alignDirTable[11] = new THREE.Vector3(0,-1,1);
    this.alignDirTable[12] = new THREE.Vector3(0,1,-1);
    this.alignDirTable[13] = new THREE.Vector3(0,1,1);
    this.alignDirTable[14] = new THREE.Vector3(-1,0,-1);
    this.alignDirTable[15] = new THREE.Vector3(1,0,-1);
    this.alignDirTable[16] = new THREE.Vector3(-1,0,1);
    this.alignDirTable[17] = new THREE.Vector3(1,0,1);

    // fill corners
    this.alignDirTable[18] = new THREE.Vector3(-1,-1,-1);
    this.alignDirTable[19] = new THREE.Vector3(-1,-1,1);
    this.alignDirTable[20] = new THREE.Vector3(-1,1,-1);
    this.alignDirTable[21] = new THREE.Vector3(-1,1,1);
    this.alignDirTable[22] = new THREE.Vector3(1,-1,-1);
    this.alignDirTable[23] = new THREE.Vector3(1,-1,1);
    this.alignDirTable[24] = new THREE.Vector3(1,1,-1);
    this.alignDirTable[25] = new THREE.Vector3(1,1,1);

    this.combined = false;

    //variables used for snapping
    this.useSnap = false;
    this.lockDeltaX = 0.0;
    this.lockedX = false;
    this.lastSnapRotateX = 0.0;
    this.lockDeltaY = 0.0;
    this.lockedY = false;
    this.lastSnapRotateY = 0.0;
    this.lastSnapDir = new THREE.Vector3(0,0,0);

    //up-down
    this.topLimit = false;
    this.bottomLimit = false;
    this.minSceneBound = 0;
    this.maxSceneBound = 0;

    //shot
    var shotParams = { destinationPercent:1.0, duration:1.0, zoomToFitScene:true, useOffAxis:false };
    this.shotParams = shotParams;   // Expose these for modification
    var camParamsInitial, camParamsFinal;

    //zoom
    this.zoomDelta = new THREE.Vector2();
    var unitAmount = 0.0;

    //walk
    var m_resetBiasX, m_resetBiasY, m_bias;

    //info about model object we need to save for fit to window
    var boundingBoxMin = new THREE.Vector3();
    var boundingBoxMax = new THREE.Vector3();

    /**
     * Parameters to control the saving and displaying of the rewind timeline
     * @example <caption> Changing the maximum number of stored rewind cameras from 25(default) to 50 </caption>
     * cam.rewindParams.maxHistorySize = 50;
     */
    this.rewindParams = {
        history:[],
        startTime:undefined,
        thumbnailSize:56.0,
        thumbnailGapSize:12.0,
        maxHistorySize:25,
        snappingEnabled:true,
        timelineIndex:0,
        timelineIndexSlide:0,
        open:false,
        openLocation:new THREE.Vector2(0,0),
        openBracket:new THREE.Vector2(0,0),
        openBracketA:new THREE.Vector2(0,0),
        openBracketB:new THREE.Vector2(0,0),
        openLocationOrigin:new THREE.Vector2(0,0),
        locationOffset:new THREE.Vector2(0,0),
        snapOffset:new THREE.Vector2(0,0),
        slideOffset:new THREE.Vector2(0,0),
        snapped:true,
        resetWeights:false,
        recordEnabled:false,
        elementIsRecording:false
    };

    this.viewCubeMenuOpen = false;
    this.menuSize = new THREE.Vector2(0,0);
    this.menuOrigin = new THREE.Vector2(0,0);

    camera.lookAt(this.center);

    // function windowResize(){
        // refresh camera on size change
        
        // We handle this elsewhere
        /*
            renderer.setSize( window.innerWidth, window.innerHeight );
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.topFov = camera.bottomFov = camera.fov/2;
            camera.leftFov = camera.rightFov = (camera.aspect * camera.fov)/2;
            camera.updateProjectionMatrix();
        */
    // }

    /*** 
    windowResize();
    window.addEventListener('resize', windowResize, false);
    ***/

    this.setCube = function(viewcube)
    {
        cube = viewcube;    // DOH!!!
    };

    /**
     * Function which loads the JSON object to the scene
     * @param {JSONObject} model - The correctly formatted JSON model
     * @param {Vector3} scale - The scale multiplier for the input model
     * @param {Vector3} position - Where to load the model
     * @example <caption>Load an object called car.json to (0,0,0) with a scale of 50 </caption>
     * cam.loadObject('Objects/car.json', new THREE.Vector3(50,50,50), new THREE.Vector3(0,0,0));
     */
    this.loadObject = function(model, scale, position){
        loader = new THREE.JSONLoader();
        loader.load( model, function( geometry, materials ) {
            var faceMaterial = new THREE.MeshPhongMaterial( materials );
            mesh = new THREE.Mesh( geometry, faceMaterial );
            mesh.scale = scale;
            mesh.position.copy(position);
            mesh.geometry.computeBoundingBox();
            var bBox = mesh.geometry.boundingBox.clone();
            boundingBoxMax.set(bBox.max.x,bBox.max.y,bBox.max.z);
            boundingBoxMin.set(bBox.min.x,bBox.min.y,bBox.min.z);
            boundingBoxMax.multiply(scale);
            boundingBoxMin.multiply(scale);
            scene.add( mesh );
            objects.push( mesh );
        });
    };


    // Sync our local data from the given external camera:
    this.sync = function(clientCamera) {
        if( clientCamera.isPerspective !== camera.isPerspective ) {
            if( clientCamera.isPerspective ) {
                camera.toPerspective();
            }
            else {
                camera.toOrthographic();
                if( clientCamera.saveFov )
                    camera.saveFov = clientCamera.saveFov;
            }
        }
        camera.fov = clientCamera.fov;
        camera.position.copy(clientCamera.position);

        if( clientCamera.target ) {
            this.center.copy(clientCamera.target);
            camera.target.copy(clientCamera.target);
        }
        if( clientCamera.pivot ) {
            this.pivot.copy(clientCamera.pivot);
            camera.pivot.copy(clientCamera.pivot);
        }
        this.dir.copy(this.center).sub(camera.position);

        this.setCameraUp(clientCamera.up);

        var worldUp = clientCamera.worldup ? clientCamera.worldup : clientCamera.up;
        if( worldUp.distanceToSquared(this.sceneUpDirection) > 0.0001 ) {
            this.setWorldUpVector(worldUp);
        }

        if( setHomeDeferred && !this.navApi.getTransitionActive() ) {
            setHomeDeferred = false;
            this.setCurrentViewAsHome(false);
        }
        if( cube )
            requestAnimationFrame(cube.render);
    };


    this.refresh = function() {
        if( cube )
            cube.refreshCube();
    };

    /*        Prototyped Functions          */

    //extending Box2 to be used like AutoCam::Box2
    THREE.Box2.prototype.setCenter = function (center){
        var halfSize = new THREE.Vector2((Math.abs(this.max.x - this.min.x)/2.0),(Math.abs(this.max.y - this.min.y))/2.0);
        this.min.copy( center ).sub( halfSize );
        this.max.copy( center ).add( halfSize );
        return this;
    }

    //Using Box2 like an AutoCam::Icon2D
    THREE.Box2.prototype.getIcon2DCoords = function(Pscreen,PIcon2D){
        var zero = this.center;
        PIcon2D.set((Pscreen.x - zero.x)/(this.size().x/2.0) , (Pscreen.y - zero.y)/(this.size().y / 2.0));
    }

    //so we dont need a matrix4 as an intermediate
    THREE.Matrix3.prototype.makeRotationFromQuaternion = function ( q ) {
        var te = this.elements;

        var x = q.x, y = q.y, z = q.z, w = q.w;
        var x2 = x + x, y2 = y + y, z2 = z + z;
        var xx = x * x2, xy = x * y2, xz = x * z2;
        var yy = y * y2, yz = y * z2, zz = z * z2;
        var wx = w * x2, wy = w * y2, wz = w * z2;

        te[0] = 1 - ( yy + zz );
        te[3] = xy - wz;
        te[6] = xz + wy;

        te[1] = xy + wz;
        te[4] = 1 - ( xx + zz );
        te[7] = yz - wx;

        te[2] = xz - wy;
        te[5] = yz + wx;
        te[8] = 1 - ( xx + yy );

        return this;
    }

    // changed to accept a matrix3
    THREE.Quaternion.prototype.setFromRotationMatrix3 = function ( m ) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

        var te = m.elements,
            m11 = te[0], m12 = te[3], m13 = te[6],
            m21 = te[1], m22 = te[4], m23 = te[7],
            m31 = te[2], m32 = te[5], m33 = te[8],

            trace = m11 + m22 + m33,
            s;

        if ( trace > 0 ) {
            s = 0.5 / Math.sqrt( trace + 1.0 );
            this.w = 0.25 / s;
            this.x = ( m32 - m23 ) * s;
            this.y = ( m13 - m31 ) * s;
            this.z = ( m21 - m12 ) * s;
        } else if ( m11 > m22 && m11 > m33 ) {
            s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
            this.w = (m32 - m23 ) / s;
            this.x = 0.25 * s;
            this.y = (m12 + m21 ) / s;
            this.z = (m13 + m31 ) / s;
        } else if ( m22 > m33 ) {
            s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
            this.w = (m13 - m31 ) / s;
            this.x = (m12 + m21 ) / s;
            this.y = 0.25 * s;
            this.z = (m23 + m32 ) / s;
        } else {
            s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
            this.w = ( m21 - m12 ) / s;
            this.x = ( m13 + m31 ) / s;
            this.y = ( m23 + m32 ) / s;
            this.z = 0.25 * s;
        }
        return this;
    }

    // NOTE: This modifies the incoming vector!!
    // TODO: Change all calls to use Vector3.applyQuaternion instead.
    THREE.Quaternion.prototype.rotate = function (vector){
        //From AutoCamMath.h file
        var kRot = new THREE.Matrix4().makeRotationFromQuaternion(this);
        var e = kRot.elements;

        //converting 4d matrix to 3d
        var viewRot = new THREE.Matrix3().set( e[0],e[1],e[2], e[4],e[5],e[6], e[8],e[9],e[10] );

        return vector.applyMatrix3(viewRot);
    }

    THREE.Vector3.prototype.findAngleWith = function(b, axis){
        var angle = 0.0;
        var cosAngle = this.clone().normalize().clone().dot(b.clone().normalize());

        var axisCheck = (this.clone().cross(b)).clone().normalize();
        if (axisCheck.clone().length() < Number.MIN_VALUE){
            if(cosAngle > 0.0){
                angle = 0.0;
            }else{
                angle = 180.0;
            }
        }else{

            var cosCheck = axisCheck.clone().dot(axis.clone().normalize());

            //check to make sure user specified axis is orthogonal to vectors.
            //If it isn't we take the closer of the two choices.
            axis = cosCheck > 0.0 ? axisCheck : -axisCheck;

            var cosAngleNextQuadrant = new THREE.Quaternion().setFromAxisAngle( axis, 90.0 * THREE.Math.degToRad );
            cosAngleNextQuadrant = ((cosAngleNextQuadrant.clone().rotate(b)).clone().normalize()).clone().dot(this);
            angle = Math.acos(cosAngle) * THREE.Math.radToDeg;

            if(Math.abs(angle - 90.0) < Number.MIN_VALUE)
                angle = 90.0;

            if ((angle < 90.0 && cosAngle * cosAngleNextQuadrant > 0.0)||
                (angle > 90.0 && cosAngle * cosAngleNextQuadrant < 0.0)||
                (angle == 90.0 && cosAngleNextQuadrant > 0.0))
                angle = -1.0 * angle;	//figure out whether we need to turn left or right
        }

        angle = THREE.Math.degToRad(angle);
        return angle;
    }

    if(!('contains' in String.prototype))
        String.prototype.contains = function(str, startIndex) { return -1 !== String.prototype.indexOf.call(this, str, startIndex); };

    Math.linearClamp = function( x, a, b ){
        if ( x <= a ) { return 0.0; }
        if ( x >= b ) { return 1.0; }

        return ( x - a ) / ( b - a );
    }

    Math.easeClamp = function( x, a, b ){
        if ( x <= a ) { return 0.0; }
        if ( x >= b ) { return 1.0; }

        var t = ( x - a ) / ( b - a );
        return 0.5 * ( Math.sin( (t - 0.5) * Math.PI ) + 1.0 );
    }

    Math.linearInterp = function( t, a, b ){
        return a * (1.0 - t) + b * t;
    }

    Math.equalityClamp = function (x,a,b){
        if ( x <= a ) { return a; }
        if ( x >= b ) { return b; }

        return x;
    }

    Math.round2 = function (x){
        return (Math.round(x*100))/100;
    }

    Math.round1 = function (x){
        return (Math.round(x*10))/10;
    }


    /*      SHOT OPERATION      */

    //transitions smoothly to destination
    this.animateTransition = function ( destination ) {

        if ( !destination ) { return; }

        var worldUpChanged = false;
        var unitTime = 0.0;

        this.setCameraOrtho(destination.isOrtho);

        if ( cam.elapsedTime >= shotParams.duration ) {
            unitTime = 1.0;

            cam.center.copy(destination.center);
            cam.pivot.copy(destination.pivot);
            camera.position.copy(destination.position);
            camera.up.copy(destination.up);
            if( !destination.isOrtho )
                camera.fov = destination.fov;

            worldUpChanged = !destination.worldUp.equals(this.sceneUpDirection);
            if( worldUpChanged )
                this.setWorldUpVector(destination.worldUp);

            this.currentlyAnimating = false;
            changed(worldUpChanged);
            this.showPivot(false);
            if( cube )
                requestAnimationFrame(cube.render);

            this.addHistoryElement();
            this.navApi.setTransitionActive(false);
            return;
        }
        this.currentlyAnimating = true;
        this.showPivot(true);
        this.navApi.setTransitionActive(true);

        var tMax = shotParams.destinationPercent;
        unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
        oneMinusTime = 1.0 - unitTime;
        cam.elapsedTime += deltaTime/500;

        var center = (cam.center.clone().multiplyScalar(oneMinusTime)).add( destination.center.clone().multiplyScalar( unitTime ));
        var position = (camera.position.clone().multiplyScalar(oneMinusTime)).add(destination.position.clone().multiplyScalar( unitTime ));
        var up = (camera.up.clone().multiplyScalar(oneMinusTime)).add(destination.up.clone().multiplyScalar( unitTime ));
        var pivot = (camera.pivot.clone().multiplyScalar(oneMinusTime)).add(destination.pivot.clone().multiplyScalar( unitTime ));
        var worldUp = (this.sceneUpDirection.clone().multiplyScalar(oneMinusTime)).add(destination.worldUp.clone().multiplyScalar( unitTime ));
        var fov = camera.fov * oneMinusTime + destination.fov * unitTime;

        cam.center.copy(center);
        cam.pivot.copy(pivot);
        camera.position.copy(position);
        camera.up.copy(up);
        if( !destination.isOrtho )
            camera.fov = fov;

        worldUpChanged = (worldUp.distanceToSquared(this.sceneUpDirection) > 0.0001);
        if( worldUpChanged )
            this.setWorldUpVector(worldUp);

        camera.lookAt(cam.center);
        changed(worldUpChanged);

        if( cube )
            requestAnimationFrame(cube.render);

        requestAnimationFrame(function() { cam.animateTransition(destination); });
    };

    //used for view cube transforms, to see difference between this and linear interpolation watch
    //http://www.youtube.com/watch?v=uNHIPVOnt-Y
    this.sphericallyInterpolateTransition = function( completionCallback )
    {
        var center, position, up;
        var unitTime = 0.0;
        this.currentlyAnimating = true;
        this.navApi.setTransitionActive(true);

        if ( cam.elapsedTime >= shotParams.duration ){
            unitTime = 1.0;
            this.currentlyAnimating = false;
        }
        else {
            var tMax = shotParams.destinationPercent;
            unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
            cam.elapsedTime += deltaTime/500;
        }

        // This seems to avoid some error in the rotation:
        if( unitTime === 1.0 ) {
            position = camParamsFinal.position;
            center   = camParamsFinal.center;
            up       = camParamsFinal.up;
        }
        else {
            var M = new THREE.Matrix3();
            var rot = rotInitial.clone();
            rot.slerp(rotFinal,(unitTime));
            M.makeRotationFromQuaternion(rot);
            var dist = Math.linearInterp(unitTime, distInitial, distFinal);

            var e = M.elements;

            center = camParamsInitial.center.clone().multiplyScalar(1.0 - unitTime).add(camParamsFinal.center.clone().multiplyScalar(unitTime));
            position = center.clone().sub(new THREE.Vector3(e[0],e[1],e[2]).multiplyScalar(dist));
            up = new THREE.Vector3(e[3],e[4],e[5]);
        }
        cam.center.copy(center);
        camera.position.copy(position);
        camera.up.copy(up);

        // The above code will have to change if we want the proper rotation
        // to occur about the pivot point instead of the center.
        if( !cam.navApi.getUsePivotAlways() )
            cam.pivot.copy(center);

        camera.lookAt(cam.center);

        if( this.currentlyAnimating === true ) {
            this.showPivot(true);
            requestAnimationFrame(function() { cam.sphericallyInterpolateTransition(completionCallback); });
        }
        else {
            this.navApi.setTransitionActive(false);
            this.showPivot(false);
            this.addHistoryElement();

            if( this.orthographicFaces && this.isFaceView() )
                this.setCameraOrtho(true);

            if( completionCallback )
                completionCallback();
        }
        changed(false);
        if( cube )
            requestAnimationFrame(cube.render);
    };

    //This is used to determine the relation between camera up vector and scene direction, used to determine which
    //face to translate to when clicking on a viewcube arrow
    this.getOrientation = function(){
        if( !cube )
            return;

        var camX = Math.round1(camera.up.x);
        var camY = Math.round1(camera.up.y);
        var camZ = Math.round1(camera.up.z);
        var sceneFront = this.sceneFrontDirection.clone();
        var sceneUp = this.sceneUpDirection.clone();
        var sceneRight = this.sceneFrontDirection.clone().cross(this.sceneUpDirection).normalize();
        sceneFront.x = Math.round1(sceneFront.x);
        sceneFront.y = Math.round1(sceneFront.y);
        sceneFront.z = Math.round1(sceneFront.z);
        sceneUp.x = Math.round1(sceneUp.x);
        sceneUp.y = Math.round1(sceneUp.y);
        sceneUp.z = Math.round1(sceneUp.z);
        sceneRight.x = Math.round1(sceneRight.x);
        sceneRight.y = Math.round1(sceneRight.y);
        sceneRight.z = Math.round1(sceneRight.z);
        var sceneLeft = sceneRight.clone().multiplyScalar(-1);
        var sceneDown = sceneUp.clone().multiplyScalar(-1);
        var sceneBack = sceneFront.clone().multiplyScalar(-1);

        switch (cube.currentFace){
            case "front":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "right";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "left"
                break;
            case "right":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneBack.x == camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "left";
                else if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "right"
                break;
            case "left":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "left";
                else if (sceneBack.x ==camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "right"
                break;
            case "back":
                if (sceneUp.x == camX && sceneUp.y == camY && sceneUp.z == camZ)
                    return "up";
                else if (sceneDown.x == camX && sceneDown.y == camY && sceneDown.z == camZ)
                    return "down";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "right";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "left"
                break;
            case "top":
                if (sceneBack.x == camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "down";
                else if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "up";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "right";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "left"
                break;
            case "bottom":
                if (sceneFront.x == camX && sceneFront.y == camY && sceneFront.z == camZ)
                    return "down";
                else if (sceneBack.x == camX && sceneBack.y == camY && sceneBack.z == camZ)
                    return "up";
                else if (sceneRight.x == camX && sceneRight.y == camY && sceneRight.z == camZ)
                    return "right";
                else if (sceneLeft.x == camX && sceneLeft.y == camY && sceneLeft.z == camZ)
                    return "left"
                break;
        }
        //console.log("Orientation not found for transformation:(");
        return;
    }

    this.setCameraOrtho = function(yes) {
        if( yes && camera.isPerspective )
            camera.toOrthographic();
        
        if( !yes && !camera.isPerspective )
            camera.toPerspective();
    };

    this.resetOrientation = function(){
        this.setCameraOrtho(this.originalHomeVector.isOrtho);
        this.sceneUpDirection.copy(this.originalHomeVector.worldUp);
        this.sceneFrontDirection.copy(this.originalHomeVector.worldFront);
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
        this.setCameraUp(this.sceneUpDirection);
        changed(true);
    };

    this.setCurrentViewAsFront = function(){
        if( cube )
            cube.currentFace = "front";

        this.sceneUpDirection.copy(camera.up.clone());
        this.sceneFrontDirection.copy(this.getView()).normalize();
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();

        if( this.orthographicFaces )
            this.setCameraOrtho(true);

        changed(true);
    };

    this.setCurrentViewAsTop = function(){
        if( cube )
            cube.currentFace = "top";

        this.sceneUpDirection.copy(this.getView()).multiplyScalar(-1).normalize();
        this.sceneFrontDirection.copy(camera.up);
        this.cubeFront.copy(this.sceneFrontDirection).cross(this.sceneUpDirection).normalize();
        changed(true);
    };

    this.calculateCubeTransform = function(faceString){
        var worldUp = this.sceneUpDirection.clone();
        var worldFront = this.sceneFrontDirection.clone();
        var worldRight = this.sceneFrontDirection.clone().cross( this.sceneUpDirection).normalize();

        camParamsInitial = camera.clone();
        camParamsInitial.center = cam.center.clone();
        camParamsInitial.pivot = cam.pivot.clone();

        camParamsFinal = camera.clone();
        camParamsFinal.center = cam.center.clone();
        camParamsFinal.pivot = cam.pivot.clone();

        // find movement offset based on given boolean flags
        var offset = new THREE.Vector3( 0, 0, 0 );
        if ( faceString.contains('back')){
            offset = offset.add(worldFront);
        }
        if ( faceString.contains('front')){
            offset = offset.sub(worldFront);
        }
        if ( faceString.contains('top')){
            offset = offset.add(worldUp);
        }
        if ( faceString.contains('bottom')){
            offset = offset.sub(worldUp);
        }
        if ( faceString.contains('right')){
            offset = offset.add(worldRight);
        }
        if ( faceString.contains('left')){
            offset = offset.sub(worldRight);
        }
        var upDir = worldUp;

        // view looking at top or bottom chosen
        var test = offset.clone().normalize();

        if ( ( 1.0 - Math.abs(test.dot(worldUp)) ) < Number.MIN_VALUE ) {
            //( offset == worldUp || offset == -worldUp )
            // find the principal view direction other than top/bottom closest to
            // the current view direction and use it as an up vector

            var viewDir = this.getView().normalize();
            var optUpDir = [ worldFront.clone(), worldFront.clone().negate(), worldRight.clone(), worldRight.clone().negate() ];

            // use both view and up vectors for test vector because transitioning from
            // top and bottom views, view direction is the same (but up direction is different)

            var sign = (test.dot(worldUp) > 0.0) ? +1.0 : -1.0; //( offset == worldUp ) ? +1.0 : -1.0;
            var testDir = viewDir.clone().add(camera.up.clone().multiplyScalar(sign)).normalize();

            var optValue = -2.0;

            for ( var i = 0; i < 4; i++ ){
                var value = testDir.dot( optUpDir[i] );

                if ( value > optValue ){
                    optValue = value;
                    upDir = optUpDir[i].multiplyScalar(sign);
                }
            }
        }

        distFinal = distInitial = this.getView().length();
        // WHY? camParamsFinal.center = this.originalCenter;
        camParamsFinal.position.copy(camParamsFinal.center.clone().add(offset.multiplyScalar(distFinal/offset.length())));
        camParamsFinal.up.copy(upDir);

        var D = camParamsInitial.center.clone().sub(camParamsInitial.position).normalize();
        var R = D.clone().cross(camParamsInitial.up).normalize();
        var U = R.clone().cross(D).normalize();
        var M = new THREE.Matrix3(D.x, U.x, R.x, D.y, U.y, R.y, D.z, U.z, R.z);
        rotInitial.setFromRotationMatrix3(M);

        D = camParamsFinal.center.clone().sub(camParamsFinal.position).normalize();
        R = D.clone().cross(camParamsFinal.up).normalize();
        U = R.clone().cross(D).normalize();
        M.set(D.x, U.x, R.x, D.y, U.y, R.y, D.z, U.z, R.z);
        //TODO: figure out when these angles aren't supposed to be 0, works for now
        rotTwist.setFromAxisAngle(D,0.0);
        rotSpin.setFromAxisAngle(U,0.0);
        rotFinal.setFromRotationMatrix3(M);
        rotFinal.multiply(rotTwist).multiply(rotSpin).normalize();

    }

    //used for center operation from steering wheel and steering wheel menu
    this.centerShot = function(fromWheelMenu){
        //TODO: investigate the problem where it is not animating sometimes (due to lag)

        if (!camParamsInitial || fromWheelMenu){
            cam.elapsedTime = 0;
            camParamsInitial = camParamsFinal = camera.clone();
            camParamsInitial.center = cam.center;
        }

        var pWorld = cam.pivot.clone();
        var P = pWorld.clone().sub(camParamsInitial.position);
        var D = (camParamsInitial.center.clone().sub(camParamsInitial.position)).normalize();
        var U = camParamsInitial.up.clone();
        var R = (D.clone().cross(U)).normalize();
        U = (R.clone().cross(D)).normalize();


        var PprojR = R.clone().multiplyScalar(R.dot(P));
        var PprojU = U.clone().multiplyScalar(U.dot(P));
        var PprojRU = PprojR.clone().add(PprojU);

        camParamsFinal.position.copy(camParamsInitial.position.clone().add(PprojRU));

        camParamsFinal.center = pWorld;
        camParamsFinal.pivot = pWorld;

        var unitTime = 0.0;
        if ( cam.elapsedTime >= shotParams.duration ) {
            unitTime = 1.0;
        } else {
            var tMax = shotParams.destinationPercent;
            unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
            cam.elapsedTime += deltaTime/2000;
        }

        var position = (camera.position.clone().multiplyScalar( 1.0 - unitTime)).add(camParamsFinal.position.clone().multiplyScalar( unitTime ));
        var center = (cam.center.clone().multiplyScalar( 1.0 - unitTime)).add( camParamsFinal.center.clone().multiplyScalar( unitTime ));
        var pivot = (cam.pivot.clone().multiplyScalar( 1.0 - unitTime)).add( camParamsFinal.pivot.clone().multiplyScalar(unitTime));
        camera.position.copy(position);
        cam.center.copy(center);
        cam.pivot.copy(pivot);

        camera.lookAt(cam.center);
        changed(false);

        if( unitTime === 1.0 )
            this.addHistoryElement();
        else
            requestAnimationFrame(function() { cam.centerShot(false); });
    };

    //This is for the level camera operation in steering wheel menu
    //Integrated from ViewManager::LevelCamera
    this.levelShot = function(){

        var view = this.getView();
        var dist = view.length();
        var worldUp = this.sceneUpDirection.clone();
        var vUp  = camera.up.clone().normalize();
        var vView = view.normalize();
        var dotView = vView.dot(worldUp);

        if ((1.0 - Math.abs(dotView)) > Number.MIN_VALUE){
            var vRight = vView.clone().cross(worldUp);
            vView = worldUp.clone().cross(vRight);
            vView.normalize();
        }else{
            vView = vUp.clone();
        }
        vView.multiplyScalar(dist);

        var destination = {
            center: vView.add(camera.position),
            up: worldUp,
            position: camera.position,
            pivot: cam.center.clone().add(vView),
            fov: camera.fov,
            worldUp: worldUp
        }
        cam.elapsedTime = 0;
        cam.animateTransition(destination);
    }

    //This is for the fit to window operation in the steering wheel drop down menu
    //Integrated from CameraOperations::FitBoundingBoxToView
    //Right now since we only load one mesh we can use the bounding box property of it, if multiple meshes loaded
    //we will need to find the bounding box around them
    this.fitToWindow = function(){

        var viewDir = this.getView();
        var upDir = camera.up.clone();
        viewDir.normalize();
        upDir.normalize();
        camParamsFinal = camera.clone();
        camParamsFinal.center = cam.center;

        upDir = getUpDirection(upDir,viewDir);
        upDir.normalize();
        camParamsFinal.up.copy(upDir);

        var rightDir = viewDir.clone().cross(upDir);
        rightDir.normalize();

        var boxMin = boundingBoxMin.clone();
        var boxMax = boundingBoxMax.clone();
        var boxPoints = [boxMin,boxMax];
        var boxMidpoint = new THREE.Vector3(boxMax.x-boxMin.x, boxMax.y-boxMin.y,boxMax.z-boxMin.z);

        boxPoints[2] = new THREE.Vector3(boxMax.x,boxMin.y,boxMax.z);
        boxPoints[3] = new THREE.Vector3(boxMax.x,boxMin.y,boxMin.z);
        boxPoints[4] = new THREE.Vector3(boxMax.x,boxMax.y,boxMin.z);
        boxPoints[5] = new THREE.Vector3(boxMin.x,boxMax.y,boxMax.z);
        boxPoints[6] = new THREE.Vector3(boxMin.x,boxMax.y,boxMin.z);
        boxPoints[7] = new THREE.Vector3(boxMin.x,boxMin.y,boxMax.z);

        //Move the box into camParams frame coordinates
        for(var j=0; j<8; j++){
            var testVector = boxPoints[j].clone().sub(camera.position);

            boxPoints[j].setX(testVector.clone().dot(rightDir));
            boxPoints[j].setY(testVector.clone().dot(upDir));
            boxPoints[j].setZ(testVector.clone().dot(viewDir));
        }

        //This is to be used when ortho camera is implemented
        /*
        var minPointH = boxPoints[0], maxPointH = boxPoints[0], minPointV = boxPoints[0],maxPointV = boxPoints[0];

        //Solve for the eye position in ortho.  We take the position as the center point
        //Of the 2D projection.
        for(var k=0; k<8; k++){
            var testVertex = boxPoints[k];
            if(testVertex.x < minPointH.x){
                minPointH = testVertex;
            }else if(testVertex.x > maxPointH.x){
                maxPointH = testVertex;
            }

            if(testVertex.y < minPointV.y){
                minPointV = testVertex;
            }else if(testVertex.y > maxPointV.y){
                maxPointV = testVertex;
            }
        }

        var geomWidth = maxPointH.x - minPointH.x;
        var geomHeight = maxPointV.y - minPointV.y;

        //Set ortho width and height
        if (geomWidth/geomHeight > camera.aspect){
            camParams.orthoWidth = geomWidth;
            camParams.orthoHeight = geomWidth/viewAspect;
        }else{
            camParams.orthoWidth = geomHeight * viewAspect;
            camParams.orthoHeight = geomHeight;
        }
        var orthoOffset = new THREE.Vector3((minPointH.x + maxPointH.x)/2.0,(minPointV.y + maxPointV.y)/2.0,0.0);
        */

        //Find the eye position in perspective.
        //While working in 2D, find the equation of the line passing through each box corner of form z = mx + b
        //that is parallel to the sides of the viewing frustum.  Note that all of the coordinates of the box
        //are still defined in the camParams frame.  Compare the z intercept values (ie. b) to figure out which two lines
        //represent the outer edges of the bounding box, and solve for their intersection to find the desired eye (x,z) position
        //that would be required to make the object touch the left and right edges of the viewport (ie. the closest we can get
        //without losing horizontal view of the object).  Repeat with z = my + b to find the eye (y,z) position for the vertical frustum.

        //TODO:fovTop and fovBottom are ALWAYS the same b/c of camera declaration, this needs to change
        var fovTop = THREE.Math.degToRad(camera.topFov);
        var fovBottom = THREE.Math.degToRad(camera.bottomFov);
        var fovLeft = THREE.Math.degToRad(camera.leftFov);
        var fovRight = THREE.Math.degToRad(camera.rightFov);

        var BLeft, BRight, BTop,BBottom;

        BLeft = (fovLeft >= 0) ? Number.MAX_VALUE : Number.MIN_VALUE;
        BRight = (fovRight >= 0)? Number.MAX_VALUE : Number.MIN_VALUE;
        BTop = (fovTop >= 0)? Number.MAX_VALUE : Number.MIN_VALUE;
        BBottom = (fovBottom >= 0)? Number.MAX_VALUE : Number.MIN_VALUE;

        var slopeRight = 1.0/Math.tan(fovRight);
        var slopeLeft = -1.0/Math.tan(fovLeft);
        var slopeTop = 1.0/Math.tan(fovTop);
        var slopeBottom = -1.0/Math.tan(fovBottom);

        for (var i = 0; i<8; i++){
            var testCorner = boxPoints[i].clone();
            var b = testCorner.z - (slopeLeft * testCorner.x);
            BLeft = (fovLeft >= 0)? Math.min(BLeft,b) : Math.max(BLeft,b);

            b = testCorner.z - (slopeRight * testCorner.x);
            BRight = (fovRight >=0) ? Math.min(BRight, b) : Math.max(BRight, b);

            //For vertical frustum
            b = testCorner.z - (slopeTop *testCorner.y);
            BTop = (fovTop >=0) ? Math.min(BTop, b) : Math.max(BTop, b);

            b = testCorner.z - (slopeBottom * testCorner.y);
            BBottom = (fovBottom >=0) ? Math.min(BBottom, b) : Math.max(BBottom, b);
        }

        //Solve for intersection of horizontal frustum
        var eyeX = (BRight - BLeft)/(slopeLeft - slopeRight);
        var eyeZH = (slopeLeft * eyeX) + BLeft;

        //Solve for intersection of vertical frustum
        var eyeY = (BBottom - BTop)/(slopeTop - slopeBottom);
        var eyeZV = slopeTop * eyeY + BTop;

        var eyeZ = 0.0;

        //With the two frustums solved, compare the two frustums to see which one is currently closer to the object based on z value.
        //Slide the closer frustum back along its median line (to ensure that the points stay within the frustum) until it's Z value
        //matches that of the further frustum. Take this as the final eye position.

        if (eyeZH <= eyeZV){
            var medianAngleV = (fovTop - fovBottom) / 2.0;
            if (Math.abs(medianAngleV) > Number.MIN_VALUE){
                var medianSlopeV = 1.0/Math.tan(medianAngleV);
                eyeY = eyeY - eyeZV/medianSlopeV + eyeZH/medianSlopeV; //derived from z1 - my1 = z2 - my2
            }
            eyeZ = eyeZH;
        }else{
            var medianAngleH = (fovRight - fovLeft) / 2.0;
            if (Math.abs(medianAngleH) > Number.MIN_VALUE){
                var medianSlopeH = 1.0/Math.tan(medianAngleH);
                eyeX = eyeX - eyeZH/medianSlopeH + eyeZV/medianSlopeH;
            }
            eyeZ = eyeZV;
        }

        var eyeOffset = new THREE.Vector3(eyeX,eyeY,eyeZ);

        //Transform eyeoffset back into world frame
        var interim1 = (rightDir.clone().multiplyScalar(eyeOffset.x));
        var interim2 = (upDir.clone().multiplyScalar(eyeOffset.y));
        var interim3 = (viewDir.clone().multiplyScalar(eyeOffset.z));
        eyeOffset = interim1.clone().add(interim2.clone().add(interim3));

        camParamsFinal.position.add(eyeOffset);
        var interim = (boxMidpoint.clone().sub(camParamsFinal.position)).dot(viewDir);
        camParamsFinal.center = camParamsFinal.position.clone().add(viewDir.multiplyScalar(interim));
        camParamsFinal.pivot = boxMidpoint.clone();

        var destination = {
              center: camParamsFinal.center,
                  up: camParamsFinal.up,
            position: camParamsFinal.position,
               pivot: camParamsFinal.pivot,
                 fov: camera.fov,
             worldUp: cam.sceneUpDirection.clone()
        }
        cam.elapsedTime = 0;
        cam.animateTransition(destination);
    }

    /*         Functions for operation         */

    //used in fit to window
    function getUpDirection(upDir, viewDir){
        var upp = upDir.clone();

        if((Math.abs(upp.clone().dot(viewDir))) < Number.MIN_VALUE){
            upp.normalize();
            return upp;
        }

        upp = getProjectionOnPlane(upDir,viewDir);
        if (upp.length() < Number.MIN_VALUE){
            upp = getEmpiricalUpDirection(viewDir);
        }
        upp.normalize();
        return upp;
    }

    //used in getUpDirection
    function getProjectionOnPlane(vector,normal){
        normal.normalize();
        var projToNormal = vector.clone().dot(normal);
        var projection = normal.clone().multiplyScalar(projToNormal);
        projection = vector.clone().sub(projection);
        return projection;
    }

    //used in getUpDirection
    function getEmpiricalUpDirection(normal){
        var zeros = new THREE.Vector3(0,0,0);
        var directions = [new THREE.Vector3(0,1,0),
            new THREE.Vector3(1,0,0),
            new THREE.Vector3(0,0,1),
            new THREE.Vector3(0,1,1),
            new THREE.Vector3(1,0,1),
            new THREE.Vector3(1,1,0),
            new THREE.Vector3(1,1,1)
            ];

        for (var i = 0; i <7; i++){
            if (Math.abs(directions[i].dot(normal)) < Number.MIN_VALUE){
                zeros = directions[i];
                break;
            }
        }
        return zeros;
    }

    //convert screen coords to window coords
    function convertCoordsToWindow( pixelX, pixelY ){
        var delta = new THREE.Vector2(0,0);

        delta.x = pixelX / window.innerWidth;
        delta.y = pixelY / window.innerHeight;

        return delta;
    }

    //picking ray intersection with the empty scene(not on object)
    function getScreenRay( mouse ){
        mouse.y = Math.abs(mouse.y - window.innerHeight);
        var rayOrigin, rayDirection;
        var eye = camera.position;
        var center = cam.center;
        var eyeToCenter = center.clone().sub(eye);
        var up = camera.up;
        var right = eyeToCenter.clone().cross(up);
        var dist = eyeToCenter.clone().length();

        var frustumLeft = dist * Math.tan(THREE.Math.degToRad(camera.leftFov));
        var frustumRight = dist * Math.tan(THREE.Math.degToRad(camera.rightFov));
        var frustumTop = dist * Math.tan(THREE.Math.degToRad(camera.topFov));
        var frustumBottom = dist * Math.tan(THREE.Math.degToRad(camera.bottomFov));
        var frustumWidth = (frustumLeft + frustumRight);
        var frustumHeight = (frustumTop + frustumBottom);

        var rightLength = mouse.x * frustumWidth / window.innerWidth;
        var centerToRightLength = rightLength - frustumLeft;

        var upLength = mouse.y * frustumHeight / window.innerHeight;
        var centerToUpLength = upLength - frustumBottom;

        up = up.clone().normalize().clone().multiplyScalar(centerToUpLength);
        right = right.clone().normalize().clone().multiplyScalar(centerToRightLength);

        /*
        // PRH -- account for difference in aspect ratio between camera FOV and viewport --
        AutoCam::AdjustForAspectRatio( params, screenWidth, screenHeight, mouseXunit, mouseYunit );
        */

        if ( cam.ortho ){
            rayOrigin = eye.clone().add(right).clone().add(up);
            rayDirection = eyeToCenter;
        }else{
            rayOrigin = eye;
            rayDirection = eyeToCenter.clone().add(up).clone().add(right);
        }

        return {
            'rayO': rayOrigin,
            'rayD': rayDirection
        };
    }

    //get ray intersection point and set pivot
    this.updatePivotPosition = function( mouse ){
        //TODO: update pivot only when mouse down

        var raycaster;
        var intersects;
        var projector = new THREE.Projector();
        //formula from online
        var direction = new THREE.Vector3((mouse.x / window.innerWidth) * 2 - 1, -(mouse.y / window.innerHeight) * 2 + 1, 0.5);

        projector.unprojectVector(direction, camera);
        raycaster = new THREE.Raycaster(camera.position, direction.sub(camera.position).normalize());
        intersects = raycaster.intersectObjects(objects);

        if (cam.mode == 'zoom'){
            if (intersects[0] !== undefined){
                var point = intersects[0].point;
                cam.pivot.copy(point);
            }else{
                var result = getScreenRay( mouse );
                cam.pivot.copy(result.rayO.clone().add(result.rayD));
            }

        }else if (intersects[0] !== undefined){
            wheel.cursorImage('pivot');
            var point = intersects[0].point;
            if (!cam.isMouseDown){
                cam.pivot.copy(point);
            }
        }else{
            wheel.cursorImage('SWInvalidArea');
        }
    }

    function getNextRotation(rotationType, snapAngle, lastDelta){
        var threshold, accelerationA, accelerationB, shiftZone;
        threshold = accelerationA = accelerationB = shiftZone = 0.0;

        var next = 0.0;
        var lockedAxis = null;
        var lockDelta = null;

        var deadZone = cam.snapOrbitDeadZone;
        var orbitMultiplier = cam.orbitMultiplier;

        if (rotationType == 'h'){
            threshold = cam.snapOrbitThresholdH;
            accelerationA = cam.snapOrbitAccelerationAX;
            accelerationB = cam.snapOrbitAccelerationBX;
            shiftZone = 1.0 -cam.snapOrbitAccelerationPointX;
            lockDelta = cam.lockDeltaX;
            lockedAxis = cam.lockedX;
        }else{
            threshold = cam.snapOrbitThresholdV;
            accelerationA = cam.snapOrbitAccelerationAY;
            accelerationB = cam.snapOrbitAccelerationBY;
            shiftZone = 1.0 -cam.snapOrbitAccelerationPointY;
            lockDelta = cam.lockDeltaY;
            lockedAxis = cam.lockedY;
        }

        if(!lockedAxis){
            if(Math.abs(snapAngle) > threshold){
                next = lastDelta * orbitMultiplier;
            }else if (Math.abs(snapAngle) > shiftZone * threshold){
                if(lastDelta * snapAngle > 0.0){
                    next = lastDelta * orbitMultiplier * accelerationA;
                }else{
                    next = lastDelta * orbitMultiplier * 1.0/accelerationA;
                }

            }else{
                if(lastDelta * snapAngle > 0.0){
                    next = lastDelta * orbitMultiplier * accelerationB;
                }else{
                    next = lastDelta * orbitMultiplier * 1.0/accelerationB;
                }

            }

            if(next * snapAngle > 0.0 && Math.abs(next) > Math.abs(snapAngle)){
                this.lockDeltaX = this.lockDeltaY = 0.0;	//want to reset both regardless of rotation axis
                lockedAxis = true;
                next = snapAngle;
            }

        }else{
            lockDelta += lastDelta;

            if(lockDelta < -deadZone){
                next =  (lockDelta + deadZone) * orbitMultiplier * 1.0/accelerationB;
                lockedAxis = false;
            }else if(lockDelta > deadZone){
                next =  (lockDelta - deadZone) * orbitMultiplier * 1.0/accelerationB;
                lockedAxis = false;
            }
        }
        return next;
    }


    function getClosestAlignDir(Dv, searchPrincipal){
        var maxAngle = -Number.MAX_VALUE;
        var maxIndex = 0;

        for ( var i = 0; i < (searchPrincipal ? 6 : 26); i++ ){
            var Di = cam.alignDirTable[i].clone().multiplyScalar(-1);
            Di.normalize();

            var angle = Di.dot(Dv);

            if ( angle > maxAngle ){
                maxAngle = angle;
                maxIndex = i;
            }
        }
        return cam.alignDirTable[maxIndex];
    }

    function snapToClosestView (up, snapAngleh, snapAnglev){
        if ( !cam.useSnap )
            return;

        if (cam.preserveOrbitUpDirection ){
            // Find closest view direction
            var lastViewDir = (cam.saveCenter.clone().sub(cam.saveEye)).clone().normalize();
            var snapDir = (getClosestAlignDir(lastViewDir, false)).clone().multiplyScalar(-1).clone().normalize();

            if(Math.abs(Math.abs(lastViewDir.clone().dot(up)) - 1.0) < Number.MIN_VALUE){
                //topdown or bottom up case
                snapAnglev = 0.0;
                var snapUp = (getClosestAlignDir(cam.saveUp, true)).clone().multiplyScalar(-1).clone().normalize();
                snapAngleh = cam.saveUp.findAngleWith(snapUp,up);
            } else {
                var lastViewDirProj = lastViewDir.clone().sub(up).multiplyScalar(up.clone().dot(lastViewDir));
                var snapDirProj = snapDir.clone().sub(up).multiplyScalar(up.clone().dot(snapDir));
                snapAngleh = lastViewDirProj.clone().findAngleWith(snapDirProj, up);
                var testRotate = new THREE.Quaternion().setFromAxisAngle( up,snapAngleh );
                var transitionDir = testRotate.clone().rotate(lastViewDir);
                var transitionRight = testRotate.clone().rotate(lastViewDir.clone().cross(cam.saveUp));
                snapAnglev = transitionDir.clone().findAngleWith(snapDir, transitionRight);
            }

            if(snapDir != cam.lastSnapDir){
                //If last and current snapDirs are not on the same plane, unlock vertical orbit
                if (Math.abs(snapDir.clone().dot(up) - cam.lastSnapDir.clone().dot(up)) > Number.MIN_VALUE){
                    cam.lockedY = false;
                }
                cam.lastSnapDir = snapDir;
            }
        } else {
            //Find closest view direction
            /*  var vDirView = cam.saveCenter.clone().sub(cam.saveEye);
            var vRight = vDirView.clone().cross( cam.saveUp );
            var snapDir = -getClosestAlignDir(vDirView, false).clone().normalize();
            var snapDirProj = snapDir.clone.sub(up.clone().multiplyScalar(up.clone().dot(snapDir)));
            snapAngleh = vDirView.findAngleWith(snapDirProj, up);

            var testRotate = new THREE.Quaternion().setFromAxisAngle(up,snapAngleh );
            var transitionDir = testRotate.clone().rotate(vDirView);
            var transitionRight = testRotate.clone().rotate(vRight);
            snapAnglev = transitionDir.findAngleWith(snapDir, transitionRight);

            if(snapDir != cam.lastSnapDir) {
                cam.cam.lockedY = false;
                cam.lockedX = false;
                cam.lastSnapDir = snapDir;
            }*/
        }
    }

/// Returns true if the operation belongs to a chain of combined operations; otherwise returns false.
    function IsCombined(){
        return cam.combined;
    }

    function isInDeadZone(currentCursor, startCursor){

        var deadZone = 30;
        var res = false;

        var w = window.innerWidth;
        var x = currentCursor.x % w;

        var h = window.innerHeight;
        var y = currentCursor.y % h;


        var diffX = (x > 0) ? (x - startCursor.x) : (w + x - startCursor.x);
        var diffY = (y > 0) ? (y - startCursor.y) : (h + y - startCursor.y);

        if((Math.abs(diffX) < deadZone) &&  (Math.abs(diffY) < deadZone))
            res = true;

        return res;
    }

    function GetXYAndWrapCounts(currentCursor, startCursor, wrapCount ){
        wrapCount.x = (currentCursor.x - startCursor.x) / window.innerWidth;
        currentCursor.x = startCursor.x + (currentCursor.x - startCursor.x) % window.innerWidth;

        wrapCount.y = (currentCursor.y - startCursor.y) / window.innerHeight;
        currentCursor.y = startCursor.y + (currentCursor.y - startCursor.y) % window.innerHeight;
    }

    function setBias( set, currentCursor, startCursor ){
        if (m_bias && set){
            return;

        }else if (set){
            var deadZone = 30;
            var wrapCount = new THREE.Vector2();

            var x = currentCursor.x;
            var y = currentCursor.y;

            GetXYAndWrapCounts(currentCursor, startCursor, wrapCount);

            m_resetBiasX = window.innerWidth * wrapCount.x;
            m_resetBiasY = window.innerHeight * wrapCount.y;

            if (x < startCursor.x)
                x = x - 2 * deadZone;
            else
                x = x + 2 * deadZone;

            if (y < startCursor.y)
                y = y - 2 * deadZone;
            else
                y = y + 2 * deadZone;
        }
        m_bias = set;
    }

    function checkBoundaryConditions(amount, cursorOffset, m_amount){
        if (cursorOffset == 0)
            return 0;

        var deltaAmount = amount;
        var eye = cam.saveEye.clone().sub(worldUp.clone().multiplyScalar(m_amount + deltaAmount));
        var prevEye = cam.saveEye.clone().sub(worldUp.clone().multiplyScalar(m_amount));

        var eyeHeight = 0.0;
        var epsilon = (cam.maxSceneBound - cam.minSceneBound) / 1000;

        //console.log(m_amount);
        //console.log(deltaAmount);


        if (cam.topLimit && (cursorOffset > 0)){
            // Cursor was on the top of the slider, but now is moving down.
            // Bring eyeHeight below maxSceneBound.
            eyeHeight = cam.maxSceneBound - epsilon;
            cam.topLimit = false;
        }else if (cam.bottomLimit && (cursorOffset < 0)){
            // Cursor was on the bottom of the slider, but now is moving up.
            // Bring eyeHeight above minSceneBound.
            eyeHeight = cam.minSceneBound + epsilon;
            cam.bottomLimit = false;
        }else{
            eyeHeight = eye.dot(worldUp);
        }

        var prevEyeHeight =	prevEye.dot(worldUp);

        //console.log(eyeHeight);

        if ( eyeHeight < cam.minSceneBound ) {
            if ( prevEyeHeight < cam.minSceneBound) {
                // this limits how far under the min we can go
                cam.bottomLimit = true;
                deltaAmount = 0.0;
            }
        }else if ( eyeHeight > cam.maxSceneBound ) {
            if ( prevEyeHeight > cam.maxSceneBound ) {
                // This limits how far over the max we can go
                cam.topLimit = true;
                deltaAmount = 0.0;
            }
        }

        return deltaAmount;
    }

    function getMoveAmountFromCursorOffset(offset){
        // Manipulating with power of 2 of cursor offset allows to amplify the visible change in the offset
        // when the offset is big to achieve the effect ofhigher sensitivity of the tool on small offsets
        // and lower sensitivity on big offsets.
        var derivedOffset = Math.pow (offset, 2.0);
        if (offset < 0){
            derivedOffset = -derivedOffset;
        }

        //delta.y = derivedOffset;
        var delta = convertCoordsToWindow( 0, derivedOffset );
        var sceneHeight = cam.maxSceneBound - cam.minSceneBound;

        // This empirical step provides a good motion of the scene when moving up/down.
        var p = sceneHeight * 0.01;
        delta.y *= p;

        var deltaAmount = cam.userHeightSpeed * delta.y;
        deltaAmount = checkBoundaryConditions(deltaAmount, offset, cam.m_amount);

        return deltaAmount;
    }

    //draw UI for up-down operation during mouse move
    this.onDrawHeight = function(mouse, pX, pY, dragged, path){
        var sliderHeight = 86;
        var upDir = new THREE.Vector3(0,1,0);
        var h = camera.position.clone().dot(upDir);
        var unitHeight = Math.linearClamp( h, cam.minSceneBound, cam.maxSceneBound );
        var height = unitHeight - 0.5 ;
        if( cubeContainer ) {
            cubeContainer.find("img#updownImageA").remove();
            cubeContainer.prepend('<img src="'+path+'SWheighthandleA.png" id="updownImageA" style="position:fixed; z-index:9999; top:'+(pY - sliderHeight * height)+'px; left:'+pX+'px;"/>');

            if (!dragged){
                cubeContainer.prepend('<img src="'+path+'SWheighthandleI.png" id="updownImageI" style="position:fixed; z-index:9998; top:'+(pY - sliderHeight * height)+'px; left:'+(pX)+'px;"/>');
            }
        }
    }

    /**
     * Draws a menu by appending an unordered list to the given container element.
     * @param {Array} menuOptions - string array of menu options, null meaning seperator
     * @param {Array} menuEnables - boolean array of menu enable flags indicating which corresponding menu entry in menuOptions should be enabled or disabled.
     * @param {Number} mousex - the x coordinate of the menu trigger point, used to position menu
     * @param {Number} mousey - the y coordinate of the menu trigger point, used to position menu
     * @param {HTMLElement} container - the container element to add the menu to.
     * @param {Object} position - object with x, y, w, h of the container element.
     */
    this.drawDropdownMenu = function(menuOptions, menuEnables, menuCallbacks, mousex, mousey, container, position) {
        var itemID = 0;

        if( !dropDownMenu ) {

            dropDownMenu = document.createElement('div');
            dropDownMenu.className = 'dropDownMenu';

            // Initialize the top and left with some approximate values
            // so that the correct width can be returned by gerBoudningClientRect().
            dropDownMenu.style.top    = '100px';
            dropDownMenu.style.left   = '-400px';

            var menuHeight = 0;
            for (var i = 0; i<menuOptions.length; i++){
                var listItem;
                if (menuOptions[i] == null) {                       // menu separator
                    listItem = document.createElement("li");
                    listItem.style.height = '1px';
                    menuHeight += 1;
                    listItem.style.backgroundColor="#E0E0E0";
                } else {
                    var content = Autodesk.Viewing.i18n.translate(menuOptions[i]);

                    if( menuCallbacks[i] ) {
                        listItem = document.createElement("div");
                        var check = document.createElement("input");
                        var text  = document.createElement("label");
                        check.type = "checkbox";
                        check.className = "dropDownMenuCheck";
                        text.innerHTML = content;
                        text.className = "dropDownMenuCheckText";
                        listItem.appendChild(check);
                        listItem.appendChild(text);
                        listItem.className = "dropDownMenuCheckbox";
                    }
                    else {
                        listItem = document.createElement("li");
                        listItem.textContent = content;
                        listItem.className = menuEnables[i] ? "dropDownMenuItem" : "dropDownMenuItemDisabled";
                    }

                    listItem.id = "menuItem" + itemID;
                    itemID++;
                    menuHeight += 25;       // HACK!!!

                    listItem.setAttribute( "data-i18n", menuOptions[i] );
                }
                dropDownMenu.appendChild(listItem);
            }

            // Add the menu to the DOM before asking for boundingClientRect.
            // Otherwise, it will be zero.
            container.appendChild(dropDownMenu);

            var menuWidth = dropDownMenu.getBoundingClientRect().width;

            this.menuSize.x = menuWidth;
            this.menuSize.y = menuHeight;
        }
        else {
            // Just add the drop down menu, It already exists. 
            container.appendChild(dropDownMenu);
        }
        itemID = 0;
        for (var i = 0; i<menuOptions.length; i++) {
            if( menuOptions[i] == null )
                continue;

            if( menuCallbacks[i] ) {
                var id = "menuItem" + itemID;
                var element = document.getElementById(id);
                if( element ) {
                    element.children[0].checked = menuCallbacks[i]();
                }
            }
            itemID++;
        }
        var top  = mousey - 15;        // 15 offset so list appears @ button
        var left = mousex + 1;

        var rect = canvas.getBoundingClientRect();

        // stderr("LEFT: " + left + " mousex: " + mousex);
        // stderr("TOP: " + top + " mousey: " + mousey);
        // stderr("canvas: " + rect.right + ", " + rect.bottom);

        if( (left + this.menuSize.x) > rect.right )
            left = mousex - this.menuSize.x - 1;
        if( (top + this.menuSize.y) > rect.bottom )
            top = rect.bottom - this.menuSize.y;

        // Make relative to container:
        top  -= position.y;
        left -= position.x;

        dropDownMenu.style.top  = top + 'px';
        dropDownMenu.style.left = left + 'px';

        this.menuOrigin.x = left;
        this.menuOrigin.y = top;
    }


    this.removeDropdownMenu = function(container) {
        container.removeChild(dropDownMenu);
    }

    function isAxisAligned(vec) {
        var sceneRight  = cam.sceneFrontDirection.clone().cross(cam.sceneUpDirection);
        var checkUp    = Math.abs(Math.abs(vec.dot(cam.sceneUpDirection)) - 1.0);
        var checkFront = Math.abs(Math.abs(vec.dot(cam.sceneFrontDirection)) - 1.0);
        var checkRight = Math.abs(Math.abs(vec.dot(sceneRight)) - 1.0);

        return (checkUp < 0.00001 || checkFront < 0.00001 || checkRight < 0.00001);
    }

    this.isFaceView = function() {
        var dir = this.center.clone().sub(camera.position).normalize();
        return isAxisAligned(dir) && isAxisAligned(camera.up);
    };

    this.startInteraction = function (x, y) {
        this.startCursor = new THREE.Vector2(x, y);

        this.startState = {
            saveCenter: this.center.clone(),
            saveEye:    this.camera.position.clone(),
            savePivot:  this.pivot.clone(),
            saveUp:     this.camera.up.clone()
        };

        this.lockDeltaX = 0.0;
        this.lockedX = false;
        this.lastSnapRotateX = 0.0;
        this.lockDeltaY = 0.0;
        this.lockedY = false;
        this.lastSnapRotateY = 0.0;
        this.lastSnapDir = new THREE.Vector3(0,0,0);
    };

    this.orbit = function (currentCursor, startCursor, distance, startState){
        if( this.navApi.getIsLocked() || this.currentlyAnimating === true )
            return;

        var mode = 'wheel';

        // If orthofaces is enabled, and camera is ortho
        // then switch to perspective
        if(cam.orthographicFaces && !camera.isPerspective) {
            camera.toPerspective();

            // Hack: update the start state with the new position:
            if( startState )
                startState.saveEye.copy(this.camera.position);
        }
        if (startState){
            mode = 'cube';
        }
        if (mode == 'cube'){
            this.saveCenter.copy(startState.saveCenter);
            this.saveEye.copy(startState.saveEye);
            this.savePivot.copy(startState.savePivot);
            this.saveUp.copy(startState.saveUp);
            this.useSnap = true;
            this.doCustomOrbit = true;
        } else {
            this.saveCenter.copy(this.center);
            this.savePivot.copy(this.pivot);
            this.saveEye.copy(camera.position);
            this.saveUp.copy(camera.up);
            this.useSnap = false;
            this.doCustomOrbit = false;
        }

        if (IsCombined() && prevCenter == undefined) {
            prevCenter = this.saveCenter.clone();
            prevEye    = this.saveEye.clone();
            prevPivot  = this.savePivot.clone();
            prevUp     = this.saveUp.clone();
        }

        // TODO: fold the two cases into one and prevent duplicate code
        if (this.preserveOrbitUpDirection ) {

            var delta = convertCoordsToWindow( currentCursor.x - startCursor.x, currentCursor.y - startCursor.y );
            var lastDelta = convertCoordsToWindow(distance.x, distance.y);

            var worldUp = this.sceneUpDirection.clone();
            var worldFront = this.sceneFrontDirection.clone();
            var worldRight = this.sceneFrontDirection.clone().cross( this.sceneUpDirection).normalize();

            /* ????? WTF:
            var worldFront = new THREE.Vector3(1,0,0);
            var worldUp = new THREE.Vector3(0,1,0);
            */

            //viewcube
            // if (this.doCustomOrbit ) {
            //     worldUp = new THREE.Vector3(0,1,0);
            //     worldFront = new THREE.Vector3(1,0,0);
            // }

            /* ?????? WTF:
            var worldR = worldFront.clone().cross( worldUp );
            worldUp = worldR.clone().cross(worldFront);
            worldUp.clone().normalize();
            */

            var pivot  = IsCombined() ? prevPivot  : this.savePivot;
            var eye    = IsCombined() ? prevEye    : this.saveEye;
            var center = IsCombined() ? prevCenter : this.saveCenter;
            var camUp  = IsCombined() ? prevUp     : this.saveUp;

            var initViewDir  = pivot.clone().sub(eye).normalize();
            var initViewDirV = center.clone().sub(eye).normalize();
            var initRightDir = initViewDirV.clone().cross( camUp );

            var fTargetDist  = eye.clone().sub(pivot).length();
            var fTargetDistV = eye.clone().sub(center).length();

            var vLookUpdate  = initViewDir.clone().multiplyScalar(-1);
            var vLookUpdateV = initViewDirV.clone().multiplyScalar(-1);
            var vRightUpdate = initRightDir;
            var vUpUpdate = camUp.clone();

            var snapAngleh = 0.0;
            var snapAnglev = 0.0;

            //viewcube

            // DOESN'T DO ANYTHING: snapToClosestView(worldUp, snapAngleh, snapAnglev);

            if ( !this.constrainOrbitHorizontal ) {
                // Need to check if:
                //  1. camera is "upside-down" (angle between world up and camera up is obtuse) or
                //  2. camera is in top view (camera up perpendicular to world up and view angle acute to world up)
                // These cases required a reversed rotation direction to maintain consistent mapping of tool:
                //  left->clockwise, right->counter-clockwise
                //
                //  PHB June 2014 - #2 above makes no sense to me. If the camera up is perpendicular to the
                //  world up then the view is parallel to world up (view dot up == 1). So the second test is
                //  meaningless. There is no good way to determine the rotation direction in this case. If you
                //  want it to feel like direct manipulation then it would be better to determine if the cursor
                //  is above or below the pivot in screen space.

                var worldUpDotCamUp = worldUp.dot(this.saveUp);
                // var worldUpDotView  = worldUp.dot(this.saveCenter.clone().sub(this.saveEye).normalize());
                // stderr("worldUpDotCamUp = " + worldUpDotCamUp.toFixed(3));

                // if ((worldUpDotCamUp < -Number.MIN_VALUE) ||
                //     ((Math.abs(worldUpDotCamUp) < Number.MIN_VALUE) && (worldUpDotView > 0.0)))
                //
                var kFlipTolerance = 0.009;     // Must be flipped by more than about 0.5 degrees
                if( worldUpDotCamUp < -kFlipTolerance ) {
                    delta.x = -delta.x;
                    lastDelta.x = -lastDelta.x;
                }

                var dHorzAngle = 0.0;
                if (IsCombined()) {
                    dHorzAngle = lastDelta.x * this.orbitMultiplier;
                } else {
                    dHorzAngle = this.useSnap ? this.lastSnapRotateX + getNextRotation('h', snapAngleh, -lastDelta.x) :
                        delta.x * this.orbitMultiplier;
                }

                this.lastSnapRotateX = dHorzAngle;
                // Define rotation transformation

                var quatH = new THREE.Quaternion().setFromAxisAngle( worldUp, -dHorzAngle );

                vLookUpdate.applyQuaternion(quatH);
                vLookUpdateV.applyQuaternion(quatH);
                vRightUpdate.applyQuaternion(quatH);
                vUpUpdate.applyQuaternion(quatH);
            }

            if ( !this.constrainOrbitVertical ) {
                var vRightProjF = worldFront.clone().multiplyScalar(worldFront.dot(vRightUpdate));
                var vRightProjR = worldRight.clone().multiplyScalar(worldRight.dot(vRightUpdate));
                var vRightProj = vRightProjF.clone().add(vRightProjR);
                vRightProj.clone().normalize();

                var dVertAngle = 0.0;

                if (IsCombined()){
                    dVertAngle = lastDelta.y * this.orbitMultiplier;
                }else{
                    var next = getNextRotation('v', snapAnglev, lastDelta.y);
                    dVertAngle = this.useSnap ? this.lastSnapRotateY + next : delta.y * this.orbitMultiplier;
                }
                var quatV = new THREE.Quaternion().setFromAxisAngle( vRightProj, -dVertAngle );

                if( !this.navApi.getOrbitPastWorldPoles() ) {

                    var vUpUpdateTemp = vUpUpdate.clone();
                    vUpUpdateTemp.applyQuaternion(quatV).normalize();

                    // Check if we've gone over the north or south poles:
                    var wDotC = worldUp.dot(vUpUpdateTemp);
                    if( wDotC < 0.0 )
                    {
                        var vLookUpdateVtemp = vLookUpdateV.clone();
                        vLookUpdateVtemp.applyQuaternion(quatV).normalize();

                        // How far past Up are we?
                        var dVertAngle2 = vLookUpdateVtemp.angleTo(worldUp);
                        if( Math.abs(dVertAngle2) > (Math.PI * 0.5) )
                            dVertAngle2 -= (dVertAngle2 > 0.0) ? Math.PI : -Math.PI;

                        // stderr('OVER!! delta=' + dVertAngle.toFixed(3) + " => " + (dVertAngle - dVertAngle2).toFixed(3));

                        dVertAngle -= dVertAngle2;

                        quatV.setFromAxisAngle( vRightProj, -dVertAngle );
                        vLookUpdate.applyQuaternion(quatV).normalize();
                        vLookUpdateV.applyQuaternion(quatV).normalize();
                        vUpUpdate.applyQuaternion(quatV).normalize();

                    }
                    else 
                    {
                        vLookUpdate.applyQuaternion(quatV).normalize();
                        vLookUpdateV.applyQuaternion(quatV).normalize();
                        vUpUpdate.applyQuaternion(quatV).normalize();
                    }
                }
                else
                {
                    vLookUpdate.applyQuaternion(quatV).normalize();
                    vLookUpdateV.applyQuaternion(quatV).normalize();
                    vUpUpdate.applyQuaternion(quatV).normalize();
                }
                this.lastSnapRotateY = dVertAngle;
            }

            // figure out new eye point
            var vNewEye = vLookUpdate.multiplyScalar(fTargetDist).add(pivot);

            camera.position.copy(vNewEye);
            camera.up.copy(vUpUpdate);
            this.center.copy(vNewEye);
            this.center.sub(vLookUpdateV.multiplyScalar(fTargetDistV));

            if( IsCombined() )
            {
                prevCenter.copy(this.center);
                prevEye.copy(camera.position);
                prevPivot.copy(this.pivot);
                prevUp.copy(camera.up);
            }
        }
        else {
            /*var lastDelta = convertCoordsToWindow(distance.x, distance.y);
            var vDir = prevPivot.clone().sub(prevEye);
            var vDirView = prevCenter.clone().sub(prevEye);
            var vRight = vDirView.clone().cross(prevUp);
            var vUp = vRight.clone().cross(vDirView);
            vUp.clone().normalize();

            var dist = (prevPivot.clone().sub(prevEye)).clone().length();
            var distView = (prevCenter.clone().sub(prevEye)).clone().length();

            var snapAngleh = 0.0;
            var snapAnglev = 0.0;

            //viewcube
            //snapToClosestView(vUp, snapAngleh, snapAnglev);

            if ( !this.constrainOrbitHorizontal ){

            var dHorzAngle = this.useSnap ? getNextRotation(HORIZONTAL, snapAngleh, lastDelta.x):
            lastDelta.x *this.orbitMultiplier;

            var quatH = new THREE.Quaternion().setFromAxisAngle( vUp.clone().normalize(), dHorzAngle );
            vDir = quatH.clone().rotate(vDir);
            vDirView = quatH.clone().rotate(vDirView);
            }

            if ( !this.constrainOrbitVertical ){
            var dVertAngle = this.useSnap ? getNextRotation(VERTICAL, snapAnglev, lastDelta.y) :
            lastDelta.y *this.orbitMultiplier;

            var quatV = new THREE.Quaternion().setFromAxisAngle( vRight.clone().normalize(), dVertAngle );
            vDir = quatV.clone().rotate(vDir);
            vDirView = quatV.clone().rotate(vDirView);
            vUp = quatV.clone().rotate(vUp);
            }

            camera.eye = this.pivot.clone().sub((vDir.clone().normalize()).clone().multiplyScalar(dist));
            this.center.copy(camera.eye.clone().add((vDirView.clone().normalize()).clone().multiplyScalar(distView)));
            camera.up.copy(vUp.clone().normalize());

            prevCenter = this.center;
            prevEye = camera.position;
            prevPivot = this.pivot;
            prevUp = camera.up;*/
        }
        camera.lookAt(this.center);
        changed(false);

        /*console.log("Camera Position: ( "+camera.position.x +", "+camera.position.y+", "+camera.position.z+" )");
        console.log("Up Vector: ( "+camera.up.x +", "+camera.up.y+", "+camera.up.z+" )");
        console.log("Center: ( "+this.center.x +", "+this.center.y+", "+this.center.z+" )");
        */
    };

    this.endInteraction = function() {
    };

    this.look = function( distance ){
        if( this.navApi.getIsLocked() ) 
            return;

        var delta = convertCoordsToWindow(distance.x, distance.y);
        var multiplier = this.userLookSpeed;

        //if ( m_manager->GetApplicationParameters().lookInvertVerticalAxis ) { deltaY = -deltaY; }

        var eyeToCenter = this.getView();

        var camUp = camera.up;
        var camRight = eyeToCenter.clone().cross(camUp).normalize();
        var worldUp = this.sceneUpDirection.clone();

        // TODO: scale look by camera's FOV
        // vertical rotation around the camera right vector
        var angle = delta.clone();
        angle.x *= Math.PI;
        angle.y *= Math.PI / camera.aspect;
        angle.multiplyScalar(multiplier);
        var qRotY = new THREE.Quaternion().setFromAxisAngle( camRight, -angle.y);

        if (camera.keepSceneUpright && !this.navApi.getOrbitPastWorldPoles()) {
            var futureUp = camUp.clone();
            futureUp.applyQuaternion(qRotY).normalize();

            if (futureUp.dot(worldUp) < 0) {
                var futureEyeToCenter = eyeToCenter.clone();
                futureEyeToCenter.applyQuaternion(qRotY);

                var deltaAngle = futureEyeToCenter.angleTo(worldUp);

                if(Math.abs(deltaAngle) > (Math.PI * 0.5))
                    deltaAngle -= (deltaAngle > 0.0) ? Math.PI : -Math.PI;

                angle.y -= deltaAngle;

                qRotY.setFromAxisAngle(camRight, -angle.y);
            }
        }

        eyeToCenter = qRotY.clone().rotate(eyeToCenter);
        camUp = qRotY.clone().rotate(camUp);
        camUp.normalize();

        var vertAxis = camera.keepSceneUpright ? worldUp : camUp;
        var qRotX = new THREE.Quaternion().setFromAxisAngle( vertAxis, -angle.x );

        eyeToCenter = qRotX.clone().rotate( eyeToCenter );
        camUp = qRotX.clone().rotate( camUp );

        this.center.copy(eyeToCenter.add(camera.position));
        camera.up.copy(camUp);

        camera.lookAt(this.center);
        changed(false);
    }

    this.pan = function ( distance ) {
        if( this.navApi.getIsLocked() ) 
            return;

        distance = convertCoordsToWindow(distance.x, distance.y);

        var W = this.getView();
        var U = camera.up.clone().cross(W);
        var V = W.clone().cross(U);

        U.normalize();
        V.normalize();
        W.normalize();

        var Pscreen = this.pivot.clone().sub(camera.position);
        var screenW = W.clone().dot(Pscreen);
        var screenU = screenW * (Math.tan( THREE.Math.degToRad(camera.leftFov)) + Math.tan(THREE.Math.degToRad(camera.rightFov)));
        var screenV = screenW * (Math.tan( THREE.Math.degToRad(camera.topFov)) + Math.tan(THREE.Math.degToRad(camera.bottomFov)));

        var offsetU = distance.x * Math.abs(screenU);
        var offsetV = distance.y * Math.abs(screenV);

        var offset = new THREE.Vector3();
        var u = U.clone().multiplyScalar(offsetU);
        var v = V.clone().multiplyScalar(offsetV);

        offset = (u.clone().add(v)).clone().multiplyScalar(this.userPanSpeed);

        camera.position.add(offset);
        this.center.add(offset);

        camera.lookAt(this.center);
        changed(false);
    };

    this.zoom = function(zoomDelta){
        if( this.navApi.getIsLocked() ) 
            return;

        //TODO: bug - when pivot is set outside the object, object zooms past the pivot point
        var zoomMin = 0.05;
        var zoomBase = this.userZoomSpeed;
        var distMax = Number.MAX_VALUE;
        var deltaXY = zoomDelta.x + zoomDelta.y;
        var dist = Math.pow ( zoomBase, deltaXY);

        var zoomPosition = (this.pivot.clone().sub((this.pivot.clone().sub(this.saveEye).clone()).multiplyScalar(dist)));
        var zoomCenter = zoomPosition.clone().add(cam.D.clone().multiplyScalar(cam.D.clone().dot((this.pivot.clone().sub(zoomPosition)).clone())));

        if (dist >= distMax)
            return;

        if (deltaXY > 0.0){
            var snapSize = 0;
            var dist2 = Math.pow(zoomBase, deltaXY - snapSize);

            // PERSP zoom out
            if ( deltaXY < snapSize ){
                // inside the zoomout speedbump region
                unitAmount = 0.0;
                return;

            } else {
                camera.position.copy(zoomPosition);
                this.center.copy(zoomCenter);

                var EprojD = (zoomPosition.clone().sub(this.saveEye)).dot(cam.D);

                if ( EprojD > distMax ) {
                    camera.position.copy((this.saveEye.sub(cam.D)).clone().multiplyScalar(distMax));
                    unitAmount = (distMax > 0.0) ? -1.0 : 0.0;
                } else {
                    unitAmount = -(EprojD / distMax);
                }
            }
        } else {


            camera.position.copy(zoomPosition);
            this.center.copy(zoomCenter);

            //Zoom In
            /*if ( dist < zoomMin) {
                //exponential zoom moved in as far as it can
                var zoomMinLinear = ( Math.log(zoomMin) / Math.log(zoomBase) );
                var distLinearXY = Math.abs(deltaXY) - Math.abs(zoomMinLinear);
                var snapSize = 0;

                // do linear zoomin
                if ( distLinearXY > snapSize ) {

                    var distLinearXY = distLinearXY - snapSize/window.innerHeight;
                    var amount = -distLinearXY;

                    var multiplier = this.userZoomSpeed;
                    var dist2 = amount * multiplier;

                    var Esnap = this.pivot.clone().sub((this.pivot.clone().sub(this.saveEye)).clone().multiplyScalar(zoomMin));
                    var E = Esnap.clone().sub((this.pivot.clone().sub(this.saveEye)).clone().multiplyScalar(dist2));

                    this.center.copy(E.clone().add(cam.D.clone().multiplyScalar(zoomMin)));
                    camera.position.copy(E);
                }
            } else {
                cam.D = (this.saveCenter.clone().sub(this.saveEye)).clone().normalize();
                camera.position.copy(zoomPosition);
                this.center.copy(zoomCenter);
            }*/
        }
        camera.lookAt(this.center);
        changed(false);
    }

    this.walk = function(currentCursor, startCursor, movementX, movementY, deltaTime){
        if( this.navApi.getIsLocked() ) 
            return;

        var worldUp = this.sceneUpDirection.clone();
        var worldFront = this.sceneFrontDirection.clone();
        var worldRight = this.sceneFrontDirection.clone().cross( this.sceneUpDirection);
        //TODO: figure out what deltaTime does

        var flyPlanarMotion = true;
        var flyUpDownSensitivity = 0.01;

        if (isInDeadZone(currentCursor, startCursor)){
            wheel.cursorImage('SWWalk');
            setBias(true, currentCursor, startCursor);
            x = startCursor.x;
            y = startCursor.y;
        }else{
            setBias(false, currentCursor, startCursor);
        }

        //x = currentCursor.x - m_resetBiasX;
        //y = currentCursor.y - m_resetBiasY;
        x = currentCursor.x;
        y = currentCursor.y;

        var delta = convertCoordsToWindow( x - startCursor.x, y - startCursor.y );

        var fInitialMoveX = -delta.x;
        var fInitialMoveY = -delta.y;
        var fSignX = (fInitialMoveX < 0.0) ? -1.0 : 1.0;
        var fSignY = (fInitialMoveY < 0.0) ? -1.0 : 1.0;
        var fMoveX = Math.abs(fInitialMoveX);
        var fMoveY = Math.abs(fInitialMoveY);

        var deadzoneRadius = new THREE.Vector2(30, 30);
        deadzoneRadius = convertCoordsToWindow (deadzoneRadius.x, deadzoneRadius.y);

        fMoveX = ( isInDeadZone(currentCursor, startCursor)) ? 0.0 : Math.abs(fInitialMoveX) - deadzoneRadius.x;
        fMoveY = ( isInDeadZone(currentCursor, startCursor)) ? 0.0 : Math.abs(fInitialMoveY) - deadzoneRadius.y;

        var rampRadius = 0.25;
        fMoveX /= rampRadius;
        fMoveY /= rampRadius;

        fMoveX = ( fMoveX < 1.0 ) ? Math.easeClamp( fMoveX, 0.0, 1.0 ) : Math.pow(fMoveX, 1.0);
        fMoveY = ( fMoveY < 1.0 ) ? Math.easeClamp( fMoveY, 0.0, 1.0 ) : Math.pow(fMoveY, 1.0);


        // scale by time
        //fMoveX *= deltaTime;
        //fMoveY *= deltaTime;

        var fDeltaX = (fMoveX > 0.0) ? fMoveX * fSignX : 0.0;
        var fDeltaY = (fMoveY > 0.0) ? fMoveY * fSignY : 0.0;

        var vViewDir = this.getView();
        var fViewDist = vViewDir.length();
        vViewDir.normalize();

        var vRightDir = vViewDir.clone().cross( camera.up );
        vRightDir.normalize();

        // project vViewDir onto plane perpendicular to up direction to get
        // better walking inside houses, etc
        // (but prevents flying down to model from 3/4 view...)

        var vYViewDirRight = worldRight.clone().multiplyScalar(worldRight.clone().dot(vViewDir));
        var vYviewDirFront = worldFront.clone().multiplyScalar(worldFront.clone().dot(vViewDir));
        var vYViewDir = vYviewDirFront.clone().add(vYViewDirRight);

        vYViewDir = (vYViewDir.clone().length() > Number.MIN_VALUE) ? vYViewDir.normalize() : camera.up;

        var scale = 1.0;
        var fDollyDist = fDeltaY * (this.walkMultiplier * scale );

        var dir = flyPlanarMotion ? vYViewDir : vViewDir;


        // Free-flying or constrained walk?
        if (flyPlanarMotion) {
            // Constrained Walk
            // To avoid perceptually confusing motion, force a reversal of flying direction along a shifted axis

           // Angle to offset threshold from up-axis
           // TODO: make cos(0.65) into an AutoCam Parameter
           var dDirThreshold = Math.cos(0.65);

           if ((dDirThreshold != 1) &&
               (((worldUp.clone().dot(camera.up) < -Number.MIN_VALUE) && (worldUp.clone().dot(vViewDir) < -dDirThreshold)) ||
                   ((worldUp.clone().dot(camera.up) > Number.MIN_VALUE) && (worldUp.clone().dot(vViewDir) > dDirThreshold)))) {
               dir = -dir;
           }
        }


        var fSpinAngle = -fDeltaX *this.walkMultiplier*0.05;

        // rotate around world-up vector instead of CameraOperations up vector (more like head movement!)
        //Quaternion quat( m_cameraParams.up, (float)fSpinAngle );

        // Define rotation axis direction
        var vRotAxis = camera.up;

        // Free-flying or constrained walk?
        if (flyPlanarMotion) {
            // Constrained Walk
            // Need to check if:
            //  1. camera is "upside-down" (angle between world up and camera up is obtuse) or
            //  2. camera is in top view (camera up perpendicular to world up and view angle acute to world up)
            // These cases require a reversed rotation direction to maintain consistent mapping of tool:
            //  left->clockwise, right->counter-clockwise
            if ((worldUp.clone().dot(camera.up) < -Number.MIN_VALUE) ||
                ((Math.abs(worldUp.clone().dot(camera.up)) < Number.MIN_VALUE)
                    && (worldUp.clone().dot(vViewDir) > Number.MIN_VALUE))) {
                fSpinAngle = -fSpinAngle;
            }
            vRotAxis = worldUp;
        }

        // Define rotation transformation

        var quat = new THREE.Quaternion().setFromAxisAngle( vRotAxis, fSpinAngle );
        quat.normalize();

        vViewDir = quat.clone().rotate( vViewDir );
        vViewDir.normalize();
        camera.up.copy(quat.clone().rotate( camera.up ));
        camera.up.normalize();

        camera.position.add(dir.clone().multiplyScalar(fDollyDist));
        this.center.copy(camera.position.clone().add(vViewDir.clone().multiplyScalar(fViewDist)));

        dir = flyPlanarMotion ? worldUp : camera.up;
        dir.normalize();

        if(fDollyDist == 0)
            fDollyDist = flyUpDownSensitivity;

        camera.lookAt(this.center);
        changed(false);
    }

    this.updown = function(movementY){
        if( this.navApi.getIsLocked() ) 
            return;

        var deltaCursor = movementY;
        var deltaAmount = getMoveAmountFromCursorOffset(deltaCursor);

        cam.m_amount += deltaAmount;

        var upDir = new THREE.Vector3(0,1,0);

        var eye = cam.saveEye.clone().sub(upDir.clone().multiplyScalar(cam.m_amount));
        var eyeHeight = eye.clone().dot(upDir);

        camera.position.copy(eye);

        if ( eyeHeight < cam.minSceneBound ) {
            camera.position.add(upDir.clone().multiplyScalar(cam.minSceneBound - eyeHeight));
        }

        if ( eyeHeight > cam.maxSceneBound ) {
            camera.position.add(upDir.clone().multiplyScalar(cam.maxSceneBound - eyeHeight));
        }

        this.center.copy(camera.position.clone().add(cam.saveCenter.clone().sub(cam.saveEye)));
        camera.lookAt(this.center);
        changed(false);
    }


    /*      REWIND FUNCTIONS */

    /**
     * This takes a snapshot of the current camera passed into Autocam and saves it to the history. A screenshot
     * is taken of the sceneContainer canvas
     */
    this.addHistoryElement = function(){

        // --- We don't require history being saved ---

        // if (cam.rewindParams.maxHistorySize > 0 && cam.rewindParams.history.length >= cam.rewindParams.maxHistorySize){
        //     this.rewindParams.history.shift();
        // }

        // //reset previous 1 or 2 weights to 0
        // if (cam.rewindParams.history.length == 1){
        //     cam.rewindParams.history[0].weight = 0.0;
        // }else if (cam.rewindParams.history.length > 1){
        //     cam.rewindParams.history[cam.rewindParams.history.length -1].weight = 0.0;
        //     cam.rewindParams.history[cam.rewindParams.history.length -2].weight = 0.0;
        // }

        // var element = {};
        // element.thumbnail = document.getElementById("sceneContainer").toDataURL("image/png");
        // element.thumbnailBounds = new THREE.Box2(new THREE.Vector2(0,0),new THREE.Vector2(56,56));
        // element.camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
        // element.camera.position = camera.position.clone();
        // element.camera.up = camera.up.clone();
        // element.camera.rotation = camera.rotation.clone();
        // element.camera.leftFov = camera.leftFov;
        // element.camera.rightFov = camera.rightFov;
        // element.camera.topFov = camera.topFov;
        // element.camera.bottomFov = camera.bottomFov;
        // element.camera.center = cam.center.clone();
        // element.camera.pivot = cam.pivot.clone();
        // element.weight = 1.0;
        // element.isEmptyScene = false;

        // //IF SCENE OUTSIDE VIEW SET ISEMPTYSCENE TO TRUE

        // cam.rewindParams.history.push(element);
        // cam.rewindParams.snapped = true;
        // cam.rewindParams.slideOffset.x=0;
        // cam.rewindParams.timelineIndex = cam.rewindParams.history.length - 1;
        // cam.rewindParams.timelineIndexSlide = cam.rewindParams.timelineIndex;
    }

    /**
     * This handles any case where the user rewinds and then does any transformations, the history is sliced depending
     * on where the user rewinds to
     */
    this.addIntermediateHistoryElement = function(){

        if (this.rewindParams.snapped){
            this.rewindParams.history = this.rewindParams.history.slice(0,this.rewindParams.timelineIndex);
        }else{
            if (this.rewindParams.slideOffset.x > 0){
                this.rewindParams.history = this.rewindParams.history.slice(0,this.rewindParams.timelineIndex);
            } else{
                this.rewindParams.history = this.rewindParams.history.slice(0,this.rewindParams.timelineIndex+1);
            }
        }
        this.addHistoryElement();
    }

    this.clearHistory = function(){
        this.rewindParams.history.length = 0;
        this.rewindParams.timelineIndex = 0;
        this.rewindParams.timelineIndexSlide = 0;
        this.rewindParams.resetWeights = true;
    }

    this.openTimeline = function (location){
        this.rewindParams.timelineIndexSlide = this.rewindParams.timelineIndex;

        if (this.rewindParams.resetWeights){
            this.rewindParams.slideOffset.x = 0;
            this.rewindParams.snapped = this.rewindParams.snappingEnabled;
        }

        //if haven't applied any transformations before clicking rewind
        if (this.rewindParams.history.length == 0) this.addHistoryElement();

        for ( var i = 0; i < this.rewindParams.history.length; i++ )
        {
            var index = i - this.rewindParams.timelineIndex;
            var size = this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize;

            this.rewindParams.history[i].thumbnailBounds.setCenter(new THREE.Vector2(location.x + index * size, location.y).add(this.rewindParams.slideOffset));

            if (this.rewindParams.resetWeights)
            {
                this.rewindParams.history[i].weight = (i==this.rewindParams.timelineIndex)? 1.0:0.0;
            }
        }

        if ( this.rewindParams.resetWeights )
        {
            this.rewindParams.resetWeights = false;
        }

        var size = (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) *2.0;
        this.rewindParams.open = true;
        this.rewindParams.openLocation = location.clone();
        this.rewindParams.openLocationOrigin = location.clone();
        this.rewindParams.openBracket = location.clone();
        this.rewindParams.openBracketA = new THREE.Vector2(size, location.y);
        this.rewindParams.openBracketB = new THREE.Vector2(window.innerWidth - size, location.y);
        // make sure dead-zone is well formed ... i.e. A.x < B.x
        if (this.rewindParams.openBracketA.x > this.rewindParams.openBracketB.x) {
            var swap = this.rewindParams.openBracketA.x;
            this.rewindParams.openBracketA.x = this.rewindParams.openBracketB.x;
            this.rewindParams.openBracketB.x = swap;
        }
        this.rewindParams.locationOffset = new THREE.Vector2(0,0);
        this.rewindParams.snapOffset = new THREE.Vector2(0,0);
    }

    this.slideTimeline = function(location_){
        /*
         Basic Idea:
         Behaviour of the current rewind timeline is similar to a tracking menu. There is a "deadzone"
         region where cursor movement does not slide the thumbnails. As the cursor goes outside the
         region, thumbnails slide to align the closest edge of the timeline to the cursor ('extent'
         variable is this sliding amount). The edges of the deadzone region are stored in
         'm_openBracketA/B' variables, and slide around with the timeline. Draw some icons at bracket
         positions to visualize the process.
         */

        if ( !this.rewindParams.open || this.rewindParams.history.length == 0  ) { return; }

        var location =  location_.clone().add(this.rewindParams.locationOffset);

        var size = (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2.0;
        var bracketA = size;
        var bracketB = window.innerWidth - size;

        var edgeA = this.rewindParams.history[0].thumbnailBounds.center().x;
        var edgeB = this.rewindParams.history[this.rewindParams.history.length - 1].thumbnailBounds.center().x;

        var extent = 0.0;

        if ( location.x < this.rewindParams.openBracketA.x )
        {
            extent = location.x - this.rewindParams.openBracketA.x;

            // don't slide thumbnails past the edge of the timeline
            var edgeAnew = edgeA - extent;

            if ( bracketA < edgeAnew )
            {
                // only want to limit the influence of extent, not overshoot the other way
                extent = Math.min( extent + (edgeAnew - bracketA), 0.0);
            }
        }
        if ( location.x > this.rewindParams.openBracketB.x )
        {
            extent = location.x - this.rewindParams.openBracketB.x;

            // don't slide thumbnails past the edge of the timeline
            var edgeBnew = edgeB - extent;

            if ( bracketB > edgeBnew )
            {
                // only want to limit the influence of extent, not overshoot the other way
                extent = Math.max( extent + (edgeBnew - bracketB), 0.0);
            }
        }

        this.rewindParams.openLocation.x += extent;
        this.rewindParams.openBracketA.x += extent;
        this.rewindParams.openBracketB.x += extent;

        this.rewindParams.openBracket.x = location.x - ( this.rewindParams.openLocation.x - this.rewindParams.openLocationOrigin.x );

        var iconOffset = new THREE.Vector2( -extent, 0.0 );

        var L = location.clone().sub( this.rewindParams.openLocation.clone().sub(this.rewindParams.openLocationOrigin));

        // snapping

        iconOffset.x += this.rewindParams.snapOffset.x;
        this.rewindParams.snapOffset.x = 0.0;

        var snapped = false;

        if ( this.rewindParams.snappingEnabled )
        {
            var kEnterSnapDistance = 4.0;
            var kLeaveSnapDistance = 16.0;

            for ( var i = 0; i < this.rewindParams.history.length; i++ )
            {
                var P = this.rewindParams.history[i].thumbnailBounds.center().add(iconOffset);
                if ( Math.abs(P.x - L.x) < kEnterSnapDistance || (this.rewindParams.snapped && Math.abs(P.x - L.x) < kLeaveSnapDistance) )
                {
                    snapped = true;
                    if (extent != 0.0)
                    {
                        this.rewindParams.snapOffset.x = P.x - L.x;
                        iconOffset.x -= this.rewindParams.snapOffset.x;
                    }
                    else
                    {
                        this.rewindParams.openBracket.x += P.x - L.x;
                    }
                    L.x = P.x;
                    break;
                }
            }
        }

        this.rewindParams.snapped = snapped;

        var weightMax = -1.0;
        var weightTotal = 0.0;
        for ( var j = 0; j < this.rewindParams.history.length; j++ )
        {
            var tempBox = this.rewindParams.history[j].thumbnailBounds.clone();

            // slide the thumbnails
            this.rewindParams.history[j].thumbnailBounds.setCenter(this.rewindParams.history[j].thumbnailBounds.center().add(iconOffset));

            if (this.rewindParams.history[j].thumbnail )
            {
                var leftEdge = this.rewindParams.history[j].thumbnailBounds.center().x - this.rewindParams.thumbnailSize/2.0;
                $('#rewindFrame' + j).css('left', leftEdge);
                $('#rewindBorder' + j).css('left', (leftEdge-4));
            }

            // grow the copied Icon2D to touch the center of its neighbor
            //think about adding offset for frames here
            var newSize = new THREE.Vector2((this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2.0, (this.rewindParams.thumbnailGapSize + this.rewindParams.thumbnailSize) * 2.0 );
            tempBox.setFromCenterAndSize(tempBox.center(),newSize);

            var Icon2DCoords = new THREE.Vector2(0,0);
            tempBox.getIcon2DCoords(L,Icon2DCoords);

            var weight = 1.0 - Math.abs( Math.equalityClamp(Icon2DCoords.x, -1.0, 1.0 ));
            this.rewindParams.history[j].weight = weight;

            // check for out-of-range cases
            if ( j == 0 && L.x < tempBox.center().x)
            { this.rewindParams.history[j].weight = 1.0; }

            if ( j == this.rewindParams.history.length - 1 && L.x > tempBox.center().x)
            { this.rewindParams.history[j].weight = 1.0; }

            weightTotal = weightTotal + this.rewindParams.history[j].weight;

            // find dominant thumbnail
            if ( this.rewindParams.history[j].weight > weightMax )
            {
                weightMax = this.rewindParams.history[j].weight;
                if ( this.rewindParams.snappingEnabled && this.rewindParams.history[j].weight == 1.0 ){
                    // snap to this element
                    this.rewindParams.slideOffset.x = 0;
                    this.rewindParams.snapped = true;
                }else{
                    this.rewindParams.slideOffset.x = this.rewindParams.history[j].thumbnailBounds.center().x - L.x;
                }
                this.rewindParams.timelineIndexSlide = j;
            }
        }

        // normalize the weights just in case
        for ( var k = 0; k < this.rewindParams.history.length; k++ )
        {
            this.rewindParams.history[k].weight = this.rewindParams.history[k].weight / weightTotal;
        }

        // prevent the bracket from moving off the ends of the timeline
        var xBracketMin = this.rewindParams.history[0].thumbnailBounds.center().x;
        var xBracketMax = this.rewindParams.history[this.rewindParams.history.length - 1].thumbnailBounds.center().x;
        if ( this.rewindParams.openBracket.x < xBracketMin )
        {
            this.rewindParams.locationOffset.x += xBracketMin - this.rewindParams.openBracket.x;
            this.rewindParams.openBracket.x = xBracketMin;
        }
        else if ( this.rewindParams.openBracket.x > xBracketMax )
        {
            this.rewindParams.locationOffset.x += xBracketMax - this.rewindParams.openBracket.x;
            this.rewindParams.openBracket.x = xBracketMax;
        }
    }

    this.shiftBackOneElement = function(){
        if ( this.rewindParams.history.length != 0 && (this.rewindParams.timelineIndex > 0 || this.rewindParams.slideOffset.x !=0)){
            if (this.rewindParams.snapped || this.rewindParams.slideOffset.x > 0){
                this.rewindParams.timelineIndex--;
            }
            this.rewindParams.timelineIndexSlide = this.rewindParams.timelineIndex;
            this.rewindParams.resetWeights = true;
            cam.elapsedTime = 0;
            this.animateToRewindIndex();
        }
    }

    this.animateToRewindIndex = function ()    {
        var currentTimelineIndex = this.rewindParams.timelineIndex;
        var unitTime = 0.0;
        if ( cam.elapsedTime >= shotParams.duration ){
            unitTime = 1.0;
        } else {
            var tMax = shotParams.destinationPercent;
            unitTime =  Math.easeClamp( cam.elapsedTime / shotParams.duration, 0.0, tMax );
            cam.elapsedTime += deltaTime/500;
        }

        cam.center.copy((cam.center.clone().multiplyScalar( 1.0 - unitTime)).clone().add( this.rewindParams.history[currentTimelineIndex].camera.center.clone().multiplyScalar( unitTime )));
        camera.position.copy((camera.position.clone().multiplyScalar( 1.0 - unitTime)).clone().add(this.rewindParams.history[currentTimelineIndex].camera.position.clone().multiplyScalar( unitTime )));
        camera.up.copy(this.rewindParams.history[currentTimelineIndex].camera.up);
        cam.pivot.copy(cam.center);

        camera.lookAt(cam.center);
        changed(false);

        if( cube )
            requestAnimationFrame(cube.render);

        if( unitTime !== 1.0 )
            requestAnimationFrame(function() { cam.animateToRewindIndex();});
    }

    this.closeTimeline = function(){
        if (this.rewindParams.timelineIndex != this.rewindParams.timelineIndexSlide){
            this.rewindParams.timelineIndex = this.rewindParams.timelineIndexSlide;
        }
        this.rewindParams.open = false;
    }

    this.getInterpolatedCamera = function (){
        var interpolatedCam = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 10000 );
        interpolatedCam.center = new THREE.Vector3(0,0,0);
        interpolatedCam.pivot = new THREE.Vector3(0,0,0);
        interpolatedCam.leftFov = 0;
        interpolatedCam.rightFov = 0;
        interpolatedCam.topFov = 0;
        interpolatedCam.bottomFov = 0;
        interpolatedCam.up.set(0,0,0);

        for (var i = 0; i < this.rewindParams.history.length; i++){
            var frameCam = this.rewindParams.history[i].camera;
            var wi = this.rewindParams.history[i].weight;

            interpolatedCam.center.add(frameCam.center.clone().multiplyScalar(wi));
            interpolatedCam.position.add(frameCam.position.clone().multiplyScalar(wi));
            interpolatedCam.up.add(frameCam.up.clone().multiplyScalar(wi));
            interpolatedCam.rotation.add(frameCam.rotation.clone().multiplyScalar(wi));
            interpolatedCam.pivot.add(frameCam.pivot.clone().multiplyScalar(wi));
            interpolatedCam.leftFov+=(frameCam.leftFov*wi);
            interpolatedCam.rightFov +=(frameCam.rightFov*wi);
            interpolatedCam.topFov+=(frameCam.topFov*wi);
            interpolatedCam.bottomFov+=(frameCam.bottomFov*wi);
        }

        camera.position.copy(interpolatedCam.position);
        camera.up.copy(interpolatedCam.up);
        camera.rotation = interpolatedCam.rotation;
        camera.leftFov = interpolatedCam.leftFov;
        camera.rightFov = interpolatedCam.rightFov;
        camera.topFov = interpolatedCam.topFov;
        camera.bottomFov = interpolatedCam.bottomFov;
        cam.center.copy(interpolatedCam.center);
        cam.pivot.copy(interpolatedCam.pivot);
        camera.lookAt(cam.center);
        camera.up.normalize();
        changed(false);
    }

};
;/* All coordinates in three.js are right handed
 * when looking at the Front of the Cube in the regular upright position: */
/**
 * This is the view cube class subset of Autocam
 * this class renders and provides all functionality for the view cube
 * @class
 * @param {string} tagId - html tag id where you want the view cube to render - OBSOLETE
 * @param {Object} autocam - the autocam controller object
 * @param {HTMLDivElement} cubeContainer - the HTML element to contain the view cube
 * @param {string} localizeResourcePath - path to localized texture images
 * */
Autocam.ViewCube = function (tagId, autocam, cubeContainer, localizeResourcePath ) {

    var self = this;
    var cam = autocam;
    var camera = autocam.camera;
    autocam.setCube(this);

    // $("body").prepend("<div id='"+tagId+"' style='position: absolute; z-index: 1000; border: 2px solid red;'></div>");

    // var path = 'src/tools/AutocamViewCube/ViewcubePrototype/Resources/Textures/';
    var path = RESOURCE_ROOT + "textures/";
    var localizedPath = localizeResourcePath ? localizeResourcePath : path;

    self.currentFace = "front";

    var edgeNames = ["top,front","top right", "top,left", "top,back", "bottom,front", "bottom,right", "bottom,left", "bottom,back", "left,front", "front,right", "right,back", "back,left"];
    var cornerNames = ["front,top,right","back,top,right","front,top,left","back,top,left","front,bottom,right","back,bottom,right","front,bottom,left","back,bottom,left"];

   /**
     *  A string array which contains the options for the view cube menu. Use null to indicate a section separator
     * @type {Array}
     */
    var menuOptionList = [
        "Go Home",
        null,
        "Orthographic",
        "Perspective",
        "Perspective with Ortho Faces",
        null,
        "Set current view as Home",
        "Focus and set as Home",
        "Reset Home",
        null,
        "Set current view as Front",
        "Set current view as Top",
        "Reset orientation"
        /*
        null,
        "Properties...",
        null,
        "Help..."
        */
    ];
    var menuEnableList = [
        true,
        null,
        true,
        true,
        true,
        null,
        true,
        true,
        true,
        null,
        true,
        true,
        true
        /*
        null,
        "Properties...",
        null,
        "Help..."
        */
    ];
    var menuStateCallbackList = [
        null,
        null,
        function() { return !cam.orthographicFaces && !camera.isPerspective; },
        function() { return !cam.orthographicFaces &&  camera.isPerspective; },
        function() { return cam.orthographicFaces; },
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
        /*
        null,
        "Properties...",
        null,
        "Help..."
        */
    ];

    // THREE.js Scenes
    var shadowScene, cubeScene, gridScene, lineScene, controlScene;

    // Either Canvas or WebGL renderer
    var renderer;
    var controlCamera;
    // self.camera = new THREE.PerspectiveCamera( camera.fov, window.innerWidth / window.innerHeight, 1, 10000 );
    self.camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
    self.camera.position.copy(camera.position);
    self.center = new THREE.Vector3(0,0,0);
    self.camera.lookAt(self.center);
    // var length = camera.position.length();

    // THREE.js Meshes
    var cube, line, home, shadow, context;
    var gridMeshes = [];
    var arrowGroup;

    // Sizes for Three.js renderers
    var windowHalfX;
    var windowHalfY;

    // Buffers and past INTERSECTS used for mouse picking
    var arrowBuffer = [];
    var intersectsFace = [];
    var controlBuffer = [];
    var cubeBuffer = [];
    var INTERSECTED = null;
    var INTERSECTED_F = null;
    var INTERSECTED_C = null;
    var rollLeftOffset, rollRightOffset, rollOffset;
    var homeOffset, menuOffset;

    // Size of cube in relation to HTML tag
    var cubeSize = 0;

    // Position of HTML element
    var position;

    // Used to wait for textures to load before rendering the View Cube
    var loadedTextureCount = 0;

    // Flags
    var _orthogonalView = true;
    var _havePointerLockFeature = false;
    var _havePointerLock = false;
    var _pointerLockMoveBugSPK865 = false;
	var _isChrome = (navigator.userAgent.search("Chrome") != -1);
	var _isWindows = (navigator.platform.search("Win32") != -1);
    var _dragged = false;
    var _transparent = false;

    // store all loaded textures here so we are not constantly re-downloading them
    var changingTextures = [];

    // Height and Width of the renderer
    // may be referred to as self.width and self.height
    this.width = 0;
    this.height = 0;

    // Public changeable values
    /**
     * view cube animation speed (not 0 or negative),
     * specified in time (milliseconds) to complete an animation
     * @type {Number}
     */
    this.animSpeed = 500;
    /**
     * turn on and off animation
     * @type {Boolean}
     */
    this.animate = true;
    /**
     * turn on and off ability to drag the view cube
     * @type {Boolean}
     */

    this.compass = false;
    this.viewScaleFactorCompass = 1.5;
    this.viewScale = 1; // Set in Init based on cubeSize

    this.draggable = true;

    /**
     * turn on and off the availability of the home button
     * @type {Boolean}
     */
    this.wantHomeButton = false;

    /**
     * turn on and off the availability of the roll arrows
     * @type {Boolean}
     */
    this.wantRollArrows = true;

    /**
     * turn on and off the availability of the menu icon
     * @type {Boolean}
     */
    this.wantContextMenu = true;

    /**
     * opacity when inactive (transparency must be enabled)
     * @type {Number}
     */
    this.inactiveOpacity = 0.5;

    /** Function to get position of html element on screen
     *
     * @param element - HTML DOM element to find position of
     * @return {Object} - object which specifies x and y screen coordinates of location of input element
     */
    var getPosition = function (element) {
        var rect = element.getBoundingClientRect();
        return { x: rect.left, y: rect.top, w: rect.width, h: rect.height };

        /*
        var xPosition = window.pageXOffset;
        var yPosition = window.pageYOffset;

        while (element) {
            xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
            yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
            element = element.offsetParent;
        }
        return { x:xPosition, y:yPosition };
        */
    };

    /** Used by pointer lock API
     *
     * @param {Object} e - event object
     */
    var pointerLockChange = function(e) {
        e.preventDefault();
        e.stopPropagation();

        _havePointerLock = (document.pointerLockElement === cubeContainer ||
                            document.mozPointerLockElement === cubeContainer ||
                            document.webkitPointerLockElement === cubeContainer);
        // stderr("POINTER LOCK: " + _havePointerLock);
    };


    /** Create ViewCube and set up renderer and camera
     * sets up all Three.js meshes for the View Cube
     * and initializes all event handlers such as mousemove
     * and mousedown and mouseup and pointerlock
     */
    var Init = function () {

        // parentTag = document.getElementById(tagId);

        // var element = $('#'+tagId); // ?? Is this different than the above?
        // element.width(300);
        // element.height(300);

        var bounds = cubeContainer.getBoundingClientRect();
        self.width  = bounds.width;
        self.height = bounds.height;

        position = getPosition(cubeContainer);

        windowHalfX = self.width / 2;
        windowHalfY = self.height / 2;

        //camera for home and arrow
        controlCamera = new THREE.PerspectiveCamera(70, self.height / self.width, 1, 10000);
        controlCamera.position.set(0, 0, 500);

        shadowScene = new THREE.Scene();
        cubeScene = new THREE.Scene();
        gridScene = new THREE.Scene();
        lineScene = new THREE.Scene();
        controlScene = new THREE.Scene();
        _orthogonalView = true;

        // This size means that the cube is (cubeSize)x(cubeSize)x(cubeSize) big
        cubeSize = 200;
        self.viewScale = cubeSize * 3.5;

        /******************************************Create the View Cube***********************************************/
        var filteringType = THREE.LinearFilter;

        // Load in the faceMap textures for 6 faces

        var texture = new THREE.DDSLoader().load(localizedPath+'VCcrossRGBA8small.dds');
        texture.minFilter = texture.maxFilter = filteringType;

        var shader = THREE.ShaderLib[ "cube" ];

        var material = new THREE.ShaderMaterial( {
            fragmentShader: shader.fragmentShader,
            vertexShader: shader.vertexShader,
            uniforms: THREE.UniformsUtils.clone(shader.uniforms),
            depthWrite: false
        } );

        material.uniforms[ "tCube" ].value = texture;

        var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize, 2, 2, 2);
        var cubeLine = new THREE.BoxGeometry(cubeSize+1 , cubeSize+1 , cubeSize+1, 2, 2, 2);

        // Create a cube object mesh with specified geometry and faceMap materials
        cube = new THREE.Mesh(cubeGeometry, material);
        cube.position.set(0.0, 0, 0);
        cubeScene.add(cube);

        // Set up a line segment for the cube border
        var borderTexture = loadTexture(path+'VCedge1.png');

        borderTexture.minFilter = borderTexture.maxFilter = filteringType;

        line = new THREE.Mesh(cubeLine, new THREE.MeshBasicMaterial({ map: borderTexture, overdraw: false, transparent: true, shading: THREE.SmoothShading }));
        line.position.set(0.0, 0, 0);
        lineScene.add(line);

        /********************************************Set up the controls**********************************************/

        // Orthogonal Arrows

        var arrowDist = cubeSize;

        var arrowGeo = new THREE.Geometry();

        var v1 = new THREE.Vector3(-30, 0, 0);
        var v2 = new THREE.Vector3(30, 0, 0);
        var v3 = new THREE.Vector3(0, -30, 0);

        arrowGeo.vertices.push(v1);
        arrowGeo.vertices.push(v2);
        arrowGeo.vertices.push(v3);

        arrowGeo.faces.push(new THREE.Face3(1, 0, 2));
        arrowGeo.computeFaceNormals();

        var arrowMaterial1 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });
        var arrowMaterial2 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });
        var arrowMaterial3 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });
        var arrowMaterial4 = new THREE.MeshBasicMaterial({ overdraw: true, color: 0xDDDDDD,
            transparent: false, opacity: 1, shading: THREE.FlatShading });

        var arrowSelection = new THREE.PlaneGeometry(cubeSize * 0.5, cubeSize * 0.3, 2, 2);
        var arrowSelectionMat = new THREE.MeshBasicMaterial({transparent: true, opacity: 0.0});

        var upArrow = new THREE.Mesh(arrowGeo, arrowMaterial1);
        var upArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        upArrow.position.set(0, arrowDist, 0.0);
        upArrowSelect.position.set(0, arrowDist * 0.9, 0.1);

        var downArrow = new THREE.Mesh(arrowGeo, arrowMaterial2);
        var downArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        downArrow.position.set(0, -arrowDist, 0.0);
        downArrowSelect.position.set(0, -arrowDist * 0.9, 0.1);
        downArrow.rotation.z += Math.PI;
        downArrowSelect.rotation.z += Math.PI;

        var rightArrow = new THREE.Mesh(arrowGeo, arrowMaterial3);
        var rightArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        rightArrow.position.set(arrowDist, 0, 0.0);
        rightArrowSelect.position.set(arrowDist * 0.9, 0, 0.1);
        rightArrow.rotation.z -= Math.PI / 2;
        rightArrowSelect.rotation.z -= Math.PI / 2;

        var leftArrow = new THREE.Mesh(arrowGeo, arrowMaterial4);
        var leftArrowSelect = new THREE.Mesh(arrowSelection, arrowSelectionMat);
        leftArrow.position.set(-arrowDist, 0, 0.0);
        leftArrowSelect.position.set(-arrowDist * 0.9, 0, 0.1);
        leftArrow.rotation.z += Math.PI / 2;
        leftArrowSelect.rotation.z += Math.PI / 2;

        arrowGroup = new THREE.Object3D();
        arrowGroup.position.set(0, 0, 0);
        arrowGroup.add(upArrow);
        arrowGroup.add(downArrow);
        arrowGroup.add(rightArrow);
        arrowGroup.add(leftArrow);

        controlScene.add(upArrowSelect);
        controlScene.add(downArrowSelect);
        controlScene.add(rightArrowSelect);
        controlScene.add(leftArrowSelect);
        controlScene.add(arrowGroup);

        arrowBuffer.push(upArrowSelect);
        arrowBuffer.push(downArrowSelect);
        arrowBuffer.push(rightArrowSelect);
        arrowBuffer.push(leftArrowSelect);

        // Home icon
        var homeGeo = new THREE.PlaneGeometry(cubeSize / 3, cubeSize / 3, 2, 2);
        var homeMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(path+'VChome.png'),
            transparent: true, shading: THREE.FlatShading });
        //homeMaterial.needsUpdate = true;
        home = new THREE.Mesh(homeGeo, homeMaterial);
        home.position.set(-cubeSize, cubeSize, 0);

        homeOffset = controlBuffer.length;
        controlScene.add(home);
        controlBuffer.push(home);

        // Arrows for rolling
        var rollArrows = new THREE.PlaneGeometry(cubeSize * 1.5, cubeSize * 1.5, 2, 2);
        var rollMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(path+'VCarrows.png'), shading: THREE.FlatShading, transparent: true});
        var roll = new THREE.Mesh(rollArrows, rollMaterial);
        roll.position.set(cubeSize * 0.5 + 20, cubeSize * 0.5 + 20, 0);

        var rollSelectionLeft = new THREE.PlaneGeometry(cubeSize * 0.6, cubeSize * 0.45, 2, 2);
        var rollSelectionLeftMat = new THREE.MeshBasicMaterial({transparent: true, opacity: 0.0});
        var rollLeft = new THREE.Mesh(rollSelectionLeft, rollSelectionLeftMat);
        rollLeft.position.set(cubeSize * 0.5 + 20, cubeSize + 20, 0.1);

        var rollSelectionRight = new THREE.PlaneGeometry(cubeSize * 0.45, cubeSize * 0.6, 2, 2);
        var rollSelectionRightMat = new THREE.MeshBasicMaterial({transparent: true, opacity: 0.0});
        var rollRight = new THREE.Mesh(rollSelectionRight, rollSelectionRightMat);
        rollRight.position.set(cubeSize + 20, cubeSize * 0.5 + 20, 0.1);

        controlScene.add(roll);
        controlScene.add(rollLeft);
        controlScene.add(rollRight);

        rollLeftOffset = controlBuffer.length;
        controlBuffer.push(rollLeft);
        rollRightOffset = controlBuffer.length;
        controlBuffer.push(rollRight);
        rollOffset = controlBuffer.length;
        controlBuffer.push(roll);

        //Menu Icon
        var contextGeo = new THREE.PlaneGeometry(cubeSize / 2.3, cubeSize / 2.3, 2, 2);
        var contextMaterial = new THREE.MeshBasicMaterial({ map: loadTexture(path+'VCcontext.png'),
            transparent: true, shading: THREE.FlatShading });
        //homeMaterial.needsUpdate = true;
        context = new THREE.Mesh(contextGeo, contextMaterial);
        context.position.set(cubeSize, -cubeSize, 0);

        menuOffset = controlBuffer.length;
        controlScene.add(context);
        controlBuffer.push(context);

        // Cube Shadow (Plane)

        var shadowGeo = new THREE.Geometry();

        shadowGeo.vertices.push(new THREE.Vector3(0, 0, 0));

        shadowGeo.vertices.push(new THREE.Vector3(-cubeSize / 2, -cubeSize / 2 - 20, -cubeSize / 2));
        shadowGeo.vertices.push(new THREE.Vector3(cubeSize / 2, -cubeSize / 2 - 20, -cubeSize / 2));
        shadowGeo.vertices.push(new THREE.Vector3(cubeSize / 2, -cubeSize / 2 - 20, cubeSize / 2));
        shadowGeo.vertices.push(new THREE.Vector3(-cubeSize / 2, -cubeSize / 2 - 20, cubeSize / 2));

        shadowGeo.faces.push(new THREE.Face3(4, 3, 2));
        shadowGeo.faces.push(new THREE.Face3(4, 2, 1));


        var shadowMat;

        // if(cam.renderer === 'WEBGL') {
        //     var vertexShader = "void main() {gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);}";
        //     var fragmentShader = "void main() {gl_FragColor = vec4(0, 0, 0, 0.5);}";
        //     shadowMat = new THREE.ShaderMaterial({vertexShader: vertexShader, fragmentShader: fragmentShader});
        // }else{
        //     shadowMat = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity: 0.5});
        // }
        shadowMat = new THREE.MeshBasicMaterial({color:0x000000, transparent:true, opacity: 0.5});

        shadow = new THREE.Mesh(shadowGeo, shadowMat);
        shadowScene.add(shadow);

        createCubeGrid();

        if (cam.renderer.toUpperCase() === 'CANVAS'){
            renderer = new THREE.CanvasRenderer();

        }else if (cam.renderer.toUpperCase() === 'WEBGL'){
            renderer = new FireflyWebGLRenderer({ alpha: true });

        }else {
            console.log("Incorrect use of Autocam.renderer property");
            renderer = new THREE.CanvasRenderer();
        }

        self.useTransparency(true);
        self.setSize(self.width,self.height);

        self.camera.topFov = self.camera.bottomFov = self.camera.fov/2;
        self.camera.leftFov = self.camera.rightFov = (self.camera.aspect * self.camera.fov)/2;

        // Auto clear needed because of multiple scenes
        renderer.autoClear = false;
        renderer.setSize(self.width, self.height);
        renderer.sortObjects = false;
        cubeContainer.appendChild(renderer.domElement);

        // Initialize all event handlers
        cubeContainer.addEventListener('touchstart', onDocumentMouseDown, false);
        cubeContainer.addEventListener('mousedown', onDocumentMouseDown, false);
        cubeContainer.addEventListener('mousemove', onDocumentMouseMove, false);
        window.addEventListener('resize', onWindowResize, false);

/*
        _havePointerLockFeature = 'pointerLockElement' in document ||
                                  'mozPointerLockElement' in document ||
                                  'webkitPointerLockElement' in document;
*/
        //Disabling this because it causes an intrusive browser pop-up asking
        //whether I want to allow full screen mode to happen (huh?)
        _havePointerLockFeature = false;

        // stderr("HAVE LOCK FEATURE: " + _havePointerLockFeature);

        if(_havePointerLockFeature) {
            document.exitPointerLock = document.exitPointerLock ||
                                       document.mozExitPointerLock ||
                                       document.webkitExitPointerLock;

            cubeContainer.requestPointerLock = cubeContainer.requestPointerLock ||
                                               cubeContainer.mozRequestPointerLock ||
                                               cubeContainer.webkitRequestPointerLock;

            // Hook pointer lock state change events
            document.addEventListener('pointerlockchange', pointerLockChange, false);
            document.addEventListener('mozpointerlockchange', pointerLockChange, false);
            document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
        }

        // Changing textures (blue highlighting for home and roll arrows)
        changingTextures.push(loadTexture(path+'VChomeS.png'));
        changingTextures.push(loadTexture(path+'VCarrowsS0.png'));
        changingTextures.push(loadTexture(path+'VCarrowsS1.png'));
        changingTextures.push(loadTexture(path+'VChome.png'));
        changingTextures.push(loadTexture(path+'VCarrows.png'));
        changingTextures.push(loadTexture(path+'VCcontext.png'));
        changingTextures.push(loadTexture(path+'VCcontextS.png'));
    };

    /** Used to make cube visible again when using the transparency option   */
    var mouseOverCube = function() {
        if( !cam.navApi.getIsLocked() ) {
            cubeContainer.style.opacity = "1.0";
            _transparent = false;
        }
        requestAnimationFrame(self.render);
    };

    /** Used to fade in and out the cube when using the transparency option */
    var mouseMoveOverCube = function(event) {
        if (!_transparent && !cam.viewCubeMenuOpen && !cam.navApi.getIsLocked() ) {
            var x = Math.max(Math.abs((event.clientX - position.x) / position.w - 0.5) * 4.0 - 1.0, 0);
            var y = Math.max(Math.abs((event.clientY - position.y) / position.h - 0.5) * 4.0 - 1.0, 0);
            var d = Math.max(0, Math.min(Math.sqrt(x*x + y*y), 1.0));
            cubeContainer.style.opacity = 1.0 - d * (1.0 - self.inactiveOpacity);
        }
        else if( !cam.navApi.getIsLocked() ) {
            cubeContainer.style.opacity = 1.0;
        }
    };

    /** Used to make cube transparent when using the transparency option */
    var mouseOutCube = function() {
        if(cam.viewCubeMenuOpen){
            return;
        }
        cubeContainer.style.opacity = self.inactiveOpacity;
        _transparent = true;
        requestAnimationFrame(self.render);
    };


    /** Takes in a image url and outputs a THREE.texture to be used
     * by Three.js materials
     * @param {string} url - path to the image you want to load as a texture
     * @return {THREE.Texture}
     */
    var loadTexture = function(url) {
        var image = new Image();
        image.crossOrigin = "anonymous";
        var texture = new THREE.Texture(image);
        image.onload = function() {
            texture.needsUpdate = true;
            loadedTextureCount++;

            if(loadedTextureCount >= 14){
                // all textures are now loaded
                requestAnimationFrame(self.render);
            }
        };

        image.src = url;
        return texture;
    };

    /** Creates the click-able grid around the View Cube
     *  by running functions to create Three.js meshes
     */
    var createCubeGrid = function () {
        var currentGridLength;
        var cubeCorners = [];
        var cubeEdges = [];

        cubeCorners[0] = buildCubeCorner(0, 0);
        cubeCorners[1] = buildCubeCorner(0, Math.PI / 2);
        cubeCorners[2] = buildCubeCorner(0, -Math.PI / 2);
        cubeCorners[3] = buildCubeCorner(0, Math.PI);
        cubeCorners[4] = buildCubeCorner(Math.PI / 2, 0);
        cubeCorners[5] = buildCubeCorner(Math.PI / 2, Math.PI / 2);
        cubeCorners[6] = buildCubeCorner(Math.PI / 2, -Math.PI / 2);
        cubeCorners[7] = buildCubeCorner(Math.PI / 2, Math.PI);

        cubeEdges[0] = buildCubeEdge(0, 0, 0);
        cubeEdges[1] = buildCubeEdge(0, Math.PI / 2, 0);
        cubeEdges[2] = buildCubeEdge(0, -Math.PI / 2, 0);
        cubeEdges[3] = buildCubeEdge(0, Math.PI, 0);
        cubeEdges[4] = buildCubeEdge(Math.PI / 2, 0, 0);
        cubeEdges[5] = buildCubeEdge(Math.PI / 2, Math.PI / 2, 0);
        cubeEdges[6] = buildCubeEdge(Math.PI / 2, -Math.PI / 2, 0);
        cubeEdges[7] = buildCubeEdge(Math.PI / 2, Math.PI, 0);
        cubeEdges[8] = buildCubeEdge(0, 0, Math.PI / 2);
        cubeEdges[9] = buildCubeEdge(0, 0, -Math.PI / 2);
        cubeEdges[10] = buildCubeEdge(-Math.PI / 2, 0, -Math.PI / 2);
        cubeEdges[11] = buildCubeEdge(-Math.PI, 0, -Math.PI / 2);

        // Draw the front square on the grid
        gridMeshes.push(buildCubeFace(0, 0));
        gridMeshes[0].name = 'front';
        intersectsFace.push(gridMeshes[0]);
        cubeBuffer.push(gridMeshes[0]);
        gridScene.add(gridMeshes[0]);

        // Draw the right square on the grid
        gridMeshes.push(buildCubeFace(0, Math.PI / 2));
        gridMeshes[1].name = 'right';
        intersectsFace.push(gridMeshes[1]);
        cubeBuffer.push(gridMeshes[1]);
        gridScene.add(gridMeshes[1]);

        // Draw the back square on the grid
        gridMeshes.push(buildCubeFace(0, Math.PI));
        gridMeshes[2].name = 'back';
        intersectsFace.push(gridMeshes[2]);
        cubeBuffer.push(gridMeshes[2]);
        gridScene.add(gridMeshes[2]);

        // Draw the left grid
        gridMeshes.push(buildCubeFace(0, -Math.PI / 2));
        gridMeshes[3].name = 'left';
        intersectsFace.push(gridMeshes[3]);
        cubeBuffer.push(gridMeshes[3]);
        gridScene.add(gridMeshes[3]);

        // Draw the bottom grid
        gridMeshes.push(buildCubeFace(Math.PI / 2, 0));
        gridMeshes[4].name = 'bottom';
        intersectsFace.push(gridMeshes[4]);
        cubeBuffer.push(gridMeshes[4]);
        gridScene.add(gridMeshes[4]);

        // Draw the top grid
        gridMeshes.push(buildCubeFace(-Math.PI / 2, 0));
        gridMeshes[5].name = 'top';
        intersectsFace.push(gridMeshes[5]);
        cubeBuffer.push(gridMeshes[5]);
        gridScene.add(gridMeshes[5]);

        currentGridLength = gridMeshes.length;

        var i;
        for (i = 0; i < cubeCorners.length; i++) {
            gridMeshes.push(cubeCorners[i]);
            gridMeshes[currentGridLength + i].name = cornerNames[i];
            gridScene.add(gridMeshes[currentGridLength + i]);
            intersectsFace.push(gridMeshes[currentGridLength + i]);
            cubeBuffer.push(gridMeshes[currentGridLength + i]);
        }

        currentGridLength = gridMeshes.length;

        for (i = 0; i < cubeEdges.length; i++) {
            gridMeshes.push(cubeEdges[i]);
            gridMeshes[currentGridLength + i].name = edgeNames[i];
            gridScene.add(gridMeshes[currentGridLength + i]);
            intersectsFace.push(gridMeshes[currentGridLength + i]);
            cubeBuffer.push(gridMeshes[currentGridLength + i]);
        }
    };


    /**
     * Get intersections between a mesh and mouse position (mouse picking)
     * @param {THREE.Vector3} pickingVector - direction vector to find intersections
     * @param {THREE.Camera} camera
     * @param {THREE.Mesh[]} intersectionBuffer - an array of three.js meshes to check for intersections with these specific meshes
     * @return {Object[]} - objects which were intersected
     */
    var findPickingIntersects = function(pickingVector, camera, intersectionBuffer) {
        var raycaster;
        var intersects;
        var projector = new THREE.Projector();

        var direction = new THREE.Vector3();
        direction.copy(pickingVector);

        projector.unprojectVector(direction, camera);
        raycaster = new THREE.Raycaster(camera.position, direction.sub(camera.position).normalize());

        intersects = raycaster.intersectObjects(intersectionBuffer);

        return intersects;

    };

    var getPickVector = function(event, position) {
        var x = event.clientX - position.x;
        var y = event.clientY - position.y;

        x = (x / position.w * 2.0) - 1.0;
        y = ((position.h - y) / position.h * 2.0) - 1.0;

        return new THREE.Vector3(x, y, 0.5);
    };

    function isFullscreen() {
        return document.fullscreenElement ||
               document.webkitFullscreenElement ||
               document.mozFullScreenElement ||
               document.msFullscreenElement;
    }

    function getEventCoords(event, self) {
        var coords = {}

        if( event.type.indexOf("touch") === 0 ) {
            if( event.touches.length > 0 ) {
                coords.clientX   = event.touches[0].clientX;
                coords.clientY   = event.touches[0].clientY;
                coords.pageX     = event.touches[0].pageX;
                coords.pageY     = event.touches[0].pageY;
                coords.screenX   = event.touches[0].screenX;
                coords.screenY   = event.touches[0].screenY;
                coords.movementX = coords.screenX - self.prevX;
                coords.movementY = coords.screenY - self.prevY;
                coords.which     = cam.navApi.getUseLeftHandedInput() ? 3 : 1;
            }
            else {
                coords = self.prevCoords;
            }
        }
        else {
            coords.clientX   = event.clientX;
            coords.clientY   = event.clientY;
            coords.pageX     = event.pageX;
            coords.pageY     = event.pageY;
            coords.screenX   = event.screenX;
            coords.screenY   = event.screenY;
            coords.which     = event.which;

            if ( _havePointerLockFeature ) {
                coords.movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                coords.movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            }
            else {
                coords.movementX = coords.screenX - self.prevX;
                coords.movementY = coords.screenY - self.prevY;
            }
        }
        self.prevX = coords.screenX;
        self.prevY = coords.screenY;
        self.prevCoords = coords;

        return coords;
    }

    /** All functionality regarding cube clicks starts here
     *
     * @param {Object} event - event when mouse down occurs
     */
    var onDocumentMouseDown = function (event) {
        event.preventDefault();
        event.stopPropagation();

        if( cam.navApi.getIsLocked() ) 
            return;

        if (cam.currentlyAnimating) { return; }

        var coords = getEventCoords(event, self);

        // Make sure our position is up to date...
        position = getPosition(cubeContainer);

        cubeContainer.removeEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('mouseup', onDocumentMouseUp, false);
        document.addEventListener('touchend', onDocumentMouseUp, false);
        // Not needed: document.addEventListener('mousemove', onDocumentMouseMove, false);

        if( !cam.navApi.getUsePivotAlways() ) {
            // If the usePivot option is not on, we pivot around the center of the view:
            cam.pivot.copy(cam.center);
            cam.navApi.setPivotPoint(cam.center);
            // This also clears the pivot set flag:
            cam.navApi.setPivotSetFlag(false);
        }

        cam.startInteraction(coords.pageX, coords.pageY);

        // Since this mouse down is for dragging the cube we should not be able do this if the cube is animating already
        var intersectsWithCube;
        var pickingVector;

        //If cube is first thing clicked, add the current shot to rewind history
        if (cam.rewindParams.history.length == 0) cam.addHistoryElement();

        //If clicking cube from anywhere other then end of timeline update history accordingly
        if (!cam.rewindParams.snapped || cam.rewindParams.timelineIndex +1 != cam.rewindParams.history.length) cam.addIntermediateHistoryElement();

        var rightMouse = cam.navApi.getUseLeftHandedInput() ? 1 : 3;
        if (coords.which === rightMouse) // Right mouse click, handled on mouse up
            return;

        if(self.animSpeed <= 0){
            console.error("animSpeed cannot be 0 or less, use ViewCube.animate flag to turn on and off animation");
            return;
        }

        // get mouse picking intersections
        pickingVector = getPickVector(coords, position);
        intersectsWithCube = findPickingIntersects(pickingVector, self.camera, cubeBuffer);


        if (intersectsWithCube.length > 0) {

            hideArrows();
            if(self.draggable){
                document.addEventListener('mousemove', onDocumentMouseMoveCube, false);
                document.addEventListener('touchmove', onDocumentMouseMoveCube, false);

                // Check if browser has pointer lock support
                if ( _havePointerLockFeature ) {
                    // Ask the browser to lock the pointer
                    cubeContainer.requestPointerLock();
					_pointerLockMoveBugSPK865 = (_isChrome && _isWindows);
                }
            }
        }
    };

    /** Used for dragging the cube,
     * @param {Object} event - event when mouse move occurs (contains information about pointer position)
     */
    var onDocumentMouseMoveCube = function (event) {

		// stderr("MOUSE MOVE CUBE: " + event.clientX + ", " + event.clientY + ", " + event.button);
        event.preventDefault();
        event.stopPropagation();

        // This is an error if user puts in self.animSpeed = 0 or less
        if(self.animSpeed <= 0){
            document.removeEventListener("mousemove", onDocumentMouseMoveCube, false);
            document.removeEventListener("touchmove", onDocumentMouseMoveCube, false);
            console.error("animSpeed cannot be 0 or less");
            return;
        }

        if(cam.currentlyAnimating) {
			return;
		}
        var coords = getEventCoords(event, self);

        if ( _havePointerLockFeature ) {
			// We skip the first movement event after requesting pointer lock
			// because Chrome on Windows sends out a bogus motion value.
			if( _pointerLockMoveBugSPK865 ) {
				_pointerLockMoveBugSPK865 = false;
				coords.movementX = coords.movementY = 0;
			}
        }

        if(_havePointerLock) {

            // Ignore erroneous data sent from pointer lock
            // not sure why erroneous data gets received
            // could be bug in pointer lock
            if(coords.movementX > 300 || coords.movementY > 300) {
                coords.movementX = 0;
                coords.movementY = 0;
            }
        }

        // If the mouse hasn't moved ignore this current movement (not sure why the mouse move event gets called)
        // Also used for ignoring erroneous data
        if(coords.movementX === coords.movementY && coords.movementX === 0) {
            cam.currentlyAnimating = false;
            return;
        }
        _orthogonalView = false;
        _dragged = true;
        cam.showPivot(true);
        cam.currentCursor = new THREE.Vector2(coords.pageX, coords.pageY);
        cam.orbit(cam.currentCursor, cam.startCursor, new THREE.Vector3( - coords.movementX, coords.movementY, 0 ), cam.startState);

        self.camera.lookAt(self.center);

        requestAnimationFrame(self.render);
    };


    var endMouseUp = function (stillNeedUp) {
        if( !stillNeedUp ) {
            document.removeEventListener('mouseup', onDocumentMouseUp, false);
            document.removeEventListener('touchend', onDocumentMouseUp, false);
        }

        document.removeEventListener('mousemove', onDocumentMouseMoveCube, false);
        document.removeEventListener('touchmove', onDocumentMouseMoveCube, false);
        cubeContainer.addEventListener('mousemove', onDocumentMouseMove, false);

        if ( _havePointerLock ) {
            document.exitPointerLock();
        }

    };

    /** Rotates the cube when a division of the cube grid is clicked,
     * also provides functionality for home button interaction, orthogonal arrows interaction,
     * and roll arrows interaction
     * @param {Object} event - event contains information about mouse position which is used in this function
     */
    var onDocumentMouseUp = function (event) {
        event.preventDefault();
        event.stopPropagation();

        var cubeIntersects;
        var arrowIntersects;
        var controlIntersects;

        if (cam.currentlyAnimating || _dragged) {
            cam.endInteraction();
            cam.showPivot(false);
            _dragged = false;

            endMouseUp(false);
            return;
        }
        var coords = getEventCoords(event, self);

        if (cam.viewCubeMenuOpen) {
            var x = coords.clientX - position.x;
            var y = coords.clientY - position.y;

            //if clicked on the menu
            if ((cam.menuOrigin.x <= x) && (x <= (cam.menuOrigin.x + cam.menuSize.x)) &&
                (cam.menuOrigin.y <= y) && (y <= (cam.menuOrigin.y + cam.menuSize.y))){

                // HACK!!
                // TODO: make this a bit more robust. It doesn't take the menu separators
                // into account and makes a gross assumption about the menu entry size.
                var menuItemNumber = Math.floor(((y-5) - cam.menuOrigin.y)/25);

                // stderr("HIT ITEM: " + menuItemNumber + " Y=" + coords.clientY + " Menu Y=" + cam.menuOrigin.y);

                switch(menuItemNumber){
                    case 0:                 //home
                        cam.goHome();
                        break;
                    case 1:                 //orthographic
                        cam.setOrthographicFaces(false);
                        cam.toOrthographic();
                        break;
                    case 2:                 //perspective
                        cam.setOrthographicFaces(false);
                        cam.toPerspective();
                        break;
                    case 3:                 //perspective with ortho faces
                        cam.setOrthographicFaces(true);
                        if( _orthogonalView )
                            cam.toOrthographic();
                        else
                            cam.toPerspective();
                        break;
                    case 4:                 //set current view as home
                        cam.setCurrentViewAsHome(false);
                        break;
                    case 5:                 //focus and set current view as home
                        cam.setCurrentViewAsHome(true);
                        break;
                    case 6:                 //reset home
                        cam.resetHome();
                        break;
                    case 7:                 //set current view as front
                        cam.setCurrentViewAsFront();
                        break;
                    case 8:                 //set current view as top
                        cam.setCurrentViewAsTop();
                        break;
                    case 9:                 //reset orientation
                        cam.resetOrientation();
                        break;
                }
            }

            cam.viewCubeMenuOpen = false;
            cam.removeDropdownMenu(cubeContainer);

            //if clicked off the cube canvas
            if( coords.clientX < position.x || coords.clientX > (position.w + position.x)
             || coords.clientY < position.y || coords.clientY > (position.h + position.y)) {
                mouseOutCube();
            }

            // In case something needs a highlight change:
            if( self.mouseMoveSave )
                self.processMouseMove(self.mouseMoveSave);

            endMouseUp(false);
            return;
        }
        var rightMouse = cam.navApi.getUseLeftHandedInput() ? 1 : 3;
        if (coords.which === rightMouse) {
            cam.viewCubeMenuOpen=true;
            cam.drawDropdownMenu(menuOptionList, menuEnableList, menuStateCallbackList, coords.clientX, coords.clientY, cubeContainer, position);
            endMouseUp(true);
            return;
        }
        var pickingVector = getPickVector(coords, position);
        cubeIntersects    = findPickingIntersects(pickingVector, self.camera, cubeBuffer);
        arrowIntersects   = findPickingIntersects(pickingVector, controlCamera, arrowBuffer);
        controlIntersects = findPickingIntersects(pickingVector, controlCamera, controlBuffer);

        // Apply logic for clicking on arrows
        if (arrowIntersects.length > 0 && _orthogonalView) {
            var orientation = cam.getOrientation();

            switch (self.currentFace){
                case "front":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                    }
                    break;

                case "right":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                        }
                    break;

                case "left":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bavk");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                    }
                    break;

                case "back":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("top");
                                self.currentFace = "top";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("bottom");
                                self.currentFace = "bottom";
                            }
                            break;
                    }
                    break;

                case "top":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                    }
                    break;

                case "bottom":
                    switch (orientation){
                        case "up":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }
                            break;
                        case "right":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }
                            break;
                        case "down":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }
                            break;
                        case "left":
                            if (arrowIntersects[0].object === arrowBuffer[0]) {
                                cam.calculateCubeTransform("left");
                                self.currentFace = "left";
                            }else if (arrowIntersects[0].object === arrowBuffer[1]) {
                                cam.calculateCubeTransform("right");
                                self.currentFace = "right";
                            }else if (arrowIntersects[0].object === arrowBuffer[2]) {
                                cam.calculateCubeTransform("front");
                                self.currentFace = "front";
                            }else if (arrowIntersects[0].object === arrowBuffer[3]) {
                                cam.calculateCubeTransform("back");
                                self.currentFace = "back";
                            }
                            break;
                    }
                    break;
            }
            cam.elapsedTime =0;
            cam.sphericallyInterpolateTransition();
        }

        if (controlIntersects.length > 0) {
            cam.elapsedTime = 0;

            if (self.wantHomeButton && controlIntersects[0].object === controlBuffer[homeOffset]) {
                cam.goHome();
                endMouseUp(false);
                return;
            }
            if (self.wantContextMenu && controlIntersects[0].object === controlBuffer[menuOffset]) {
                cam.viewCubeMenuOpen=true;
                cam.drawDropdownMenu(menuOptionList, menuEnableList, menuStateCallbackList, coords.clientX, coords.clientY, cubeContainer, position);
                endMouseUp(true);
                return;
            }
            if (self.wantRollArrows && _orthogonalView && (controlIntersects[0].object === controlBuffer[rollLeftOffset] || controlIntersects[0].object === controlBuffer[rollRightOffset])) {
                //TODO: when panning, dir changes -> position
                var clockwise = (controlIntersects[0].object === controlBuffer[rollRightOffset]);
                var destination = {
                    center: cam.center.clone(),
                    position: camera.position.clone(),
                    pivot: camera.pivot.clone(),
                    fov: camera.fov,
                    worldUp: cam.sceneUpDirection.clone(),
                    isOrtho: (camera.isPerspective === false)
                };
                var dir = cam.center.clone().sub(camera.position).normalize();

                if (clockwise){
                    destination.up = camera.up.clone().cross(dir);
                }else{
                    destination.up = camera.up.clone().multiplyScalar(-1);
                    destination.up.cross(dir);
                }
                destination.up.normalize();

                cam.elapsedTime = 0.0;
                cam.animateTransition(destination)
            }
        }
        if (cubeIntersects.length > 0) {
            self.currentFace = cubeIntersects[0].object.name;

            // If ortho faces is on and the target is not another face,
            // switch to perspective mode:
            if( cam.orthographicFaces && (self.currentFace.indexOf(',') !== -1) ) {
                cam.setCameraOrtho(false);
            }
            cam.calculateCubeTransform(self.currentFace);

            // stderr("MOUSE UP, hit: " + self.currentFace);
            cam.elapsedTime =0;
            self.mouseMoveSave = event;

            // After interpolating to the new target we may have to simulate
            // a mouse move event at the final location so that the appropriate
            // part of the cube is highlighted:
            cam.sphericallyInterpolateTransition(function(){
                if( self.mouseMoveSave )
                    self.processMouseMove(self.mouseMoveSave);
            });
        }
        endMouseUp(false);
    };

    /** Used to highlight cube grid divisions/arrows/home
     * @param {Object} event - event contains information about mouse position which is used in this function
     */
    this.processMouseMove = function (event) {
        var intersectsFaces;
        var arrowIntersects;
        var controlIntersects;

        if (cam.viewCubeMenuOpen || cam.currentlyAnimating) {
            self.mouseMoveSave = event;
            return;
        }
        self.mouseMoveSave = null;

        var coords = getEventCoords(event, self);

        var pickingVector = getPickVector(coords, position);

        intersectsFaces = findPickingIntersects(pickingVector, self.camera, intersectsFace);
        arrowIntersects = findPickingIntersects(pickingVector, controlCamera, arrowBuffer);
        controlIntersects = findPickingIntersects(pickingVector, controlCamera, controlBuffer);

        /**********Highlight arrows when hovered over************/

        if (INTERSECTED && !_dragged) {
            INTERSECTED.material.color.setHex(0xDDDDDD);
            INTERSECTED = null;
            requestAnimationFrame(self.render);
        }

        if (arrowIntersects.length > 0 && !_dragged) {
                INTERSECTED = arrowIntersects[0].object;
                for( var i=arrowGroup.children.length;  --i >= 0; ) {
                    if (INTERSECTED === arrowBuffer[i]) {
                        INTERSECTED = arrowGroup.children[i];
                        INTERSECTED.material.color.setHex(0x00afff);
                        break;
                    }
                }
                requestAnimationFrame(self.render);
        }

        /**************Highlight faces on cube******************/

        if (INTERSECTED_F && !_dragged) {
            // Make the previously selected face opacity: 0.0
                INTERSECTED_F.material.opacity = 0.0;
                INTERSECTED_F = null;
                requestAnimationFrame(self.render);
        }

        if (intersectsFaces.length > 0 && !_dragged) {
            // Make the currently selected face opacity: 0.3
                INTERSECTED_F = intersectsFaces[0].object;
                INTERSECTED_F.material.opacity = 0.3;
                requestAnimationFrame(self.render);
        }

        if (controlIntersects.length > 0 && !_dragged){
            if(INTERSECTED_C !== controlIntersects[0].object){
                // home mouse over
                if(self.wantHomeButton && controlIntersects[0].object === controlBuffer[homeOffset]){
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[homeOffset].material.map = changingTextures[0];
                }

                // Left roll arrow mouse over
                else if(self.wantRollArrows && controlIntersects[0].object === controlBuffer[rollLeftOffset]){
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[rollOffset].material.map = changingTextures[1];
                }

                // Right roll arrow mouse over
                else if(self.wantRollArrows && controlIntersects[0].object === controlBuffer[rollRightOffset]) {
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[rollOffset].material.map = changingTextures[2];
                }

                // Menu Icon
                else if(self.wantContextMenu && controlIntersects[0].object === controlBuffer[menuOffset]){
                    INTERSECTED_C = controlIntersects[0].object;
                    controlBuffer[menuOffset].material.map = changingTextures[6];
                }

                else{
                    // home mouse over
                    if(self.wantHomeButton && INTERSECTED_C === controlBuffer[homeOffset]) {
                        INTERSECTED_C = null;
                        controlBuffer[homeOffset].material.map = changingTextures[3];
                    }

                    // Left roll and Right roll arrow
                    else if(self.wantRollArrows && (INTERSECTED_C === controlBuffer[rollLeftOffset] ||
                        INTERSECTED_C === controlBuffer[rollRightOffset] || INTERSECTED_C === controlBuffer[rollOffset])){
                        INTERSECTED_C = null;
                        controlBuffer[rollOffset].material.map = changingTextures[4];
                    }

                    // menu icon
                    else if(self.wantContextMenu && INTERSECTED_C === controlBuffer[menuOffset]){
                        INTERSECTED_C = null;
                        controlBuffer[menuOffset].material.map = changingTextures[5];
                    }
                }
                requestAnimationFrame(self.render);
            }
        }else if(INTERSECTED_C !== null && !_dragged){
            // home mouse over
            if(self.wantHomeButton && INTERSECTED_C === controlBuffer[homeOffset]) {
                INTERSECTED_C = null;
                controlBuffer[homeOffset].material.map = changingTextures[3];
            }

            // Left roll and Right roll arrow
            else if(self.wantRollArrows && (INTERSECTED_C === controlBuffer[rollLeftOffset] ||
                INTERSECTED_C === controlBuffer[rollRightOffset] || INTERSECTED_C === controlBuffer[rollOffset])){
                INTERSECTED_C = null;
                controlBuffer[rollOffset].material.map = changingTextures[4];
            }

            // menu icon
            else if(self.wantContextMenu && INTERSECTED_C === controlBuffer[menuOffset]){
                INTERSECTED_C = null;
                controlBuffer[menuOffset].material.map = changingTextures[5];
            }

            requestAnimationFrame(self.render);
        }
    };

    var onDocumentMouseMove = function (event) {
        if( !cam.navApi.getIsLocked() ) 
            self.processMouseMove(event);
    };

    /** Refreshes values so that renderer is correct size (in pixels) **/
    var onWindowResize = function () {
        position = getPosition(cubeContainer);

        // cubeContainer.style.width = self.width.toString() + "px";
        // cubeContainer.style.height = "inherit";

        self.width  = cubeContainer.offsetWidth;
        self.height = cubeContainer.offsetHeight;

        windowHalfX = self.width / 2;
        windowHalfY = self.height / 2;

        self.camera.aspect = self.width / self.height;
        self.camera.updateProjectionMatrix();

        // PHB added. See Autocam.js windowResize
        self.camera.topFov = self.camera.bottomFov = self.camera.fov/2;
        self.camera.leftFov = self.camera.rightFov = (self.camera.aspect * self.camera.fov)/2;

        renderer.setSize(self.width, self.height);
        requestAnimationFrame(self.render);
    };

    /** Builds one square mesh of the grid (located on each face of the cube)
     *
     * @param {Number} rotationX - rotate shape by this amount in X
     * @param {Number} rotationY - rotate shape by this amount in Y
     * @return {THREE.Mesh} - mesh of the cube face (square part) rotated by params
     */
    var buildCubeFace = function (rotationX, rotationY) {

        // These sizes may be changed if cube size is changed
        var material;
        var edge = 45;
        var square = 60;
        var masterCubeSize = edge + square;

        var geo = new THREE.Geometry();

        // Center of the cube
        var v0 = new THREE.Vector3(0, 0, 0);

        /******************FRONT OF CUBE********************/
        var v1 = new THREE.Vector3(square, -square, masterCubeSize);
        var v2 = new THREE.Vector3(square, square, masterCubeSize);
        var v3 = new THREE.Vector3(-square, square, masterCubeSize);
        var v4 = new THREE.Vector3(-square, -square, masterCubeSize);

        geo.vertices.push(v0);

        geo.vertices.push(v1);
        geo.vertices.push(v2);
        geo.vertices.push(v3);
        geo.vertices.push(v4);

        /******************FRONT FACE********************/

            // Front square
        geo.faces.push(new THREE.Face3(1, 2, 3));
        geo.faces.push(new THREE.Face3(1, 3, 4));


        // Apply matrix rotations for sides which are not the front
        geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));
        geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));

        geo.computeFaceNormals();
        geo.computeVertexNormals();

        material = new THREE.MeshBasicMaterial({ overdraw:true, opacity:0.0, color:0x00afff, transparent:true });
        return new THREE.Mesh(geo, material);
    };

    /** Builds one edge mesh of the grid
     *
     * @param rotationX - rotate shape by this amount X
     * @param rotationY - rotate shape by this amount Y
     * @param rotationZ - rotate shape by this amount Z
     * @return {THREE.Mesh} - mesh of the cube edge rotated by params
     */
    var buildCubeEdge = function (rotationX, rotationY, rotationZ) {
        var material;
        var edge = 45;
        var square = 60;
        var masterCubeSize = edge + square;
        var meshReturn;

        var geo = new THREE.Geometry();

        var e0 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);
        var e1 = new THREE.Vector3(-square, masterCubeSize, masterCubeSize);
        var e2 = new THREE.Vector3(-square, square, masterCubeSize);
        var e3 = new THREE.Vector3(square, square, masterCubeSize);

        var e4 = new THREE.Vector3(square, masterCubeSize, square);
        var e5 = new THREE.Vector3(-square, masterCubeSize, square);
        var e6 = new THREE.Vector3(-square, masterCubeSize, masterCubeSize);
        var e7 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);

        geo.vertices.push(e0);
        geo.vertices.push(e1);
        geo.vertices.push(e2);
        geo.vertices.push(e3);

        geo.vertices.push(e4);
        geo.vertices.push(e5);
        geo.vertices.push(e6);
        geo.vertices.push(e7);

        geo.faces.push(new THREE.Face3(0, 1, 2));
        geo.faces.push(new THREE.Face3(0, 2, 3));

        geo.faces.push(new THREE.Face3(4, 5, 6));
        geo.faces.push(new THREE.Face3(4, 6, 7));


        geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));
        geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));
        geo.applyMatrix(new THREE.Matrix4().makeRotationZ(rotationZ));

        geo.computeFaceNormals();
        geo.computeVertexNormals();

        material = new THREE.MeshBasicMaterial({ overdraw:true, opacity:0.0, color:0x00afff, transparent:true });
        meshReturn = new THREE.Mesh(geo, material);
        return meshReturn;
    };

    /** Builds one corner mesh of the grid
     *
     * @param {Number} rotationX - rotate shape by this amount in X
     * @param {Number} rotationY - rotate shape by this amount in Y
     * @return {THREE.Mesh} - the cube corner mesh rotated by params
     */
    var buildCubeCorner = function (rotationX, rotationY) {
        var material;
        var edge = 45;
        var square = 60;
        var masterCubeSize = edge + square;
        var meshReturn;

        var geo = new THREE.Geometry();

        var c0 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
        var c1 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);
        var c2 = new THREE.Vector3(square, square, masterCubeSize);
        var c3 = new THREE.Vector3(masterCubeSize, square, masterCubeSize);

        var c4 = new THREE.Vector3(masterCubeSize, masterCubeSize, square);
        var c5 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
        var c6 = new THREE.Vector3(masterCubeSize, square, masterCubeSize);
        var c7 = new THREE.Vector3(masterCubeSize, square, square);

        var c8 = new THREE.Vector3(masterCubeSize, masterCubeSize, masterCubeSize);
        var c9 = new THREE.Vector3(masterCubeSize, masterCubeSize, square);
        var c10 = new THREE.Vector3(square, masterCubeSize, square);
        var c11 = new THREE.Vector3(square, masterCubeSize, masterCubeSize);

        geo.vertices.push(c0);
        geo.vertices.push(c1);
        geo.vertices.push(c2);
        geo.vertices.push(c3);

        geo.vertices.push(c4);
        geo.vertices.push(c5);
        geo.vertices.push(c6);
        geo.vertices.push(c7);

        geo.vertices.push(c8);
        geo.vertices.push(c9);
        geo.vertices.push(c10);
        geo.vertices.push(c11);

        geo.faces.push(new THREE.Face3(0, 1, 2));
        geo.faces.push(new THREE.Face3(0, 2, 3));

        geo.faces.push(new THREE.Face3(4, 5, 6));
        geo.faces.push(new THREE.Face3(4, 6, 7));

        geo.faces.push(new THREE.Face3(8, 9, 10));
        geo.faces.push(new THREE.Face3(8, 10, 11));


        geo.applyMatrix(new THREE.Matrix4().makeRotationX(rotationX));
        geo.applyMatrix(new THREE.Matrix4().makeRotationY(rotationY));

        geo.computeFaceNormals();
        geo.computeVertexNormals();

        material = new THREE.MeshBasicMaterial({ overdraw:true, opacity:0.0, color:0x00afff, transparent:true });
        meshReturn = new THREE.Mesh(geo, material);
        return meshReturn;
    };

    var changeBasisWorldToStandard = function (V) {
        var worldD = cam.cubeFront.clone();
        var worldU = cam.sceneUpDirection.clone();
        var worldR = worldD.clone().cross(worldU);
        worldU.copy(worldR).cross(worldD);

        worldD.normalize();
        worldU.normalize();
        worldR.normalize();

        var answer = new THREE.Vector3(worldD.x,worldU.x,worldR.x).multiplyScalar(V.x);
        answer.add(new THREE.Vector3(worldD.y,worldU.y,worldR.y).multiplyScalar(V.y));
        answer.add(new THREE.Vector3(worldD.z,worldU.z,worldR.z).multiplyScalar(V.z));

        return answer;
    };

    /** Render the View Cube scenes and perform checks for control visibility **/
    this.render = function () {
        var scale = self.compass ? self.viewScaleFactorCompass * self.viewScale : self.viewScale;
        var viewDir = cam.center.clone().sub(camera.position).normalize();
        var upDir   = camera.up.normalize();

        viewDir = changeBasisWorldToStandard(viewDir);
        upDir   = changeBasisWorldToStandard(upDir);

        self.camera.position.copy(viewDir);
		self.camera.position.multiplyScalar(-scale / self.camera.position.length());
        self.camera.up = upDir.normalize();
        self.camera.lookAt(self.center);

        checkControlVisibility();
        renderer.clear();
        // There are 3 scenes: the first is the shadow, then the cube with textures, then the grid is on top
        renderer.render(shadowScene, self.camera);
        renderer.render(cubeScene, self.camera);
        renderer.render(lineScene, self.camera);
        renderer.render(gridScene, self.camera);
        // Different camera since these shouldn't move with the View Cube
        renderer.render(controlScene, controlCamera);
    };

    /**
     * checks whether arrows (orthogonal and roll), drop down menus, and home button should be visible or not at
     * this current time
     */
    var checkControlVisibility = function(){
        // Arrow Visibility

        _orthogonalView = cam.isFaceView();

        (_orthogonalView && !_transparent && !cam.currentlyAnimating) ? showArrows() : hideArrows();

        // Menu Visibility
        _transparent ? hideContext() : showContext();

        // Home Visibility
        _transparent ? hideHome() : showHome();
    };

    /** Hide View Cube Arrows **/
    var hideArrows = function() {
        controlScene.remove(arrowGroup);

        controlBuffer[rollOffset].material.opacity = 0.0;
        controlBuffer[menuOffset].material.opacity = 0.0;
    };

    /** Show View Cube Arrows **/
    var showArrows = function() {
        controlScene.add(arrowGroup);

        var opacity = self.wantRollArrows ? 1.0 : 0.0;
        controlBuffer[rollOffset].material.opacity = opacity;
        controlBuffer[menuOffset].material.opacity = opacity;
    };

    /** Hide the view cube menu button **/
    var hideContext = function() {
        context.material.opacity = 0.0;
    };

    /** Show the view cube menu button **/
    var showContext = function() {
        context.material.opacity = self.wantContextMenu ? 1.0 : 0.0;
    };

    /** Hide the home button **/
    var hideHome = function() {
        home.material.opacity = 0.0;
    };

    /** Show the home button **/
    var showHome = function() {
        home.material.opacity = self.wantHomeButton ? 1.0 : 0.0;
    };

    /* Public Methods */
    /** Update the View Cube camera to a new camera view
     * @public
     * @this ViewCube
     * @param {int[]} eye - client provided camera position (in their world coordinates)
     * @param {int[]} centre - client provided pivot point or centre (where the camera is looking at in their world coordinates)
     * @param {int[]} upVector - client provided up vector
     */

    /** Refresh height and width renderer sizes
     * @public
     * @this ViewCube
     */
    this.refreshCube = function () {
        onWindowResize();
    };

    /** Set the size of the View Cube
     * @public
     * @this ViewCube
     * @param {int} width - in pixels
     * @param {int} height - in pixels
     */
    this.setSize = function (width, height) {
        self.width = width;
        self.height = height;

        if(cubeContainer.children.length > 1){
            for(var i = 1; i < cubeContainer.children.length; i++)
                cubeContainer.children[i].style.bottom = (self.height/5).toString() + "px";
        }

        onWindowResize();
    };

    /** Option to turn on and off transparency on mouse out for the view cube
     * @public
     * @this ViewCube
     * @param {boolean} transparent - true to use transparency, false to turn it off
     */
    this.useTransparency = function (transparent){
        _transparent = transparent;
        if(transparent) {
            cubeContainer.onmouseover = mouseOverCube;
            cubeContainer.onmousemove = mouseMoveOverCube;
            cubeContainer.onmouseout = mouseOutCube;
            mouseOutCube();
        }
        else {
            cubeContainer.onmouseover = null;
            cubeContainer.onmouseout = null;
            cubeContainer.onmousemove = null;
            cubeContainer.style.opacity = "1.0";
        }
    };
    /* Build the cube */
    Init();
};
;AutodeskNamespace('Autodesk.Viewing');

/**
 * This is the core interface to add and remove canvas interactions to the viewer. This class is created internally by the Viewer api and is available via the "toolController" property of the Viewer3D api object. Client implementations should not normally instantiate this class directly.
 *  @class
 *  @param {Object} viewerImpl - The viewer implementation object.
 *  @param {Object} viewerApi - The viewer api object.
 *  @param {Object} autocam - The Autocam interface object
 *  @param {Object} utilities - The ViewingUtilities object
 *  @param {Object} defaultHandler - The default event handling tool.
 *  @constructor
 *  @see Autodesk.Viewing.Viewer3D
 */
Autodesk.Viewing.ToolController = function( viewerImpl, viewerApi, autocam, utilities, defaultHandler )
{
    this.domElement = viewerImpl.canvas;
    this.selector = viewerImpl.selector;
    this.autocam = autocam;
    this.downX = -1;
    this.downY = -1;
    this.lastClickX = -1;
    this.lastClickY = -1;

    var isMac = (navigator.userAgent.search("Mac OS") != -1);
    var isFirefox = (navigator.userAgent.search("Firefox") != -1);

    var kTwo_PI  = 2.0 * Math.PI; // 360 degrees.

    var kMouseLeft = 0;
    var kMouseMiddle = 1;
    var kMouseRight = 2;

    var kClickThreshold = 2;        // Pixels
    var kTapThreshold = 8;          // Pixel threshold to accept a tap
    var kDoubleTapThreshold = 32;   // Pixel threshold to accept a double tap
    var kTapLength = 300.0;         // Maximum hold time to accept a tap (milliseconds)
    var kDoubleTapDelay = 300.0;    // Maximum time between taps for double-tap (milliseconds)
    var kDoubleClickDelayThreshold = 500; // ms
    var kTouchSwapThreshold = 2.9;

    var _tools = {};
    var _toolStack = [];
    var _lock = false;

    var _tapBeginX = -1;
    var _tapBeginY = -1;
    var _tapBeginTime = -1;
    var _taps = [];
    var _doubleTapTimer = null;
    var _firefoxLMBfix = false;
    var _currentCursor = null;
    var _lastTouchedElement = undefined;

    // Save click parameters when clicking with right mouse button
    // and "Left handed mouse setup" is enabled so that we can
    // simulate a double-click with the right mouse button.
    //
    var _checkMouseDoubleClick = {};

    var _this = this;

    var _keys = {
          BACKSPACE: 8,
                TAB: 9,
              ENTER: 13,
              SHIFT: 16,
            CONTROL: 17,
                ALT: 18,
             ESCAPE: 27,
              SPACE: 32,
           LCOMMAND: 91,
           RCOMMAND: 93,
             PAGEUP: 33,
           PAGEDOWN: 34,
                END: 35,
               HOME: 36,
               LEFT: 37,
                 UP: 38,
              RIGHT: 39,
               DOWN: 40,
             INSERT: 45,
             DELETE: 46,
               ZERO: 48,
       SEMICOLONMOZ: 59,
          EQUALSMOZ: 61,
                  d: 68,
                  f: 70,
                  h: 72,
                  o: 79,
                  p: 80,
                  x: 88,
                  y: 89,
                  z: 90,
            DASHMOZ: 109,
                 F1: 112,
                 F2: 113,
                 F3: 114,
                 F4: 115,
                 F5: 116,
                 F6: 117,
                 F7: 118,
                 F8: 119,
                 F9: 120,
                F10: 121,
                F11: 122,
                F12: 123,
         DASHMOZNEW: 173,
          SEMICOLON: 186,
             EQUALS: 187,
              COMMA: 188,
               DASH: 189,
             PERIOD: 190,
              SLASH: 191,
           LBRACKET: 219,
           RBRACKET: 221,
        SINGLEQUOTE: 222,
         COMMANDMOZ: 224
    };

    this.__registerToolByName = function(tool, toolName)
    {
        _tools[toolName] = tool;

		tool.utilities = utilities;
		tool.controller = this;
    };

    /**
     * This method registers an event handling tool with the controller. This makes the tool available for activation and deactivation. Tools are registered under one or more names which must be provided via their "getNames" method. The tools "getNames" method must return an array of one or more names. Typically a tool will only have one name but if it wishes to operate in different modes it can use different names to activate the modes. Registered tools have the properties named "utilities" and "controller" added to them which refer to the ViewingUtilities object and this controller respectively. Tools may not use the name "default" which is reserved.
     *  @param {Object} tool - the tool to be registered.
     */
    this.registerTool = function(tool)
    {
        var names = tool.getNames();

        if( !names || names.length == 0 )
        {
            console.log("Cannot register tool with no name.");
            return false;
        }
        var registered = false;
        for( var i = 0; i < names.length; ++i )
        {
            if( names[i] !== "default" )
            {
                this.__registerToolByName(tool, names[i]);
                registered = true;
            }
        }
        return registered;
    };

    /**
     * This method deregisters an event handling tool with the controller afterwhich it will no longer be available for activation and deactivation. All names that the tool is registered under will be deregistered. If any tool is active at the time of deregistration will first be deactivated and it's "deactivate" method will be called.
     *  @param {Object} tool - the tool to be deregistered.
     */
    this.deregisterTool = function(tool)
    {
        var names = tool.getNames();

        if( !names || names.length == 0 )
        {
            return false;
        }
        for( var i = names.length; --i >= 0; )
            this.__deregisterToolName(names[i]);

		tool.utilities = null;
		tool.controller = null;
        return true;
    };

    this.__deregisterToolName = function(name)
    {
        function cleanStack(name)
        {
            for( var i = _toolStack.length;  --i >= 0;  )
                if( _toolStack[i] === name )
                {
                    _tools[name].deactivate(name);
                    _toolStack.splice(i, 1);
                }
        }
        if( name in _tools )
        {
            cleanStack(name);
            delete _tools[name];
        }
    };

    /**
     * This method returns the tool registered under the given name.
     *  @param {string} name - the tool name to look up
     *  @returns {Object} - The tool registered under the given name or undefined if not found.
     */
    this.getTool = function(name)
    {
        return _tools[name];
    };

    /**
     * This method returns the name of the topmost tool on the tool stack. If no tools are active the name of the default tool is returned (which is "default").
     *  @returns {string} name - the tool name to look up
     */
    this.getActiveToolName = function()
    {
        var l = _toolStack.length;
        return (l > 0) ? _toolStack[l-1] : "default";
    };

    /**
     * Activates the tool registered under the given name. Activation implies pushing the tool on a stack of "active" tools, each of which (starting from the top of the stack) is given the opportunity to handle incoming events. Tools may "consume" events by returning true from their event handling methods, or they may allow events to be passed down to the next tool on the stack by returning false from the handling methods. Upon activation the tools "activate" method is called with the name under which it has been activated. Activation is not allowed while the controller is in a "locked" state (see the methods "setIsLocked" and "getIsLocked"). Tools must be registered prior to activation (see the methods "registerTool" and "deregisterTool").
     *  @param {string} toolName - the name of the tool to be activated.
     *  @returns {boolean} - true if activation was successful
     */
    this.activateTool = function(toolName)
    {
        if( _lock )
            return false;

        var tool = _tools[toolName];
        if( tool )
        {
            _toolStack.push(toolName);
            tool.activate(toolName);

            viewerApi.fireEvent(
                {
                    type: Autodesk.Viewing.TOOL_CHANGE_EVENT,
                    toolName: toolName,
                    active: true
                });

            // stderr("push: [" + _toolStack.length + "] = " + toolName);
            return true;
        }
        stderr("activateTool not found: " + toolName);
        return false;
    };

    /**
     * The first tool found on the active stack with the given name is removed and its "deactivate" method is called. Once deactivated the tool will no longer receive events via its handler methods. Deactivation is not allowed while the controller is in a "locked" state (see the methods "setIsLocked" and "getIsLocked").
     *  @param {string} toolName - the name of the tool to be deactivated.
     *  @returns {boolean} - true if deactivation was successful
     */
    this.deactivateTool = function(toolName)
    {
        if( _lock )
            return false;

        for( var i = _toolStack.length;  --i >= 0;  )
        {
            if( _toolStack[i] === toolName )
            {
                _toolStack.splice(i, 1);
                _tools[toolName].deactivate(toolName);

                viewerApi.fireEvent(
                    {
                        type: Autodesk.Viewing.TOOL_CHANGE_EVENT,
                        toolName: toolName,
                        active: false
                    });

                // stderr(" pop: [" + _toolStack.length + "] = " + this.getActiveToolName());
                return true;
            }
        }
        stderr("deactivateTool not found: " + toolName);
        return false;
    };

    /**
     * Obtain a list of all the currently registered tool names.
     *  @returns {Array} - list of all registered tool names.
     */
    this.getToolNames = function()
    {
        return Object.keys(_tools);
    };

    /**
     * Set the tool which will be requested to handle events if no other active tool handles them.
     *  @param {Object} tool - The tool to be registered as the default.
     */
    this.setDefaultTool = function(tool)
    {
        var current = this.getDefaultTool();
        if( tool && tool !== current )
        {
            this.__registerToolByName(tool, "default");
            if( current )
                current.deactivate("default");
            tool.activate("default");
            return true;
        }
        return false;
    };

    /**
     * Get the tool which handle events if no other active tool handles them.
     *  @returns {Object} - The tool to be registered as the default.
     */
    this.getDefaultTool = function()
    {
        return _tools["default"];
    };

    this.setDefaultTool(defaultHandler);

    /**
     * Set the controller into a locked or unlocked state. While locked, tool activation and deactivation is not allowed. Locking the controller is sometimes necessary to force an interaction to remain active until it is fully completed.
     *  @param {boolean} state - The state of the controller lock.
     *  @returns {boolean} - The previous state of the lock (this may be used to restore the lock to it's previous state).
     */
    this.setIsLocked = function(state)
    {
        // if( _lock != !!state )
        //     stderr("lock: " + !!state);

        var prev = _lock;
        _lock = !!state;
        return prev;
    };

    /**
     * Get the current state of the controller lock.
     *  @returns {boolean} - The state of the lock.
     */
    this.getIsLocked = function()
    {
        return _lock;
    };

    this.__checkCursor = function()
    {
        var cursor = null;
        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var tool = _tools[_toolStack[n]];
            if( "getCursor" in tool )
            {
                cursor = tool.getCursor();
                if( cursor )
                    break;
            }
        }
        if( !cursor )
            cursor = "auto";

        if( _currentCursor != cursor )
        {
            viewerApi.canvas.style.cursor = cursor;
            _currentCursor = cursor;
        }
    };

    this.update = function(highResTimestamp)
    {
        this.__checkCursor();

        var refresh = false;

        if( utilities && utilities.update() )
            refresh = true;

        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var tool = _tools[_toolStack[n]];
            if( "update" in tool && tool.update(highResTimestamp) )
                refresh = true;
        }
        if( viewerApi.navigation.getCamera().dirty )
        {
            viewerApi.navigation.updateCamera();
            refresh = true;
            this.cameraUpdated = true;
        } else {
            this.cameraUpdated = false;
        }

        //Delay reporting stationary
        if( refresh )
        {
            viewerApi.navigation.updateCamera();
            this.moveDelay = Date.now() + 150;   // Milliseconds
        }
        else if( this.moveDelay !== 0 )
        {
            var delta = this.moveDelay - Date.now();
            if( delta > 0 )
                refresh = true;
            else
                this.moveDelay = 0;
        }
        return refresh;
    };


    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    this.__clientToCanvasCoords = function (event, normalized, screen)
    {
        var viewport = viewerApi.navigation.getScreenViewport();
        var width  = viewport.width;
        var height = viewport.height;

        // Canvas coordinates: relative to the canvas element.
        // 0 = top left, +ve right and down.
        //
        var canvasX = event.clientX - viewport.left;
        var canvasY = event.clientY - viewport.top;
        event.canvasX = canvasX;
        event.canvasY = canvasY;

        // Normalized coordinates: [-1, +1].
        // 0 = center, +ve = right and up.
        //
        event.normalizedX = (canvasX / width) * 2.0 - 1.0;
        event.normalizedY = ((height - canvasY) / height) * 2.0 - 1.0;

        // Vector: [0, 1].
        // 0 = top left, +ve right and down.
        //
        if (normalized)
            normalized.set(canvasX / width, canvasY / height, 0.0);

        if (screen)
            screen.set(canvasX, canvasY);
    };

    this.__invokeStack = function( method, arg1, arg2 )
    {
        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var name = _toolStack[n];
            var tool = _tools[name];

            if( method in tool && tool[method](arg1, arg2) )
            {
                // console.log(method + " consumed by " + tool.getName() + " = " + arg1.type);
                return true;
            }
        }
        var last = this.getDefaultTool();
        if( method in last )
            return last[method](arg1, arg2);

        return false;
    };

    this.distributeEvent = function(methodName, arg1, arg2)
    {
        return this.__invokeStack(methodName, arg1, arg2);
    };

    this.handleResize = function()
    {
        viewerApi.navigation.setScreenViewport( viewerApi.container.getBoundingClientRect() );

        // Call handleResize on all tools in case they need it:
        for( var n = _toolStack.length;  --n >= 0;  )
        {
            var tool = _tools[_toolStack[n]];

            if( "handleResize" in tool )
                tool.handleResize();
        }
    };

    this.handleSingleClick = function( event )
    {
        var button = this.applyButtonMappings( event );
        this.lastClickX = event.clientX;
        this.lastClickY = event.clientY;

        if( this.__invokeStack("handleSingleClick", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleDoubleClick = function( event )
    {
        var button = this.applyButtonMappings( event );

        if( this.__invokeStack("handleDoubleClick", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleSingleTap = function( event )
    {
        this.lastClickX = event.canvasX;
        this.lastClickY = event.canvasY;

        if( this.__invokeStack("handleSingleTap", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleDoubleTap = function( event )
    {
        this.lastClickX = event.canvasX;
        this.lastClickY = event.canvasY;

        if( this.__invokeStack("handleDoubleTap", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleWheelInput = function(delta, event)
    {
        if( this.__invokeStack("handleWheelInput", delta) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.applyButtonMappings = function( event )
    {
        var button = event.button;

        // Check for Firefox spoof: Control+LMB converted to RMB.
        // The "buttons" property in Firefox will include 1 for LMB and 2 for RMB.
        if( "buttons" in event )
        {
            // This method sometimes gets called more than once with
            // the same event:
            if( event.firefoxSpoof )
            {
                button = kMouseLeft;
            }
            // For button down the 1 bit will be on indicating LMB.
            // For button up it's off so check the flag to see if we
            // switched the down event.
            else if( _firefoxLMBfix && !(event.buttons & 1) ) // Button up?
            {
                event.firefoxSpoof = true;
                _firefoxLMBfix = false;
                button = kMouseLeft;
            }
            else if( (button === kMouseRight) && (event.buttons & 1) )
            {
                button = kMouseLeft;    // Convert back to reality.
                event.firefoxSpoof = _firefoxLMBfix = true;
            }
        }
        if( viewerApi.navigation.getUseLeftHandedInput() )
        {
            button = (button === kMouseLeft)  ? kMouseRight :
                     (button === kMouseRight) ? kMouseLeft  : button
        }
        return button;
    };

    this.applyKeyMappings = function( event, state )
    {
        switch( event.keyCode )
        {
            case _keys.LCOMMAND:
            case _keys.RCOMMAND:
            case _keys.COMMANDMOZ:
                // Most likely is a Mac but check anyway.
                // We need to ignore Command + Shift combo:
                return ( isMac && event.metaKey && event.shiftKey ) ? null : _keys.CONTROL;

            case _keys.SHIFT:
                // We need to ignore Command + Shift combo:
                return ( state && isMac && event.metaKey ) ? null : _keys.SHIFT;

            case _keys.EQUALSMOZ:   return _keys.EQUALS;

            case _keys.DASHMOZNEW:
            case _keys.DASHMOZ:     return _keys.DASH;
        }
        return event.keyCode;
    };

    this.handleKeyDown = function( event )
    {
        var keyCode = this.applyKeyMappings( event, true );

        if( keyCode && this.__invokeStack("handleKeyDown", event, keyCode) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleKeyUp = function( event )
    {
        var keyCode = this.applyKeyMappings( event, true );

        if( keyCode && this.__invokeStack("handleKeyUp", event, keyCode) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleButtonDown = function( event, button )
    {
        if( this.__invokeStack("handleButtonDown", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleButtonUp = function( event, button )
    {
        if( this.__invokeStack("handleButtonUp", event, button) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    this.handleMouseMove = function( event )
    {
        if( this.__invokeStack("handleMouseMove", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    function isValidTap(tap)
    {
        var deltaX = Math.abs(tap.endX - tap.startX);
        var deltaY = Math.abs(tap.endY - tap.startY);
        var deltaT = tap.endTime - tap.startTime;

        var passThreshold = deltaX <= kTapThreshold && deltaY <= kTapThreshold;
        var passLength = deltaT <= kTapLength;
        var pass = passThreshold && passLength;

        // if ( !pass ) {
        //     stderr("INVALID TAP: deltaX="+deltaX+" deltaY="+deltaY+" deltaT="+deltaT);
        // }

        return pass;
    }

    function isSingleTap(tap)
    {
        var delay = Date.now() - tap.endTime;
        return delay >= kDoubleTapDelay;
    }

    function isDoubleTap(tap1, tap2)
    {
        var delay = tap2.startTime - tap1.endTime;
        var deltaX = Math.abs(tap2.endX - tap1.startX);
        var deltaY = Math.abs(tap2.endY - tap1.startY);

        var passThreshold = deltaX <= kDoubleTapThreshold && deltaY <= kDoubleTapThreshold;
        var passDelay = delay <= kDoubleTapDelay;
        var pass = passThreshold && passDelay;

        // if ( !pass ) {
        //     stderr("REJECT DOUBLE TAP: deltaX="+deltaX+" deltaY="+deltaY+" delay="+delay);
        // }

        return pass;
    }

    this.handleBlur = function( event )
    {
        if( this.__invokeStack("handleBlur", event) )
        {
            event.preventDefault();
            event.stopPropagation();
        }
    };

    // ====================================================
    // Event handlers: (only use "_this" in these methods):

    this.keydown = function( event )
    {
        if (_lastTouchedElement !== viewerImpl.canvas
         || document.activeElement instanceof HTMLInputElement
         || document.activeElement instanceof HTMLTextAreaElement) return;

        // stderr("KEYDOWN: " + event.keyCode);

        // Ignore command key shortcuts on the mac.
        // We don't seem to get key up events for these keys.
        if( isMac && event.metaKey && (event.keyCode != _keys.LCOMMAND) && (event.keyCode != _keys.RCOMMAND) )
            return;

        _this.handleKeyDown(event);
    };

    this.keyup = function( event )
    {
        // stderr("KEYUP: " + event.keyCode);

        if( isMac && event.metaKey && (event.keyCode != _keys.LCOMMAND) && (event.keyCode != _keys.RCOMMAND) )
            return;

        _this.handleKeyUp(event);
    };

    this.mousedown = function( event )
    {
        // Don't do blur in full screen (IE issue)
        if (!(_isIE11 && inFullscreen())) {
            document.activeElement.blur();
        }
        
        _this.__clientToCanvasCoords(event);

        var buttonDown = _this.applyButtonMappings( event );
        _this.handleButtonDown( event, buttonDown );

        _this.downX = event.canvasX;
        _this.downY = event.canvasY;

        if( (viewerApi.navigation.getUseLeftHandedInput() && buttonDown === 0) || (isFirefox && buttonDown === 1) )
        {
            var cmdc = _checkMouseDoubleClick;

            var delayOK = ((cmdc.time !== undefined) &&
                ((event.timeStamp - cmdc.time) < kDoubleClickDelayThreshold));

            var positionOK = ((cmdc.x !== undefined && cmdc.y !== undefined) &&
                (Math.abs(cmdc.x - event.canvasX) <= kClickThreshold) &&
                (Math.abs(cmdc.y - event.canvasY) <= kClickThreshold));

            if (!delayOK || !positionOK || (cmdc.clickCount && 2 <= cmdc.clickCount)) {
                cmdc.clickCount = 0;
            }

            if (!cmdc.clickCount) {
                cmdc.clickCount = 1;
                cmdc.x = event.canvasX;
                cmdc.y = event.canvasY;
                cmdc.time = event.timeStamp;

            } else if (cmdc.clickCount === 1) {
                cmdc.clickCount = 2;
            }
        }

        function handleUp(event)
        {
            var buttonUp = _this.applyButtonMappings( event );
            if( buttonUp === buttonDown )
            {
                document.removeEventListener( 'mouseup', handleUp );
                _this.mouseup(event);
            }
        }

        document.addEventListener( 'mouseup', handleUp, false );
    };

    this.mousemove = function( event )
    {
        _this.__clientToCanvasCoords(event);

        var deltaX = _this.downX - event.canvasX;
        var deltaY = _this.downY - event.canvasY;
        if( Math.abs(deltaX) > kClickThreshold || Math.abs(deltaY) > kClickThreshold )
        {
            _this.downX = -1;
            _this.downY = -1;
        }
        _this.handleMouseMove(event);
    };

    this.mouseup = function( event )
    {
        _this.__clientToCanvasCoords(event);

        var buttonUp = _this.applyButtonMappings( event );
        _this.handleButtonUp( event, buttonUp );
        
        var deltaX = _this.downX - event.canvasX;
        var deltaY = _this.downY - event.canvasY;

        _this.downX = -1;
        _this.downY = -1;

        if( Math.abs(deltaX) <= kClickThreshold && Math.abs(deltaY) <= kClickThreshold )
            _this.handleSingleClick( event );

        if( (viewerApi.navigation.getUseLeftHandedInput() && buttonUp === 0) || (isFirefox && buttonUp === 1) )
        {
            var cmdc = _checkMouseDoubleClick;
            if (cmdc.clickCount === 2) {
                _this.handleDoubleClick(event);

                cmdc.clickCount = 0;
                cmdc.x = undefined;
                cmdc.y = undefined;
                cmdc.time = undefined;
            }
        }
    };

    this.doubleclick = function( event )
    {
         _this.__clientToCanvasCoords(event);

        _this.downX = event.canvasX;
        _this.downY = event.canvasY;

        _this.handleDoubleClick( event );
    };

    this.mousewheel = function( event )
    {
        var delta = 0;

        if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9
            delta = event.wheelDelta / 40;
        }
        else if ( event.detail ) { // Firefox
            delta = - event.detail;
        }
        _this.handleWheelInput( delta, event );
    };

    this.blur = function(event)
    {
        _this.handleBlur(event);
    };

    // ??? this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

    this.domElement.addEventListener( 'mousedown', this.mousedown, false );
    // If we want to continue listenting to mouse movements outside of the window
    // we need to tie our event listener to the window
    window.addEventListener( 'mousemove', this.mousemove, false );

    this.domElement.addEventListener( 'dblclick',  this.doubleclick, false );

    // this.domElement.addEventListener( 'mousemove', this.mousemove, false );
    // this.domElement.addEventListener( 'mouseup',   this.mouseup,   false );

    this.domElement.addEventListener( 'mousewheel',     this.mousewheel, false );
    this.domElement.addEventListener( 'DOMMouseScroll', this.mousewheel, false ); // firefox

    //** this.domElement.addEventListener( 'touchstart', function( event ) { _this.touchstart( event )}, false );
    //** this.domElement.addEventListener( 'touchmove', function( event ) { _this.touchmove( event )}, false );

    window.addEventListener( 'keydown', this.keydown, false );
    window.addEventListener( 'keyup',   this.keyup,   false );

    this.mouseover = function(e) {
        _lastTouchedElement = e.target;
        // ??? if (_lastTouchedElement != viewerImpl.canvas) _this.autoMove(-1, false)
    };

    window.addEventListener( 'mouseover', this.mouseover, false );
    window.addEventListener( 'blur', this.blur, false );

    this.uninitialize = function () {
        window.removeEventListener('mousemove', this.mousemove, false);
        window.removeEventListener('keydown', this.keydown, false);
        window.removeEventListener('keyup', this.keyup, false);
        window.removeEventListener('mouseover', this.mouseover, false);
        window.removeEventListener('blur', this.blur, false);

        this.domElement = null;
        this.selector = null;
        this.autocam = null;
        _tools = null;
        _toolStack = null;
        _this = null;
    };

    this.setSelector = function(selector)
    {
        this.selector = selector;
    };

    // Compatibility methods. TODO: eliminate these
    this.set2DMode = function(state) {};
    this.setAutocam = function(autocam) {};
    this.syncCamera = function() {};

    // TODO: implement this in navapi - then set autocam home from navapi values
    this.recordHomeView = function()
    {
        var camera = viewerApi.navigation.getCamera();
        autocam.sync( camera );
        autocam.setHomeViewFrom( camera );
    };
};
;AutodeskNamespace('Autodesk.Viewing');

/**
 * This class provides a variety of utilities convenient to navigation and tool development. This class is instantiated internally and made available to all registered interaction tools via their "utilities" property.
 *  @see Autodesk.Viewing.ToolController
 *  @class
 *  @param {Object} viewerImpl - The viewer implementation object.
 *  @param {Object} autocam - The Autocam interface object
 *  @param {Object} navigation - The Navigation interface object
 *  @constructor
 */
Autodesk.Viewing.ViewingUtilities = function( viewerImpl, autocam, navapi )
{
    this.autocam = autocam;

    var kIndicatorPixelSize = 5;    // Pixels
	var _camera = navapi.getCamera();
    var _savePivot = null;
    var _savePivotSet = false;


    function PivotIndicator( viewerImpl )
    {
        var kFadeTimeMilliseconds = 500;
        var kIndicatorColor   = 0x007F00;
        var kIndicatorOpacity = 0.6;        // Not working for some reason!!!

        var myFadeTime = 0;
        var myGeometry = new THREE.SphereGeometry( 1.0 );
        var myMaterialPre = new THREE.MeshPhongMaterial({color:kIndicatorColor, ambient:kIndicatorColor, opacity:kIndicatorOpacity, transparent:true});
        var myMaterialPost = new THREE.MeshPhongMaterial({color:kIndicatorColor, ambient:kIndicatorColor, opacity:kIndicatorOpacity, transparent:true});
        var myMesh     = new THREE.Mesh( myGeometry, myMaterialPost );
        var myViewer = viewerImpl;

        myViewer.createOverlayScene("pivot", myMaterialPre, myMaterialPost);
        myMesh.visible = false;

        this.shown = function()
        {
			// return myMesh.parent !== undefined;
			return myMesh.visible;
        };

        this.show = function( position, scale, fade )
        {
            myMesh.scale.x = scale;
            myMesh.scale.y = scale;
            myMesh.scale.z = scale;

            myMesh.position.set(position.x, position.y, position.z);
            myMaterialPost.opacity = kIndicatorOpacity; // Start out full opacity
            myMaterialPre.opacity  = kIndicatorOpacity;

            myMesh.visible = true;
            myViewer.addOverlay("pivot", myMesh);

            if( fade )
            {
                myFadeTime = Date.now() + kFadeTimeMilliseconds;
            }
            else
                myFadeTime = 0;
        };

        this.hide = function()
        {
            if( myMesh.visible )
            {
                myMesh.visible = false;
                myViewer.removeOverlay("pivot", myMesh);
                myFadeTime = 0;
            }
        };

        this.fade = function()
        {
            if( myFadeTime > 0 )
            {
                var fadeDelta = myFadeTime - Date.now();

                if( fadeDelta <= 0 )
                {
                    this.hide();
                    return true;
                }
                var opacity = (fadeDelta / kFadeTimeMilliseconds) * kIndicatorOpacity;
                myMaterialPre.opacity  = opacity;
                myMaterialPost.opacity = opacity;
                return true;
            }
            return false;
        };

        this.fading = function()
        {
            return (myFadeTime > 0);
        };
    }

    var _pivotIndicator  = new PivotIndicator(viewerImpl);

    function computeOrthogonalUp(pos, coi, worldUp)
    {
        var eye = coi.clone().sub(pos);
        if( eye.lengthSq() === 0.0 )    // Invalid view?
            return eye.copy(worldUp);

        var right = eye.clone().cross(worldUp);
        if( right.lengthSq() === 0 )
        {
            // If eye and up are colinear, perturb eye
            // to get a valid result:
            if( worldUp.z > worldUp.y )
                eye.y -= 0.0001;
            else
                eye.z -= 0.0001;

            right.crossVectors( eye, worldUp );
        }
        return right.cross(eye).normalize();
    }

    /**
     * This method triggers a camera view transition as specified by the parameters.
     *  @param {THREE.Vector3} pos - The new world space position of the camera.
     *  @param {THREE.Vector3} coi - The new center of interest (look at point).
     *  @param {Number} fov - The new field of view for the camera in degrees.
     *  @param {THREE.Vector3} up - The new camera up direction.
     *  @param {THREE.Vector3} worldUp - The new world up direction.
     *  @param {boolean} reorient - If true the given camera up parameter is ignored and a new up direction will be calculated to be aligned with the given world up direction.
     */
    this.transitionView = function( pos, coi, fov, up, worldUp, reorient )
    {
        worldUp = worldUp || navapi.getWorldUpVector();

        var upVec = reorient ? computeOrthogonalUp(pos, coi, worldUp) : up;
        if( !upVec )
            upVec = _camera.up;

        var targetView = {
            position: pos,
              center: coi,
               pivot: coi,
                 fov: fov,
                  up: upVec,
             worldUp: worldUp,
             isOrtho: (_camera.isPerspective === false)
        };
        autocam.goToView(targetView);
    };

    /**
     * This method triggers a camera view transition to the registered home view for the current scene.
     */
    this.goHome = function()
    {
        autocam.goHome();
    };
    
    /**
     * This method performs a hit test with the current model using a ray cast from the given screen coordinates.
     *  @param {Number} x - The normalized screen x coordinate in [0, 1].
     *  @param {Number} y - The normalized screen y coordinate in [0, 1].
     *  @returns {THREE.Vector3} the world space hit position or null if no object was hit.
     */
    this.getHitPoint = function(x, y)
    {
        y = 1.0 - y;    // Invert Y so 0 == bottom.

        // Map to [-1, 1]
        x = x * 2.0 - 1.0;
        y = y * 2.0 - 1.0;

        var vpVec = new THREE.Vector3(x, y, 1);

        var result = viewerImpl.hitTestViewport(vpVec, false);
        return result ? result.intersectPoint : null;
    };

    /**
     * This method activates the in scene pivot indicator. The pivot is positioned at the current camera's pivot point.
     *  @param {boolean} fadeIt - If true the indicator will be displayed and then fade away after a short period.
     *  @see Autodesk.Viewing.Navigation
     */
    this.activatePivot = function(fadeIt)
    {
        var distance = _camera.isPerspective ? navapi.getPivotPlaneDistance()
                                             : navapi.getEyeVector().length();
        var fov = navapi.getVerticalFov();
        var worldHeight = 2.0 * distance * Math.tan(THREE.Math.degToRad(fov * 0.5));

        var viewport = navapi.getScreenViewport();
        var devicePixelRatio = window.devicePixelRatio || 1;
        var indicatorSize = kIndicatorPixelSize * worldHeight / (viewport.height * devicePixelRatio);

        _pivotIndicator.show( navapi.getPivotPoint(), indicatorSize, fadeIt );
    };

    /**
     * This method changes the display state of the in scene pivot indicator. If the current scene is 2D this method has no effect.
     *  @param {boolean} state - The requested display state for the indicator.
     *  @param {boolean} fadeIt - If true and "state" is also true, the indicator will be displayed and then fade away after a short period.
     *  @see Autodesk.Viewing.Navigation
     */
    this.pivotActive = function( state, fadeIt )
    {
        state = state && !navapi.getIs2D();  // Currently disabled in 2D mode.

        fadeIt = fadeIt || false;

        if( !state && _pivotIndicator.shown() )
        {
            _pivotIndicator.hide();
            return;
        }
        if( state )
            this.activatePivot(fadeIt);
    };

    /**
     * Invoke this method to refresh the pivot indicator and continue its fading action if required.
     */
    this.pivotUpdate = function()
    {
        if( _pivotIndicator.shown() && _pivotIndicator.fade() )
            viewerImpl.invalidate(false, false, true);
    };

    /**
     * Set the current pivot point and pivot set flag. If the pivot indicator is active its position will be updated accordingly.
     *  @param {THREE.Vector3} newPivot - The world space position of the new pivot point.
     *  @param {boolean} preserveView - If false the camera's view direction will change to look at the new pivot point. If true the camera's view will not be changed.
     *  @param {boolean} isset - The new state of the pivot set flag.
     *  @see Autodesk.Viewing.Navigation
     */
    this.setPivotPoint = function( newPivot, preserveView, isset )
    {
        // Disallow setting the pivot when in 2D.
        if (navapi.getIs2D())
            return;

        navapi.setPivotPoint(newPivot);

        if( !preserveView )
            navapi.setTarget(newPivot);

        if( isset )
            navapi.setPivotSetFlag(true);

        if( _pivotIndicator.shown() ) // The pivot indicator location may need updating:
            this.activatePivot(_pivotIndicator.fading());
    };

    /**
     * Save a copy of the current pivot point and pivot set flag. 
     */
    this.savePivot = function()
    {
        _savePivot    = navapi.getPivotPoint();
        _savePivotSet = navapi.getPivotSetFlag();
    };

    /**
     * Restore the saved copy of the current pivot point and pivot set flag. 
     */
    this.restorePivot = function()
    {
        if( _savePivot !== null )
        {
            this.setPivotPoint( _savePivot, true, _savePivotSet );
            if( !_savePivotSet )
            {
                // Force the flag off, setPivotPoint only turns it on.
                navapi.setPivotSetFlag(false);
            }
            _savePivot = null;
        }
    };

    /**
     * Return the bounding box of the current model or model selection.
     *  @param {boolean} ignoreSelection - If true the current selection is ignored and the model bounds is returned.
     *  @returns {THREE.Box3}
     */
    this.getBoundingBox = function( ignoreSelection )
    {
        return viewerImpl.getFitBounds(ignoreSelection);
    }; 
    
    /**
     * Request a camera transition to fit the current model or model selection into the view frustum.
     *  @param {boolean} immediate - If true the transition will be immediate, otherwise animated over a short time period.
     *  @returns {Object} - fit positioning information with properties "position" and "target".
     */
    this.fitToView = function(immediate)
    {
        var fit = navapi.fitBounds(immediate, viewerImpl.getFitBounds(false));

        // Show the pivot on a fit:
        this.activatePivot(true);

        return fit;
    };

    this.update = function()
    {
        if( navapi.getRequestFitToView() && !navapi.getTransitionActive() )
        {
            navapi.setRequestFitToView(false);
            this.fitToView();
        }
        if( navapi.getRequestHomeView() && !navapi.getTransitionActive() )
        {
            navapi.setRequestHomeView(false);
            this.goHome();
        }
        var request = navapi.getRequestTransition();
        if( request && !navapi.getTransitionActive() )
        {
            navapi.setRequestTransition(false);
            this.transitionView( request.position, request.coi, request.fov, request.up, request.worldUp, request.reorient );
        }
        return false;
    };
};
;AutodeskNamespace('Autodesk.Viewing');
//
// This object handles the default click behaviour, some of which is controlled
// via the "setClickBehavior" configuration.
//
Autodesk.Viewing.DefaultHandler = function( viewerImpl, navapi, utilities )
{
    this.clickConfig = null;

    this.getNames = function()
    {
        return [ "default" ];
    };

    this.setClickBehavior = function(config)
    {
        this.clickConfig = config;
    };

    this.getClickBehavior = function()
    {
        return this.clickConfig;
    };
    
    this.activate = function(name) {};
    this.deactivate = function(name) {};

    this.handleAction = function(actionArray, rayData)
    {
        for (var i=0; i < actionArray.length; ++i) {
            switch(actionArray[i]) {
            case "selectOnly":
                if (viewerImpl.selector) {
                    if (rayData.node) {
                        viewerImpl.selector.setSelection([rayData.node]);
                    }
                }
                break;
            case "deselectAll":
                if (viewerImpl.selector) {
                   viewerImpl.selector.setSelection([]);
                }
                break;
            case "selectToggle":
                if (viewerImpl.selector) {
                    if (rayData.node) {
                        viewerImpl.selector.toggleSelection(rayData.node);
                    }
                }
                break;
            case "isolate":
                if (rayData.node) {
                    viewerImpl.isolate(rayData.node);
                }
                break;
            case "showAll":
                viewerImpl.showAll();
                break;
            case "setCOI":
                if (rayData.intersectPoint) {
                    utilities.setPivotPoint( rayData.intersectPoint, true, true );
                    utilities.pivotActive(true, true);
                }
                break;
            case "hide":
                if (rayData.node) {
                    viewerImpl.hideMultiple([rayData.node]);
                }
                break;
			case "show":
                if (rayData.node) {
                    viewerImpl.showMultiple([rayData.node]);
                }
                break;
			case "toggleVisibility":
                if (rayData.node) {
                    viewerImpl.toggleVisibility(rayData.node);
                }
                break;
            case "focus":
                // As a side effect of focus we also select
                if (viewerImpl.selector) {
                    if (rayData.node) {
                        viewerImpl.selector.setSelection([rayData.node]);
                    } else {
                        viewerImpl.selector.setSelection([]);
                    }
                    utilities.fitToView();
                }
                break;
            }
        }
    };

    this.handleSingleClick = function( event, button )
    {
        var control = event.ctrlKey || event.metaKey;
        var shift   = event.shiftKey;
        var alt     = event.altKey;

        if (button === 0) {
            var click = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(click, false);
            var key = "click";

            if (control) key += "Ctrl";
            if (shift)   key += "Shift";
            if (alt)     key += "Alt";
            
            var objectKey = result.node ? "onObject" : "offObject";

            if (this.clickConfig && this.clickConfig[key] && this.clickConfig[key][objectKey]) {
                this.handleAction(this.clickConfig[key][objectKey], result);
                return true;
            }
        }
        else if (button === 1 && shift && !alt && !control) {
            var click = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(click, false);
            if( result.intersectPoint )
            {
                utilities.setPivotPoint( result.intersectPoint, true, true );
                utilities.pivotActive(true, true);
                return true;
            }
        }
        return false;
    };
    
    this.handleDoubleClick = function( event, button )
    {
        if( viewerImpl.selector != null && button === 0 )
        {
            var click = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(click, false);
            if (result.node) {
                viewerImpl.selector.setSelection([result.node]);
            }
            else {
                viewerImpl.selector.clearSelection();
            }
            utilities.fitToView();
            return true;
        }
        if( button === 1 )
        {
            navapi.fitBounds(false, utilities.getBoundingBox(true));
            navapi.setPivotSetFlag(false);
            return true;
        }
        return false;
    };

    this.handleSingleTap = function( event )
    {
        return this.handleSingleClick(event, 0);
    };

    this.handleDoubleTap = function( event )
    {
        if( viewerImpl.selector != null )
        {
            var vp = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
            var result = viewerImpl.hitTestViewport(vp, false);

            if (result.node) {
                viewerImpl.selector.setSelection([result.node]);
            }
            else {
                viewerImpl.selector.clearSelection();
            }
            utilities.fitToView();
            return true;
        }
        return false;
    };

}
;AutodeskNamespace('Autodesk.Viewing');


Autodesk.Viewing.GestureHandler = function(viewerApi)
{
    var _navapi = viewerApi.navigation;
    var _names = [ "gestures" ];
    var _this = this;

    var isTouch = ('ontouchstart' in window);

    _navapi.setIsTouchDevice(isTouch);
    if( isTouch )
    {
        var hammer = new Hammer.Manager(viewerApi.canvas, {
            recognizers: [
                // RecognizerClass, [options], [recognizeWith, ...], [requireFailure, ...]
                [Hammer.Tap, { event: 'doubletap', taps: 2, interval: 500, threshold: 6, posThreshold: 30 } ],
                [Hammer.Tap, { event: 'singletap' } ],
                [Hammer.Pan, { event: 'drag3', pointers: 3, threshold: 15 } ],
                [Hammer.Pan, { event: 'pan', pointers: 2, threshold: 20 } ],
                [Hammer.Pan, { event: 'drag', pointers: 1 } ],
                [Hammer.Rotate, { enable: true, threshold: 7.0 }],
                [Hammer.Pinch, { enable: true, threshold: 0.05 }],
            ]
        });
    }

    this.getNames = function() {
        return _names;
    };

    this.getName = function() {
        return _names[0];
    };

    function dirToString(obj) {
        var output = [];
        for(var key in obj) {
            if(obj.hasOwnProperty(key)) {
                var value = obj[key];
                if(Array.isArray(value)) {
                    value = "Array("+ value.length +"):"+ value;
                } else if(value instanceof HTMLElement) {
                    value = value +" ("+ value.outerHTML.substring(0, 50) +"...)";
                }
                output.push(key +": "+ value);
            }
        }
        return output.join("\n")
    };


    this.__clientToCanvasCoords = function (event)
    {
        var viewport = _navapi.getScreenViewport();
        var width  = viewport.width;
        var height = viewport.height;

        // Canvas coordinates: relative to the canvas element.
        // 0 = top left, +ve right and down.
        //
        var canvasX = event.center.x - viewport.left;
        var canvasY = event.center.y - viewport.top;

        event.canvasX = canvasX;
        event.canvasY = canvasY;

        // Normalized coordinates: [-1, +1].
        // 0 = center, +ve = right and up.
        //
        event.normalizedX = (canvasX / width) * 2.0 - 1.0;
        event.normalizedY = ((height - canvasY) / height) * 2.0 - 1.0;
    };


    this.distributeGesture = function(event)
    {
        // console.log("====\n" + dirToString(event));

        _this.__clientToCanvasCoords(event);

        // console.log("Gesture: " + event.type);
        if( _this.controller.distributeEvent("handleGesture", event) )
            event.preventDefault();
    };

    this.onSingleTap = function(event)
    {
        // console.log("====\n" + dirToString(event));

        _this.__clientToCanvasCoords(event);

        if( _this.controller.distributeEvent("handleSingleTap", event) )
            event.preventDefault();
    };

    // TODO: Why is this not working? We aren't getting double tap events!
    this.onDoubleTap = function(event)
    {
        // console.log("====\n" + dirToString(event));

        _this.__clientToCanvasCoords(event);

        if( _this.controller.distributeEvent("handleDoubleTap", event) )
            event.preventDefault();
    };

    this.activate = function(name)
    {
        if( hammer )
        {
            hammer.on("dragstart dragmove dragend", this.distributeGesture);
            hammer.on("panstart panmove panend", this.distributeGesture);
            hammer.on("pinchstart pinchmove pinchend", this.distributeGesture);
            hammer.on("rotatestart rotatemove rotateend", this.distributeGesture);
            hammer.on("drag3start drag3move drag3end", this.distributeGesture);
            hammer.on("singletap", this.onSingleTap);
            hammer.on("doubletap", this.onDoubleTap);

            // we only want to trigger a tap, when we don't have detected a doubletap
            hammer.get('doubletap').recognizeWith('singletap');
            // hammer.get('singletap').requireFailure('doubletap');
        }
    };

    this.deactivate = function(name)
    {
        if( hammer )
        {
            hammer.off("dragstart dragmove dragend", this.distributeGesture);
            hammer.off("panstart panmove panend", this.distributeGesture);
            hammer.off("pinchstart pinchmove pinchend", this.distributeGesture);
            hammer.off("rotatestart rotatemove rotateend", this.distributeGesture);
            hammer.off("drag3start drag3move drag3end", this.distributeGesture);
            hammer.off("singletap", this.onSingleTap);
            hammer.off("doubletap", this.onDoubleTap);
        }
    };


    this.update = function()
    {
        return false;
    };


    this.handleBlur = function(event) {
        return false;
    };
};
;AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.OrbitDollyPanTool = function( viewerImpl, viewerApi )
{
    var _this = this;
    var kScreenEpsilon = 0.001;
    var kEpsilon = 0.00001;
    var kAutoDeltaZ  = 1.5;         // Dolly increment
    var kAutoDeltaXY = 0.01;
    var kAutoScreenXY = 20;
    var kDollyDragScale = 100.0;
    var kDollyPinchScale = 0.5;

    var isMac = (navigator.userAgent.search("Mac OS") != -1);

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["orbit", "dolly", "pan"];

    var _activeMode = _names[0];            
    var _activations = [ _activeMode ];   // Safeguard
    var _activatedMode = _activeMode;

    var _touchType = null;
    var _dollyScale = 1.0;
    var _prevDollyScale = 1.0;

    var _activeModeLocked = false;
    var _autoCamStartXY = null;
    var _interactionActive = false;
    var _lastMouseX, _lastMouseY;
    var _wheelAccum = 0;
    var _wheelOldest = null;
    var _wheelNewest = null;

    var _keys = {
          BACKSPACE: 8,
                TAB: 9,
              ENTER: 13,
              SHIFT: 16,
            CONTROL: 17,
                ALT: 18,
             ESCAPE: 27,
              SPACE: 32,
           LCOMMAND: 91,
           RCOMMAND: 93,
             PAGEUP: 33,
           PAGEDOWN: 34,
                END: 35,
               HOME: 36,
               LEFT: 37,
                 UP: 38,
              RIGHT: 39,
               DOWN: 40,
             INSERT: 45,
             DELETE: 46,
               ZERO: 48,
       SEMICOLONMOZ: 59,
          EQUALSMOZ: 61,
                  d: 68,
                  f: 70,
                  h: 72,
                  o: 79,
                  p: 80,
                  x: 88,
                  y: 89,
                  z: 90,
            DASHMOZ: 109,
                 F1: 112,
                 F2: 113,
                 F3: 114,
                 F4: 115,
                 F5: 116,
                 F6: 117,
                 F7: 118,
                 F8: 119,
                 F9: 120,
                F10: 121,
                F11: 122,
                F12: 123,
         DASHMOZNEW: 173,
          SEMICOLON: 186,
             EQUALS: 187,
              COMMA: 188,
               DASH: 189,
             PERIOD: 190,
              SLASH: 191,
           LBRACKET: 219,
           RBRACKET: 221,
        SINGLEQUOTE: 222,
         COMMANDMOZ: 224
    };

    // Interaction Triggers:
    var kNone = -5;
    var kKeyboard = -4;
    var kWheel = -1;
    var kMouseLeft = 0;
    var kMouseMiddle = 1;
    var kMouseRight = 2;
    var kTouch = 3;

    var _activeTrigger = kNone;
    var _startXYZ = new THREE.Vector3();
    var _moveXYZ  = new THREE.Vector3();
    var _touchStartXY  = new THREE.Vector2();
    var _startXY  = new THREE.Vector2();
    var _moveXY   = new THREE.Vector2();
    var _deltaXY  = new THREE.Vector2();
    var _motionDelta = new THREE.Vector3();
    var _autoMove = [false, false, false, false, false, false];  // left, right, up, down, in, out
    var _modifierState = { SHIFT: 0, ALT: 0, CONTROL: 0, SPACE: 0 };
    
    var kDampingFactor = 0.6;
    var kLookSpeedDefault = 5.0;
    var kDollySpeedDefault = 0.025;
    var kMinDollySpeed = 0.01;
    var kDollyScale = 0.6;

    var _trackingDistance = 1.0;
    var myLookSpeed = kLookSpeedDefault;
    var myDollySpeed = kDollySpeedDefault;

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
        // console.log("ACTIVATE: " + _activatedMode + " => " + name);
        _activations.push(name);
        _activatedMode = name;
    };

    this.deactivate = function(name)
    {
        var end = _activations.length - 1;
        if( end > 0 && _activations[end] === name )
        {
            _activations.pop();
            _activatedMode = _activations[end-1];
            // console.log("DEACTIVATE: " + name + " => " + _activatedMode );
        }
    };

    this.adjustDollyLookSpeed = function( direction )
    {
        if( direction === 0 )
        {
            myDollySpeed = kDollySpeedDefault;
            myLookSpeed  = kLookSpeedDefault;
        }
        else
        {
            myDollySpeed *= (direction > 0) ?  1.10 : 0.90;
            myLookSpeed  *= (direction > 0) ?  1.10 : 0.90;

            // May need more appropriate minimums (and maximums) here.
            if( myDollySpeed < 0.000001 )
                myDollySpeed = 0.000001;

            if( myLookSpeed < 0.000001 )
                myLookSpeed = 0.000001;
        }
    };

    this.getDollySpeed = function()
    {
        // The distance that one unit of virtual dolly will move:
        var distance = _navapi.getPivotPlaneDistance() * myDollySpeed;
        return (distance < kMinDollySpeed) ? kMinDollySpeed : distance;
    };

    this.getLookSpeed = function()
    {
        return myLookSpeed;
    };

    function coiIsBehind()
    {
        var position = _navapi.getPosition();
        var pivot = _navapi.getPivotPoint();
        var view  = _navapi.getEyeVector();

        return (pivot.sub(position).dot(view) < 0.0);
    }

    this.coiIsVisible = function()
    {
        if( coiIsBehind() )
            return false;

        // Note, these are normalized:
        var right = _navapi.getCameraRightVector();
        var up    = _navapi.getCameraUpVector();

        var eye = _navapi.getPosition();
        var eyeCOI = _navapi.getPivotPoint().sub(eye);

        var offX = Math.abs(right.dot(eyeCOI));
        var offY = Math.abs(up.dot(eyeCOI));

        var halfW, halfH;
        if( _camera.isPerspective )
        {
            var viewport = _navapi.getScreenViewport();
            halfH = _navapi.getPivotPlaneDistance() * Math.tan(THREE.Math.degToRad(_camera.fov * 0.5));
            halfW = halfH * (viewport.width / viewport.height);
        }
        else
        {
            halfW = _camera.right;
            halfH = _camera.top;
        }
        return (offX < halfW) && (offY < halfH);
    };

    this.coiIsActive = function()
    {
        return _navapi.getPivotSetFlag() && this.coiIsVisible();
    };
    
    this.adjustSpeed = function( direction )
    {
        this.adjustDollyLookSpeed( direction );

        if( this.utilities.autocam )
            this.utilities.autocam.orbitMultiplier = this.getLookSpeed();
    };

    // TO DO: Where/when do we push/pop tool state?
    function isTrack()
    {
        var mod = _modifierState;
        return ((_activeTrigger === kMouseRight)  && !mod.SHIFT && !(mod.ALT ^ mod.CONTROL))
            || ((_activeTrigger === kMouseMiddle) && !mod.SHIFT && !mod.CONTROL)
            || ((_activeTrigger === kMouseMiddle) && mod.ALT)
            || ((_activeTrigger === kMouseMiddle) && mod.CONTROL && !mod.SHIFT && !mod.ALT)
            || ((_activeTrigger === kMouseLeft) && mod.SHIFT && !mod.CONTROL && !mod.ALT)
            || ((_activatedMode === "pan") && (_activeTrigger !== kMouseMiddle) && !mod.ALT && !(_touchType === "pinch"))
            || (mod.SPACE);
    }

    function isDolly()
    {
        var mod = _modifierState;
        return ((_activeTrigger === kMouseRight)  && mod.SHIFT && !mod.ALT && !mod.CONTROL)
            || ((_activeTrigger === kMouseRight)  && mod.ALT && !mod.SHIFT && !mod.CONTROL)
            || ((_activatedMode === "dolly") && !mod.ALT && !(_touchType === "pinch"))
    }

    function shouldPanOverrideDolly()
    {
        var mod = _modifierState;
        return !mod.CONTROL && !mod.ALT && !mod.SHIFT && (_activeTrigger === kMouseRight || _activeTrigger === kMouseMiddle);
    }

    function getTriggeredMode()
    {
        return (isDolly() || _motionDelta.z !== 0.0) ? shouldPanOverrideDolly() ? "pan" : "dolly"
             : isTrack() ? "pan"
             : (_touchType === 'pan' || _touchType === 'pinch') ? "dollypan"
             : !_navapi.getIs2D() ? "orbit"
             : _activatedMode;
    }

    this.initTracking = function(x, y)
    {
        var distance;

        if( !_camera.isPerspective )
        {
            distance = _navapi.getEyeVector().length();
        }
        else
        {
            // Decide what point in world space defines the plane 
            // orthogonal to the view that will be used to track
            // the camera. If we get an intersection point use it,
            // otherwise use the COI/pivot point.
            var p = this.utilities.getHitPoint(x, y);
            var position = _navapi.getPosition();
            if( p && p.sub )
            {
                // Calculate orthogonal distance along view vector:
                var hitToEye = p.sub(position);
                var view = _navapi.getEyeVector().normalize();
                distance = Math.abs(view.dot(hitToEye));
            }
            else
            {
                distance = _navapi.getPivotPlaneDistance();
            }
        }
        _trackingDistance = distance;
    };

    this.getCursor = function()
    {
        switch( _activeMode )
        {
            case "orbit":
                return 'url(data:image/x-icon;base64,AAACAAEAGBgAAAAAAACICQAAFgAAACgAAAAYAAAAMAAAAAEAIAAAAAAAYAkAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAsQAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYRERH/sbGx/wAAALEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEQcHB/9/f3///////wAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAdCAgI/3p6ev///////////wAAAP8AAADWAAAAqAAAAHwAAABKAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQAAAHQEBAT/AAAABAAAABQUFBT/hoaG/////////////////+Hh4f/W1tb/qKio/3x8fP9KSkr/EhIS/wAAAHQAAAAdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEHR0d/3R0dP9nZ2f/AAAAdgAAABQUFBT/sbGx//////////////////z8/P//////////////////////x8fH/3R0dP8dHR3/AAAARAAAAAAAAAAAAAAAAAAAADQ0NDT/ra2t///////f39//VFRU/wQEBP8BAQH/MDAw/7q6uv///////////4iIiP9mZmb/g4OD/7W1tf/t7e3///////////+tra3/NDQ0/wAAADQAAAAAAAAAAAAAAJ2dnZ3//////+Li4v+Li4v/MTEx/wAAADEAAAABAAAAUScnJ/+5ubn//////wAAAP8AAABmAAAAgwAAALU4ODj/i4uL/+Li4v//////nZ2d/wAAAJ0AAAAAAAAAAAAAAO/v7+///////2JiYv8AAACLAAAAOAAAAAEAAAAJAAAAAAAAAFAsLCz/uLi4/wAAALgAAAAAAAAAAAAAAAAAAAA4AAAAi2JiYv//////7+/v/wAAAO8AAAAAAAAAAAAAAJ2dnZ3//////+Li4v+Li4v/ODg4/wEBAf8JCQn/AAAAVwAAADMAAABPCwsL/wAAAE8AAABXAAAAgwAAALU4ODj/i4uL/+Li4v//////nZ2d/wAAAJ0AAAAAAAAAAAAAADQ0NDT/ra2t////////////7e3t/7W1tf+Dg4P/V1dX/zMzM/8YGBj/FxcX/zMzM/9XV1f/g4OD/7W1tf/t7e3///////////+tra3/NDQ0/wAAADQAAAAAAAAAAAAAAAAAAABEHR0d/3R0dP/Hx8f/////////////////////////////////////////////////////////////////x8fH/3R0dP8dHR3/AAAARAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQAAAHQSEhL/SkpK/3x8fP+oqKj/zMzM/+jo6P/5+fn/+fn5/+jo6P/MzMz/qKio/3x8fP9KSkr/EhIS/wAAAHQAAAAdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAASgAAAHwAAACoAAAAzAAAAOgAAAD5AAAA+QAAAOgAAADMAAAAqAAAAHwAAABKAAAAEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNAAAA9gAAAI0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD29vb2/0hISP8AAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///////n5+f9OTk7/AAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////5+fn/Tk5O/wAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////+fn5/wAAAPkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACWAAAA/wAAAP8AAAD/AAAA+QAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8x////O////1D/8f9y/+H/Rv/B/3P9gA9k8AADXOAAAVzAAABnwAAAIMAhwGXAAAB4wAAAXOAAAWPwAANt/AAPVP///3Qf//87D///cAf//28D//9cA///XAP//2c=), wait';

            case "dolly":
                return "url(data:image/x-icon;base64,AAACAAEAGBgAAAAAAACICQAAFgAAACgAAAAYAAAAMAAAAAEAIAAAAAAAYAkAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANQAAAJ4AAACeAAAANQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5CQkJ/56env+enp7/CQkJ/wAAADkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8JCQn/oqKi////////////oqKi/wkJCf8AAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATQsLC/+oqKj//////////////////////6ioqP8LCwv/AAAATQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYDg4O/7a2tv////////////////////////////////+2trb/Dg4O/wAAAFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQMDAz/wcHB////////////////////////////////////////////wcHB/wwMDP8AAABkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYxoaGv/Nzc3//////////////////////////////////////////////////////83Nzf8aGhr/AAAAYwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoKCgo/8zMzP/////////////////////////////////////////////////////////////////MzMz/KCgo/wAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7Ozs7/2lpaf9qamr/gICA/76+vv////////////////////////////////++vr7/gICA/2pqav9paWn/Ozs7/wAAADsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOwAAAGkAAABqAAAAgE5OTv////////////////////////////////9OTk7/AAAAgAAAAGoAAABpAAAAOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJP////////////////////////////////8kJCT/AAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAv/29vb///////////////////////b29v8CAgL/AAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMzMzMz//////////////////////8zMzP8AAADMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ2dnZ3//////////////////////52dnf8AAACdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGhoaGj//////////////////////2hoaP8AAABoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAADs7Ozv//////////////////////zs7O/8AAAA7AAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGBgYG/wAAAGQAAAD7+/v7////////////+/v7/wAAAPsAAABkBgYG/wAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBA/2RkZP9RUVH/8vLy////////////8vLy/1FRUf9kZGT/QEBA/wAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNAAAA9gAAAI0AAAAAAAAAEQAAAAAAAAAmJiYm/6mpqf////////////////////////////////+pqan/JiYm/wAAACYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD29vb2/0hISP8AAACQAAAAAAAAABEAAAAAAAAAQAAAAKlZWVn/6enp////////////6enp/1lZWf8AAACpAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///////n5+f9OTk7/AAAAkAAAAAAAAAADAAAAAAAAAAAAAACAJycn/729vf+9vb3/Jycn/wAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////5+fn/Tk5O/wAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAVAAAAL0AAAC9AAAAVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////+fn5/wAAAPkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACWAAAA/wAAAP8AAAD/AAAA+QAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8x////O8A8A1CAGAFyAAAARgAAAHMPAPBkDwDwXA8A8FwPAPBnAAAAIAAAAGWAAAF4gAABXMAAA2PAAANt4AAHVOAAB3QQAA87CBgPcAQ8H28D//9cA///XAP//2c=), wait";

            case "pan":
                return "url(data:image/x-icon;base64,AAACAAEAGBgAAAAAAACICQAAFgAAACgAAAAYAAAAMAAAAAEAIAAAAAAAYAkAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0NDUsNDA2zMjEy31lZWfNQUFDrKysrwwkJCZAMDAxgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPDw8ZDQ0NoVxcXfbLy8v/4ODh//b29//y8fL/3Nzc/8nJyf98e3z/FRUWuQ0NDSYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCT0mJSbSlpaW//7+/v//////////////////////////////////////uLe4/zc2N+MNDQ00AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUFBQFCgoJcD4+P/HMzM3//////////////////////////////////////////////////////8/Pz/8kJCTCEREREwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8PD0oTExOPcXFy//Ly8v//////8/Pz//v7+/////////////////////////////////////////////////+AgID/BAQEQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwcHLpNTU36+vr6/+fn5/99e33/Ly8v83d3eP3///////////////////////////////////////////////+bm5v/CQkJXQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABISElIbGxuaZGRk/zIyMusODg6GCQkJXVFRUvj8/Pz///////////////////////////////////////////+dnZ3/DAwMaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUFBQKBwcHPA8PDykAAAAADg4OUnBvcP7///////////////////////////////////////////////+BgYH/BAQEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhYWqcPDw////////////////////////////////////////////+Xl5f8tLS2+Dw8PDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBA4Pz8/6/////+7u7z/1dXW///////4+Pj//////////////////////6Ojo/8HBwdwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABUVFQELCwuTsLCw//39/v+Dg4T/19fX/+Li4v+ZmJr//////9vb2/+6urv//////zMzM94SEhIUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDCc7Ozzx8fDx/8zMzf+SkZP//////5qam/+np6f//////5mYm//Hx8j/ubm5/xEREZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCWqSkpL//////5iXmf/P0ND/8/Pz/3h3ef/o6Oj/7e3u/3Fxc///////Tk5O+woKChwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg4OBy0tLeri4eL/9/f3/29tcP//////qqqr/5qZmv//////mZma/8zMzf/Kysr/HR0engAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQByMjI8+mpqb/mZiZ/8LCw//6+vr/fn6A/9LS0v/8/P3/a2pu//////92dnb4BAQEOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQUFBwHBweAGhoa5f/////Kysr/i4qM//////+vr7D/MC8x/3x8fP8mJiawERERCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhYWok5OTvY0NDT1Pj4++aGhof86OjvNCQkJTAgICGATExMnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNAAAA9gAAAI0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFRUVCAoKCg8NDQ0KEBEQKxQUFH4SEhIpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD29vb2/0hISP8AAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///////n5+f9OTk7/AAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////5+fn/Tk5O/wAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////+fn5/wAAAPkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACWAAAA/wAAAP8AAAD/AAAA+QAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8x/+AfO/+AB1D/AANy/AABRvgAAXP4AAFk+AABXPxAAVz/wAFn/4ADIP8AA2X/AAd4/wAHXP4AD2P+AA9t/wAPVP/AH3QfwP87D///cAf//28D//9cA///XAP//2c=), wait";
        }
        return null;
    };

    this.getMotionDelta = function(dxyz, dxy)
    {
        // Add any offset triggered by key controls:
        // TODO: Change these to scale based on real time so fast frame
        // rate doesn't cause super fast motion.

        var autoDeltaZ = (_navapi && _navapi.getReverseZoomDirection()) ? -kAutoDeltaZ : kAutoDeltaZ;
        if( isMac )
            autoDeltaZ *= -1;   // Match the "natural" scroll direction on Mac.

        if( _autoMove[0] ) { _moveXYZ.x += kAutoDeltaXY; _moveXY.x += kAutoScreenXY; }
        if( _autoMove[1] ) { _moveXYZ.x -= kAutoDeltaXY; _moveXY.x -= kAutoScreenXY; }
        if( _autoMove[2] ) { _moveXYZ.y += kAutoDeltaXY; _moveXY.y += kAutoScreenXY; }
        if( _autoMove[3] ) { _moveXYZ.y -= kAutoDeltaXY; _moveXY.y -= kAutoScreenXY; }
        if( _autoMove[4] ) { _moveXYZ.z += autoDeltaZ; }
        if( _autoMove[5] ) { _moveXYZ.z -= autoDeltaZ; }

        var deltaX = _moveXYZ.x - _startXYZ.x;
        var deltaY = _moveXYZ.y - _startXYZ.y;
        var deltaZ = _moveXYZ.z - _startXYZ.z;

        if( Math.abs(deltaX) < kScreenEpsilon ) deltaX = 0.0;
        if( Math.abs(deltaY) < kScreenEpsilon ) deltaY = 0.0;
        if( Math.abs(deltaZ) < kScreenEpsilon ) deltaZ = 0.0;

        dxyz.set(deltaX, deltaY, deltaZ);

        if( dxy )
        {
            dxy.set(_moveXY.x - _startXY.x, _moveXY.y - _startXY.y);
        }
    };

    this.stepMotionDelta = function(delta, damped)
    {
        if( damped )
        {
            _startXYZ.x += delta.x * kDampingFactor;
            _startXYZ.y += delta.y * kDampingFactor;
            _startXYZ.z += delta.z * kDampingFactor;
        }
        else
            _startXYZ.copy(_moveXYZ);

        _startXY.copy(_moveXY);
    };

    this.update = function()
    {
        var wheelEnded = false;
        var updatePivot = false;

        this.getMotionDelta(_motionDelta, _deltaXY);

        var deltaX = _motionDelta.x;
        var deltaY = _motionDelta.y;
        var deltaZ = _motionDelta.z;

        if( !_activeModeLocked )
            this.checkInteractionMode();

        _activeModeLocked = (_activeTrigger > kWheel);

        if( _activeModeLocked )
            this.controller.setIsLocked(true);

        if( deltaX !== 0.0 || deltaY !== 0.0 || deltaZ !== 0.0 )
        {
            switch( _activeMode )
            {
                case "orbit":
                    if( this.utilities.autocam && this.utilities.autocam.startState )
                    {
                        _deltaXY.x = -_deltaXY.x;
                        if( _autoCamStartXY )
                            this.utilities.autocam.orbit(_moveXY, _autoCamStartXY, _deltaXY, this.utilities.autocam.startState);
                    }
                    break;

                case "dolly":
                    var dollyTarget, screenX, screenY;

                    deltaZ *= kDollyScale;

                    if( _activeTrigger >= kMouseLeft )
                    {
                        // Map XY movement to Z:
                        deltaY = -deltaY;   // Invert Y
                        deltaZ = (Math.abs(deltaX) > Math.abs(deltaY)) ? deltaX : deltaY;
                        deltaZ *= kDollyDragScale;
                        deltaX = 0.0;
                        deltaY = 0.0;

                        // Towards center of screen:
                        screenX = screenY = 0.5;
                    }
                    else
                    {
                        // Towards cursor position:
                        var viewport = _navapi.getScreenViewport();
                        screenX = (_lastMouseX - viewport.left) / viewport.width;
                        screenY = (_lastMouseY - viewport.top) / viewport.height;
                    }
                    if( !_navapi.getIs2D() && _navapi.getZoomTowardsPivot() )
                    {
                        if( !this.coiIsActive() )
                        {
                            // Center of screen if pivot is not active
                            dollyTarget = _navapi.getWorldPoint(0.5, 0.5);
                        }
                        else
                            dollyTarget = _navapi.getPivotPoint();
                    }
                    else
                        dollyTarget = _navapi.getWorldPoint(screenX, screenY);

                    _navapi.dollyFromPoint(deltaZ * this.getDollySpeed(), dollyTarget);
                    break;

                case "pan":
                    // Moving camera down/left moves the model up/right:
                    _navapi.panRelative(-deltaX, deltaY, _trackingDistance);
                    break;

                case "dollypan":
                    if( deltaX !== 0.0 || deltaY !== 0.0 )
                        _navapi.panRelative(-deltaX, deltaY, _trackingDistance);

                    // Towards cursor position:
                    var viewport = _navapi.getScreenViewport();
                    screenX = (_lastMouseX - viewport.left) / viewport.width;
                    screenY = (_lastMouseY - viewport.top) / viewport.height;

                    dollyTarget = _navapi.getWorldPoint(screenX, screenY);
                    var position = _navapi.getPosition();
                    var distance = position.sub(dollyTarget).length();

                    // Note: Touch returns a scale value based on the start point
                    // but we are dollying incrementally, so convert to delta.
                    var touchScale = (_dollyScale - _prevDollyScale) * kDollyPinchScale;

                    // console.log("dollypan: scale: " + -touchScale.toFixed(3) + " distance: " + distance.toFixed(3));

                    _navapi.dollyFromPoint(-touchScale * distance, dollyTarget);

                    _prevDollyScale = _dollyScale;
                    break;
            };
            updatePivot = true;
        }
        this.stepMotionDelta(_motionDelta, (_activeMode !== "pan" && _activeMode !== 'dollypan'));

        // If a wheel event triggered this we've now handled it,
        if( _activeTrigger === kWheel && Math.abs(deltaZ) < kEpsilon )
        {
            this.interactionEnd(kWheel);
            wheelEnded = true;
            updatePivot = true;
        }
        // stderr("mode: " + _activeMode + " locked: " + _activeModeLocked + " active: " + _interactionActive + " trigger: " + _activeTrigger);

        // If the interaction has "ended" we can now forget the trigger.
        if( !_interactionActive && (wheelEnded || (_activeTrigger > kNone)) )
        {
            if( _activeTrigger > kWheel )
            {
                // Kill any ongoing damped motion if we aren't using
                // the wheel.
                _startXYZ.copy(_moveXYZ);
            }
            this.utilities.autocam.endInteraction();
            _activeTrigger = kNone;
            if( _activeModeLocked )
                this.controller.setIsLocked(false);
            _activeModeLocked = false;
            _autoCamStartXY = null;
            _touchType = null;
        }
        if( updatePivot )
            this.utilities.pivotActive(_navapi.getPivotSetFlag(), (_activeTrigger <= kWheel));
        else
            this.utilities.pivotUpdate();

        return _camera.dirty;
    };


    this.checkInteractionMode = function()
    {
        var newMode = getTriggeredMode();

        if( newMode !== _activeMode )
        {
			_activeMode = newMode;

            if( (_activeMode === "pan" && _activeTrigger > kWheel) || (_activeMode === "dollypan") )
                this.initTracking(_startXYZ.x, _startXYZ.y);
        }
    };

    this.interactionStart = function(trigger, force)
    {
        // Just a simple way to give device input a sort of priority 
        // so we don't have to track all active triggers. Just remember
        // the most recent with highest "priority".
        if( force || trigger > _activeTrigger )
        {
            // Perhaps we need to remember the modifier keys now.
            _activeTrigger = trigger;
            _interactionActive = true;

            if( this.utilities.autocam )
            {
                this.utilities.autocam.startInteraction(_startXY.x, _startXY.y);
                _autoCamStartXY = _startXY.clone();
            }
            if( trigger > kWheel )
            {
                if( _activeMode === "pan" )
                    this.initTracking(_startXYZ.x, _startXYZ.y);
            }
            this.utilities.pivotActive(_navapi.getPivotSetFlag(), (trigger === kWheel));
            // stderr("START INTERACTION: " + _activeTrigger);
        }
    };

    this.interactionCheck = function()
    {
        // Restart keyboard interaction if certain keys are still down:
        //
        if( _autoMove[0]
         || _autoMove[1]
         || _autoMove[2]
         || _autoMove[3]
         || _autoMove[4]
         || _autoMove[5]
         || _modifierState.SHIFT
         || _modifierState.CONTROL
         || _modifierState.ALT
         || _modifierState.SPACE ) this.interactionStart(kKeyboard, true);
    };

    this.interactionEnd = function(trigger)
    {
        if( trigger === _activeTrigger )
        {
            // stderr("END INTERACTION: " + _activeTrigger);
            if( trigger !== kWheel )
                this.utilities.pivotActive(false);

            // We have to leave the _activeTrigger set until the
            // next update occurs so the update will apply the correct
            // operation.
            _interactionActive = false;
        }
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    
    this.handleWheelInput = function(delta)
    {
        if( this.isDragging )
            return false;

        //Auto-update the center of zoom (pivot) to center on the cursor
        //on mouse wheel.
        if( _navapi.getIs2D() ) {
            // TODO: Perhaps this should be in the update method
            // to avoid unnecessary calls.
            var point = viewerImpl.intersectGround(_lastMouseX, _lastMouseY);
            this.utilities.setPivotPoint( point, true, true ); 
        }

        if( _navapi.getReverseZoomDirection() )
            delta *= -1;

        _moveXYZ.z += delta;

        _wheelAccum += delta;
        var now = Date.now();
        if ( !_wheelOldest ) {
            _wheelOldest = now;
        }
        _wheelNewest = now;

        if( delta != 0.0 )
            this.interactionStart(kWheel);

        return true;
    };

    this.resetKeys = function()
    {
        // Turn off any auto motion that may be stuck due to lost focus
        this.autoMove(-1, false);

        // Clear modifier states:
        _modifierState.SHIFT = 0;
        _modifierState.CONTROL = 0;
        _modifierState.ALT = 0;
        _modifierState.SPACE = 0;
    };

    this.autoMove = function(index, state)
    {
        if( !state || !this.isDragging )
        {
            if( index < 0 )
                _autoMove[0] =
                _autoMove[1] =
                _autoMove[2] =
                _autoMove[3] =
                _autoMove[4] =
                _autoMove[5] = state;
            else
                _autoMove[index] = state;

            if( !state )
                this.interactionEnd(kKeyboard);

            this.interactionCheck();
        };
    };

    this.updateModifierState = function( event )
    {
        /* See SPK-930 and SPK-928
        _modifierState.CONTROL = ((isMac && event.metaKey) || (!isMac && event.ctrlKey)) ? 1 : 0;
         */
        _modifierState.CONTROL = ((isMac && event.metaKey) || event.ctrlKey) ? 1 : 0;
        _modifierState.SHIFT = (event.shiftKey) ? 1 : 0;
        _modifierState.ALT = (event.altKey) ? 1 : 0;
    };

    this.handleKeyDown = function( event, keyCode )
    {
        var isModKey = false;
        var handled = false;

        switch( keyCode )
        {
            case _keys.SHIFT:   _modifierState.SHIFT = 1;   isModKey = true; break;
            case _keys.CONTROL: _modifierState.CONTROL = 1; isModKey = true; break;
            case _keys.ALT:     _modifierState.ALT = 1;     isModKey = true; break;
            case _keys.SPACE:   _modifierState.SPACE = 1;   isModKey = true; break;

            case _keys.EQUALS: this.adjustSpeed(1);  handled = true; break;
            case _keys.DASH:   this.adjustSpeed(-1); handled = true; break;
            case _keys.ZERO:   this.adjustSpeed(0);  handled = true; break; // Reset dolly speed to default

            case _keys.LEFT:     this.autoMove(0, true); handled = true; break;
            case _keys.RIGHT:    this.autoMove(1, true); handled = true; break;
            case _keys.PAGEUP:   this.autoMove(2, true); handled = true; break;
            case _keys.PAGEDOWN: this.autoMove(3, true); handled = true; break;
            case _keys.UP:       this.autoMove(4, true); handled = true; break;
            case _keys.DOWN:     this.autoMove(5, true); handled = true; break;

            default:
                return false;
        }
        if( isModKey && !this.isDragging )
            this.interactionStart(kKeyboard);

        return handled;
    };

    this.handleKeyUp = function( event, keyCode )
    {
        var isModKey = false;
        var handled = false;

        switch( keyCode )
        {
            case _keys.SHIFT:   _modifierState.SHIFT = 0;   isModKey = true; break;
            case _keys.CONTROL: _modifierState.CONTROL = 0; isModKey = true; break;
            case _keys.ALT:     _modifierState.ALT = 0;     isModKey = true; break;
            case _keys.SPACE:   _modifierState.SPACE = 0;   isModKey = true; break;

            case _keys.LEFT:     this.autoMove(0, false); handled = true; break;
            case _keys.RIGHT:    this.autoMove(1, false); handled = true; break;
            case _keys.PAGEUP:   this.autoMove(2, false); handled = true; break;
            case _keys.PAGEDOWN: this.autoMove(3, false); handled = true; break;
            case _keys.UP:       this.autoMove(4, false); handled = true; break;
            case _keys.DOWN:     this.autoMove(5, false); handled = true; break;

            default:
                return false;
        }
        if( handled )
        {
            this.interactionEnd(kKeyboard);

            if( !_interactionActive )
                this.interactionCheck();
        }
        return handled;
    };

    this.handleDollyPan = function(event)
    {
        _lastMouseX = event.canvasX;
        _lastMouseY = event.canvasY;

        var viewport = _navapi.getScreenViewport();
        _moveXY.x  = _touchStartXY.x + event.deltaX;
        _moveXY.y  = _touchStartXY.y + event.deltaY;
        _moveXYZ.x = _moveXY.x / viewport.width;
        _moveXYZ.y = _moveXY.y / viewport.height;
        _dollyScale = event.scale;
    };

    this.handleGesture = function( event )
    {
        switch( event.type )
        {
            case "dragstart":
                _touchType = "drag";
                // Single touch, fake the mouse for now...
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "dragend":
                // We seem to often get a lone dragend after a multi-touch.
                if( _touchType === "drag" )
                {
                    this.handleButtonUp(event, 0);
                    _touchType = null;
                    return true;
                }
                return false;


            case "panstart":
                _touchType = "pan";
                this.isDragging = true;

                _prevDollyScale = _dollyScale = 1.0;

                _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
                _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

                _touchStartXY.set(event.canvasX, event.canvasY);
                _startXY.set(event.canvasX, event.canvasY);

                this.interactionStart(kTouch);
                this.handleDollyPan(event);
                return true;

            case "panmove":
                return (_touchType === "pan") ?  this.handleDollyPan(event) : false;

            case "panend":
                if( _touchType === "pan" )
                {
                    this.isDragging = false;
                    this.handleDollyPan(event);
                    this.interactionEnd(kTouch);
                    return true;
                }
                return false;


            case "pinchstart":
                this.isDragging = true;
                _touchType = "pinch";

                _prevDollyScale = _dollyScale = 1.0;

                _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
                _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

                _touchStartXY.set(event.canvasX, event.canvasY);
                _startXY.set(event.canvasX, event.canvasY);

                this.interactionStart(kTouch);
                this.handleDollyPan(event);
                return true;

            case "pinchmove":
                return (_touchType === "pinch") ? this.handleDollyPan(event) : false;

            case "pinchend":
                if( _touchType === "pinch" )
                {
                    this.isDragging = false;
                    this.handleDollyPan(event);
                    this.interactionEnd(kTouch);
                    return true;
                }
                return false;
        }
        return false
    };

    this.handleButtonDown = function( event, button )
    {
        this.updateModifierState(event);

        _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        _startXY.set(event.canvasX, event.canvasY);
        _moveXYZ.copy(_startXYZ);
        _moveXY.copy(_startXY);

        _lastMouseX = event.clientX;
        _lastMouseY = event.clientY;

        this.isDragging = true;

        this.interactionStart(button);
        return true;
    };

    this.handleButtonUp = function( event, button )
    {
        this.updateModifierState(event);

        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        _moveXY.set(event.canvasX, event.canvasY);

        this.interactionEnd(button);

        this.isDragging = false;
        return true;
    };

    this.handleMouseMove = function( event )
    {
        this.updateModifierState(event);

        //Handles non-dragging mouse move over the canvas.
        //Updates the last known mouse point for
        //using during mouse wheel (as zoom center) and
        //will eventually be needed for mouse over highlighting
        if( !this.isDragging )
        {
            _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
            _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

            _startXY.set(event.canvasX, event.canvasY);
            _moveXYZ.x = _startXYZ.x;
            _moveXYZ.y = _startXYZ.y;
            _moveXY.copy(_startXY);

            _lastMouseX = event.clientX;
            _lastMouseY = event.clientY;

            //mouse over highlighting
            if( _navapi.getIs2D() ) {
                // TODO: Perhaps this should be in the update method
                // to avoid unnecessary calls.
                viewerImpl.rolloverObject(_lastMouseX, _lastMouseY);
            }
            return false;
        }
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        _moveXY.set(event.canvasX, event.canvasY);
        return true;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.resetKeys();
        this.interactionEnd(_activeTrigger);
    };

    viewerApi.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, function(event) {
        _this.handleBlur(event);
    });
};
;AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.HotGestureTool = function( viewerApi )
{
    var isMac = (navigator.userAgent.search("Mac OS") != -1);
    var isActive = false;

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["hottouch"];

    var _modifierState = { SHIFT: 0, ALT: 0, CONTROL: 0 };
    var _commandKeyDown = false;
    var _setMode = null;
    var _saveMode = null;
    var _fovActive = false;
    var _rollActive = false;
    var _startEvent = null;

    var _keys = {
              SHIFT: 16,
            CONTROL: 17,
                ALT: 18,
             ESCAPE: 27,
           LCOMMAND: 91,
           RCOMMAND: 93,
         COMMANDMOZ: 224
    };

    var ORBIT   = "orbit";
    var ROLL    = "worldup";
    var FOV     = "fov";

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
    };

    this.deactivate = function(name)
    {
    };
    
    this.__checkStart = function()
    {
        // Since the start event triggers the tool change we re-send the
        // start event so that the new tool can trigger from it.
        if( _startEvent )
        {
            this.controller.distributeEvent("handleGesture", _startEvent);
            _startEvent = null;
        }
    };

    this.update = function()
    {
        if( this.controller.getIsLocked() )
            return false;

        var got = viewerApi.getActiveNavigationTool();
        var wantRoll = (_fovActive === false && _rollActive === true);
        var wantFov  = (_fovActive === true && _rollActive === false);

        if( wantRoll || wantFov )
        {
            var want = wantRoll ? ROLL : FOV;

            if( got === want )
                return false;

            if( got === _setMode )  // We set it we can change it
            {
                viewerApi.setActiveNavigationTool(want);
                _setMode = want;
                this.__checkStart();
                // stderr("HOT: " + got + " => " + want);
                return false;
            }
            _saveMode = got;
            viewerApi.setActiveNavigationTool(want);
            _setMode = want;
            this.__checkStart();
            // stderr("HOT: " + got + " => " + want);
        }
        else if( _setMode )
        {
            // stderr("HOT: " + got + " => " + _saveMode);
            viewerApi.setActiveNavigationTool(_saveMode);
            _setMode = null;
            _saveMode = null;
        }
        return false;
    };

    this.resetKeys = function()
    {
        // Clear modifier states:
        _modifierState.SHIFT = 0;
        _modifierState.CONTROL = 0;
        _modifierState.ALT = 0;
    };

    this.updateModifierState = function( event )
    {
        _modifierState.CONTROL = event.ctrlKey  ? 1 : 0;
        _modifierState.SHIFT   = event.shiftKey ? 1 : 0;
        _modifierState.ALT     = event.altKey   ? 1 : 0;
    };

    this.handleGesture = function( event )
    {
        if( event === _startEvent )
            return false;

        switch( event.type )
        {
            case "drag3start":
                _startEvent = event;
                _fovActive = true;
                break;

            case "drag3move":
                break;

            case "drag3end":
                _fovActive = false;
                break;

            case "rotatestart":
                _startEvent = event;
                _rollActive = true;
                break;

            case "rotatemove":
                break;

            case "rotateend":
                _rollActive = false;
                break;
        }
        return false
    };

    this.handleKeyDown = function( event, keyCode )
    {
        this.updateModifierState(event);

        switch( keyCode )
        {
            // Do we need to consume these events?
            case _keys.SHIFT:   _modifierState.SHIFT = 1;   break;
            case _keys.CONTROL: _modifierState.CONTROL = 1; break;
            case _keys.ALT:     _modifierState.ALT = 1;     break;
        }
        return false;
    };

    this.handleKeyUp = function( event, keyCode )
    {
        this.updateModifierState(event);

        switch( keyCode )
        {
            // Do we need to consume these events?
            case _keys.SHIFT:   _modifierState.SHIFT = 0;   break;
            case _keys.CONTROL: _modifierState.CONTROL = 0; break;
            case _keys.ALT:     _modifierState.ALT = 0;     break;
        }
        return false;
    };

    this.handleButtonDown = function( event, button )
    {
        this.updateModifierState(event);
        return false;
    };

    this.handleButtonUp = function( event, button )
    {
        this.updateModifierState(event);
        return false;
    };

    this.handleMouseMove = function( event )
    {
        this.updateModifierState(event);
        return false;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.resetKeys();
        return false;
    };
}
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Private');

/**
 * @callback Autodesk.Viewing.HotkeyManager~onHotkeyPressCallback
 * @param {number[]} keycodes - The key combination that triggered this callback
 * @returns {boolean} - True if the press event was handled, false otherwise.
 */

/**
 * @callback Autodesk.Viewing.HotkeyManager~onHotkeyReleaseCallback
 * @param {number[]} keycodes - The key combination that triggered this callback
 * @returns {boolean} - True if the release event was handled, false otherwise.
 */

/**
 * @typedef {Object} Autodesk.Viewing.HotkeyManager~Hotkey
 * @property {number[]} keycodes - The keycode combination (order doesn't matter).
 * @property {Autodesk.Viewing.HotkeyManager~onHotkeyPressCallback} [onPress] - The callback used when the combination is engaged.
 * @property {Autodesk.Viewing.HotkeyManager~onHotkeyReleaseCallback} [onRelease] - The callback used when the combination is disengaged.
 */

/**
 * The HotkeyManager manages the hotkeys for the viewer.
 * Access the members and methods via the singleton theHotkeyManager.
 *
 * @constructor
 */
Autodesk.Viewing.HotkeyManager = function () {
    var stack = []; // The hotkey stack

    var keys = []; // The keys that are currently held

    // Pending items
    var onPressQueue = [];
    var onReleaseQueue = [];

    /**
     * Enum for keycodes
     * @readonly
     * @enum {number}
     */
    var KEYCODES = {
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        SHIFT: 16,
        CONTROL: 17,
        ALT: 18,
        ESCAPE: 27,
        SPACE: 32,
        PAGEUP: 33,
        PAGEDOWN: 34,
        END: 35,
        HOME: 36,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        INSERT: 45,
        DELETE: 46,
        ZERO: 48,
        a: 65,
        b: 66,
        c: 67,
        d: 68,
        e: 69,
        f: 70,
        g: 71,
        h: 72,
        i: 73,
        j: 74,
        k: 75,
        l: 76,
        m: 77,
        n: 78,
        o: 79,
        p: 80,
        q: 81,
        r: 82,
        s: 83,
        t: 84,
        u: 85,
        v: 86,
        w: 87,
        x: 88,
        y: 89,
        z: 90,
        F1: 112,
        F2: 113,
        F3: 114,
        F4: 115,
        F5: 116,
        F6: 117,
        F7: 118,
        F8: 119,
        F9: 120,
        F10: 121,
        F11: 122,
        F12: 123,
        SEMICOLON: 186,
        EQUALS: 187,
        COMMA: 188,
        DASH: 189,
        PERIOD: 190,
        SLASH: 191,
        LBRACKET: 219,
        RBRACKET: 221,
        SINGLEQUOTE: 222
    };

    var _names = ["hotkeys"];

    function getNames()
    {
        return _names;
    }

    function getName()
    {
        return _names[0];
    }

    // Apparently javascript sorts by string values by default so we need
    // our own sort function.
    function compare(a, b) {
        return a - b;
    }

    /**
     * Pushes new hotkeys onto the stack
     *
     * @param {String} id - The id for this hotkey set.
     * @param {Autodesk.Viewing.HotkeyManager~Hotkey[]} hotkeys - The list of hotkeys.
     * @param {Object} [options] - An optional dictionary of options for this hotkey set.
     * @param {boolean} [options.tryUntilSuccess] - When true, the onPress callback will be called until it returns true
     *                                              or the hotkey state changes. The onRelease callback will be called
     *                                              until it returns true or until the combination is reengaged. Stops
     *                                              propagation through the stack. Non-blocking.
     * @returns {boolean} - True if the hotkeys were successfully pushed.
     */
    function pushHotkeys(id, hotkeys, options) {
        var idAlreadyUsed = stack.some(function(element) {
            return element.id === id;
        });

        if (idAlreadyUsed) {
            return false;
        }

        for (var i = 0; i < hotkeys.length; i++) {
            stack.push({
                id: id,
                keys: hotkeys[i].keycodes.sort(compare).join(),
                onPress: hotkeys[i].onPress,
                onRelease: hotkeys[i].onRelease,
                options: options || {}
            });
        }

        return true;
    }

    /**
     * Removes hotkeys associated with an ID from the stack.
     *
     * @param {String} id - The id associated with the hotkeys.
     * @returns {boolean} - True if the hotkeys were successfully popped.
     */
    function popHotkeys(id) {
        var found = false;
        for (var i = stack.length - 1; i >= 0; i--) {
            if (stack[i].id === id) {
                stack.splice(i, 1);
                found = true;
            }
        }

        return found;
    }

    function cleanQueues() {
        var index = keys.join();

        var item;
        var i;

        for (i = 0; i < onReleaseQueue.length;) {
            item = onReleaseQueue[i];
            if (item.keys === index) {
                onReleaseQueue.splice(i, 1);
            } else {
                i++;
            }
        }

        for (i = 0; i < onPressQueue.length;) {
            item = onPressQueue[i];
            if (item.keys !== index) {
                onPressQueue.splice(i, 1);
            } else {
                i++;
            }
        }
    }

    function handleKeyDown(event, keyCode) {
        if (keys.indexOf(keyCode) !== -1) {
            // Ignore duplicate key down events. (see ToolController.applyKeyMappings())
            return;
        }

        var currentIndex = keys.join();
        var currentKeys = keys.slice(0);

        var i = 0;
        while (i < keys.length && keys[i] < keyCode) {
            i++;
        }
        keys.splice(i, 0, keyCode);

        var newIndex = keys.join();
        var newKeys = keys.slice(0);

        cleanQueues();

        // Make sure onRelease is called before onPress
        var releaseHandlers = [];
        var pressHandlers = [];
        var item;

        for (i = stack.length - 1; i >= 0; i--) {
            item = stack[i];
            if (item.keys === currentIndex && item.onRelease) {
                releaseHandlers.unshift(item);
            } else if (item.keys === newIndex && item.onPress) {
                pressHandlers.unshift(item);
            }
        }

        for (i = releaseHandlers.length - 1; i >= 0; i--) {
            item = releaseHandlers[i];
            if (item.onRelease(currentKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onReleaseQueue.unshift(item);
            }
        }

        for (i = pressHandlers.length - 1; i >= 0; i--) {
            item = pressHandlers[i];
            if (item.onPress(newKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onPressQueue.unshift(item);
            }
        }
    }

    function handleKeyUp(event, keyCode) {
        var currentIndex = keys.join();
        var currentKeys = keys.slice(0);

        var i = keys.indexOf(keyCode);
        if (i > -1) {
            keys.splice(i, 1);
        }

        var newIndex = keys.join();
        var newKeys = keys.slice(0);

        cleanQueues();

        // Make sure onRelease is called before onPress
        var releaseHandlers = [];
        var pressHandlers = [];
        var item;

        for (i = stack.length - 1; i >= 0; i--) {
            item = stack[i];
            if (item.keys === currentIndex && item.onRelease) {
                releaseHandlers.unshift(item);
            } else if (item.keys === newIndex && item.onPress) {
                pressHandlers.unshift(item);
            }
        }

        for (i = releaseHandlers.length - 1; i >= 0; i--) {
            item = releaseHandlers[i];
            if (item.onRelease(currentKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onReleaseQueue.unshift(item);
            }
        }

        for (i = pressHandlers.length - 1; i >= 0; i--) {
            item = pressHandlers[i];
            if (item.onPress(newKeys)) {
                break;
            } else if (item.options.tryUntilSuccess) {
                onPressQueue.unshift(item);
            }
        }
    }

    function update() {
        var item;
        var i;

        for (i = 0; i < onReleaseQueue.length;) {
            item = onReleaseQueue[i];
            if (item.onRelease(item.keys.split()) === true) {
                onReleaseQueue.splice(i, 1);
            } else {
                i++;
            }
        }

        for (i = 0; i < onPressQueue.length;) {
            item = onPressQueue[i];
            if (item.onPress(item.keys.split()) === true) {
                onPressQueue.splice(i, 1);
            } else {
                i++;
            }
        }

        return false;
    }

    function handleBlur() {
        // Release all keys.
        for (var i = keys.length - 1; i >= 0; i--) {
            handleKeyUp(null, keys[i]);
        }
    }

    return {
        pushHotkeys: pushHotkeys,
        popHotkeys: popHotkeys,
        handleKeyDown: handleKeyDown,
        handleKeyUp: handleKeyUp,
        handleBlur: handleBlur,
        getName: getName,
        getNames: getNames,
        activate: function(){},
        deactivate: function(){},
        update: update,
        KEYCODES: KEYCODES
    };
};

Autodesk.Viewing.theHotkeyManager = new Autodesk.Viewing.HotkeyManager();
;AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.FovTool = function( viewerApi )
{
    var kScreenEpsilon = 0.001;
    var kEpsilon = 0.00001;
    var kFovDragScale = -1.0;
    var kDampingFactor = 0.6;
    var kWheelThresholdMs = 100;

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["fov"];

    var _interactionActive = false;

    var _wheelAccum = 0;
    var _wheelOldest = null;
    var _wheelNewest = null;
    var _wheelContinuous = false;

    // Interaction Triggers:
    var kNone = -5;
    var kWheel = -1;
    var kMouseLeft = 0;
    var kMouseMiddle = 1;
    var kMouseRight = 2;

    var _activeTrigger = kNone;
    var _startXYZ = new THREE.Vector3();
    var _moveXYZ  = new THREE.Vector3();
    var _motionDelta = new THREE.Vector3();
    var _touchType = null;
    
    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
    };

    this.deactivate = function(name)
    {
        _activeTrigger = kNone;
    };
    
    this.getCursor = function()
    {
        return "url(data:image/x-icon;base64,AAACAAEAGBgAAAAAAACICQAAFgAAACgAAAAYAAAAMAAAAAEAIAAAAAAAYAkAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAACEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAnAwMD/yEhIf8AAABmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAGknJyf/goKC/8/Pz/8aGhr/AAAALQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////AAAA/wAAAAAAAAAAAAAAAAAAAAAAAABTFBQU/2lpaf/MzMz///////////+Wlpb/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAKAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAOAAAAKFTU1P/t7e3////////////8PDw////////////AQEB/wAAAAEAAAAAAAAAFAAAAH0KCgr/AAAAYwAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAjCwsL/6Ghof/t7e3///////Dw8P9MTEz/LS0t//Pz8///////Ghoa/wAAABoAAAANDQ0N/319ff+rq6v/Y2Nj/wAAAK8AAABGAAAA////////////AAAA/wAAAF0hISH/jIyM////////////sLCw/xEREf8AAACHAAAArKysrP//////V1dX/wAAAFcAAABSUlJS//f39///////8PDw/6+vr/86Ojr/LS0t////////////FRUV/1xcXP/Gxsb/+Pj4//Hx8f9MTEz/AAAAsAAAAEcAAAAAAAAAZ2dnZ///////pKSk/wAAAKQAAACtra2t///////////////////////m5ub/kZGR/wAAAP8AAAD/q6ur//Hx8f//////vb29/x0dHf8AAACIAAAAAAAAAAAAAAAAAAAAOjo6Ov//////5+fn/wAAAOcAAADd3d3d////////////////////////////+/v7/9bW1v/i4uL//v7+//Pz8/9hYWH/AAAAvQAAAFQAAAAAAAAAAAAAAAAAAAAAAAAAJycnJ//6+vr//////wMDA/8AAADv7+/v/////////////////////////////////////////////////7y8vP8ODg7/AAAAKwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJiYmJv/6+vr//////wkJCf8AAADv7+/v//////////////////////////////////f39//9/f3//////+np6f+UlJT/GBgY/wAAAH0AAAACAAAAAAAAAAAAAAAAAAAAKSkpKf///////v7+/w0NDf8AAADd3d3d////////////////////////////29vb/39/f/+Xl5f/5+fn////////////5ubm/1RUVP8CAgL/AAAAPwAAAAAAAAAAAAAAOTk5Of//////8PDw/wgICP8AAAChoaGh/////////////////+np6f+YmJj/QkJC/wAAAP8AAAD/UFBQ/7e3t//39/f///////////+oqKj/EBAQ/wAAAIgAAAAAAAAAZ2dnZ///////29vb/wEBAf8AAAA4NTU1/9zc3P/t7e3/tbW1/01NTf8AAACYAAAA////////////AwMD/wsLC/9oaGj/y8vL////////////8fHx/zg4OP8AAACWAAAApaWlpf//////n5+f/wAAAJ8AAAAAAAAAczg4OP9LS0v/EhIS/wAAAE0AAAAAAAAA////////////FRUV/wAAABUAAABoJSUl/4GBgf/i4uL///////////9+fn7/Pz8///b29v//////SkpK/wAAAEoAAAAAAAAAAAAAADgAAABLAAAAEgAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAJQAAAIE8PDz/np6e//z8/P/////////////////8/Pz/CQkJ/wAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAA8DAwM/09PT/+7u7v///////////+QkJD/AAAAkwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////Dw8P/wAAAA8AAAAAAAAAAAAAAAAAAAAAAAAADAAAAFIYGBj/aGho/729vf8WFhb/AAAAJwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////FRUV/wAAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAQEB/w8PD/8AAABUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA////////////DAwM/wAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAA8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlgAAAP8AAAD/AAAAlgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8x/h/nO/4fw1D+HwFy/h4BRu4YAHOGEABkAAAAXAAAIFwAAOBnAAHgIAAD4GUAAOB4AABgXAAAIGMAAABtggAAVMYYAHT+HgE7/g8BcP4Pw2/+D+dc/h//XP///2c=), wait";
    };

    this.getMotionDelta = function(dxyz)
    {
        var deltaX = _moveXYZ.x - _startXYZ.x;
        var deltaY = _moveXYZ.y - _startXYZ.y;
        var deltaZ = _moveXYZ.z - _startXYZ.z;

        if( Math.abs(deltaX) < kScreenEpsilon ) deltaX = 0.0;
        if( Math.abs(deltaY) < kScreenEpsilon ) deltaY = 0.0;
        if( Math.abs(deltaZ) < kScreenEpsilon ) deltaZ = 0.0;

        dxyz.set(deltaX, deltaY, deltaZ);
    };

    this.stepMotionDelta = function(delta, damped)
    {
        if( damped )
        {
            _startXYZ.x += delta.x * kDampingFactor;
            _startXYZ.y += delta.y * kDampingFactor;
            _startXYZ.z += delta.z * kDampingFactor;
        }
        else
            _startXYZ.copy(_moveXYZ);
    };

    function promoteDelta(delta)
    {
        // promote a wheel delta to a full wheel stop (3)
        if ( delta < 0 && delta > -3 ) {
            return -3;
        }
        return ( delta > 0 && delta < 3 ) ? 3 : delta;
    }

    this.getAccumulatedWheelDelta = function()
    {
        var now = Date.now();
        var delta = 0;

        if ( _wheelNewest && now - _wheelNewest > kWheelThresholdMs ) {
            // Newest event in accumulator has aged out; assume wheel motion has stopped.
            delta = promoteDelta(_wheelAccum);
            _wheelAccum = 0;
            _wheelOldest = null;
            _wheelNewest = null;
            _wheelContinuous = false;
        }
        else if ( _wheelOldest && (now - _wheelOldest) > kWheelThresholdMs ) {
            // Oldest event in accumulator has aged out; process continuously.
            if ( _wheelContinuous ) {
                if( Math.abs(_wheelAccum) >= 3 ) {
                    delta = _wheelAccum;
                    _wheelAccum = 0;
                }
            } else {
                delta = promoteDelta(_wheelAccum);
                _wheelContinuous = true;
                _wheelAccum = 0;
            }
        }
        return delta;
    };

    this.update = function()
    {
        var wheelEnded = false;

        if( _activeTrigger > kNone )
        {
            this.controller.setIsLocked(true);
            this.getMotionDelta(_motionDelta);

            var deltaX = _motionDelta.x;
            var deltaY = _motionDelta.y;
            var deltaZ = _motionDelta.z;

            if( deltaX !== 0.0 || deltaY !== 0.0 || deltaZ !== 0.0 )
            {
                if( _activeTrigger >= kMouseLeft )
                {
                    // Map XY movement to Z:
                    deltaY = -deltaY;   // Invert Y
                    deltaZ = (Math.abs(deltaX) > Math.abs(deltaY)) ? deltaX : deltaY;
                    if( deltaZ !== 0.0 )
                    {
                        deltaZ *= kFovDragScale;
                        _navapi.setVerticalFov(_navapi.getVerticalFov() * (1.0 + deltaZ), true);
                    }
                }
                else 
                {
                    // Translate wheelAccum backwards to determine the number of wheel stops.
                    var deltaFocalLength = this.getAccumulatedWheelDelta() / 3;
                    if( deltaFocalLength !== 0.0 )
                        _navapi.setFocalLength(_navapi.getFocalLength() + deltaFocalLength, true);
                }
            }
            this.stepMotionDelta(_motionDelta, true);

            // If a wheel event triggered this we've now handled it,
            if( _activeTrigger === kWheel && Math.abs(deltaZ) < kEpsilon )
            {
                this.interactionEnd(kWheel);
                wheelEnded = true;
            }
        }
        // If the interaction has "ended" we can now forget the trigger.
        if( !_interactionActive && (wheelEnded || (_activeTrigger > kNone)) )
        {
            if( _activeTrigger > kWheel )
            {
                // Kill any ongoing damped motion if we aren't using
                // the wheel.
                _startXYZ.copy(_moveXYZ);
            }
            _activeTrigger = kNone;
            this.controller.setIsLocked(false);
        }
        return _camera.dirty;
    };

    this.interactionStart = function(trigger, force)
    {
        // Just a simple way to give device input a sort of priority 
        // so we don't have to track all active triggers. Just remember
        // the most recent with highest "priority".
        if( force || trigger > _activeTrigger )
        {
            // Perhaps we need to remember the modifier keys now.
            _activeTrigger = trigger;
            _interactionActive = true;
        }

        // Switch to perspective
        _navapi.toPerspective();
    };

    this.interactionEnd = function(trigger)
    {
        if( trigger === _activeTrigger )
        {
            // stderr("END INTERACTION: " + _activeTrigger);
            if( trigger !== kWheel )
                this.utilities.pivotActive(false);

            // We have to leave the _activeTrigger set until the
            // next update occurs so the update will apply the correct
            // operation.
            _interactionActive = false;
        }
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    
    this.handleWheelInput = function(delta)
    {
        if( _activeTrigger > kWheel )
            return false;

        // Match original reverse behaviour:
        if( _navapi.getReverseZoomDirection() )
            delta *= -1;

        _moveXYZ.z += delta;
        _wheelAccum += delta;
        var now = Date.now();
        if ( !_wheelOldest ) {
            _wheelOldest = now;
        }
        _wheelNewest = now;

        if( delta != 0.0 )
            this.interactionStart(kWheel);

        return true;
    };

    this.handleGesture = function( event )
    {
        switch( event.type )
        {
            case "dragstart":
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return this.handleMouseMove(event);

            case "dragend":
                return this.handleButtonUp(event, 0);

            case "drag3start":
                _touchType = "drag";
                // Fake the mouse for now. Coord should be centroid.
                return this.handleButtonDown(event, 0);

            case "drag3move":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "drag3end":
                if( _touchType === "drag" )
                    this.handleButtonUp(event, 0)

                _touchType = null;
                // Sigh... minor hack
                // Can't consume the end event because the hot gesture
                // tool needs to see it to end the interaction.
                return false;
        }
        return false;
    };


    this.handleButtonDown = function( event, button )
    {
        _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        _moveXYZ.copy(_startXYZ);

        this.interactionStart(button);
        return true;
    };

    this.handleButtonUp = function( event, button )
    {
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        this.interactionEnd(button);
        return true;
    };

    this.handleMouseMove = function( event )
    {
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        return (_activeTrigger > kWheel);
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.interactionEnd(_activeTrigger);
        return false;
    };

};
;AutodeskNamespace('Autodesk.Viewing');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.WorldUpTool = function( viewerImpl, viewerApi )
{
    // Returns the projection of (x,y,z) onto the plane with this unit normal
    var projectAxis = function()
    {
        var projectionVec = new THREE.Vector3();

        return function (x, y, z, normal)
        {
            var vec = new THREE.Vector3(x, y, z);
            var projectionLength = normal.dot(vec);
            projectionVec.copy(normal);
            projectionVec.multiplyScalar(projectionLength);
            return vec.sub(projectionVec);
        }
    }();

    // /** @constructor */
    function RollInteraction( viewerImpl, camera )
    {
        var kRollColor = 0xBBBBBB;
        var kHudFov = 30;
        var kHudWorldScale = 2.0 * Math.tan(THREE.Math.degToRad(kHudFov * 0.5));

        var myMaterialPre  = new THREE.MeshPhongMaterial({color:kRollColor, ambient: kRollColor, opacity:0.5, transparent:true});
        var myMaterialPost = new THREE.MeshPhongMaterial({color:kRollColor, ambient: kRollColor, opacity:0.5, transparent:true});

        // Preallocate these as work objects:
        var myVec1   = new THREE.Vector3();
        var myVec2   = new THREE.Vector3();
        var myRotate = new THREE.Quaternion();

        // Use our own camera for the Roll HUD:
        // var myCamera = camera.clone();   // There's a bug in Object3D.clone()
        var myCamera = new THREE.PerspectiveCamera(camera.fov, camera.aspect, camera.near, camera.far);
        var mySceneCamera = camera;
        var kRingSizeMin = 0.55; // Proportion of screen height
        var kRingSizeMax = 0.85; // Proportion of screen height
        var myRingShrink = 1.0;
        var myLookAtPoint = null;
        var myReferenceCircle = null;
        var myReferenceXaxis = null;
        var myReferenceYaxis = null;
        var myReferenceZaxis = null;
        var myReferenceGeometry = null;
        var myReferenceUp = null;
        var mySnapPoints = null;
        var mySnapFlags = null;
        var mySnapAngles = new Array(6);
        var myClosestAngle = 0.0;
        var myRollAngle = 0.0;
        var myAnglesFlipped = false;
        var myCurrentlySnapped = true;  // Assume initially true
        var mySnappedRoll = 0.0;
        var kSnapInThreshold  = 5.0 * Math.PI / 180.0;
        var kSnapOutThreshold = 7.0 * Math.PI / 180.0;

        var kNOSNAP = 1e3;
        var kAliasLengthThreshold = 0.1;

        viewerImpl.createOverlayScene("roll", myMaterialPre, myMaterialPost, myCamera);

        function angleDiff(a, b)
        {
            var diff = Math.abs(a - b);
            if( diff > kTwo_PI )
                return diff;

            return Math.min(kTwo_PI - diff, diff);
        }

        function isThisAxis(index, worldUp)
        {
            var snapVec = getSnapVector(index);
            if( snapVec.distanceToSquared(worldUp) < kEpsilon )
                return true;

            myVec2.set(-worldUp.x, -worldUp.y, -worldUp.z);
            return (snapVec.distanceToSquared(myVec2) < kEpsilon);
        }

        function filterSnapAngles(snapLengths, worldUp)
        {
            // For some rotation axes the snap angles for two axes can be close together.
            // Snapping to one or the other doesn't give expected results. This filters
            // the snap angles and removes one of the close angles. When two angles are
            // withing AliasSnapThreshold, one of the angles is removed. The one we keep
            // is the one with the longest projection length unless it happens to be the
            // current up direction.

            // This threshold should be greater than the snap out threshold plus the snap
            // in threshold so that when two snap points are close together there is room
            // to snap out of one and into the other.
            var kAliasSnapThreshold = kSnapInThreshold + kSnapOutThreshold + (2.0 * Math.PI / 180.0);

            for (var i = 0; i < 6; ++i)
            {
                if( mySnapAngles[i] === kNOSNAP )
                    continue;

                for (var j = i + 1; j < 6; ++j)
                {
                    if( mySnapAngles[j] === kNOSNAP )
                        continue;

                    var diff = angleDiff(mySnapAngles[i], mySnapAngles[j]);
                    // stderr("Angle diff: (" + i + ", " + j + ") " + diff);
                    // stderr("Angles: " + mySnapAngles[i] + " - " + mySnapAngles[j]);

                    if (diff < kAliasSnapThreshold)
                    {
                        if( (snapLengths[i] < snapLengths[j] && !isThisAxis(i, worldUp))
                        ||  isThisAxis(j, worldUp) )
                        {
                            mySnapAngles[i] = kNOSNAP;
                            break;  // angle i is removed stop checking
                        }
                        else
                            mySnapAngles[j] = kNOSNAP;
                    }
                }
            }
        }

        // Calculate the opposite angle from angle. angle should be
        // from -PI to PI, or kNOSNAP
        function oppositeAngle(angle)
        {
            if( angle > kTwo_PI )
                return angle;
            if( angle <= 0.0 )
                return angle + Math.PI;
            return angle - Math.PI;
        }

        function updateSnapPoints(viewVec, cameraUp, worldUp)
        {
            var normal = viewVec.clone().normalize();
            var snaps   = new Array(3);
            var lengths = new Array(6);

            // Project the 6 axis vectors onto the view plane:
            snaps[0] = projectAxis(1.0, 0.0, 0.0, normal);
            snaps[1] = projectAxis(0.0, 1.0, 0.0, normal);
            snaps[2] = projectAxis(0.0, 0.0, 1.0, normal);

            var i;
            var left = cameraUp.clone().cross(normal).normalize();

            for( i=0; i < 3; ++i )
            {
                var snap = snaps[i];
                lengths[i] = snap.length();

                // A short projection length means the axis was too close to
                // the view vector:
                if( lengths[i] < kAliasLengthThreshold )
                {
                    mySnapAngles[i] = kNOSNAP;
                }
                else
                {
                    snap.multiplyScalar(1.0 / lengths[i]);
                    mySnapAngles[i] = Math.atan2(left.dot(snap), cameraUp.dot(snap));
                }
            }
            mySnapAngles[3] = oppositeAngle(mySnapAngles[0]);
            mySnapAngles[4] = oppositeAngle(mySnapAngles[1]);
            mySnapAngles[5] = oppositeAngle(mySnapAngles[2]);
            lengths[3] = lengths[0];
            lengths[4] = lengths[1];
            lengths[5] = lengths[2];

            filterSnapAngles(lengths, worldUp);

            for( i=0; i < 6; ++i )
            {
                // stderr("SNAP[" + i + "] = " + mySnapAngles[i].toFixed(3) + " (" + lengths[i].toFixed(3) + ")");

                if( mySnapAngles[i] !== kNOSNAP )
                {
                    var z = myVec2.set(0.0, 0.0, 1.0);
                    myRotate.setFromAxisAngle( z, mySnapAngles[i] );
                    // The radius of the circle is 0.5 so place the points
                    // just outside the circle:
                    var pos = myVec2.set(0.0, 0.54, 0.0);
                    pos.applyQuaternion( myRotate );
                    mySnapPoints[i].position.copy(pos);
                    mySnapPoints[i].visible = true;
                }
                else
                    mySnapPoints[i].visible = false;
            }
        }

        function buildReferenceGeometry()
        {
            myReferenceGeometry = new THREE.Object3D();

            // The roll hud geometry is built with unit diameter and then scaled
            // to world space later.
            var geom   = new THREE.RingGeometry( 0.49, 0.5, 60 );
            var circle = new THREE.Mesh( geom, myMaterialPre );

            myReferenceCircle = circle;

            var geomX = new THREE.BoxGeometry( 0.930, 0.007, 0.007 );
            var geomY = new THREE.BoxGeometry( 0.007, 0.930, 0.007 );
            var geomZ = new THREE.BoxGeometry( 0.007, 0.007, 0.930 );

            myReferenceXaxis = new THREE.Mesh( geomX, myMaterialPre );
            myReferenceYaxis = new THREE.Mesh( geomY, myMaterialPre );
            myReferenceZaxis = new THREE.Mesh( geomZ, myMaterialPre );

            myReferenceGeometry.add( myReferenceXaxis );
            myReferenceGeometry.add( myReferenceYaxis );
            myReferenceGeometry.add( myReferenceZaxis );

            myReferenceUp = new THREE.Mesh( new THREE.CircleGeometry( 0.005 ), myMaterialPre );
            myReferenceGeometry.add(myReferenceUp);

            mySnapPoints = new Array(6);
            mySnapFlags  = new Array(6);
            for( var i = 0;  i < 6;  ++i )
            {
                mySnapPoints[i] = new THREE.Mesh( new THREE.CircleGeometry( 0.0050, 16 ), myMaterialPre );
                mySnapFlags[i]  = new THREE.Mesh( new THREE.CircleGeometry( 0.0025, 16 ), myMaterialPre );
                mySnapFlags[i].visible = false;
                mySnapPoints[i].add(mySnapFlags[i]);
                circle.add(mySnapPoints[i]);
            }
            myReferenceGeometry.add( circle );

            return myReferenceGeometry;
        }

        function getReferenceGeometry(scale, lookAtPoint, viewVec, worldUp, cameraUp)
        {
            if( !myReferenceGeometry )
                myReferenceGeometry = buildReferenceGeometry();

            _navapi.orient(myReferenceCircle, lookAtPoint, myCamera.position, worldUp);

            updateSnapPoints(viewVec, cameraUp, worldUp);

            myReferenceGeometry.scale.x = scale;
            myReferenceGeometry.scale.y = scale;
            myReferenceGeometry.scale.z = scale;

            myReferenceGeometry.position.copy(lookAtPoint);

            return myReferenceGeometry;
        }

        function getSnapVector(index)
        {
            myVec1.set(0.0, 0.0, 0.0);
            if( index >= 0 )
            {
                var v = (index >= 3) ? -1 : 1;
                index %= 3;
                if( index === 0 ) myVec1.x = v;
                if( index === 1 ) myVec1.y = v;
                if( index === 2 ) myVec1.z = v;
            }
            if( myAnglesFlipped )
                myVec1.multiplyScalar(-1);

            return myVec1;
        }

        function closestSnap(dtheta, snapThresh)
        {
            var diff = angleDiff(mySnapAngles[0], dtheta);
            var closest = 0;
            for (var i = 1; i < 6; ++i)
            {
                var d = angleDiff(mySnapAngles[i], dtheta);
                if (d < diff)
                {
                    diff = d;
                    closest = i;
                }
            }
            myClosestAngle = diff;
            return (diff < snapThresh) ? closest : -1;
        }

        function setWorldUp(upvec)
        {
            _navapi.setIsLocked(false);
            _navapi.setWorldUpVector(upvec, true);
            _navapi.setIsLocked(true);
        }

        function applyRoll(angle)
        {
            if( angle === 0.0 )
                return;

            var kStableRollThreshold = 30.0 * Math.PI / 180.0;
            var view = myVec2.copy(myCamera.position).sub(myLookAtPoint).normalize();

            // Create a quaterion rotation about the roll axis by the angle:
            myRotate.setFromAxisAngle( view, angle );

            // Check the angle between the view vector and the world up.
            // When we get close the roll about the view vector becomes unstable
            // so we jump the up vector to the camera's current vertical.
            // This should be OK because if we're here we know we aren't snapped.
            var up = _navapi.getWorldUpVector();
            var viewUpAngle = Math.abs(view.angleTo(up));
            if( viewUpAngle < kStableRollThreshold || (Math.PI - viewUpAngle) < kStableRollThreshold )
            {
                // stderr("JUMP angle " + viewUpAngle.toFixed(3));
                up.copy(_navapi.getCameraUpVector());  // This is the actual camera up
            }
            // Rotate the current up vector by that quaternion:
            up.applyQuaternion( myRotate );

            // stderr("New UP: " + up.x.toFixed(2) + ", " + up.y.toFixed(2) + ", " + up.z.toFixed(2) );
            setWorldUp(up);
        }

        function justNowSnapped()
        {
            if( !myCurrentlySnapped )
            {
                var closest = closestSnap(myRollAngle, kSnapInThreshold);
                if( closest >= 0 )
                {
                    myClosestAngle = 0.0;
                    myCurrentlySnapped = true;
                    myRollAngle = mySnapAngles[closest];
                    return getSnapVector(closest);
                }
            }
            return false;
        }

        function justNowUnsnapped()
        {
            if( myCurrentlySnapped )
            {
                var closest = closestSnap(myRollAngle, kSnapOutThreshold);
                if( closest < 0 )
                {
                    // stderr("UNSNAP");
                    myCurrentlySnapped = false;
                    return true;
                }
                myClosestAngle = 0.0;
            }
            return false;
        }

        function isReallySnapped(angle, threshold, i, worldUp)
        {
            var circleSnapped = (angle < threshold);
            if( circleSnapped )
            {
                // Check if the up direction really is the same:
                var snapUp = getSnapVector(i);
                return (snapUp.distanceToSquared(worldUp) < kEpsilon);
            }
            return false;
        }

        function updateIndicators(worldUp, cameraUp)
        {
            // Check if the camera is upside down. If so, up is down.
            var wDotC = worldUp.dot(cameraUp);
            var flipped = (wDotC < 0.0);
            if( flipped )
                cameraUp = cameraUp.clone().multiplyScalar(-1);

            // Need to re-orient and position the UP indicator.
            // The scalar is the middle radius of the ring geometry.
            _navapi.orient(myReferenceUp, myLookAtPoint, myCamera.position, cameraUp);
            myReferenceUp.position.copy(cameraUp.multiplyScalar(0.495));

            var isSnapped = false;
            var threshold = myCurrentlySnapped ? kSnapOutThreshold : kSnapInThreshold;
            for (var i = 0; i < 6; ++i)
            {
                var angle = angleDiff(mySnapAngles[i], myRollAngle);
                var snapped = isReallySnapped(angle, threshold, i, worldUp);
                if( snapped )
                    isSnapped = true;
                var proximityScale = snapped ? 4.0 : (1.0 - 3.0 * angle / Math.PI) * 3.0;
                if( proximityScale < 1.0 )
                    proximityScale = 1.0;

                // Keep the snap point sizes independent of the ring size:
                proximityScale *= myRingShrink;

                // This turns off/on the inner snap indicator circle within
                // each of the snap points:
                mySnapFlags[i].visible = snapped;
                var snap = mySnapPoints[i];
                snap.scale.x = proximityScale;
                snap.scale.y = proximityScale;
                snap.scale.z = proximityScale;
            }
            myReferenceXaxis.visible = isSnapped;
            myReferenceYaxis.visible = isSnapped;
            myReferenceZaxis.visible = isSnapped;

            return isSnapped;
        }

        this.updateRollCamera = function(size, distance)
        {
            myCamera.position.copy(mySceneCamera.position);
            myCamera.quaternion.copy(mySceneCamera.quaternion);
            myCamera.up.copy(mySceneCamera.up);
            myCamera.aspect = mySceneCamera.aspect;
            myCamera.fov = kHudFov;

            if( size && distance )
            {
                myCamera.near = distance - size;
                myCamera.far  = distance + size;
            }
            myCamera.updateProjectionMatrix();
        };

        this.isSnapped = function()
        {
            return myCurrentlySnapped;
        };

        // TODO: Check for rolled camera and re-orient to up before setting up HUD.
        this.start = function(lookAtPoint)
        {
            var worldUp  = _navapi.getWorldUpVector();
            var cameraUp = _navapi.getCameraUpVector();

            myLookAtPoint = lookAtPoint;

            // We used to have a variable ring size but for now it's fixed size:
            var ringSize = (kRingSizeMin + kRingSizeMax) * 0.5;
            myRingShrink = kRingSizeMax / ringSize;

            var viewVec = myVec1.copy(lookAtPoint).sub(mySceneCamera.position);
            var distance = viewVec.length();

            var worldHeight = distance * kHudWorldScale;
            var worldSize   = worldHeight * ringSize;

            this.updateRollCamera(worldSize, distance);

            viewerImpl.addOverlay("roll", getReferenceGeometry(worldSize, lookAtPoint, viewVec, worldUp, cameraUp));
            myRollAngle = 0.0;
            mySnappedRoll = 0.0;

            var wDotC = worldUp.dot(cameraUp);
            myAnglesFlipped = (wDotC < 0.0);

            myCurrentlySnapped = updateIndicators(worldUp, cameraUp);
        };

        this.handleRoll = function( dx, dy, p2 )
        {
            this.updateRollCamera();

            updateIndicators(_navapi.getWorldUpVector(), _navapi.getCameraUpVector());

            if( dx !== 0.0 || dy !== 0.0 )
            {
                // 2D vectors from the center of the screen (0.5, 0.5)
                var v1x = p2.x - dx - 0.5;
                var v1y = p2.y - dy - 0.5;
                var v2x = p2.x - 0.5;
                var v2y = p2.y - 0.5;

                // Angle between those to vectors is the rotation of the mouse
                // around the center of the screen:
                return handleRollByAngle(Math.atan2(v2y, v2x) - Math.atan2(v1y, v1x));
            }
            return false;
        };

        this.handleRollTouch = function ( angle )
        {
            this.updateRollCamera();

            updateIndicators(_navapi.getWorldUpVector(), _navapi.getCameraUpVector());

            var delta = angle - myRollAngle;
            return (Math.abs(delta) > 0.001) ? handleRollByAngle(delta) : false;
        };

        function handleRollByAngle ( angle )
        {
            // Make sure it's in the right range for comparison with the
            // snap angles:
            myRollAngle += angle;
            if( myRollAngle > Math.PI )
                myRollAngle = myRollAngle - kTwo_PI;
            else if( myRollAngle <= -Math.PI )
                myRollAngle = kTwo_PI + myRollAngle;

            // stderr("ROLL: " + myRollAngle.toFixed(3));

            var snappedUp = justNowSnapped();
            if( snappedUp )
            {
                // stderr("SNAP: " + snappedUp.x + ", " + snappedUp.y + ", " + snappedUp.z );
                mySnappedRoll = myRollAngle;
                setWorldUp(snappedUp);
            }
            else if( justNowUnsnapped() )
            {
                // Because the snap points are "sticky" the roll amount
                // in this case is the distance from the snap point:
                var deltaRoll = myRollAngle - mySnappedRoll;
                applyRoll(deltaRoll);
                mySnappedRoll = 0.0;
            }
            else if( !myCurrentlySnapped )
            {
                applyRoll(angle);
            }
            else
                return false;

            return true;
        }

        this.end = function()
        {
            viewerImpl.removeOverlay("roll", myReferenceGeometry);
        };
    }

    var kTwo_PI  = 2.0 * Math.PI; // 360 degrees.
    var kScreenEpsilon = 0.001;
    var kEpsilon = 0.00001;

    var _navapi = viewerApi.navigation;
    var _camera = _navapi.getCamera();
    var _names = ["worldup"];

    var _isDragging = false;
    var _needNextRefresh = false;

    var _rollInteraction = new RollInteraction(viewerImpl, _camera);
    var _startXYZ = new THREE.Vector3();
    var _moveXYZ  = new THREE.Vector3();
    var _motionDelta = new THREE.Vector3();
    var _touchType = null;
    var _touchAngle = 0.0;
    
    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(name)
    {
        // Stash the current COI and while the interaction is active
        // use the center of the view as the pivot for rolling.
        //
        // Position the temporary COI half way between the near and far
        // clipping planes to avoid clipping problems:
        //
        var viewVec = _navapi.getEyeVector();
        var distance = (_camera.near + _camera.far) * 0.5;
        viewVec.normalize().multiplyScalar(distance);
        var target = viewVec.add(_camera.position);

        this.utilities.savePivot();
        this.utilities.setPivotPoint( target, true, true );
        this.utilities.pivotActive(true);

        _navapi.setIsLocked(true);

        _rollInteraction.start( target );
    };

    this.deactivate = function(name)
    {
        _rollInteraction.end();
        _navapi.setIsLocked(false);
        this.utilities.restorePivot();

        _isDragging = false;
    };
    
    this.getCursor = function()
    {
        return "auto";
    };

    this.getMotionDelta = function(dxyz)
    {
        var deltaX = _moveXYZ.x - _startXYZ.x;
        var deltaY = _moveXYZ.y - _startXYZ.y;
        var deltaZ = _moveXYZ.z - _startXYZ.z;

        if( Math.abs(deltaX) < kScreenEpsilon ) deltaX = 0.0;
        if( Math.abs(deltaY) < kScreenEpsilon ) deltaY = 0.0;
        if( Math.abs(deltaZ) < kScreenEpsilon ) deltaZ = 0.0;

        dxyz.set(deltaX, deltaY, deltaZ);
    };

    this.stepMotionDelta = function()
    {
        _startXYZ.copy(_moveXYZ);
    };

    this.update = function()
    {
        var moved = _needNextRefresh;

        this.getMotionDelta(_motionDelta);

        var deltaX = _motionDelta.x;
        var deltaY = _motionDelta.y;
        var deltaZ = _motionDelta.z;

        if( _needNextRefresh || _touchType === "roll" || _isDragging && (deltaX !== 0.0 || deltaY !== 0.0 || deltaZ !== 0.0) )
        {
            if( _touchType === "roll" )
                _needNextRefresh = _rollInteraction.handleRollTouch(_touchAngle);
            else
                _needNextRefresh = _rollInteraction.handleRoll(deltaX, deltaY, _moveXYZ);
        }
        this.stepMotionDelta();

        if( _camera.dirty )
            moved = true;

        return moved;
    };

    this.handleResize = function()
    {
        _needNextRefresh = true;
    };
    
    this.handleGesture = function( event )
    {
        switch( event.type )
        {
            case "dragstart":
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return this.handleMouseMove(event);

            case "dragend":
                return this.handleButtonUp(event, 0);

            case "rotatestart":
                _touchType = "roll";
                _touchAngle = THREE.Math.degToRad(event.rotation);
                // Single touch, fake the mouse for now...
                return true;

            case "rotatemove":
                _touchAngle = THREE.Math.degToRad(event.rotation);
                return (_touchType === "roll");

            case "rotateend":
                _touchAngle = THREE.Math.degToRad(event.rotation);

                // Sigh... minor hack
                // Can't consume the end event because the hot gesture
                // tool needs to see it to end the interaction.
                return false;
        }
        return false;
    };

    this.handleWheelInput = function(delta)
    {
        // Disable wheel while roll active:
        return true;
    };

    this.handleButtonDown = function( event, button )
    {
        _startXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _startXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        _moveXYZ.copy(_startXYZ);

        _isDragging = true;
        _touchType = null;
        this.controller.setIsLocked(true);
        return true;
    };

    this.handleButtonUp = function( event, button )
    {
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;

        _isDragging = false;
        _needNextRefresh = true;    // To accept final motion.
        this.controller.setIsLocked(false);
        return true;
    };

    this.handleMouseMove = function( event )
    {
        _moveXYZ.x = (event.normalizedX + 1.0) * 0.5;
        _moveXYZ.y = 1.0 - (event.normalizedY + 1.0) * 0.5;
        return true;
    };

    this.handleBlur = function(event)
    {
        _isDragging = false;
        _touchType = null;
        return false;
    };

};
;AutodeskNamespace('Autodesk.Viewing.Private');

Autodesk.Viewing.Private.Selector = function(viewer) {

    //Selection support
    var _this = this;
    this.viewer = viewer;
    this.model = null;
    this.selectedObjectIds = {};
    this.selectionCount = 0;

    var selectedParentMap = {};

    viewer.api.addEventListener( Autodesk.Viewing.ISOLATE_EVENT, function(event) {
        _this.deselectInvisible();
    });
    
    viewer.api.addEventListener( Autodesk.Viewing.HIDE_EVENT, function(event) {
        _this.deselectInvisible();
    });
    
    function unmarkObject(object) {
        var objectId = object.dbId || object.fragIds;

        if (selectedParentMap[objectId] > 0) {
            selectedParentMap[objectId]--;
            if (selectedParentMap[objectId] == 0) {
                _this.viewer.highlightObjectNode(_this.model, object, false);
            }

        } else if (selectedParentMap[objectId] < 0) {
            throw ("Selection State machine broken. Negatively selected object!");
        }
        if (object.children) {
            for (var i = 0; i < object.children.length; i++) {
                unmarkObject(object.children[i]);
            }
        }

    }

    function markObject(object, isChild) {
        var objectId = object.dbId || object.fragIds;

        if (selectedParentMap[objectId]) {
            selectedParentMap[objectId]++;
        } else {
            _this.viewer.highlightObjectNode(_this.model, object, true, isChild);
            selectedParentMap[objectId] = 1;
        }
        if (object.children) {
            for (var i = 0; i < object.children.length; i++) {
                markObject(object.children[i], true);
            }
        }
    }

    this.getSelectionLength = function() {
        return _this.selectionCount;
    };


    this.getSelection = function() {
        var ret = [];
        var sset = _this.selectedObjectIds;
        for (var p in sset) {
            if (sset[p]) {
                ret.push(sset[p]);
            }
        }

        return ret;
    };

    this.clearSelection = function(nofire) {
        if (this.selectionCount > 0) {
            var sset = _this.selectedObjectIds;
            for (var p in sset) {
                if (sset[p])
                    unmarkObject(sset[p]);
            }
            _this.selectedObjectIds = {};
            _this.selectionCount = 0;

            if( !nofire )
                this.fireSelectionChangedEvent();
        }
    };

    this.fireSelectionChangedEvent = function() {
        var dbIdArray = [];
        var fragIdsArray = [];

        var sset = _this.selectedObjectIds;
        for (var p in sset) {
            var obj = sset[p];
            if (obj) {
                dbIdArray.push(obj.dbId);
                fragIdsArray.push(obj.fragIds);
            }
        }

        var event = {
            type: Autodesk.Viewing.SELECTION_CHANGED_EVENT,
            dbIdArray: dbIdArray,
            fragIdsArray: fragIdsArray,
            nodeArray: this.getSelection()
        };

        Autodesk.Viewing.Private.logger.log({
           viewer_current_time : Date.now(),
           viewer_event_type : 'selection',
           viewer_event_on_object : dbIdArray
        });

        this.viewer.api.fireEvent(event);
    };

    this.isSelected = function(dbNode) {
        if (dbNode && this.selectedObjectIds[dbNode.dbId])
            return true;
    };


    // NB: Node cannot be null
    function select(dbNode) {
        var found = _this.isSelected(dbNode);
        if (!found) {
            _this.selectedObjectIds[dbNode.dbId] = dbNode;
            _this.selectionCount++;
            markObject(dbNode);
        }
    }

    // NB: Node cannot be null
    function deselect(dbNode) {
        var found = _this.isSelected(dbNode);
        if (found) {
            unmarkObject(dbNode);
            _this.selectedObjectIds[dbNode.dbId] = null;
            _this.selectionCount--;
        }
    }

    // TODO: Optimize this so both select and toggleSelection don't have to lookup the node index.
    this.toggleSelection = function(dbNode) {
        if (!dbNode) {
            console.error("Attempting to select a null node.");
            return;
        }

        if (!this.isSelected(dbNode)) {
            select(dbNode);
        } else {
            deselect(dbNode);
        }
        _this.fireSelectionChangedEvent();
    };

    this.setSelectionIds = function(dbNodeIdArray) {
        this.setSelection(this.model.getNodesByIds(dbNodeIdArray));
    };

    this.selectionIsEqual = function(dbNodeArray) {
        if( this.selectionCount !== dbNodeArray.length )
            return false;

        for (var i = 0; i < dbNodeArray.length; i++) {
            if (!this.isSelected(dbNodeArray[i])) 
                return false;
        }
        return true;
    };

    this.setSelection = function(dbNodeArray) {
        if( this.selectionIsEqual( dbNodeArray ) )
            return;

        this.clearSelection(true);

        if (dbNodeArray == null)
            return;

        for (var i = 0; i < dbNodeArray.length; i++) {
            select(dbNodeArray[i]);
        }

        this.fireSelectionChangedEvent();
    };

    this.deselectInvisible = function() {
        var changed = false;

        var sset = _this.selectedObjectIds;
        for (var p in sset) {
            var obj = sset[p];
            if (obj && obj.visible == false) {
                deselect(obj);
                changed = true;
            }
        }

        if (changed) {
            this.fireSelectionChangedEvent();
        }
    };
    
    this.toggleSelectionId = function(dbNodeId) {
        this.toggleSelection(this.model.getNodeById(dbNodeId));
    };

    this.isSelectedOrParentIsSelected = function(node) {
        while (node) {
            if (this.isSelected(node)) {
                return true;
            }
            node = node.parent;
        }
        return false;
    };

    function getSelectionFragIds() {
        var res = [];
        var sset = _this.selectedObjectIds;
        for (var p in sset) {
            var dbNode = sset[p];
            if (dbNode)
                _this.model.getNodeFragments(parseInt(p), res);
        }

        return res;
    }

    this.getSelectionBounds = function() {
        var bounds = new THREE.Box3();
        var box = new THREE.Box3();

        var fragIds = getSelectionFragIds();
        var viewer = this.viewer;
        var model = this.model;

        for (var i = 0; i < fragIds.length; ++i) {
            var m = viewer.getRenderProxy(model, fragIds[i]);
            if (m) {
                box.copy(m.geometry.boundingBox).applyMatrix4(m.matrixWorld);
                bounds.union(box);
            }
        }

        return bounds;
    };

    this.getSelectionVisibility = function () {
        var hasVisible = false,
            hasHidden = false;

        var sset = _this.selectedObjectIds;
        for (var p in sset) {
            var obj = sset[p];
            if (obj) {
                if (Autodesk.Viewing.Private.VisibilityManager.isVisible(obj)) {
                    hasVisible = true;
                } else {
                    hasHidden = true;
                }
                if (hasVisible && hasHidden) {
                    break;
                }
            }
        }

        return {hasVisible: hasVisible, hasHidden: hasHidden};
    };

    this.uninitialize = function () {
        this.viewer = null;
        this.model = null;
        this.selectedObjectIds = null;
    };
};
;AutodeskNamespace('Autodesk.Viewing.Private');

Autodesk.Viewing.Private.VisibilityManager = function(viewerImpl) {
	this.viewerImpl = viewerImpl;

	//Currently the visibility manager works on a single model only
	//so we make this explicit here.
	this.model = null;

    // Keep track of isolated nodes
    this.isolatedNodes = [];
};

Autodesk.Viewing.Private.VisibilityManager.prototype.getIsolatedNodes = function() {
    return this.isolatedNodes.slice(0);
}

Autodesk.Viewing.Private.VisibilityManager.prototype.isolate = function(node)
{
    if (node) {
        this.isolateMultiple([node]);
    } else {
        this.isolateNone();
    }
};

Autodesk.Viewing.Private.VisibilityManager.prototype.isolateNone = function() {

	this.viewerImpl.setModelVisibility(this.model, true);

	var root = this.model ? this.model.getRoot() : null;
	if (root) {
		this.setVisibilityOnNode(root, true);
	}

    this.isolatedNodes = [];
    this.viewerImpl.resetIsolation(this.model);

	var event = {type:Autodesk.Viewing.ISOLATE_EVENT, nodeIdArray: []};
	this.viewerImpl.api.fireEvent(event);
};

//Makes the children of a given node visible and
//everything else not visible
Autodesk.Viewing.Private.VisibilityManager.prototype.isolateMultiple = function(nodeList)
{
    //If given nodelist is null or is an empty array or contains the whole tree
    if (!nodeList || nodeList.length == 0 ) {
        this.isolateNone();
    }
    else {

    	var root = this.model ? this.model.getRoot() : null;
    	if (root) {
			this.setVisibilityOnNode(root, false);
		}
		this.viewerImpl.setModelVisibility(this.model, false);

        for (var i=0; i < nodeList.length; i++) {
            this.setVisibilityOnNode(nodeList[i], true);
            this.viewerImpl.needGhostedPass = true;
        }

        this.isolatedNodes = nodeList.slice(0);
        var event = {type:Autodesk.Viewing.ISOLATE_EVENT, nodeIdArray: nodeList};
        this.viewerImpl.api.fireEvent(event);
    }

    //force a repaint and a clear
    this.viewerImpl.invalidate(true);
};


Autodesk.Viewing.Private.VisibilityManager.prototype.hideMultiple = function(nodes) {
    for (var i=0; i < nodes.length; ++i) {
        this.setVisibilityOnNode(nodes[i],false);
    }

    if (nodes.length > 0) {
        var event = { type: Autodesk.Viewing.HIDE_EVENT, nodeIdArray: nodes};
        this.viewerImpl.api.fireEvent(event);
    }
};

//Makes the children of a given node visible and
//everything else not visible
Autodesk.Viewing.Private.VisibilityManager.prototype.hide = function(node)
{
    this.setVisibilityOnNode(node,false);
    var event = { type: Autodesk.Viewing.HIDE_EVENT, nodeIdArray: [node] };
    this.viewerImpl.api.fireEvent(event);
};

Autodesk.Viewing.Private.VisibilityManager.prototype.showMultiple = function(nodes) {
    for (var i=0; i < nodes.length; ++i) {
        this.setVisibilityOnNode(nodes[i],true);
    }

    if (nodes.length > 0) {
        var event = { type: Autodesk.Viewing.SHOW_EVENT, nodeIdArray: nodes};
        this.viewerImpl.api.fireEvent(event);
    }
};

Autodesk.Viewing.Private.VisibilityManager.prototype.show = function(node)
{
    this.setVisibilityOnNode(node,true);
    var event = { type: Autodesk.Viewing.SHOW_EVENT, nodeIdArray: [node] };
    this.viewerImpl.api.fireEvent(event);
};

Autodesk.Viewing.Private.VisibilityManager.prototype.toggleVisibility = function(node)
{
    var vis = Autodesk.Viewing.Private.VisibilityManager.isVisible(node);
	this.setVisibilityOnNode(node, !vis);
	if (vis) {
		var event = { type: Autodesk.Viewing.HIDE_EVENT, nodeIdArray: [node] };
		this.viewerImpl.api.fireEvent(event);
	} else {
	    var event = { type: Autodesk.Viewing.SHOW_EVENT, nodeIdArray: [node] };
		this.viewerImpl.api.fireEvent(event);
	}
};

Autodesk.Viewing.Private.VisibilityManager.prototype.setVisibilityOnNode = function(node, visible)
{
    var viewer = this.viewerImpl;
    var model = this.model;
    var that = this;

    //Now descend the node and mark any child fragments
    //as visible
    (function makeInVisibleRec(node) {
        // Make sure to remove from isolation tracking array
        if (node.visible && !visible) {
            for (var iN = 0, len = that.isolatedNodes.length; iN < len; ++iN) {
                if (that.isolatedNodes[iN].dbId === node.dbId) {
                    that.isolatedNodes.splice(iN,1);
                    break;
                }
            }
        }

		node.visible = visible;
        var frags = node.fragIds;

        if (frags !== undefined) {
            if (Array.isArray(frags)) {
                for (var j=0; j<frags.length; j++) {
                    viewer.setFragmentVisibility(model, frags[j], visible);
                }
            }
            else  {
                viewer.setFragmentVisibility(model, frags, visible);
            }
        }

        if (node.children)
            for (var k=0; k<node.children.length; k++)
                makeInVisibleRec(node.children[k]);
    })(node);

    this.viewerImpl.needGhostedPass = true;

    //force a repaint and a clear
    this.viewerImpl.invalidate(true,false,true);
};


Autodesk.Viewing.Private.VisibilityManager.isVisible = function (node) {
	if (node.visible != null) {
		return node.visible;
	}
	return true;
};

Autodesk.Viewing.Private.VisibilityManager.prototype.areAllVisible = function () {
	return this.viewerImpl.isWholeModelVisible(this.model);
};
;AutodeskNamespace('Autodesk.Viewing.Private');

var NUM_WORKER_THREADS = 3;
var NUM_PARALLEL_DOWNLOADS = 2;
// A cache of entire worker script.
var WORKER_SCRIPT = null;

if (!LMV_WORKER_URL)
    var LMV_WORKER_URL = "src/workers/MainWorker.js";

if (ENABLE_INLINE_WORKER == undefined)
    var ENABLE_INLINE_WORKER = false;

if (ENABLE_DEBUG) {
    //On a local machine, these settings are faster
    NUM_WORKER_THREADS = 6;
    NUM_PARALLEL_DOWNLOADS = 6;
}

var WORKER_LOAD_GEOMETRY = "LOAD_GEOMETRY";
var WORKER_LOAD_SVF = "LOAD_SVF";
var WORKER_SEARCH = "SEARCH";
var WORKER_GET_PROPERTIES = "GET_PROPERTIES";
var WORKER_SEARCH_PROPERTIES = "SEARCH_PROPERTIES";
var WORKER_GET_OBJECT_TREE = "GET_OBJECT_TREE";
var WORKER_PARSE_F2D = "PARSE_F2D";
var WORKER_STREAM_F2D = "STREAM_F2D";
var WORKER_PARSE_F2D_FRAME = "PARSE_F2D_FRAME";
var WORKER_CLOUD_RENDERING = "CLOUD_RENDERING";
var WORKER_SVF_TO_SPD = "SVF_TO_SPD";

/** @constructor */
Autodesk.Viewing.Private.SvfLoader = function (parent) {
    this.viewer3DImpl = parent;
    this.next_pack = 0;
    this.loading = false;
    this.tmpMatrix = new THREE.Matrix4();
	this.getObjectTreeCallbacks = [];

    // When we reach here and logger is still not initialized,
    // then we are sure that viewer is running in 'local testing mode',
    // since that is the only case the global initialization functions are not invoked.
    // So, initialize logger in 'local mode' where the only data sink is browser console.
    if (!Autodesk.Viewing.Private.logger) {
        var loggerConfig = {
            console : true,
            viewingservice : false,
            webstorage : false,
            endpoint : '',
            flushThreshold : 0
        };

        Autodesk.Viewing.Private.logger = new Autodesk.Viewing.Private.Logger(loggerConfig);
    }
    this.logger = Autodesk.Viewing.Private.logger;
    this.loadTime = 0;
    this.domainParam = auth ? ("domain=" + window.location.hostname) : "";
}

Autodesk.Viewing.Private.SvfLoader.prototype.uninitialize = function () {
    this.svf = null;
    this.viewer3DImpl = null;
};

//Maps a relative resource path (like a pack file or texture)
//to an absolute URL (possibly signed).
Autodesk.Viewing.Private.SvfLoader.prototype.pathToURL = function(path) {

    if (path.substr(0,7) == "http://" ||
        path.substr(0,8) == "https://" ||
        path.substr(0,8) == "file:///" ||
        path.substr(0,4) == "urn:") {
        return path;
    }
    
    var rootRelPath = window.location.pathname;
    //chop off the index.html part
    var lastSlash = rootRelPath.lastIndexOf("/");
    rootRelPath = rootRelPath.substr(0, lastSlash+1);
    var absPath = window.location.protocol + "//" + window.location.host + rootRelPath + path;
    //stderr(absPath);
    return absPath;
};

Autodesk.Viewing.Private.SvfLoader.prototype.loadSvf = function(path, ids, propertyDbPath, onSuccess, onError) {
    if (this.loading) {
        stderr("loading of SVF already in progress.");
        return false;
    }

    var index = path.indexOf('urn:');
    if (index != -1) {
        // Extract urn:adsk.viewing:foo.bar.whateverjunks out of the path URL and bind it to logger.
        // From now on, we can send logs to viewing service, and logs are grouped by urn to make Splunk work.
        this.logger.bindURN(path.substr(index, path.substr(index).indexOf('/')));
        stderr("Extracted URN: " + this.logger.urn);

        // Extract urn(just base64 code)
        var _index = this.logger.urn.lastIndexOf(':');
        this.svfUrn = this.logger.urn.substr(_index + 1);
    }

    this.sharedDbPath = propertyDbPath;
    this.currentLoadPath = path;
    var isf2d = this.isf2d = path.indexOf(".f2d") != -1;

    if (ENABLE_INLINE_WORKER) {
        var xhr = new XMLHttpRequest();
        var scriptURL = (RESOURCE_ROOT + LMV_WORKER_URL);

        // We need to request the same version of the library for this worker.
        //
        // Determine the version of the library that was originally requested by searching
        // for the script URL and parsing the version query string.
        //
        function getOriginalScriptURL() {
            var scripts = document.getElementsByTagName('SCRIPT');
            if (scripts && scripts.length > 0) {
                for (var i = 0; i < scripts.length; ++i) {
                    if (scripts[i].src && scripts[i].src.indexOf(LMV_WORKER_URL) !== -1) {
                        return scripts[i].src;
                    }
                }
            }
            return null;
        }

        var originalScriptURL = getOriginalScriptURL();

        if (originalScriptURL) {
            scriptURL = originalScriptURL;
        }

        xhr.open("GET", scriptURL, true);
        xhr.setRequestHeader("Access-Control-Allow-Origin", "*");
        xhr.withCredentials = false;

        var scope = this;
        xhr.onload = function () {
            // TODO:  Should this be set somewhere?  Is this the right place?
            // this.loading = true;
            //
            // Set up global cached worker script.
            WORKER_SCRIPT = xhr.responseText;

            if (isf2d)
                scope.loadFydoCB(path, ids, onSuccess, onError);
            else
                scope.loadSvfCB(path, ids, onSuccess, onError);
        };

        xhr.send();
        
        // The loading of the SVF was started, return true.
        //
        return true;
    } else {
        if (isf2d)
            return this.loadFydoCB(path, ids, onSuccess, onError);
        else
            return this.loadSvfCB(path, ids, onSuccess, onError);
    }
};

Autodesk.Viewing.Private.SvfLoader.prototype.loadSvfCB = function(path, ids, onSuccess, onError) {
    this.t0 = new Date().getTime();
    this.failedToLoadSomeGeometryPacks = null;

    var scope = this;
    var onSVFLoad = function (ew) {
        var cleaner = function() {
            w.finish();
            w = null;
        };

        if (ew.data && ew.data.svf) {
            //Decompression is done.
            var svf = scope.svf = ew.data.svf;


            if (scope.failedToLoadSomeGeometryPacks) {
                // Report a warning. It is not a fatal error.
                if (onError)
                    onError( scope.failedToLoadSomeGeometryPacks.code, scope.failedToLoadSomeGeometryPacks.msg);
                scope.failedToLoadSomeGeometryPacks = null;
            }

            scope.onSvfLoadDone(svf);
            if (onSuccess)
                onSuccess(svf);

            //Launch jobs for some geometry packs
            var numGeomPacks = svf.geompacks.length;
            if (numGeomPacks) {
                var count = Math.min(numGeomPacks, NUM_PARALLEL_DOWNLOADS);
                for (var i=0; i<count; i++) {
                    var pf = svf.geompacks[i];
                    scope.loadGeometryPack(pf.id, pf.uri);
                    scope.next_pack = i + 1;
                }
            } else {
                scope.onGeomLoadDone();
            }
            scope.loading = false;

            cleaner();
        } else if (ew.data && ew.data.progress) {
            // TODO: ????
        } else if (ew.data && ew.data.error) {
            scope.loading = false;
            cleaner();
            if (onError)
                onError(ew.data.error.code, ew.data.error.msg);
        } else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else {
            stderr("SVF download failed.");
            //Download failed.
            scope.loading = false;
            cleaner();
        }
    };
    var w = createWorkerWithTokenRefresh(onSVFLoad, 'SVF Load');
    var svfPath = scope.pathToURL(path);
    var msg = { operation:WORKER_LOAD_SVF,
        url: svfPath,
        headers: {} ,
        objectIds : ids,
        auth : auth,
        viewing_url : VIEWING_URL,
        queryParams : this.domainParam
    };

    w.postMessage(msg);

    return true;
};

Autodesk.Viewing.Private.SvfLoader.prototype.loadFydoCB = function(path, ids, onSuccess, onError) {
    this.t0 = Date.now();

    var svfPath = this.pathToURL(path);

    // Streaming worker as data producer that generates fydo frame streams.
    var streamingWorker = createWorker();
    // Parsing worker as data consumer that consumes fydo frame streams and generate meshes.
    var parsingWorker = createWorker();
    var scope = this;

    var f2dOptions = {
        //modelSpace : true
    };

    var onStream = function (ew) {
        if (ew.data && ew.data.type == "F2DBLOB") {
            var msg = { operation:WORKER_PARSE_F2D,
                data: ew.data.buffer,
                metadata: ew.data.metadata,
                manifest: ew.data.manifest,
                basePath: ew.data.basePath,
                f2dLoadOptions: f2dOptions,
                url: svfPath
                };
            parsingWorker.postMessage(msg, [msg.data]);
            streamingWorker.terminate();

        } else if (ew.data && ew.data.type == "F2DSTREAM") {

            var msg = { operation:WORKER_PARSE_F2D_FRAME,
                        data: ew.data.frames,
                        url: svfPath,
                        f2dLoadOptions: f2dOptions
                      };

            //first frame
            if (ew.data.metadata) {
                msg.metadata = ew.data.metadata;
                msg.manifest = ew.data.manifest;
            }

            //last frame?
            if (ew.data.finalFrame)
                msg.finalFrame = true;

            if (ew.data.progress)
                scope.viewer3DImpl.signalProgress(100*ew.data.progress);

            parsingWorker.postMessage(msg, msg.data ? [msg.data] : undefined);

            if (ew.data.finalFrame)
                streamingWorker.terminate();
        }
        else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else if (ew.data && ew.data.error) {
            scope.loading = false;
            streamingWorker.terminate();
            if (onError)
                onError.call(this, ew.data.error.code, ew.data.error.msg);
        } else {
            stderr("F2D download failed.");
            scope.loading = false;
            streamingWorker.terminate();
        }
    };



    var onParse = function (ew) {
        if (ew.data && ew.data.f2d) {
            var f = scope.svf = ew.data.f2d;

            parsingWorker.terminate();

            stderr("Num polylines: " + f.numPolylines);
            stderr("Line segments: " + f.numLineSegs);
            stderr("Circular arcs: " + f.numCircles);
            stderr("Ellipitcal arcs:" + f.numEllipses);
            stderr("Plain triangles:" + f.numTriangles);
            stderr("Total # of op codes generated by fydo.parse: " + f.opCount);

            scope.onSvfLoadDone(scope.svf);
            if (onSuccess)
                onSuccess(scope.svf);

            for (var i=0; i < f.meshes.length; i++) {
                scope.processReceivedMesh2D(f.meshes[i], i);
            }

            f.meshes = null;

            scope.onGeomLoadDone();

            scope.loading = false;

        }  else if (ew.data && ew.data.f2dframe) {
            // stderr("# of op codes generated by f2d.parseFrame: " + ew.data.f2dframe.opCount);
            var baseIndex = 0;

            if (!ew.data.meshes) {
                //First message from the worker
                scope.svf = ew.data.f2dframe;
                baseIndex = ew.data.baseIndex;
            } else {
                //Update the world box and current mesh index
                //on subsequent messages from the worker.
                var bbox = ew.data.bbox;
                scope.svf.bbox = new THREE.Box3(bbox.min, bbox.max);
                baseIndex = ew.data.baseIndex;
            }

            var f = scope.svf;

            if (!f.fragments || !f.fragments.initialized) {
                //First message from the worker,
                //initialize the load states, fragment lists, etc.
                scope.onSvfLoadDone(f);

                if (onSuccess) {
                    onSuccess(f);
                }
            }
            else {
                f.maxObjectNumber = ew.data.maxObjectNumber;
            }

            if (ew.data.meshes && ew.data.meshes.length)
            {
                for (var i = 0; i < ew.data.meshes.length; i++) {
                    scope.processReceivedMesh2D(ew.data.meshes[i], baseIndex+i);
                }

                if (ew.data.finalFrame) {
                    scope.onGeomLoadDone();

                    scope.loading = false;

                    parsingWorker.terminate();
                }
            }

        } else if (ew.data && ew.data.progress) {
            // TODO: ???
        } else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else if (ew.data && ew.data.error) {
            scope.loading = false;
            parsingWorker.terminate();

            stderr("Error while parsing F2d: " + JSON.stringify(ew.data.error.args));

            // TODO: in debug model, viewer3d.html does not have any on error callback.
            // So, any errors would be swallowed, instead of reported back.
            // Is this intended? We should at least print the stack on console to help make our life easier.
            if (onError)
                onError.call(this, ew.data.error.code, ew.data.error.msg);
        } else {
            stderr("F2D download failed.");
            //Download failed.
            scope.loading = false;
            parsingWorker.terminate();
        }
    };

    streamingWorker.addEventListener('message', onStream, false);
    parsingWorker.addEventListener('message', onParse, false);

    var msg = { operation:WORKER_STREAM_F2D,
        url: svfPath,
        headers: {} ,
        objectIds : ids,
        auth : auth,
        viewing_url : VIEWING_URL,
        queryParams : this.domainParam };  // For CORS caching issue.

    streamingWorker.postMessage(msg);

    return true;
};


Autodesk.Viewing.Private.SvfLoader.prototype.loadGeometryPack = function (packId, path) {
    var w;
    var workerId;
    var i, j;
    var scope = this;

    var onMeshLoad = function (ew) {
        if (ew.data && ew.data.mesh) {
            scope.processReceivedMesh(ew.data);

            //Is the worker done loading the geom pack?
            if (ew.data.progress >= 1.0) {
                scope.pack_workers[ew.data.workerId].queued -= 1;

                //Are all workers done?
                var isdone = true;
                for (j = 0; j < scope.pack_workers.length; j++) {
                    if (scope.pack_workers[j].queued != 0) {
                        isdone = false;
                        break;
                    }
                }

                if (isdone) {
                    for (j = 0; j < NUM_WORKER_THREADS; j++) {
                        scope.pack_workers[j].finish();
                    }
                    scope.pack_workers = null;
                }

                if (scope.svf.fragments.numLoaded == scope.svf.fragments.length) { //all workers are done?
                    //then launch the texture loads
                    scope.onGeomLoadDone();
                    scope.viewer3DImpl.matman().loadTextures(scope.svf);
                }
            }
        } else if (ew.data && ew.data.progress) {
            //download is done, queue the next download
            scope.pack_workers[ew.data.workerId].queued -= 1;

            if (scope.next_pack < scope.svf.geompacks.length) {
                var pf = scope.svf.geompacks[scope.next_pack++];
                scope.loadGeometryPack(pf.id, pf.uri);
            }
            scope.viewer3DImpl.signalProgress(100 * scope.next_pack / scope.svf.geompacks.length);
        } else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else if (ew.data && ew.data.error) {
            scope.failedToLoadSomeGeometryPacks = {code:ew.data.error.code, msg:ew.data.error.msg};
        } else {
            //Download failed.
            scope.pack_workers[ew.data.workerId].queued -= 2;
        }
    };

    if (!this.pack_workers) {
        this.pack_workers = [];

        for (i = 0; i < NUM_WORKER_THREADS; i++) {
            var wr = createWorkerWithTokenRefresh(onMeshLoad, 'Mesh Load');

            wr.queued = 0;
            this.pack_workers.push(wr);
        }
    }

    //Find the least busy worker
    var which = 0;
    var queued = this.pack_workers[0].queued;
    for (i = 1; i < NUM_WORKER_THREADS; i++) {
        if (this.pack_workers[i].queued < queued) {
            which = i;
            queued = this.pack_workers[i].queued;
        }
    }
    w = this.pack_workers[which];
    w.queued += 2;
    workerId = which;


    //Pass unzip job to the worker
    var reqPath = this.pathToURL(this.svf.basePath + path);
    var xfer = { "operation":WORKER_LOAD_GEOMETRY,
                 "url": reqPath,
                 "packId": parseInt(packId), /* mesh IDs treat the pack file id as integer to save on storage in the per-fragment arrays */
                 "headers": {},
                 "workerId": workerId,
                 "auth" : auth,
                 "viewing_url" : VIEWING_URL};

    w.postMessage(xfer); // Send data to our worker.
};


function meshToGeometry(mdata) {
    var mesh = mdata.mesh;
    var geometry = new THREE.BufferGeometry();

    mdata.byteSize = 0;

    geometry.vb = mesh.vb;
    mdata.byteSize += mesh.vb.byteLength;

    geometry.vbstride = mesh.vbstride;
    if (mesh.isLines) /* mesh is SVF lines */
        geometry.isLines = mesh.isLines;
    if (mdata.is2d) /* mesh is from F2D */
        geometry.is2d = true;

    geometry.numInstances = mesh.numInstances;

    for (var attributeName in mesh.vblayout) {
        var attributeData = mesh.vblayout[attributeName];

        //Note .array could be undefined in case we are using
        //an interleaved buffer.
        var attr = new THREE.BufferAttribute(attributeData.array, attributeData.itemSize);

        attr.bytesPerItem = attributeData.bytesPerItem;
        attr.normalize = attributeData.normalize;
        attr.isPattern = attributeData.isPattern;

        geometry.addAttribute(attributeName, attr);

        if (geometry.numInstances) {
            geometry.attributes[attributeName].divisor = attributeData.divisor;
        }

        if (attributeData.array) {
            mdata.byteSize += attributeData.array.byteLength;
        }
        else if (attributeData.hasOwnProperty("offset")) {
            //If the attribute is in the interleaved VB, it has
            //an offset into it.
            geometry.attributes[attributeName].itemOffset = attributeData.offset;
        }
        else {
            stderr("VB attribute is neither interleaved nor separate. Something is wrong with the buffer specificaiton.");
        }
    }

    //Index buffer setup
    geometry.addAttribute("index", new THREE.BufferAttribute(mesh.indices, 1));
    mdata.byteSize += mesh.indices.byteLength;

    //TODO: Not sure chunking into list of smaller offset/counts
    //is required for LMV data since it's already broken up.
    //if (mesh.indices.length > 65535)
    //    stderr("Mesh with >65535 indices. May have to break up the draw calls.");
    if (mesh.vb.length / mesh.vbstride > 65535)
        stderr("Mesh with >65535 vertices. It will fail to draw.");

    //Those are pre-computed by the worker thread
    geometry.boundingBox = new THREE.Box3().copy(mesh.boundingBox);
    geometry.boundingSphere = new THREE.Sphere().copy(mesh.boundingSphere);

    mdata.geometry = geometry;

    delete mdata.mesh;
}

function getFragmentTransform(dstmtx, fragments, fragId) {

    var mtxOffset = fragId * 16;
    var fragTransforms = fragments.transforms;

    if (!fragTransforms)
        return null;

    var isIdentity = true;
    for (var j=0; j<16; j++) {
        if ((j%5 && fragTransforms[mtxOffset+j]!=0) || (!(j%5) && fragTransforms[mtxOffset+j] != 1)) {
            isIdentity = false;
            break;
        }
    }

    if (!isIdentity) {
        for (var k=0; k<16; k++)
            dstmtx.elements[k] = fragTransforms[mtxOffset+k];
        return dstmtx;
    } else
        return null;
}


Autodesk.Viewing.Private.SvfLoader.prototype.processReceivedMesh = function(mdata) {
    //Convert the received mesh to THREE buffer geometry
    meshToGeometry(mdata);

    //Find all fragments that instance this mesh
    var meshid = mdata.packId + ":" + mdata.meshIndex;

    var svf = this.svf;
    var fragments = svf.fragments;

    var fragIndexes = fragments.mesh2frag[meshid];
    if (fragIndexes === undefined) {
        stderr("Mesh " + meshid + " was not referenced by any fragments.");
        return;
    }

    svf.meshCount ++;

    //Heuristically determine if we want to load this mesh onto the GPU
    //or use streaming draw from system memory
    var GPU_MEMORY_LOW = 64*1024*1024;
    var GPU_MEMORY_HIGH = 256*1024*1024;
    var GPU_ITEMS_LOW = MAX_FRAGS_PER_GROUP;
    var GPU_ITEMS_HIGH = 2000;

    if (this.isf2d)
        GPU_MEMORY_HIGH *= 2; //there isn't much in terms of textures in 2d drawings, so we can afford to more room for geometry

    if (svf.disableStreaming
        || (svf.gpuMeshMemory < GPU_MEMORY_LOW && svf.gpuNumMeshes < GPU_ITEMS_LOW))
    {
        //We are below the lower limits, so the mesh automatically is
        //assigned to retained mode
        mdata.geometry.streamingDraw = false;
        mdata.geometry.streamingIndex = false;
    }
    else if (svf.gpuMeshMemory > GPU_MEMORY_HIGH || svf.gpuNumMeshes > GPU_ITEMS_HIGH) {
        //We are above the upper limit, so mesh is automatically
        //assigned to streaming draw
        mdata.geometry.streamingDraw = true;
        mdata.geometry.streamingIndex = true;
    }
    else
    {
        //Between the lower and upper limits,
        //Score mesh importance based on its size
        //and number of instances it has. If the score
        //is high, we will prefer to put the mesh on the GPU
        //so that we don't schlep it across the bus all the time.
        var weightScore;

        if (!this.isf2d) {
            if (Array.isArray(fragIndexes)) {
                weightScore = fragIndexes.length * mdata.byteSize;
            } else if ((0 | fragIndexes) < 300) { //keep the first few hundred meshes on GPU for faster first frame
                mdata.geometry.streamingDraw = false;
                mdata.geometry.streamingIndex = false;
            } else {
                weightScore = mdata.byteSize;
            }
        } else {
            //In the case of 2D, there are no instances, so we just keep
            //piling into the GPU until we reach the "high" mark.
            weightScore = 100001;
        }

        if (weightScore < 100000) {
            mdata.geometry.streamingDraw = true;
            mdata.geometry.streamingIndex = true;
        }
    }

    if (!mdata.geometry.streamingDraw) {
        svf.gpuMeshMemory += mdata.byteSize;
        svf.gpuNumMeshes += 1;
    }


    if (!Array.isArray(fragIndexes)) {
        //Case where it's just a single fragment referencing the mesh

        var mtx = getFragmentTransform(this.tmpMatrix, fragments, 0|fragIndexes);
        var materialId = fragments.materials[fragIndexes].toString();

        //This bakes the transform into the mesh -- with the current renderer
        //we would not get any savings from this.
        //if (mtx)
        //    mdata.geometry.applyMatrix(mtx);
        //this.viewer3DImpl.addMeshInstance(mdata.geometry, 0|fragIndexes, materialId, null);
        this.viewer3DImpl.addMeshInstance(mdata.geometry, 0|fragIndexes, materialId, mtx);
    } else {
        //For each fragment, add a mesh instance to the renderer
        for (var i=0; i<fragIndexes.length; i++) {
            var fragId = 0 |fragIndexes[i];
            var materialId = fragments.materials[fragId].toString();
            this.viewer3DImpl.addMeshInstance(mdata.geometry, fragId, materialId, getFragmentTransform(this.tmpMatrix, fragments, fragId));
        }
    }

    //don't need this mapping anymore.
    delete fragments.mesh2frag[meshid];

    //Update various stats
    var numTris = mdata.geometry.attributes.index.array.length / 3;
    svf.geomPolyCount += numTris;
    svf.instancePolyCount += numTris * (fragIndexes.length || 1);
    svf.geomMemory += mdata.byteSize;

    //Repaint and progress reporting
    fragments.numLoaded += (fragIndexes.length || 1);

    var numLoaded = fragments.numLoaded;
    var total = fragments.length;
    var fraction = numLoaded / total;

    //repaint every once in a while -- more initially, less as the load drags on.
    if (svf.geomPolyCount > svf.nextRepaintPolys) {
		//console.log("num loaded " + numLoaded);
		svf.numRepaints ++;
        svf.nextRepaintPolys += 10000 * Math.pow(1.5, svf.numRepaints);
        this.viewer3DImpl.invalidate(false, true);
    }

    //If it's the last mesh, also trigger a full repaint (with screen clear)
    if (this.isf2d && (numLoaded % 20) == 0) {
        this.viewer3DImpl.invalidate(false, true);
    }
    else if (!this.isf2d && fraction == 1.0)
        this.viewer3DImpl.invalidate(true);
};

Autodesk.Viewing.Private.SvfLoader.prototype.processReceivedMesh2D = function(mesh, mindex) {

    var mdata = { mesh: mesh, is2d: true, packId : "0", meshIndex: mindex };

    var meshId = "0:" + mindex;

    var frags = this.svf.fragments;

    //Remember the list of all dbIds referenced by this mesh.
    //In the 2D case this is 1->many (1 frag = many dbIds) mapping instead of
    // 1 dbId -> many fragments like in the SVF 3D case.
    frags.fragId2dbId[mindex] = mdata.mesh.dbIds;

    for (var p in mdata.mesh.dbIds) {
        var dbId = parseInt(p);
        var fragIds = frags.dbId2fragId[dbId];
        if (Array.isArray(fragIds))
             fragIds.push(mindex);
        else if (typeof fragIds !== "undefined") {
            frags.dbId2fragId[dbId] = [fragIds, mindex];
        }
        else {
            frags.dbId2fragId[dbId] = mindex;
        }
    }

    frags.mesh2frag[meshId] = mindex;
    frags.materials[mindex] = this.viewer3DImpl.matman().create2DMaterial(mesh.material);

    frags.length++;

    this.processReceivedMesh(mdata);

};

Autodesk.Viewing.Private.SvfLoader.prototype.onSvfLoadDone = function(svf) {

    if (this.isf2d) {
        //In the 2d case we create and build up the fragments mapping
        //on the receiving end.
        svf.fragments = {};
        svf.fragments.mesh2frag = {};
        svf.fragments.materials = [];
        svf.fragments.fragId2dbId = [];
        svf.fragments.dbId2fragId = [];
        svf.fragments.length = 0;
        svf.fragments.initialized = true;
    }
    else {
        if (svf.packFileTotalSize) {
            //In pack files, primitive indices use 4 byte integers,
            //while we use 2 byte integers for rendering, so make this
            //correction when estimating GPU usage for geometry
            var estimatedGPUMem = svf.packFileTotalSize - svf.primitiveCount * 3 * 2;

            //If the model is certain to be below a certain size,
            //we will skip the heuristics that upload some meshes to
            //GPU and keep other in system mem, and just push it all to the GPU.
            var GPU_MEMORY_HIGH = 256*1024*1024;
            if (estimatedGPUMem <= GPU_MEMORY_HIGH)
                svf.disableStreaming = true;
        }
    }



    svf.geomPolyCount = 0;
    svf.instancePolyCount = 0;
    svf.geomMemory = 0;
    svf.fragments.numLoaded = 0;
    svf.meshCount = 0;
    svf.gpuNumMeshes = 0;
    svf.gpuMeshMemory = 0;

	svf.nextRepaintPolys = 10000;
	svf.numRepaints = 0;

    svf.basePath = "";
    var lastSlash = this.currentLoadPath.lastIndexOf("/");
    if (lastSlash != -1)
        svf.basePath = this.currentLoadPath.substr(0, lastSlash+1);



    var t1 = Date.now();
    this.loadTime += t1 - this.t0;
    stderr("SVF load: " + (t1 - this.t0));

    this.viewer3DImpl.matman().convertMaterials(svf);

    this.t0 = t1;

    //The BBox object loses knowledge of its
    //type when going across the worker thread boundary...
    svf.bbox = new THREE.Box3(svf.bbox.min, svf.bbox.max);

    //Camera vectors also lose their prototypes when they
    //cross the thread boundary...
    if (svf.cameras) {
        for (var i = 0; i < svf.cameras.length; i++) {
            var camera = svf.cameras[i];
            camera.position = new THREE.Vector3().copy(camera.position);
            camera.target = new THREE.Vector3().copy(camera.target);
            camera.up = new THREE.Vector3().copy(camera.up);
        }
    }

    stderr("scene bounds: " + JSON.stringify(svf.bbox));

    this.viewer3DImpl.signalProgress(5, "Hold on, getting the model...");
};

Autodesk.Viewing.Private.SvfLoader.prototype.onGeomLoadDone = function() {
    this.svf.loadDone = true;

    // We need to keep a copy of the original fragments
    // transforms in order to restore them after explosions, etc.
    // the rotation/scale 3x3 part.
    // TODO: consider only keeping the position vector and throwing out
    //
    //delete this.svf.fragments.transforms;

    // Don't need these anymore (except perhaps for out of core stuff?)
    this.svf.fragments.entityIndexes = null;
    this.svf.fragments.packIds = null;

    var t1 = Date.now();
    var msg = "Fragments load time: " + (t1 - this.t0);
    this.loadTime += t1 - this.t0;

    this.viewer3DImpl.onLoadComplete();

    stderr(msg);
    stderr("Total geometry size: " + (this.svf.geomMemory / (1024 * 1024)) + " MB");
    stderr("Number of meshes: " + this.svf.meshCount);
    stderr("Num Meshes on GPU: " + this.svf.gpuNumMeshes);
    stderr("Net GPU geom memory used: " + this.svf.gpuMeshMemory);

    var modelStats = {
        viewer_current_time : Date.now(),
        viewer_model_stats_is_f2d : this.isf2d,
        viewer_model_stats_total_load_time : this.loadTime,
        viewer_model_stats_total_geometry_size : this.svf.geomMemory / (1024 * 1024),
        viewer_model_stats_total_meshes_count : this.svf.meshCount,
        viewer_model_stats_total_meshes_on_gpu : this.svf.gpuNumMeshes,
        viewer_model_stats_total_gpu_memory_used : this.svf.gpuMeshMemory / (1024 * 1024)
    };
    this.logger.log(modelStats, true);

    this.currentLoadPath = null;
    this.isf2d = undefined;
};

Autodesk.Viewing.Private.SvfLoader.prototype.getProperties = function(dbId, onSuccessCallback, onErrorCallback ) {
    var _this = this;
    var f = function(ew) {
        if (ew.data && ew.data.error) {
            if (onErrorCallback)
                onErrorCallback(ew.data.error.code, ew.data.error.msg, ew.data.error.args);
        } else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else {
            // TODO: checking for dbId should probably be done in other workers to make sure we're 
            //       not getting duplicate results. 
            if (ew.data && ew.data.dbId === dbId) {
                _this.propWorker.removeMessageEventListener(f);
                onSuccessCallback(ew.data.result);
            }
        }
    };

    if (!this.propWorker) {
        this.propWorker = createWorkerWithTokenRefresh(f, 'Property');
    } else {
        this.propWorker.addMessageEventListener(f);
    }

    var reqPath = this.pathToURL(this.svf.basePath);

    //If there is a shared db path and there is no
    //per-SVF specific property database, use the shared one
    if (this.sharedDbPath && !this.svf.propertydb.values.length) {
        reqPath = this.sharedDbPath;
        stderr("Using shared property db: " + reqPath);
    }

    var xfer = { "operation":WORKER_GET_PROPERTIES,
                 "url": reqPath,
                 "propertydb" : this.svf.propertydb,
                 "dbId": dbId,
                 "headers": {},
                 "auth" : auth,
                 "viewing_url" : VIEWING_URL };
    this.propWorker.postMessage(xfer); // Send data to our worker.
};

Autodesk.Viewing.Private.SvfLoader.prototype.searchProperties = function(searchText, onSuccessCallback, onErrorCallback) {
    var _this = this;

    var localSearchCB = function (ew) {
        if (ew.data && ew.data.error) {
            if (onErrorCallback)
                onErrorCallback(ew.data.error.code, ew.data.error.msg);
        } else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else {
            _this.propWorker.removeMessageEventListener(localSearchCB);
            if (onSuccessCallback)
                onSuccessCallback(ew.data);
        }
    };

    if (!this.propWorker) {
        this.propWorker = createWorkerWithTokenRefresh(localSearchCB, 'Property');
    } else {
        this.propWorker.addMessageEventListener(localSearchCB);
    }

    var reqPath = this.pathToURL(this.svf.basePath);

    //If there is a shared db path and there is no
    //per-SVF specific property database, use the shared one
    if (this.sharedDbPath && !this.svf.propertydb.values.length) {
        reqPath = this.sharedDbPath;
        stderr("Using shared property db: " + reqPath);
    }

    var xfer = {
        "operation": WORKER_SEARCH_PROPERTIES,
        "url": reqPath,
        "propertydb" : this.svf.propertydb,
        "searchText": searchText,
        "headers": {},
        "auth": auth,
        "viewing_url" : VIEWING_URL };  // For CORS caching issue.
    this.propWorker.postMessage(xfer); // Send data to our worker.
};


//Creates an array that maps fragment id to the document
//tree leaf node that owns that fragment.
Autodesk.Viewing.Private.SvfLoader.prototype.createFragToNodeMapping = function() {
    var svf = this.svf;
    var f2db = svf.fragments.fragId2dbId;
    if (!svf.instanceTree || !f2db)
        return;

    var f2n = svf.fragments.fragToDbNode = new Array(f2db.length);

    (function descendTree(node) {
        var frags = node.fragIds;

        if (frags !== undefined) {
            if (Array.isArray(frags)) {
                for (var j=0; j<frags.length; j++) {
                    f2n[frags[j]] = node;
                }
            } else  {
                f2n[frags] = node;
            }
        }

        if (node.children)
            for (var k=0; k<node.children.length; k++)
                descendTree(node.children[k]);

    })(svf.instanceTree);
    svf.fragToNodeDone = true;
    this.viewer3DImpl.api.fireEvent({
        type: Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT
    });
};

Autodesk.Viewing.Private.SvfLoader.prototype.getObjectTree = function(onSuccessCallback, onErrorCallback) {
    var scope = this;

    if (onSuccessCallback) {
    	this.getObjectTreeCallbacks.push(onSuccessCallback);
    }
	
	function callCallbacks() {
		for (var i=0; i<scope.getObjectTreeCallbacks.length; i++) {
			scope.getObjectTreeCallbacks[i](scope.svf.instanceTree);
		}
		scope.getObjectTreeCallbacks = [];
	}
	
	if (scope.svf.instanceTree) {
		callCallbacks();
		return;
	}

    var onObjectTreeRead = function(ew) {
        if (ew.data && ew.data.error) {
            //TODO: commenting out until we can definitely know
            //whether property packs are supposed to exist
            //by checking the bubble/manifest. Otherwise
            //we get error for cases where there really is no property database.
            /*
            if (onErrorCallback)
                onErrorCallback(ew.data.error.code, ew.data.error.msg, ew.data.error.args);
            */
        } else if (ew.data && ew.data.debug) {
            stderr(ew.data.message);
        } else {
            //This worker will produce two results -- first
            //it will give us back the model hierarchy tree
            //and then it will send us back the bounding boxes for
            //all nodes in the tree.
            var it = ew.data.instanceTree;
            var ib = ew.data.instanceBoxes;
            if (it) {
                // We've already downloaded the tree, just return it.
                if (!scope.svf.instanceTree) {
                    scope.svf.instanceTree = it;
                    scope.svf.maxTreeDepth = ew.data.maxTreeDepth;
                    scope.createFragToNodeMapping();
                }
            }
            else if (ew.data.objectCount) {
                //Case where there is no object tree, but objects
                //do still have properties. This is the case for F2D drawings.
                scope.svf.hasObjectProperties = ew.data.objectCount;
                //stderr("Object count " + ew.data.objectCount);
            }
            callCallbacks();
            if (ib) {
                scope.svf.instanceBoxes = ib;
                scope.propWorker.removeMessageEventListener(onObjectTreeRead);
            }
        }
    };

    if (!this.propWorker) {
        this.propWorker = createWorkerWithTokenRefresh(onObjectTreeRead, 'Property');
    } else {
        this.propWorker.addMessageEventListener(onObjectTreeRead);
    }

    var reqPath = this.pathToURL(this.svf.basePath);

    //If there is a shared db path and there is no
    //per-SVF specific property database, use the shared one
    if (this.sharedDbPath && !this.svf.propertydb.values.length) {
        reqPath = this.sharedDbPath;
        stderr("Using shared property db: " + reqPath);
    }

    var xfer = { "operation":WORKER_GET_OBJECT_TREE,
                 "url": reqPath,
                 "propertydb" : this.svf.propertydb,
                 "headers": {},
                 "fragToDbId": this.svf.fragments.fragId2dbId, //the 1:1 mapping of fragment to dbId we got from the SVF
                 "fragBoxes" : this.svf.fragments.boxes, //needed to precompute bounding box hierarchy for explode function (and possibly others)
                 "auth" : auth,
                 "viewing_url" : VIEWING_URL };
    this.propWorker.postMessage(xfer); // Send data to our worker.
};



// Create a web worker.
function createWorker() {
    // When we are not at release mode, create web worker as usual.
    if (ENABLE_DEBUG || !ENABLE_INLINE_WORKER ) {
        return new Worker( LMV_WORKER_URL );
    }

    var blob;
    window.URL = window.URL || window.webkitURL;

    try {
        blob = new Blob([WORKER_SCRIPT], {type: 'application/javascript'});
    } catch (e) {
        // Backward compatibility.
        blob = new BlobBuilder();
        blob.append(WORKER_SCRIPT);
        blob = blob.getBlob();
    }

    return new Worker(URL.createObjectURL(blob));
}


function createWorkerWithTokenRefresh(callback, name) {
    var worker = createWorker();
    worker.hasEventListener = false;
    worker.onMessageReceivedCallbacks = [];
    worker.name = name;
    worker.onMessageReceived = function (e) {
        if (e.data && e.data.refreshToken) {
            var refreshTokenHandler = new Autodesk.Viewing.Private.WorkerViewingServiceRefreshTokenHandler();
            refreshTokenHandler.refreshToken(
                function (e) {
                    stderr('Token refreshed in thread');
                    worker.postMessage({tokenRefreshed: true});
                },
                function (e) {
                    stderr('Failed token refresh in thread');
                    worker.postMessage({tokenRefreshed: false});
                }
            );
            return;
        }
//        console.log('Callback Count ' + worker.onMessageReceivedCallbacks.length + ' for: ' + worker.name);
        for (var i = 0; i < worker.onMessageReceivedCallbacks.length; ++i) {
            worker.onMessageReceivedCallbacks[i](e);
        }
    };

    worker.addMessageEventListener = function (listener) {
        var foundIndex = worker.onMessageReceivedCallbacks.indexOf(listener);

        // Only add the callback if it was not already added previously.
        //
        if (foundIndex === -1 || true) {
            worker.onMessageReceivedCallbacks.push(listener);

            if (!worker.hasEventListener) {
                worker.addEventListener('message', worker.onMessageReceived, false);
                worker.hasEventListener = true;
            }
            return true;
        }
        return false;
    };

    if (callback) {
        worker.addMessageEventListener(callback);
    }

    worker.postMessageWithCallback = function (message, onMessageReceivedCallback, forceInvalidToken) {
        if(onMessageReceivedCallback) {
            worker.addMessageEventListener(onMessageReceivedCallback);
        }

        // For testing the token refresh functionality, this is an option in debug
        // to force a bad token and consequently trigger a token refresh.
        //
        if (ENABLE_DEBUG && forceInvalidToken) {
            function sendMessage(e) {
                worker.postMessage.call(worker, message);
            }

            if (Autodesk.Viewing.Private.env.indexOf('Autodesk') === 0) {
                Autodesk.Viewing.Private.setApigeeTokenInCookie('invalid', sendMessage);
            } else {
                Autodesk.Viewing.Private.setAuthTokenInCookie('invalid', sendMessage);
            }
        } else {
            worker.postMessage.call(worker, message);
        }
    };

    worker.removeMessageEventListener = function (listener) {
        var foundIndex = worker.onMessageReceivedCallbacks.indexOf(listener);
        if (foundIndex !== -1) {
            worker.onMessageReceivedCallbacks.splice(foundIndex, 1);

            if (worker.onMessageReceivedCallbacks.length === 0) {
                worker.removeEventListener('message', worker.onMessageReceived);
                worker.hasEventListener = false;
            }
            return true;
        }
        return false;
    };

    worker.removeAllMessageEventListeners = function() {
        worker.onMessageReceivedCallbacks = [];
        worker.removeEventListener('message', worker.onMessageReceived);
        worker.hasEventListener = false;
    };

    worker.finish = function () {
        worker.removeAllMessageEventListeners();
        worker.terminate();
    };

    return worker;
}



// Test function for basic data pipeline of cloud rendering.
Autodesk.Viewing.Private.SvfLoader.prototype.cloudRendering = function(viewer, camera, imageNo) {
    var w = this.cloudRenderingWorker;
    var scope = this;

    var msg = { operation : WORKER_CLOUD_RENDERING,
        /* SPD url for now - until we teach VS to infer SPD url from seed URN. This is the Lambo model.*/
        //url : 'urn:dXJuOmFkc2suczM6ZnMuZmlsZTp6aGFuZ3l1bi9yYWFzL3VwL2NvcmVfMi5zcGQ=',
        url : 'urn:' + scope.spdUrn,
        headers : {} ,
        auth : auth,
        viewing_url : VIEWING_URL,
        queryParams : this.domainParam,  // For CORS caching issue.
        camera : camera,
        canvas : {width : this.viewer3DImpl.canvas.width,
                  height : this.viewer3DImpl.canvas.height},
        imageNo : imageNo,
        exposureBias : this.viewer3DImpl.renderer().getExposureBias(),
        currentLightPreset : this.viewer3DImpl.currentLightPreset(),
        upVector : this.viewer3DImpl.model.getUpVector()};

    w.postMessage(msg);
};

Autodesk.Viewing.Private.SvfLoader.prototype.svfToSpdTranslator = function(viewer, imageNum, onSuccess, onError) {
    var w = this.cloudRenderingWorker;
    var scope = this;

    if (!this.cloudRenderingWorker) {
        this.cloudRenderingWorker = createWorker();

        w = this.cloudRenderingWorker;

        var onRenderingsReady = function (ew) {
            var cleaner = function() {
                w.removeEventListener('message', onRenderingsReady);
                w.terminate();
                w = null;
            };

            if (ew.data && ew.data.translation) {

                scope.spdUrn = ew.data.translation.spdUrn;
                scope.spdUrn = btoa(scope.spdUrn);
                stderr("spdUrn = " + scope.spdUrn);

                var camera = ew.data.translation.camera;
                var imageNo = ew.data.translation.imageNo;
                scope.cloudRendering(viewer, camera, imageNo);

                alertify.success("Translation Job Complete");

            } else if (ew.data && ew.data.translationProgress) {
                alertify.success("Translation Job In Progress");

            } else if (ew.data && ew.data.translationError) {
                alertify.error("Translation Job Error");
                onError(ew.data.translationError);
                cleaner();
            } else if (ew.data && ew.data.renderings) {
                //TODO: do stuff with the pixels.
                alertify.success("RaaS Rendering Job Complete");
                onSuccess(ew.data.renderings);
                stderr(renderings);
            } else if (ew.data && ew.data.progress) {
                alertify.success("RaaS Rendering Job in Progress");
            } else if (ew.data && ew.data.error) {
                alertify.error("RaaS Rendering Job Error");
                onError(ew.data.error);
                cleaner();
            } else if (ew.data && ew.data.debug) {
                stderr(ew.data.message);
            }
        };
        w.addEventListener('message', onRenderingsReady, false);
    }

    var msg = { operation : WORKER_SVF_TO_SPD,
        url : "urn:",
        headers : {} ,
        auth : auth,
        viewing_url : VIEWING_URL,
        queryParams : this.domainParam, // For CORS caching issue.
        svfUrn : scope.svfUrn,
        camera : this.viewer3DImpl.camera,
        imageNo : imageNum
    };

    w.postMessage(msg);
};
;
//TODO: better heuristic for group size might be needed
//But it should be based on polygon count as well as
//fragment count. But polygon count is not known
//until we get the meshes later on.
var MAX_FRAGS_PER_GROUP = 333;


/** @constructor */
function RenderQueue(initialSize, prototypeScene, initialBbox, fragsPerScene) {


    var NORMAL = 0,
        HIGHLIGHTED = 1,
        HIDDEN = 2,
        //visibility/highlight bitmask flags
        MESH_VISIBLE = 1,
        MESH_HIGHLIGHTED = 2,
        MESH_HIDELINES = 4;

    var _currentScene = 0;
    var _firstFrameItems = -1;

	var _allVisible = true;
	var _allVisibleDirty = false;
    var _numHighlighted = 0;

    //assuming initial bounding box is correct
	var _visibleBounds = new THREE.Box3();
	var _visibleBoundsIncludesGhosted;
	var _tmpBox = new THREE.Box3();

	var _fragsPerScene = fragsPerScene > 0 ? fragsPerScene : MAX_FRAGS_PER_GROUP;

	if (initialSize <= 0)
	    initialSize = 1;

    //This will be the list of all mesh instances in the model.
    //Corresponds to all fragments in the case of SVF.
    var _vizmeshes = new Array(initialSize);
    var _vizflags = new Uint8Array(initialSize); // visibility/highlight mode flags

    //TODO: To be used for frustum based culling traversal.
    var _camera;

    var _raycaster = new THREE.Raycaster();


    this.prototypeScene = prototypeScene;

    var _drawMode = NORMAL;
    var _wasBeginFrame = false;
    var _measuredFrameTime = 0;
    var _timeMultiplier = 1;

    //Create a scene for each batch of fragments.
    //We will then draw each scene in turn to get a progressive
    //effect. The number of fragments per scene should be close
    //to what we can draw in a single frame while maintaining interactivity.
    //TODO: add dynamic adjustment for slowly drawing scenes, r-tree traversal instead of linear, etc.
    var numScenes = 0 | ((initialSize + _fragsPerScene - 1) / _fragsPerScene);
    var _geomScenes = new Array(numScenes);
    for (var i=0; i<numScenes; i++) {
        //Scene for this fragment group
        var scene = _geomScenes[i] = new THREE.Scene(true);
        scene.__lights = prototypeScene.__lights; //Share the same lights between all scenes.
    }

	this.visibleBoundsDirty = false;

	if (initialBbox)
	    _visibleBounds.copy(initialBbox);


    this.addMesh = function(fragId, mesh) {
        //Remove any temporary geometry we used for the fragment
        //while it was loading
        var oldGeom = _vizmeshes[fragId];
        if (oldGeom) {
            stderr("duplicate fragment.");
            oldGeom.parent.remove(oldGeom);
        }

        //Remember the mesh in the frag->viz mesh array
        _vizmeshes[fragId] = mesh;
        mesh.fragId = fragId;

        //The flags aray will not auto-resize (it's ArrayBuffer)
        //so we have to do it manually
        if (_vizflags.length < _vizmeshes.length)
        {
            var nlen = 2 * _vizflags.length;
            if (nlen < _vizmeshes.length)
                nlen = _vizmeshes.length;

            var nflags = new Uint8Array(nlen);
            for (var i= 0, iEnd=_vizflags.length; i<iEnd; i++)
                nflags[i] = _vizflags[i];
            _vizflags = nflags;
        }

        _vizflags[fragId] = 1; // 1 = visible, but not highlighted

        //Find a parent for the mesh -- in the case of SVF
        //fragments we just map fragment index to increasing
        //scene index, since fragments are already ordered
        //in the way we want to draw them
        var sceneIndex = 0 | (fragId / _fragsPerScene);
        var scene = _geomScenes[sceneIndex];
        if (!scene) {
            _geomScenes[sceneIndex] = scene = new THREE.Scene(true);
            scene.__lights = this.prototypeScene.__lights; //Share the same lights between all scenes.
        }

        //update the world bbox
        {
            _tmpBox.copy(mesh.geometry.boundingBox);
            _tmpBox.applyMatrix4(mesh.matrixWorld);
            _visibleBounds.union(_tmpBox);
        }

        //Add the mesh to the render group for this fragment
        //Note each render group renders potentially many fragments.
        scene.add(mesh);

        this.visibleBoundsDirty = true;
    };


    //Incrementally render some meshes until we run out of time
    //For SVF we just iterate linearly since scenes/fragments are
    //already ordered in a way suitable for progressive render.
    //This could be replaced by r-tree traversal or other distance/visibility
    //based approach.
    this.renderSome = function(renderObjectCB, timeRemaining) {
        //stderr("mesh # : " + _vizmeshes.length);

        var i = _currentScene, iEnd = _geomScenes.length;
        var vizflags = _vizflags;

        var t0 = Date.now(), t1;
        var start = t0;
        var firstIter = true;

        //If the render queue is just starting to render
        //we will remember how many items we draw on the first pass
        //and keep drawing the same number of items on subsequent first passes,
        //until we get to a second renderSome pass. This is to make sure that
        //while moving the camera in a single motion, the number of items we draw
        //does not vary, which causes some ugly flashing -- because the render time
        //per item varies a little from frame to frome.
        var isBeginFrame = ( i == 0 );
        if (isBeginFrame && !_wasBeginFrame) {
            //case of a new initial frame when the previous frame was not initial
            _firstFrameItems = -1;
            _wasBeginFrame = true;
        }

        //The time multiplier attempts to relate CPU side draw time
        //with total render time (including GPU/render process). It's computed
        //as a ratio between the measured time between window animation frames
        //and the measured time to execute the corresponding draw calls to draw the frame.
        //The actual computation is after the draw loop below.
        timeRemaining *= _timeMultiplier;

        for (; i<iEnd; i++) {

            var scene = _geomScenes[i];

            var done = false;

            if (isBeginFrame && _firstFrameItems > 0)
            {
                //In case we are drawing an initial frame, and the previous frame
                //was also an initial frame, we will loop for as many items as we
                //drew on the last pass.
                if (i == _firstFrameItems)
                    done = true;
                firstIter = false;
            }
            else //Otherwise (not first frame) draw based on timing.
            {
                //On the first pass through the loop, render a scene if we have any non-zero time left.
                //On subsequent loops, only begin rendering a scene if we have
                //enough time to fit it in the frame at least halfway.
                if (!firstIter) {
                    if (timeRemaining <= scene.avgFrameTime * 0.5)
                        done = true;
                } else {
                    if (timeRemaining <= 0)
                        done = true;
                    firstIter = false;
                }
            }

            if (done)
                break;

            //Used when parts of the same scene
            //have to draw in separate passes (e.g. during isolate).
            //Consider maintaining two render queues instead if the
            //use cases get too complex, because this approach
            //is not very scalable as currently done (it traverses
            //the entire scene twice, plus the flag flipping for each item).
            var children = scene.children;
            var allHidden = true;
            if (_drawMode == HIDDEN) {
                for (var j= 0, jEnd=children.length; j<jEnd; j++) {
                    var c = children[j];
                    var v = !(vizflags[c.fragId] & 1/*MESH_VISIBLE*/); //visible (bit 0 on)
                    c.visible = v;
                    allHidden = allHidden && !v;
                }
            } else if (_drawMode == HIGHLIGHTED) {
                for (var j= 0, jEnd=children.length; j<jEnd; j++) {
                    var c = children[j];
                    var v = !!(vizflags[c.fragId] & 2/*MESH_HIGHLIGHTED*/); //highlighted (bit 1 on)
                    c.visible = v;
                    allHidden = allHidden && !v;
                }
            } else {
                for (var j= 0, jEnd=children.length; j<jEnd; j++) {
                    var c = children[j];
                    var v = (vizflags[c.fragId] == 1/*MESH_VISIBLE*/); //visible but not highlighted, and not a hidden line (bit 0 on, bit 1 off, bit 2 off)
                    c.visible = v;
                    allHidden = allHidden && !v;
                }
            }

            if (!allHidden)
                renderObjectCB(scene);

            t1 = Date.now();
            var delta = t1 - t0;
            t0 = t1;

            //For each sub-scene, keep a running average
            //of how long it took to render over the
            //last few frames.
            if (scene.avgFrameTime === undefined)
                scene.avgFrameTime = delta;
            else
                scene.avgFrameTime = 0.9 * scene.avgFrameTime + 0.1 * delta;

            //stderr(i + " " + scene.avgFrameTime);
            _currentScene = i+1;

            timeRemaining -= scene.avgFrameTime;
        }

        //Remember how many items we drew on the first progressive frame, so that
        //we draw the same number if the next frame is also a first progressive frame
        //(e.g. camera moved and reset the render queue)
        if (isBeginFrame && _firstFrameItems == -1) {
            _firstFrameItems = i;
        }

        //stderr(t0 - start);

        //Update the time multiplier.
        if (isBeginFrame && _measuredFrameTime) {
            _timeMultiplier = (t0 - start) / _measuredFrameTime;
            if (_timeMultiplier <= 0)
                _timeMultiplier = 1;
            if (_timeMultiplier > 1)
                _timeMultiplier = 1;
//            stderr("tm " + _timeMultiplier);
        }


        if (i == iEnd || !isBeginFrame) {
            _firstFrameItems = -1;
            _wasBeginFrame = false;
        }

        return timeRemaining / _timeMultiplier;  // just cancel out the scale we did at the beginning to get back to actual time units
    };


    this.isDone = function() {
        return _currentScene == _geomScenes.length;
    };

    //Resets the scene traversal
    this.reset = function(camera, measuredFrameAvg) {
        _camera = camera;
        _currentScene = 0;
        _measuredFrameTime = measuredFrameAvg;
    };

    this.drawNormalObjectsOnly = function() {
        _drawMode = NORMAL;
    };

    this.drawHighlightedObjectsOnly = function() {
        _drawMode = HIGHLIGHTED;
    };

    this.drawHiddenObjectsOnly = function() {
        _drawMode = HIDDEN;
    };

    this.setOverrideMaterial = function(mat) {
        for (var i= 0, iEnd = _geomScenes.length; i<iEnd; i++)
            _geomScenes[i].overrideMaterial = mat;
    };


    function setFlagFragment(fragId, flag, value)
    {
        var old = _vizflags[fragId];

        if (!!(old & flag) == value)
            return false;

        if (value)
            _vizflags[fragId] = old | flag;
        else
            _vizflags[fragId] = old & ~flag;

        return true;
    }

    this.setHightlighted = function(fragId, value) {
        var changed = setFlagFragment(fragId, MESH_HIGHLIGHTED, value);

        if (changed) {
            if (value)
                _numHighlighted++;
            else
                _numHighlighted--;
        }

        this.visibleBoundsDirty = true;
    };

    // This function should probably not be called outside VisibityManager
    // in order to maintain node visibility state.
    this.setVisibility = function(fragId, value) {
        setFlagFragment(fragId, MESH_VISIBLE, value);
        _allVisibleDirty = true;
        this.visibleBoundsDirty = true;
    };


    function setFlagGlobal(flag, value)
    {
        var vizflags = _vizflags;
        var i= 0, iEnd = vizflags.length;
        if (value) {
            for (; i<iEnd; i++) {
                vizflags[i] = vizflags[i] | flag;
            }
        } else {
            var notflag = ~flag;
            for (; i<iEnd; i++) {
                vizflags[i] = vizflags[i] & notflag;
            }
        }
    }

    this.setAllVisibility = function(value) {
        setFlagGlobal(MESH_VISIBLE, value);

         _allVisible = value;
         _allVisibleDirty = false;
         this.visibleBoundsDirty = true;
    };


    this.hideLines = function(hide) {

//        setFlagGlobal(MESH_HIDELINES, hide);
        var flag = MESH_HIDELINES;

        var vizflags = _vizflags;
        var i= 0, iEnd = vizflags.length;
        if (hide) {
            for (; i<iEnd; i++) {
                if (_vizmeshes[i] && _vizmeshes[i].isLine)
                    vizflags[i] = vizflags[i] | flag;
            }
        } else {
            var notflag = ~flag;
            for (; i<iEnd; i++) {
                if (_vizmeshes[i] && _vizmeshes[i].isLine)
                    vizflags[i] = vizflags[i] & notflag;
            }
        }

        _allVisibleDirty = true;
    };

    this.hasHighlighted = function() {
        return !!_numHighlighted;
    };

    this.isFragVisible = function(frag) {
        return (_vizflags[frag] & 3/*MESH_VISIBLE|MESH_HIGHLIGHTED*/) == 1;
    };

    this.areAllVisible = function() {
        if (_allVisibleDirty) {
            _allVisible = true;
            _allVisibleDirty = false;
            var vizflags = _vizflags;
            for (var i= 0, iEnd = vizflags.length; i<iEnd; i++) {
                if ((vizflags[i] & 1/*MESH_VISIBLE*/) == 0) {
                    _allVisible = false;
                    break;
                }
            }
        }

        return _allVisible;
    };

    this.getVisibleBounds = function(includeGhosted) {

        if (!this.visibleBoundsDirty && (includeGhosted == _visibleBoundsIncludesGhosted))
            return _visibleBounds;

        _visibleBoundsIncludesGhosted = includeGhosted;
        var bounds = _visibleBounds;
        var box = _tmpBox;
        var vizflags = _vizflags;
        var vizmeshes = _vizmeshes;

        bounds.makeEmpty();

        for (var i = 0, iEnd = vizflags.length; i < iEnd; i++) {
            var f = vizflags[i];
            if ((f&1/*MESH_VISIBLE*/) || (includeGhosted && (f==0/*not a hidden object*/))) {
                var m = vizmeshes[i];
                if (m) {
                    box.copy(m.geometry.boundingBox).applyMatrix4(m.matrixWorld);
                    bounds.union(box);
                }
            }
        }

        this.visibleBoundsDirty = false;
        return bounds;
    };

    this.rayIntersect = function(position, direction, ignoreTransparent) {

        _raycaster.set(position, direction);
        var intersects = _raycaster.intersectObjects(_geomScenes, true);

        //pick the nearest object that is visible as the selected.
        var object = null;
        var intersectPoint = null;
        for (var i=0; i<intersects.length; i++) {
            var obj = intersects[i].object;

            //skip past f2d consolidated meshes.
            //TODO: we should completely avoid intersecting those in the ray caster.
            if (obj.is2d)
                continue;

            var isVisible = obj.visible;
            if (obj.fragId !== undefined) {
                //make sure the object is not ghosted.
                isVisible = this.isFragVisible(obj.fragId); //visible set,
            }
            if (isVisible) {
                if (ignoreTransparent && intersects[i].object.material.transparent)
                    continue;
                object = intersects[i].object;
                intersectPoint = intersects[i].point;
                break;
            }
        }

        return [object, intersectPoint];
    };


    this.getRenderProgress = function() {
        return _currentScene / _geomScenes.length;
    };

    this.getVizmesh = function (fragId) {
        return _vizmeshes[fragId];
    };

    this.getSceneCount = function() {
        return _geomScenes.length;
    }
}
;
function RenderContext() {

    var _renderer;
    var _canvas;
    var _depthMaterial;
    var _idMaterial;
    var _camera;

    var _clearPass;
    var _saoBlurPass;
    var _saoPass;
    var _saoMipPass;
    var _saoMipFirstPass;
    var _fxaaPass;
    var _blendPass;

    var _saoBufferValid = false;

    var _depthTarget;
    var _depthMipMap = null;
    var _colorTarget = null;
    var _overlayTarget = null;
    var _postTarget1 = null;
    var _postTarget2 = null;
    var _idTarget = null;

    var _exposureBias = 0.0;
    var _tonemapMethod = 0;
	var _unitScale = 1.0;

    var _w, _h;

    var _readbackBuffer = new Uint8Array(4);

    var _white = {r: 1, g: 1, b: 1};
    var _black = {r: 0, g: 0, b: 0};
    var _blockMRT = false;

    //Rendering options
    var _settings = {
        antialias: true,
        sao: false,
        useHdrTarget: false,
        haveTwoSided: false,
        useSSAA: false, /* Whether to use supersampled targets when antialiasing is used (default is FXAA) */
        idbuffer: false
    };

    //TODO: hide this once there is a way
    //to obtain the current pipeline configuration
    this.settings = _settings;


    this.init = function (thecanvas, renderer, width, height) {

        //Firefox on Mac OSX reports it can do MRT, but it actually does not work in our case,
        //so we have to detect this case manually.
        _blockMRT = window.navigator.userAgent.indexOf("Firefox") != -1 && window.navigator.userAgent.indexOf("Mac OS") != -1;

        _canvas = thecanvas;

        _w = width || _canvas.clientWidth;
        _h = height || _canvas.clientHeight;

        //Underlying THREE/GL renderer initialization
        if (renderer)
            _renderer = renderer; //Can be optionally passed in, if already created with other settings.
        else
            _renderer = createRenderer();

        createRenderPasses();

        this.initPostPipeline(_settings.sao, _settings.antialias, false);
    };


    function createRenderer() {

        //TODO: improve the pixel scale heuristics below
        var dpr = window.devicePixelRatio;
        if (!dpr) dpr = 1;

        //High density display -- turn off antialiasing since
        //it's not worth the slowdown in that case.
        //if (dpr >= 2.0)
        //    _settings.antialias = false;

        var params = {
            canvas: _canvas,
            antialias: false,
            alpha: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false, //change it to true for the screen capture api
            stencil: false,
            depth: false,
            devicePixelRatio: dpr
        };

        var renderer = new FireflyWebGLRenderer(params);

        renderer.autoClear = false;

        //Turn off scene sorting by THREE -- this is ok if we
        //do progressive draw in an order that makes sense
        //transparency-wise. If we start drawing using a frustum culling
        //r-tree or there are problems with transparency we'd have to turn on sorting.
        renderer.sortObjects = false;

        return renderer;
    }

    function createRenderPasses() {

        function setNoDepthNoBlend(pass) {
            pass.material.blending = THREE.NoBlending;
            pass.material.depthWrite = false;
            pass.material.depthTest = false;
        }

        var depthShader = NormalsShader;

        _depthMaterial = new THREE.ShaderMaterial({
            fragmentShader: depthShader.fragmentShader,
            vertexShader: depthShader.vertexShader,
            uniforms: THREE.UniformsUtils.clone(depthShader.uniforms) });
        _depthMaterial.blending = THREE.NoBlending;

        _saoPass = new THREE.ShaderPass(SAOShader);
        setNoDepthNoBlend(_saoPass);

        _saoBlurPass = new THREE.ShaderPass(SAOBlurShader);
        setNoDepthNoBlend(_saoBlurPass);

        _saoMipFirstPass = new THREE.ShaderPass(SAOMinifyFirstShader);
        setNoDepthNoBlend(_saoMipFirstPass);

        _saoMipPass = new THREE.ShaderPass(SAOMinifyShader);
        setNoDepthNoBlend(_saoMipPass);

        _fxaaPass = new THREE.ShaderPass(FXAAShader);
        setNoDepthNoBlend(_fxaaPass);

        _blendPass = new THREE.ShaderPass(BlendShader);
        setNoDepthNoBlend(_blendPass);

        _clearPass = new THREE.ShaderPass(BackgroundShader);
        setNoDepthNoBlend(_clearPass);
    }


    this.beginScene = function (prototypeScene, camera, needClear) {
        _camera = camera;
        _saoBufferValid = false;

        //We need to render once with the "prototype" scene which
        //only contains the cameras and lights, so that their positions
        //and transforms get updated to the latest camera. Hence the
        //call to render instead of just clear.


        //Clear the color target
        if (needClear) {
            _renderer.setClearColor(_black, 0.0);
            _renderer.clearTarget(_colorTarget, false, true, false); //clear depth buffer
            _clearPass.render(_renderer, _colorTarget, null); //clear the color buffer
        }

         //Clear the id buffer
         if (_idTarget)
         {
            _renderer.setClearColor(_black, 0.0);
            _renderer.clearTarget(_idTarget, true, false, false);
         }

        //Clear the G-buffer target if needed and update the SSAO uniforms.
        if (_settings.sao) {

            if (needClear) {
                _renderer.setClearColor(_black, 0.0);
                //Skip clearing the depth buffer as it's shared with the color target
                _renderer.clearTarget(_depthTarget, true, false, false);
            }

            _saoPass.uniforms[ 'cameraNear' ].value = camera.near;
            _saoPass.uniforms[ 'cameraFar' ].value = camera.far;
            _saoMipFirstPass.uniforms[ 'cameraNear' ].value = camera.near;
            _saoMipFirstPass.uniforms[ 'cameraInvNearFar' ].value = 1.0 / (camera.near - camera.far);

            var P = camera.projectionMatrix.elements;

            //Scaling factor needed to increase contrast of our SSAO.
            if (camera.isPerspective) {
                /*  vec4(-2.0f / (width*P[0][0]),
                 -2.0f / (height*P[1][1]),
                 ( 1.0f - P[0][2]) / P[0][0],
                 ( 1.0f + P[1][2]) / P[1][1])*/
                _saoPass.uniforms[ 'projInfo' ].value.set(-2.0 / (_colorTarget.width * P[0]),
                        -2.0 / (_colorTarget.height * P[5]),
                        (1.0 - P[8]) / P[0],
                        (1.0 + P[9]) / P[5]); //TODO: Not certain if we need + or - here for OpenGL off-center matrix (original is DX-style)
                                              //would have to verify if some day we have off-center projections.

                _saoPass.uniforms[ 'isOrtho' ].value = 0.0;
            } else {
                _saoPass.uniforms[ 'projInfo' ].value.set(-2.0 / (_colorTarget.width * P[0]),
                        -2.0 / (_colorTarget.height * P[5]),
                    (1.0 - P[12]) / P[0],
                    (1.0 - P[13]) / P[5]);

                _saoPass.uniforms[ 'isOrtho' ].value = 1.0;
            }

            var hack_scale = 0.25;
            _saoPass.uniforms[ 'projScale' ].value = hack_scale * 0.5 * (_colorTarget.height * P[5]);

        }

        //Render the prototype/pre-model scene -- this will also do various camera/light
        // updates to prepare for the progressive passes.
        this.renderScenePart(prototypeScene, true, true, false);

    };


    //Called incrementally by the scene traversal, potentially
    //across several frames.
    this.renderScenePart = function (scene, colorTarget, saoTarget, idTarget) {

        //console.time("renderScenePart");
        _saoBufferValid = false;

        if (this.hasMRT()) {

            if (_settings.sao && saoTarget && _settings.idbuffer && idTarget)
                stderr("Incompatible render target combination given to renderScenePart");

            //In case of MRT, we ignore the which target flags, because
            //we assume the shaders are set up to write to the multiple targets anyway.
            if (_settings.idbuffer) {
                _renderer.render(scene, _camera, [_colorTarget, _idTarget]);
            }
            else if (_settings.sao) {
                _renderer.render(scene, _camera, [_colorTarget, _depthTarget]);
            }
            else /*if (_settings.antialias)*/ {
                _renderer.render(scene, _camera, _colorTarget);
            }
            //else {
            //	_renderer.render(scene, _camera, null);
			//}
        }
        else {
            //Render the color target first -- actually this is slower
            //because the color shader is likely a lot slower than the
            //depth+normal shader, but if we render depth first, then
            //we lose stuff behind transparent objects (potentially).
            //So we cannot do this until the progressive render is split
            //into non-transparent and transparent worlds.
            if (colorTarget) {
                _renderer.render(scene, _camera, _colorTarget);
            }

            if (_settings.idbuffer && idTarget) {
                _renderer.render(scene, _camera, _idTarget);
            }

            if (_settings.sao && saoTarget) {
                //Render the depth pass
                var oldMat = scene.overrideMaterial;

                scene.overrideMaterial = _depthMaterial;
                
                _renderer.render(scene, _camera, _depthTarget);

                scene.overrideMaterial = oldMat;
            }
        }

        //console.timeEnd("renderScenePart");
    };


    this.clearAllOverlays = function () {
        _renderer.clearTarget(_overlayTarget, true, false, false);
    };

    this.renderOverlays = function (overlays) {
        var haveOverlays = 0;

        for (var key in overlays) {
            if (!overlays.hasOwnProperty(key))
                continue;
            var p = overlays[key];
            var s = p.scene;
            var c = p.camera ? p.camera : _camera;
            if (s.children.length) {

                if (!haveOverlays) {
                    //clear the overlay target once we see
                    //the first non-empty overlay scene
                    haveOverlays = 1;
                    _renderer.setClearColor(_black, 0.0);
                    _renderer.clearTarget(_overlayTarget, true, false, false);
                }

                if (p.materialPre) {
                    s.overrideMaterial = p.materialPre;
                    _renderer.render(s, c, _overlayTarget, false);
                }

                if (p.materialPost) {
                    s.overrideMaterial = p.materialPost;
                    _renderer.context.depthFunc(_renderer.context.GREATER);
                    _renderer.render(s, c, _overlayTarget, false);
                    _renderer.context.depthFunc(_renderer.context.LEQUAL);
                }

                s.overrideMaterial = null;
            }
        }

        _blendPass.uniforms['useOverlay'].value = haveOverlays;
    };


    this.composeFinalFrame = function (skipAOPass) {

        //Apply the post pipeline and then show to screen.
        //Note that we must preserve the original color buffer
        //so that we can update it progressively
        if (!skipAOPass && _settings.sao) {

            //console.time("SAO");
            if (!_saoBufferValid) {
                //Create mip levels for the depth/normals target
                if (_depthMipMap) {
                    var prevMip = _depthMipMap[0];
                    _saoMipFirstPass.uniforms['resolution'].value.set(1.0 / prevMip.width, 1.0 / prevMip.height);
                    _saoMipFirstPass.render(_renderer, prevMip, _depthTarget);
                    for (var i = 1; i < _depthMipMap.length; i++) {
                        var curMip = _depthMipMap[i];
                        _saoMipPass.uniforms['resolution'].value.set(1.0 / curMip.width, 1.0 / curMip.height);
                        _saoMipPass.render(_renderer, curMip, prevMip);
                        prevMip = curMip;
                    }
                }

                _saoPass.render(_renderer, _postTarget2, _colorTarget);

                //console.timeEnd("SAO");
                //console.time("SAOblur");
                //Do the bilateral blur
                _saoBlurPass.uniforms['axis'].value.set(1, 0);
                _saoBlurPass.render(_renderer, _postTarget1, _postTarget2);
                _saoBlurPass.uniforms['axis'].value.set(0, 1);
                _saoBlurPass.render(_renderer, _postTarget2, _postTarget1);

                _saoBufferValid = true;
            }

            _blendPass.uniforms['useAO'].value = 1;
            //console.timeEnd("SAOblur");
        } else {
            _blendPass.uniforms['useAO'].value = 0;
        }

        //console.time("post");
        //If we have fxaa, do the blending into an offsecreen target
        //then FXAA into the final target
        if (_settings.antialias) {
            _blendPass.render(_renderer, _postTarget1, _colorTarget);
            _fxaaPass.render(_renderer, null, _postTarget1);
        }
        else {
            _blendPass.render(_renderer, null, _colorTarget);
        }

        _renderer.endFrame();

        //console.timeEnd("post");

    };

    this.setSize = function (w, h, force) {

        _w = w;
        _h = h;
        _renderer.setSize(w, h);

        var sw = 0 | (w * _renderer.devicePixelRatio);
        var sh = 0 | (h * _renderer.devicePixelRatio);

        _settings.logicalWidth = w;
        _settings.logicalHeight = h;
        _settings.deviceWidth = sw;
        _settings.deviceHeight = sh;

        var resX = 1.0 / sw;
        var resY = 1.0 / sh;

        //supersample antialiasing
        //Create a somewhat larger render target, that is power of 2 size and has mipmap
        var usingSSAA = false;
        if (_settings.useSSAA) {
            if (_settings.antialias) {
                sw *= 3 / _renderer.devicePixelRatio;
                sh *= 3 / _renderer.devicePixelRatio;

                var w = 1;
                while (w < sw) w *= 2;
                var h = 1;
                while (h < sh) h *= 2;

                sw = w;
                sh = h;
            }

            usingSSAA = true;
            force = true;
        }

        //Just the regular color target -- shares depth buffer
        //with the depth target.
        if (force || !_colorTarget || _colorTarget.width != sw || _colorTarget.height != sh) {

            stderr("Reallocating render targets.");

            _colorTarget = new THREE.WebGLRenderTarget(sw, sh,
                {   minFilter: usingSSAA ? THREE.LinearMipMapLinearFilter : THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBFormat,
                    type: _settings.useHdrTarget ? THREE.FloatType : THREE.UnsignedByteType,
                    //anisotropy: Math.min(this.getMaxAnisotropy(), 4),
                    stencilBuffer: false,
                    generateMipmaps: usingSSAA
                });

            _overlayTarget = new THREE.WebGLRenderTarget(sw, sh,
                {  minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat,
                    stencilBuffer: false
                });


            _overlayTarget.shareDepthFrom = _colorTarget;


            _depthTarget = null;
            _postTarget1 = null;
            _postTarget2 = null;
            _depthMipMap = [];
        }

        if (_settings.antialias || _settings.sao)
        {
            if (force || !_postTarget1 || _postTarget1.width != sw || _postTarget1.height != sh) {
                //We need one extra post target if FXAA is on, so
                //to use as intermediate from Blend->FXAA pass.
                _postTarget1 = new THREE.WebGLRenderTarget(sw, sh,
                    {
                        minFilter: THREE.LinearFilter,
                        magFilter: THREE.LinearFilter,
                        format: THREE.RGBAFormat,
                        //anisotropy: 0,
                        //anisotropy: Math.min(this.getMaxAnisotropy(), 4),
                        stencilBuffer: false,
                        depthBuffer: false
                    });
            }
        }


        if (_settings.sao) {
            if (force || !_depthTarget || _depthTarget.width != sw || _depthTarget.height != sh) {

                _depthTarget = new THREE.WebGLRenderTarget(sw, sh,
                    { minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        format: THREE.RGBFormat,
                        type: THREE.FloatType,
                        stencilBuffer: false});

                _depthTarget.shareDepthFrom = _colorTarget;

                //SSAO depth/normals mip maps. Those are "manually" created
                //because we use custom sampling. Also, they are separately bound into
                //the shader because there doesn't seem to be an easy way to load them
                //as mip levels of the same texture, in the case they were render buffers initially.
                _depthMipMap = [];
                for (var j = 0; j < 5; j++) {
                    var mip = new THREE.WebGLRenderTarget(0 | (sw / (2 << j)), 0 | (sh / (2 << j)),
                        {   minFilter: THREE.NearestFilter,
                            magFilter: THREE.NearestFilter,
                            format: THREE.RGBAFormat,
                            //type:THREE.FloatType,
                            depthBuffer: false,
                            stencilBuffer: false});
                    mip.generateMipmaps = false;
                    _depthMipMap.push(mip);
                    _saoPass.uniforms['tDepth_mip' + (j + 1)].value = mip;
                }

                //Re-check this when render targets change
                _renderer.verifyMRTWorks([_colorTarget, _depthTarget]);

                //We only need a second post target if SAO is on.
                _postTarget2 = _postTarget1.clone();
            }

            _idTarget = null; //SSAO and ID buffer are currently mutually exclusive

            _saoPass.uniforms[ 'size' ].value.set(sw, sh);
            _saoPass.uniforms[ 'tDepth' ].value = _depthTarget;
            _saoBlurPass.uniforms[ 'size' ].value.set(sw, sh);
            _saoBlurPass.uniforms[ 'resolution' ].value.set(resX, resY);
        }


        if (_settings.idbuffer) {
            if (force || !_idTarget || _idTarget.width != sw || _idTarget.height != sh) {
                _idTarget = new THREE.WebGLRenderTarget(sw, sh,
                    {   minFilter: THREE.NearestFilter,
                        magFilter: THREE.NearestFilter,
                        format: THREE.RGBFormat, /* TODO: need full RGBA for ids over 2^24, but that doesn't match the color target */
                        type: THREE.UnsignedByteType,
                        stencilBuffer: false,
                        generateMipmaps: usingSSAA
                    });

                _idTarget.shareDepthFrom = _colorTarget;

                //Re-check this when render targets change
                _renderer.verifyMRTWorks([_colorTarget, _idTarget]);

                //SSAO and ID buffer are currently mutually exclusive
                _depthTarget = null;
                _depthMipMap = null;
            }
        }


        _fxaaPass.uniforms[ 'resolution' ].value.set(resX, resY);

        _blendPass.uniforms[ 'tOverlay' ].value = _overlayTarget;
        _blendPass.uniforms[ 'tAO' ].value = _postTarget2;
        _blendPass.uniforms[ 'useAO' ].value = _settings.sao ? 1 : 0;
        _blendPass.uniforms[ 'resolution' ].value.set(resX, resY);
        _blendPass.uniforms[ 'tID' ].value = _idTarget;
    };

    this.getMaxAnisotropy = function () {
        return _renderer.getMaxAnisotropy();
    };

    this.hasMRT = function () {
        return !_blockMRT && _renderer.supportsMRT();
    };

    this.initPostPipeline = function (useSAO, useFXAA, useIDBuffer) {

        //TODO: Do we want to move the IE check to higher level code?
        _settings.sao = useSAO && !_isIE11;
        _settings.antialias = useFXAA && !_isIE11;
        _settings.idbuffer = useIDBuffer;

        //Those two are mutually exclusive at the moment.
        if (useIDBuffer)
            _settings.sao = false;

        if (_settings.haveTwoSided)
            _depthMaterial.side = THREE.DoubleSide;

        //TODO: do we really need to update all these or just the depthMaterial?
        _depthMaterial.needsUpdate = true;
        _saoPass.material.needsUpdate = true;
        _saoBlurPass.material.needsUpdate = true;
        _saoMipFirstPass.material.needsUpdate = true;
        _saoMipPass.material.needsUpdate = true;
        _fxaaPass.material.needsUpdate = true;
        _blendPass.material.needsUpdate = true;
        _clearPass.material.needsUpdate = true;

        //Also reallocate the render targets
        this.setSize(_w, _h);
    };

    this.setClearColors = function (colorTop, colorBot) {

        _clearPass.uniforms['color2'].value.copy(colorTop);
        if (colorBot)
            _clearPass.uniforms['color1'].value.copy(colorBot);
        else
            _clearPass.uniforms['color1'].value.set(0, 0, 0, 1);
    };


    this.setAOOptions = function (radius, intensity) {

        if (radius !== undefined) {
            _saoPass.uniforms[ 'radius' ].value = radius;
            //_saoPass.uniforms[ 'bias' ].value = radius * 1e-5;
            //stderr("ao radius " + _saoPass.uniforms[ 'radius' ].value);
        }
        if (intensity !== undefined) {
            _saoPass.uniforms[ 'intensity' ].value = intensity;
            //stderr("ao intensity" + _saoPass.uniforms[ 'intensity' ].value);
        }
        _saoBufferValid = false;
    };

    this.getAORadius = function () {
        return _saoPass.uniforms['radius'].value;
    };

    this.getAOIntensity = function() {
        return _saoPass.uniforms['intensity'].value;
    };

    this.setExposureBias = function (bias) {
        _exposureBias = bias;

        //_blendPass.uniforms['exposureBias'].value = Math.pow(2.0, bias);

        //The clear pass scales the background color by the inverse
        //of the exposure bias, so that the overall brightness of
        //the environment remains similar to the original color after
        //tone mapping.
        //_clearPass.uniforms['luminance'].value = Math.pow(2.0, -bias);
    };

    this.getExposureBias = function () {
        return _exposureBias;
    };

    this.setTonemapMethod = function (value) {

        _tonemapMethod  = value;

        if (value == 0) {
        /*
            if (_settings.useHdrTarget) {
                //reallocate the render target if we are going from hdr to ldr
                _settings.useHdrTarget = false;
                this.setSize(_w, _h, true);
            }
            */
            _renderer.gammaInput = false;
        }
        else {
        /*
            if (!_settings.useHdrTarget) {
                //reallocate the render target if we are going from hdr to ldr
                _settings.useHdrTarget = true;
                this.setSize(_w, _h, true);
            }
*/
            //Tell the renderer to linearize all material colors
            _renderer.gammaInput = true;
        }

/*
        _blendPass.uniforms['toneMapMethod'].value = value;

        //If hdr is on, we have to linearize the background color
        //so that when gamma is applied we get the desired one back
        _clearPass.uniforms['linearize'].value = (value == 0) ? 0 : 1;
*/
    };

    this.getToneMapMethod = function () {
        return _tonemapMethod;
    };

    this.toggleTwoSided = function (isTwoSided) {

        //In case the viewer encounters two-sided materials
        //it will let us know, so that we can update
        //the override material used for the SAO G-buffer to also
        //render two sided.
        if (_settings.haveTwoSided != isTwoSided) {
            if (_depthMaterial) {
                _depthMaterial.side = isTwoSided ? THREE.DoubleSide : THREE.FrontSide;
                _depthMaterial.needsUpdate = true;
            }
        }
        _settings.haveTwoSided = isTwoSided;
    };

    this.enter2DMode = function(idMaterial) {
        _idMaterial = idMaterial;
    };

    //Returns the value of the ID buffer at the given
    //viewport location. Note that the viewport location is in
    //OpenGL-style coordinates [-1, 1] range.
    this.idAtPixel = function (vpx, vpy) {
        if (!_idTarget)
            return 0;

        var px = (vpx + 1.0) * 0.5 * _idTarget.width;
        var py = (vpy + 1.0) * 0.5 * _idTarget.height;

        //stderr("x:" + px + " y:" + py);

        _renderer.readPixels(_idTarget, px, py, 1, 1, _readbackBuffer);

        return  (_readbackBuffer[2] << 16) | (_readbackBuffer[1] << 8) | _readbackBuffer[0];
    };


    this.rolloverObjectViewport = function (vpx, vpy) {

        var objId = this.idAtPixel(vpx, vpy);

        //Check if nothing was at that pixel -- 0 means object
        //that has no ID, ffffff means background, and both result
        //in no highlight.
        if (objId == 0) {
            _readbackBuffer[0] = _readbackBuffer[1] = _readbackBuffer[2] = _readbackBuffer[3] = 0;
        }

        _blendPass.uniforms['objID'].value = objId;
        _blendPass.uniforms['objIDv3'].value.set(_readbackBuffer[0]/255, _readbackBuffer[1]/255, _readbackBuffer[2]/255);

    };


    this.screenCapture = function() {
        //TODO: might have to manually read the pixels from the render target for a
        //better solution here.
        return _renderer.domElement.toDataURL("image/png");
    };

	this.setUnitScale = function(metersPerUnit) {
		_unitScale = metersPerUnit;
	};

	this.getUnitScale = function() {
		return _unitScale;
	};
}
;
function StereoRenderContext(options) {

    var _leftCamera, _rightCamera;
    var _leftContext, _rightContext;
    var _renderer;
    var _w, _h;


	// Specific HMD parameters
	var HMD = (options && options.HMD) ? options.HMD: {
		// Parameters from the Oculus Rift DK1
//		hResolution: 1280,
//		vResolution: 800,
		hScreenSize: 0.14976,
		vScreenSize: 0.0936,
		interpupillaryDistance: 0.064,
		lensSeparationDistance: 0.064,
		eyeToScreenDistance: 0.041,
		distortionK : [1.0, 0.22, 0.24, 0.0],
		chromaAbParameter: [ 0.996, -0.004, 1.014, 0.0]
	};


    function createRenderer(canvas) {

        //TODO: improve the pixel scale heuristics below
        var dpr = window.devicePixelRatio;
        if (!dpr) dpr = 1;

        //High density display -- turn off antialiasing since
        //it's not worth the slowdown in that case.
        //if (dpr >= 2.0)
        //    _settings.antialias = false;

        var params = {
            canvas: canvas,
            antialias: false,
            alpha: false,
            premultipliedAlpha: false,
            preserveDrawingBuffer: false, //change it to true for the screen capture api
            stencil: false,
            depth: false,
            devicePixelRatio: dpr
        };

        var renderer = new FireflyWebGLRenderer(params);

        renderer.autoClear = false;

        //Turn off scene sorting by THREE -- this is ok if we
        //do progressive draw in an order that makes sense
        //transparency-wise. If we start drawing using a frustum culling
        //r-tree or there are problems with transparency we'd have to turn on sorting.
        renderer.sortObjects = false;

        return renderer;
    }


    this.init = function (thecanvas) {

        _renderer = createRenderer(thecanvas);

        _leftContext = new RenderContext();
        _leftContext.init(thecanvas, _renderer, thecanvas.clientWidth/2, thecanvas.clientHeight);

        _rightContext = new RenderContext();
        _rightContext.init(thecanvas, _renderer, thecanvas.clientWidth/2, thecanvas.clientHeight);

        this.settings = _leftContext.settings;

    };

	function applyCameraChanges(camera) {

		//Correct aspect ration. Stereo rendering cuts horizontal
		//size in half.
		_leftCamera.aspect = _rightCamera.aspect = camera.aspect * 0.5;

		//Apply field of view correction
		var halfScreenDistance = HMD.vScreenSize / 2;
		var yfov = 2.0 * Math.atan(halfScreenDistance/HMD.eyeToScreenDistance);
		_leftCamera.fov = _rightCamera.fov = THREE.Math.radToDeg(yfov);


		//Offset real world camera position for each eye
		var unitsPerM = 1.0 / _leftContext.getUnitScale();
		var right = camera.target.clone().sub(camera.position).cross(camera.up).normalize();
		right.multiplyScalar(0.5 * HMD.interpupillaryDistance * unitsPerM);
		_leftCamera.position.sub(right);
		_rightCamera.position.add(right);
		_leftCamera.target.sub(right);
		_rightCamera.target.add(right);

		_leftCamera.toPerspective();
		_rightCamera.toPerspective();

		//TODO: offset the projection matrices by the lens center vs. screen center difference.
		// Post-projection viewport coordinates range from (-1.0, 1.0), with the
		// center of the left viewport falling at (1/4) of horizontal screen size.
		// We need to shift this projection center to match with the lens center.
		// We compute this shift in physical units to correct
		// for different screen sizes and then rescale to viewport coordinates.
		var viewCenter = HMD.hScreenSize * 0.25;
		var eyeProjectionShift = viewCenter - HMD.lensSeparationDistance*0.5;
		var projectionCenterOffset = 4.0 * eyeProjectionShift / HMD.hScreenSize;
		_leftCamera.projectionMatrix.elements[12] += projectionCenterOffset;
		_leftCamera.projectionMatrix.elements[12] -= projectionCenterOffset;
	}

    this.beginScene = function (prototypeScene, camera, needClear) {

		_leftCamera = camera.clone();
		_rightCamera = camera.clone();

		applyCameraChanges(camera);

        _leftContext.beginScene(prototypeScene, _leftCamera, needClear);
        _rightContext.beginScene(prototypeScene, _rightCamera, needClear);
    };


    this.renderScenePart = function (scene, colorTarget, saoTarget, idTarget) {
        _leftContext.renderScenePart(scene, colorTarget, saoTarget, idTarget);
        _rightContext.renderScenePart(scene, colorTarget, saoTarget, idTarget);
    };


    this.clearAllOverlays = function () {
        _leftContext.clearAllOverlays();
        _rightContext.clearAllOverlays();
    };

    this.renderOverlays = function (overlays) {
        _leftContext.renderOverlays(overlays);
        _rightContext.renderOverlays(overlays);
    };


    this.composeFinalFrame = function (skipAOPass) {

        _renderer.setViewport(0,0,_w/2,_h);
        _leftContext.composeFinalFrame(skipAOPass);

        _renderer.setViewport(_w/2,0,_w/2,_h);
        _rightContext.composeFinalFrame(skipAOPass);

        _renderer.setViewport(0,0,_w,_h);
    };

    this.setSize = function (w, h, force) {
        _w = w;
        _h = h;
        _leftContext.setSize(w/2, h, force);
        _rightContext.setSize(w/2, h, force);

        _renderer.setSize(w,h);
    };

    this.getMaxAnisotropy = function () {
        return _leftContext.getMaxAnisotropy();
    };

    this.hasMRT = function () {
        return _leftContext.hasMRT();
    };

    this.initPostPipeline = function (useSAO, useFXAA, useIDBuffer) {
        _leftContext.initPostPipeline(useSAO, useFXAA, useIDBuffer);
        _rightContext.initPostPipeline(useSAO, useFXAA, useIDBuffer);
    };

    this.setClearColors = function (colorTop, colorBot) {
        _leftContext.setClearColors(colorTop, colorBot);
        _rightContext.setClearColors(colorTop, colorBot);
    };


    this.setAOOptions = function (radius, intensity) {
        _leftContext.setAOOptions(radius, intensity);
        _rightContext.setAOOptions(radius, intensity);
    };

    this.getAORadius = function () {
        return _leftContext.getAORadius();
    };

    this.getAOIntensity = function() {
        return _leftContext.getAOIntensity();
    };

    this.setExposureBias = function (bias) {
        _leftContext.setExposureBias(bias);
        _rightContext.setExposureBias(bias);
    };

    this.getExposureBias = function () {
        return _leftContext.getExposureBias();
    };

    this.setTonemapMethod = function (value) {
        _leftContext.setTonemapMethod(value);
        _rightContext.setTonemapMethod(value);
    };

    this.getToneMapMethod = function () {
        return _leftContext.getToneMapMethod();
    };

    this.toggleTwoSided = function (isTwoSided) {
        _leftContext.toggleTwoSided(isTwoSided);
        _rightContext.toggleTwoSided(isTwoSided);
    };

    this.enter2DMode = function(idMaterial) {
        _leftContext.enter2DMode(idMaterial);
        _rightContext.enter2DMode(idMaterial);
    };

    //Returns the value of the ID buffer at the given
    //viewport location. Note that the viewport location is in
    //OpenGL-style coordinates [-1, 1] range.
    this.idAtPixel = function (vpx, vpy) {
        console.warn("idAtPixel not implemented in stereo context.");
        return 0;
    };


    this.rolloverObjectViewport = function (vpx, vpy) {
        console.warn("rolloverObjectViewport not implemented in stereo context");
    };


    this.screenCapture = function() {
        console.warn("Screen capture not implemented by stereo render context");
        return null;
    };

	this.setUnitScale = function(metersPerUnit) {
		_leftContext.setUnitScale(metersPerUnit);
		_rightContext.setUnitScale(metersPerUnit);
	};

	this.getUnitScale = function() {
		return _leftContext.getUnitScale();
	}


};;/**
 * WebGL port of:
 * NVIDIA FXAA by Timothy Lottes
 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
 */

FXAAShader = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"resolution": { type: "v2", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform vec2 resolution;",

		"varying vec2 vUv;",

		"#define FXAA_SPAN_MAX     8.0",
        "#define FXAA_EDGE_THRESHOLD_MIN (1.0/24.0)",
        "#define FXAA_EDGE_THRESHOLD (1.0/8.0)",
        "#define FXAA_SEARCH_THRESHOLD (1.0/4.0)",
        "#define FXAA_SEARCH_STEPS 24", //Recommended (preset 3) is 16, we do some more
        "#define FXAA_SUBPIX_TRIM (1.0/4.0)",
        "#define FXAA_SUBPIX_TRIM_SCALE (1.0/(1.0 - FXAA_SUBPIX_TRIM))",
        "#define FXAA_SUBPIX_CAP (3.0/4.0)",

        "vec4 getColor(sampler2D tex, vec2 uv) {",
            "vec4 c = texture2D(tex, uv);",
            "return c;",
        "}",

        "float FxaaLuma(vec3 rgb) {",
            "return rgb.y * (0.587/0.299) + rgb.x; }",
            //"return dot(rgb, vec3(0.299, 0.587, 0.114 ));}",

        "vec4 FxaaFilterReturn(vec4 rgba) {",
            "return rgba;}",

        "vec3 FxaaLerp3(vec3 a, vec3 b, float amountOfA) {",
            "return (vec3(-amountOfA) * b) +",
            "((a * vec3(amountOfA)) + b); }",

        "vec4 FxaaTex(sampler2D tex, vec2 pos) {",
           "return getColor(tex, pos.xy);}",

        "vec4 FxaaTexOff(sampler2D tex, vec2 pos, vec2 offset, vec2 resolution) {",
            "vec2 uv = pos.xy + offset * resolution;",
            "return getColor(tex, uv);}",

        "void main() {",

            "vec3 rgbN = FxaaTexOff( tDiffuse, vUv, vec2(0.0,-1.0), resolution ).xyz;",
            "vec3 rgbE = FxaaTexOff( tDiffuse, vUv, vec2(1.0, 0.0), resolution ).xyz;",
            "vec3 rgbW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,0.0), resolution ).xyz;",
            "vec3 rgbS = FxaaTexOff( tDiffuse, vUv, vec2(0.0, 1.0), resolution ).xyz;",
            "vec4 rgbaM = FxaaTex( tDiffuse, vUv);",
            "vec3 rgbM  = rgbaM.xyz;",

            "float lumaN = FxaaLuma(rgbN);",
            "float lumaE = FxaaLuma(rgbE);",
            "float lumaW = FxaaLuma(rgbW);",
            "float lumaS = FxaaLuma(rgbS);",
            "float lumaM = FxaaLuma(rgbM);",

            "float rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));",
            "float rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));",
            "float range = rangeMax - rangeMin;",

            "if(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD)) {",
                "gl_FragColor = FxaaFilterReturn(rgbaM); return;}",

            "vec3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;",

            "float lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;",
            "float rangeL = abs(lumaL - lumaM);",
            "float blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE;",
            "blendL = min(FXAA_SUBPIX_CAP, blendL);",

            "vec3 rgbNW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,-1.0), resolution ).xyz;",
			"vec3 rgbNE = FxaaTexOff( tDiffuse, vUv, vec2(1.0,-1.0), resolution ).xyz;",
			"vec3 rgbSW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,1.0), resolution ).xyz;",
			"vec3 rgbSE = FxaaTexOff( tDiffuse, vUv, vec2(1.0,1.0), resolution ).xyz;",
			"float opacity  = rgbaM.w;",

            "rgbL += (rgbNW + rgbNE + rgbSW + rgbSE);",
            "rgbL *= vec3(1.0/9.0);",

			"float lumaNW = FxaaLuma( rgbNW);",
			"float lumaNE = FxaaLuma( rgbNE);",
			"float lumaSW = FxaaLuma( rgbSW);",
			"float lumaSE = FxaaLuma( rgbSE);",

            "float edgeVert = abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +",
                "abs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +",
                "abs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));",
            "float edgeHorz = abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +",
                    "abs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +",
                    "abs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));",
            "bool horzSpan = edgeHorz >= edgeVert;",

            "float lengthSign = horzSpan ? -resolution.y : -resolution.x;",
            "if(!horzSpan) lumaN = lumaW;",
            "if(!horzSpan) lumaS = lumaE;",
            "float gradientN = abs(lumaN - lumaM);",
            "float gradientS = abs(lumaS - lumaM);",
            "lumaN = (lumaN + lumaM) * 0.5;",
            "lumaS = (lumaS + lumaM) * 0.5;",

            "bool pairN = gradientN >= gradientS;",
            "if(!pairN) lumaN = lumaS;",
            "if(!pairN) gradientN = gradientS;",
            "if(!pairN) lengthSign *= -1.0;",
            "vec2 posN;",
            "posN.x = vUv.x + (horzSpan ? 0.0 : lengthSign * 0.5);",
            "posN.y = vUv.y + (horzSpan ? lengthSign * 0.5 : 0.0);",

            "gradientN *= FXAA_SEARCH_THRESHOLD;",

            "vec2 posP = posN;",
            "vec2 offNP = horzSpan ? vec2(resolution.x, 0.0) : vec2(0.0, resolution.y);",
            "float lumaEndN = lumaN;",
            "float lumaEndP = lumaN;",
            "bool doneN = false;",
            "bool doneP = false;",
            "posN += offNP * vec2(-1.0, -1.0);",
            "posP += offNP * vec2( 1.0,  1.0);",
            "for(int i = 0; i < FXAA_SEARCH_STEPS; i++) {",
                "if(!doneN) lumaEndN = FxaaLuma(FxaaTex( tDiffuse, posN.xy).xyz);",
                "if(!doneP) lumaEndP = FxaaLuma(FxaaTex( tDiffuse, posP.xy).xyz);",
                "doneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);",
                "doneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);",
                "if(doneN && doneP) break;",
                "if(!doneN) posN -= offNP;",
                "if(!doneP) posP += offNP; }",

            "float dstN = horzSpan ? vUv.x - posN.x : vUv.y - posN.y;",
            "float dstP = horzSpan ? posP.x - vUv.x : posP.y - vUv.y;",
            "bool directionN = dstN < dstP;",
            "lumaEndN = directionN ? lumaEndN : lumaEndP;",

            "if(((lumaM - lumaN) < 0.0) == ((lumaEndN - lumaN) < 0.0))",
                "lengthSign = 0.0;",

            "float spanLength = (dstP + dstN);",
            "dstN = directionN ? dstN : dstP;",
            "float subPixelOffset = (0.5 + (dstN * (-1.0/spanLength))) * lengthSign;",
            "vec3 rgbF = FxaaTex(tDiffuse, vec2(",
                "vUv.x + (horzSpan ? 0.0 : subPixelOffset),",
                "vUv.y + (horzSpan ? subPixelOffset : 0.0))).xyz;",
            "gl_FragColor = FxaaFilterReturn(vec4(FxaaLerp3(rgbL, rgbF, blendL), opacity));",
		"}"

	].join("\n")

};
;


TonemapShaderChunk = [

        //post-gamma luminance
        "float luminance_post(vec3 rgb) {",
        "return dot(rgb, vec3(0.299, 0.587, 0.114));",
        "}",

        //pre-gamma luminance
        "float luminance_pre(vec3 rgb) {",
            "return dot(rgb, vec3(0.212671, 0.715160, 0.072169));",
        "}",

    /*
        "vec3 xyz2rgb(vec3 xyz) {",
            //XYZ -> RGB conversion matrix using HDTV constants
            "vec3 R = vec3( 3.240479, -1.537150, -0.498535);",
            "vec3 G = vec3(-0.969256,  1.875992,  0.041556);",
            "vec3 B = vec3( 0.055648, -0.204043,  1.057311);",

            "vec3 rgb;",
            "rgb.b = dot(xyz, B);",
            "rgb.g = dot(xyz, G);",
            "rgb.r = dot(xyz, R);",

            "return rgb;",
        "}",

        "vec3 rgb2xyz(vec3 rgb) {",
            //RGB -> XYZ conversion matrix using HDTV constants
            "vec3 X = vec3(0.412453, 0.35758, 0.180423);",
            "vec3 Y = vec3(0.212671, 0.71516, 0.0721688);",
            "vec3 Z = vec3(0.0193338, 0.119194, 0.950227);",

            "vec3 xyz;",
            "xyz.x = dot(rgb, X);",
            "xyz.y = dot(rgb, Y);",
            "xyz.z = dot(rgb, Z);",

            "return xyz;",
        "}",

        "vec3 xyz2xyY(vec3 xyz) {",
            "float sum = xyz.x + xyz.y + xyz.z;",

            //Note in case of division by 0, the hardware
            //should output zero for sum, so we are still ok with the result
            "sum = 1.0 / sum;",

            "vec3 xyY;",
            "xyY.z = xyz.y;",
            "xyY.x = xyz.x * sum;",
            "xyY.y = xyz.y * sum;",

            "return xyY;",
        "}",

        "vec3 xyY2xyz(vec3 xyY) {",

            "float x = xyY.x;",
            "float y = xyY.y;",
            "float Y = xyY.z;",

            "vec3 xyz;",
            "xyz.y = Y;",
            "xyz.x = x * (Y / y);",
            "xyz.z = (1.0 - x - y) * (Y / y);",

            "return xyz;",
        "}",
      */

        "const float Shift = 1.0 / 0.18;",

        //Best fit of John Hable's generalized filmic function parameters to the Canon curve
        //This is a significantly better and cheaper to compute fit than the power and polynomial
        //least squares fits from OGS/RaaS (which have larger max and average error, and also go negative near
        //the origin).
        "float toneMapCanonFilmic_NoGamma(float x) {",

            //This extra exposure by 1.0/0.18 mimics what is also done in OGS's implementation
            //and the curve fit was done with this scale in mind.
            "x *= Shift;",

            "const float A = 0.2;", //shoulder strength
            "const float B = 0.34;", //linear strength
            "const float C = 0.002;", //linear angle
            "const float D = 1.68;", //toe strength
            "const float E = 0.0005;", //toe numerator
            "const float F = 0.252;", //toe denominator (E/F = toe angle)
            "const float scale = 1.0/0.833837;",

            "return (((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F) * scale;",
        "}",


        //Same as above but with 2.2 gamma built into the fit and working on the
        // whole RGB triplet at once (i.e. non color preserving version).
        "vec3 toneMapCanonFilmic_WithGamma(vec3 x) {",

            //This extra exposure by 1.0/0.18 mimics what is also done in OGS's implementation
            //and the curve fit was done with this scale in mind.
            "x *= Shift;",

            //Best overall error params
    /*
            "const float A = 0.2;",
            "const float B = 0.23;",
            "const float C = 0.147;",
            "const float D = 0.26;",
            //"const float E = 0.0;",
            "const float F = 0.22;",
            "const float scale = 1.0/0.900202;",
    */

            //Best max deviation params
            "const float A = 0.27;",
            "const float B = 0.29;",
            "const float C = 0.052;",
            "const float D = 0.2;",
            //"const float E = 0.0;",
            "const float F = 0.18;",
            "const float scale = 1.0/0.897105;",

            "return (((x*(A*x+C*B))/(x*(A*x+B)+D*F))) * scale;",
        "}",

].join("\n");
;
//Shader that composes a final frame from the color target, SSAO target and overlays target.
BlendShader = {

	uniforms: {
		"tDiffuse": { type: "t", value: null }, //Color buffer containing the rendered 3d model

        "tAO": {type: "t", value:null }, //Ambient occlusion + depth buffer
        "useAO": {type: "i", value: 0 }, //Whether to blend in the AO buffer

        "tOverlay" : { type: "t", value: null}, //The selection/overlays buffer
        "useOverlay" : { type: "i", value:0 }, //Whether to blend in the overlays

        "tID" : { type: "t", value: null }, //The ID buffer
        "objID" : {type : "i", value: 0 }, //The currently highlighted object ID (0 means no highlight)
        "objIDv3" : {type : "v3", value: new THREE.Vector3(0,0,0) }, //The currently highlighted object ID as RGB triplet


        "resolution": { type: "v2", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }, // 1/size

        //Enable these if the forward pass renders in HDR-linear target and the Blend shader is doing the tone mapping
        //"exposureBias" : { type:"f", value: 1.0 },
        //"toneMapMethod" : { type:"i", value: 0 }

		//Stereo rendering (Oculus) uniforms. Warp and aberration constants are from DK1 Rift.
		"scale": { type: "v2", value: new THREE.Vector2(1.0,1.0) },
		"scaleIn": { type: "v2", value: new THREE.Vector2(1.0,1.0) },
		"lensCenter": { type: "v2", value: new THREE.Vector2(0.0,0.0) },
		"hmdWarpParam": { type: "v4", value: new THREE.Vector4(1.0, 0.22, 0.24, 0.0) },
		"chromAbParam": { type: "v4", value: new THREE.Vector4(0.996, -0.004, 1.014, 0.0) }
	},


	defines: {
		//"OCULUS" : 1
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
        "uniform sampler2D tAO;",
        "uniform int useAO;",
        "uniform sampler2D tOverlay;",
        "uniform int useOverlay;",
        "uniform vec2 resolution;",
        //"uniform float exposureBias;",
        //"uniform int toneMapMethod;",
        "uniform int objID;",
        "uniform vec3 objIDv3;",
        "uniform sampler2D tID;",

	//"#define OCULUS 1",


	"#ifdef OCULUS",
		"uniform vec2 scale;",
		"uniform vec2 scaleIn;",
		"uniform vec2 lensCenter;",
		"uniform vec4 hmdWarpParam;",
		'uniform vec4 chromAbParam;',
	"#endif",


		"varying vec2 vUv;",

        TonemapShaderChunk,

        "vec4 fetchOverlayTexel(vec2 uv, vec2 offset) {",
            "return texture2D(tOverlay, uv + resolution * offset);",
        "}",

		"#define checkOnePixel(i, j) { \
			vec4 c = fetchOverlayTexel(vUv, vec2(i, j));\
			max_alpha = max(max_alpha, c.a);\
			if (i==0 && j==0)\
				center = c;\
			if (c.a == 0.0)\
				has_zero++;\
			else \
				non_zero_pixel = c;\
		}",

        "vec4 overlayEdgeDetect(vec2 vUv) {",
            "int has_zero = 0;",
            "vec4 center = vec4(0.0);",
            "vec4 non_zero_pixel = vec4(0.0);",
            "float max_alpha = 0.0;",

        //NOTE: The loop below is unrolled in extremely ugly way, in order to avoid a Chrome/Windows codegen
        //issue that results in linker errors when the loop is not unrolled. My best guess
        //is that it has to do with the integer precision setting of the loop variable and then
        //later using that with another expected precision.
/*
            "for (int j=-1; j<=1; j++) {",
                "for (int i=-1; i<=1; i++) {",
                        "vec4 c = fetchOverlayTexel(vUv, vec2(i, j));",
                        "max_alpha = max(max_alpha, c.a);",
                        "if (i==0 && j==0)",
                            "center = c;",
                        "if (c.a == 0.0)",
                            "has_zero++;",
                        "else ",
                            "non_zero_pixel = c;",
                "}",
            "}",
*/
            "checkOnePixel(-1,-1);",
            "checkOnePixel(0,-1);",
            "checkOnePixel(1,-1);",
            "checkOnePixel(-1,0);",
            "checkOnePixel(0,0);",
            "checkOnePixel(1,0);",
            "checkOnePixel(-1,1);",
            "checkOnePixel(0,1);",
            "checkOnePixel(1,1);",


            "if (has_zero != 0 && has_zero != 9)",
            "{",
                "if (center == vec4(0.0))",
                    "center = non_zero_pixel;",
                "float maxComponent = max(center.r, max(center.g, center.b));",
                "center.rgb /= maxComponent;",
                "center.rgb = sqrt(center.rgb);",
                "center.a = 0.5 + 0.5 * max_alpha * 0.125 * float(has_zero);",
            "}",

            // IE11 does not support parameter qualifiers, so use a negative
            // alpha to signal this condition instead. We could inline this
            // whole function, but supposedly IE 11.0.3 will fix the underlying
            // issue, so hopefully we can just undo this workaround soon.
            "if (has_zero == 0) {",
                "center.a = -center.a;",
            "}",

            "return center;",
        "}",

		"vec4 sampleColor() {",

		"#ifdef OCULUS",
			//In our case the source texture is one eye only, so we deviate from the sample
			"vec2 uv = (vUv*2.0)-1.0;", // range from [0,1] to [-1,1]

			"vec2 theta = (uv-lensCenter)*scaleIn;",
			"float rSq = theta.x*theta.x + theta.y*theta.y;",
			"vec2 rvector = theta*(hmdWarpParam.x + hmdWarpParam.y*rSq + hmdWarpParam.z*rSq*rSq + hmdWarpParam.w*rSq*rSq*rSq);",
		     /*
		    "vec2 tc = (lensCenter + scale * rvector);",
		  	"tc = (tc+1.0)/2.0;", // range from [-1,1] to [0,1]

			"if (any(bvec2(clamp(tc, vec2(0.0,0.0), vec2(1.0,1.0))-tc)))",
			"  return vec4(0.0, 0.0, 0.0, 1.0);",

			"return texture2D( tDiffuse, tc);",
               */

			"  vec2 rBlue = rvector * (chromAbParam.z + chromAbParam.w * rSq);",
			"  vec2 tcBlue = (lensCenter + scale * rBlue);",
			"  tcBlue = (tcBlue+1.0)/2.0;", // range from [-1,1] to [0,1]

			"  if (any(bvec2(clamp(tcBlue, vec2(0.0,0.0), vec2(1.0,1.0))-tcBlue)))",
			"    return vec4(0.0, 0.0, 0.0, 1.0);",

			"  vec2 tcGreen = lensCenter + scale * rvector;",
			"  tcGreen = (tcGreen+1.0)/2.0;", // range from [-1,1] to [0,1]

			"  vec2 rRed = rvector * (chromAbParam.x + chromAbParam.y * rSq);",
			"  vec2 tcRed = lensCenter + scale * rRed;",
			"  tcRed = (tcRed+1.0)/2.0;", // range from [-1,1] to [0,1]

			"  return vec4(texture2D(tDiffuse, tcRed).r, texture2D(tDiffuse, tcGreen).g, texture2D(tDiffuse, tcBlue).b, 1);",

		"#else",
			"return texture2D( tDiffuse, vUv );",
		"#endif",
		"}",

		"float sampleAO() {",
			"return (useAO != 0) ? texture2D(tAO, vUv).r : 1.0;",
		"}",

		"void main() {",

			"vec4 texel = sampleColor();",

            //add in the ambient occlusion
            "float ao = sampleAO();",

//Tone mapping is currently done by the main forward pass, in order to fit the
//output into an RGBA8 render target. It's mathematically wrong to apply the
//ambient obscurance in gamma space, but the performance savings of not using RGBA32 target
//are significant.
            "texel.rgb *= ao;",//sqrt for gamma correct the AO -- TODO: play with this to see if we get better results
/*
            "texel.rgb *= ao;",

            //Apply tone mapping
            "if (toneMapMethod == 1) {",
                "vec3 rgb = texel.rgb * exposureBias;",
                "texel.rgb = toneMapCanonFilmic_WithGamma(rgb);",
            "} else if (toneMapMethod == 2) {",
                "vec3 rgb = texel.rgb * exposureBias;",
                "float lum = luminance_pre(rgb);",
                "float lum2 = toneMapCanonFilmic_NoGamma(lum);",
                "rgb *= lum2 / lum;",
                "texel.rgb = rgb;",
                "texel.rgb = pow(texel.rgb, vec3(1.0/2.2));", //apply gamma, since this tone mapper is done in linear space
            "}",
*/
            //composite in the overlays texture
            "if (useOverlay!=0) {",
                "vec4 overlay = overlayEdgeDetect(vUv);",
                // Negative alpha signals the inside overlay condition, as above.
                "if (overlay.a < 0.0) {",
                    "overlay.a = -overlay.a;",

                    "if (overlay.a >= 0.99) {",
                        //Blend the overlay color with the luminance of the underlying
                        //pixel so that we do not lose detail from any underlying texture map
                        "overlay.a = 0.75;",
                        "texel.rgb = vec3(luminance_post(texel.rgb));",
                    "}",
                "}",

                "texel.rgb = mix(texel.rgb, sqrt(overlay.rgb)/*sqrt=gamma*/, overlay.a);",
            "}",

            "if (objID != 0) {",

                "vec4 idAtPixel = texture2D(tID, vUv);",

                "vec3 idDelta = abs(idAtPixel.rgb - objIDv3.rgb);",
                "if (max(max(idDelta.r, idDelta.g), idDelta.b) < 1e-3) {",
                    "texel.rgb = mix(texel.rgb, vec3(1.0,1.0,0.0), 0.25);",
                "}",

            "}",

			"gl_FragColor = texel;",
		"}"

	].join("\n")

};;/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShaderPass = function ( shader, textureID ) {

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	this.material = new THREE.ShaderMaterial( {

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	} );

	this.renderToScreen = false;

	this.enabled = true;
	this.clear = false;

    this.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );

    //this.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), this.material );

    //Instead of using a screen quad we use a large triangle -- this is slightly
    //faster (~6% measured in our specific case), due to better cache coherency. See this article:
    //http://michaldrobot.com/2014/04/01/gcn-execution-patterns-in-full-screen-passes/
    var triangle = new THREE.BufferGeometry();
    var p = new Float32Array(9);
    p[0] = -1; p[1] = -1; p[2] = 0;
    p[3] = 3; p[4] = -1; p[5] = 0;
    p[6] = -1; p[7] = 3; p[8] = 0;

    var uv = new Float32Array(6);
    uv[0] = 0; uv[1] = 0;
    uv[2] = 2; uv[3] = 0;
    uv[4] = 0; uv[5] = 2;

    triangle.addAttribute("position", new THREE.BufferAttribute(p, 3));
    triangle.addAttribute("uv", new THREE.BufferAttribute(uv, 2));

    this.quad = new THREE.Mesh( triangle, this.material );


    this.scene = new THREE.Scene();
    this.scene.add( this.quad );
};

THREE.ShaderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer;

		}

		if ( this.renderToScreen || !writeBuffer ) {

			renderer.render( this.scene, this.camera );

		} else {

			renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		}

	}

};


;
/* Scalable Ambient Obscurance implementation based on: {http://graphics.cs.williams.edu/papers/SAOHPG12/} */

SAOShader = {

    uniforms: {

        "tDepth":       { type: "t", value: null },
        "size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },
        "cameraNear":   { type: "f", value: 1 },
        "cameraFar":    { type: "f", value: 100 },
        "radius":       { type: "f", value: 10.0 },
        "bias":         { type: "f", value: 0.01 },
        "projScale":    { type: "f", value: 500 },
        //"clipInfo":     { type: "v3", value: new THREE.Vector3(100, 99, -100) }, /* zf*zn, zn-zf, zf */
        "projInfo":     { type: "v4", value: new THREE.Vector4(0,0,0,0) },
        "intensity":    { type: "f", value: 0.5 },
        "isOrtho" :     { type: "f", value: 1.0 },

        "tDepth_mip1":       { type: "t", value: null },
        "tDepth_mip2":       { type: "t", value: null },
        "tDepth_mip3":       { type: "t", value: null },
        "tDepth_mip4":       { type: "t", value: null },
        "tDepth_mip5":       { type: "t", value: null }
    },

    vertexShader: [

        "varying vec2 vUv;",

        "void main() {",

        "vUv = uv;",

        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

        "#extension GL_OES_standard_derivatives : enable",

        "#define USE_MIPMAP 1",

        "uniform float cameraNear;",
        "uniform float cameraFar;",


        "uniform vec2 size;",        // texture width, height

        "uniform float lumInfluence;",  // how much luminance affects occlusion

        "varying vec2 vUv;",

        // Total number of direct samples to take at each pixel
        "#define NUM_SAMPLES (17)",

        // If using depth mip levels, the log of the maximum pixel offset before we need to switch to a lower
        // miplevel to maintain reasonable spatial locality in the cache
        // If this number is too small (< 3), too many taps will land in the same pixel, and we'll get bad variance that manifests as flashing.
        // If it is too high (> 5), we'll get bad performance because we're not using the MIP levels effectively
        "#define LOG_MAX_OFFSET (3)",

        // This must be less than or equal to the MAX_MIP_LEVEL defined in SSAO.cpp
        "#define MAX_MIP_LEVEL (5)",

        // This is the number of turns around the circle that the spiral pattern makes.  This should be prime to prevent
        // taps from lining up.  This particular choice (7) was tuned for NUM_SAMPLES == 9
        "#define NUM_SPIRAL_TURNS (7)",

        //////////////////////////////////////////////////

        /** The height in pixels of a 1m object if viewed from 1m away.
         You can compute it from your projection matrix.  The actual value is just
         a scale factor on radius; you can simply hardcode this to a constant (~500)
         and make your radius value unitless (...but resolution dependent.)  */
        "uniform float           projScale;",

        /** Negative, "linear" values in world-space units */
        "uniform sampler2D tDepth;",

        //The mip levels of the depth -- with WebGL
        //we can't sample specific mips, so we have to
        //declare them explicitly
        "#ifdef USE_MIPMAP",
        "uniform sampler2D tDepth_mip1;",
        "uniform sampler2D tDepth_mip2;",
        "uniform sampler2D tDepth_mip3;",
        "uniform sampler2D tDepth_mip4;",
        "uniform sampler2D tDepth_mip5;",
        "#endif",

        /** World-space AO radius in scene units (r).  e.g., 1.0m */
        "uniform float radius;",

        /** Bias to avoid AO in smooth corners, e.g., 0.01m */
        "uniform float bias;",

        "uniform float intensity;",

        "uniform float isOrtho;",

        /** intensity / radius^6 */
        //"uniform float intensityDivR6;",
        "float intensityDivR6 = intensity / pow(radius, 6.0);",

        /** Returns a unit vector and a screen-space radius for the tap on a unit disk (the caller should scale by the actual disk radius) */
        "vec2 tapLocation(int sampleNumber, float spinAngle, out float ssR){",
            // Radius relative to ssR
            "float alpha = float(float(sampleNumber) + 0.5) * (1.0 / float(NUM_SAMPLES));",
            "float angle = alpha * (float(NUM_SPIRAL_TURNS) * 6.28) + spinAngle;",

            "ssR = alpha;",
            "return vec2(cos(angle), sin(angle));",
        "}",


        /** Used for packing Z into the GB channels */
        "float CSZToKey(float z) {",
            "return clamp(z * (1.0 / -cameraFar), 0.0, 1.0);",
        "}",


        /** Used for packing Z into the GB channels */
        "void packKey(float key, out vec2 p) {",
            // Round to the nearest 1/256.0
            "float temp = floor(key * 256.0);",

            // Integer part
            "p.x = temp * (1.0 / 256.0);",

            // Fractional part
            "p.y = key * 256.0 - temp;",
        "}",


        //Used to unpack depth value when input depth texture is RGBA8
        "float unpackDepth( const in vec4 rgba_depth ) {",
            "float depth = dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );",
            "if (depth == 0.0)",
                "return -cameraFar * 1.0e10;",
            "return depth * (cameraNear - cameraFar) - cameraNear;",
        "}",

        /*
         Clipping plane constants for use by reconstructZ

         clipInfo = (z_f == -inf()) ? Vector3(z_n, -1.0f, 1.0f) : Vector3(z_n * z_f,  z_n - z_f,  z_f);
         */
        //"uniform vec3      clipInfo;",
        //"vec3 clipInfo = vec3(cameraNear * cameraFar, cameraNear - cameraFar, cameraFar);",

        //"float reconstructCSZ(float d) {",
        //    "return clipInfo[0] / (clipInfo[1] * d + clipInfo[2]);",
        //"}",

        /**  vec4(-2.0f / (width*P[0][0]),
         -2.0f / (height*P[1][1]),
         ( 1.0f - P[0][2]) / P[0][0],
         ( 1.0f + P[1][2]) / P[1][1])


         where P is the projection matrix that maps camera space points
         to [-1, 1] x [-1, 1].  That is, GCamera::getProjectUnit(). */
        "uniform vec4 projInfo;",

    /** Reconstruct camera-space P.xyz from screen-space S = (x, y) in
         pixels and camera-space z < 0.  Assumes that the upper-left pixel center
         is at (0.5, 0.5) [but that need not be the location at which the sample tap
         was placed!]

         Costs 3 MADD.  Error is on the order of 10^3 at the far plane, partly due to z precision.
         */
        "vec3 reconstructCSPosition(vec2 S, float z) {",
            "return vec3((S.xy * projInfo.xy + projInfo.zw) * mix(z, -1.0, isOrtho), z);",
        "}",

        /** Reconstructs screen-space unit normal from screen-space position */
        "vec3 reconstructCSFaceNormal(vec3 C) {",
            "return normalize(cross(dFdy(C), dFdx(C)));",
        "}",

        "vec3 reconstructNonUnitCSFaceNormal(vec3 C) {",
            "return cross(dFdy(C), dFdx(C));",
        "}",


        "vec2 sizeM1 = vec2(1.0/(size.x), 1.0/(size.y));",

        /** Read the camera-space position of the point at screen-space pixel ssP */
        "vec3 getPosition(ivec2 ssP, float depth) {",
            "vec3 P;",

            // Offset to pixel center
            "P = reconstructCSPosition(vec2(ssP) + vec2(0.5), depth);",
            "return P;",
        "}",

    /** Read the camera-space position of the point at screen-space pixel ssP + unitOffset * ssR.  Assumes length(unitOffset) == 1 */
        "vec3 getOffsetPosition(ivec2 ssC, vec2 unitOffset, float ssR) {",

            "ivec2 ssP = ivec2(ssR * unitOffset) + ssC;",

            "vec3 P;",

            // We need to divide by 2^mipLevel to read the appropriately scaled coordinate from a MIP-map.
            // Manually clamp to the texture size because texelFetch bypasses the texture unit
            //"ivec2 mipP = clamp(ssP >> mipLevel, ivec2(0), textureSize(CS_Z_buffer, mipLevel) - ivec2(1));",
            //"ivec2 mipP = ssP;",
            //"P.z = texelFetch(tDepth, mipP, 0).w;",

            "vec2 screenUV = (vec2(ssP) + vec2(0.5)) * sizeM1;",

            "#ifdef USE_MIPMAP",
                //"int mipLevel = clamp(int(floor(log2(ssR))) - LOG_MAX_OFFSET, 0, MAX_MIP_LEVEL);",
                "int mipLevel = int(max(0.0, min(floor(log2(ssR)) - float(LOG_MAX_OFFSET), float(MAX_MIP_LEVEL))));",

                "if (mipLevel == 0) {",
                    "P.z = texture2D(tDepth, screenUV).z;",
                    "if (P.z == 0.0) P.z = -cameraFar * 1.0e10;",
                "}",
                "else if (mipLevel == 1)",
                    "P.z = unpackDepth(texture2D(tDepth_mip1, screenUV));",
                "else if (mipLevel == 2)",
                    "P.z = unpackDepth(texture2D(tDepth_mip2, screenUV));",
                "else if (mipLevel == 3)",
                    "P.z = unpackDepth(texture2D(tDepth_mip3, screenUV));",
                "else if (mipLevel == 4)",
                    "P.z = unpackDepth(texture2D(tDepth_mip4, screenUV));",
                "else if (mipLevel == 5)",
                    "P.z = unpackDepth(texture2D(tDepth_mip5, screenUV));",
            "#else",
                "P.z = texture2D(tDepth, screenUV).z;",
                "if (P.z == 0.0) P.z = -cameraFar * 1.0e10;",
            "#endif",

            // Offset to pixel center
            "P = reconstructCSPosition(vec2(ssP) + vec2(0.5), P.z);",

            "return P;",
        "}",

        "float radius2 = radius * radius;",
        "float invRadius2 = 1.0 / radius2;",

        /** Compute the occlusion due to sample with index \a i about the pixel at \a ssC that corresponds
         to camera-space point \a C with unit normal \a n_C, using maximum screen-space sampling radius \a ssDiskRadius

         Note that units of H() in the HPG12 paper are meters, not
         unitless.  The whole falloff/sampling function is therefore
         unitless.  In this implementation, we factor out (9 / radius).

         Four versions of the falloff function are implemented below
         */
        "float sampleAO(in ivec2 ssC, in vec3 C, in vec3 n_C, in float ssDiskRadius, in int tapIndex, in float randomPatternRotationAngle) {",
            // Offset on the unit disk, spun for this pixel
            "float ssR;",
            "vec2 unitOffset = tapLocation(tapIndex, randomPatternRotationAngle, ssR);",
            "ssR *= ssDiskRadius;",

            // The occluding point in camera space
            "vec3 Q = getOffsetPosition(ssC, unitOffset, ssR);",

            "vec3 v = Q - C;",

            "float vv = dot(v, v);",
            "float vn = dot(v, n_C);",

            "const float epsilon = 0.01;",

            // A: From the HPG12 paper
            // Note large epsilon to avoid overdarkening within cracks
            //"return float(vv < radius2) * max((vn - bias) / (epsilon + vv), 0.0) * radius2 * 0.6;",

            // B: Smoother transition to zero (lowers contrast, smoothing out corners). [Recommended]
            "float f = max(radius2 - vv, 0.0); return f * f * f * max((vn - bias) / (epsilon + vv), 0.0);",

            // C: Medium contrast (which looks better at high radii), no division.  Note that the
            // contribution still falls off with radius^2, but we've adjusted the rate in a way that is
            // more computationally efficient and happens to be aesthetically pleasing.
            //"return 4.0 * max(1.0 - vv * invRadius2, 0.0) * max(vn - bias, 0.0);",

            // D: Low contrast, no division operation
            //"return 2.0 * float(vv < radius * radius) * max(vn - bias, 0.0);",
        "}",


        // user variables

        "const bool useNoise = true;",      // use noise instead of pattern for sample dithering


        // generating noise / pattern texture for dithering

        "vec2 rand( const vec2 coord ) {",

            "vec2 noise;",

            "if ( useNoise ) {",

            "float nx = dot ( coord, vec2( 12.9898, 78.233 ) );",
            "float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );",

            "noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );",

            "} else {",

            "float ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );",
            "float gg = fract( coord.t * ( size.y / 2.0 ) );",

            "noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;",

            "}",

            //put in the range -1/1 for use as rotation angle
            "return ( noise * 2.0  - 1.0 );",

        "}",


        "float getRandomAngle(vec2 pos) {",
            "vec2 rnd = rand(pos);",
            "return atan(rnd.y, rnd.x);",
        "}",


        "void main() {",

        // Pixel being shaded
        "ivec2 ssC = ivec2(gl_FragCoord.xy);",

        //get the normal and depth from our normal+depth texture
        "vec4 nrmz = texture2D(tDepth, vUv);",

        // Unneccessary with depth test.
        "if (nrmz.z == 0.0) {",
            // We're on the skybox
            "gl_FragColor.r = 1.0;",
            "gl_FragColor.a = 0.0;",
            "packKey(1.0, gl_FragColor.gb);",
            "return;",
        "}",

        // World space point being shaded
        "vec3 C = getPosition(ssC, nrmz.z);",

        "packKey(CSZToKey(C.z), gl_FragColor.gb);",

        // Hash function used in the HPG12 AlchemyAO paper
        //"float randomPatternRotationAngle = (3 * ssC.x ^ ssC.y + ssC.x * ssC.y) * 10;",

        //No integer stuff on WebGL, so we have to use an alternative jitter pattern
        "float randomPatternRotationAngle = getRandomAngle(vUv);",

        // Reconstruct normals from positions. These will lead to 1-pixel black lines
        // at depth discontinuities, however the blur will wipe those out so they are not visible
        // in the final image.
        //"vec3 n_C = reconstructCSFaceNormal(C);",
        "vec3 n_C = vec3(nrmz.x, nrmz.y, sqrt(1.0 - dot(nrmz.xy, nrmz.xy)));",

        // Choose the screen-space sample radius
        // proportional to the projected area of the sphere
        "float ssDiskRadius = -projScale * radius / mix(C.z, -1.0, isOrtho);",

        "float sum = 0.0;",

		//NOTE: The loop below is unrolled in extremely ugly way, in order to avoid a Chrome/Windows codegen
		//issue that results in linker errors when the loop is not unrolled. My best guess
		//is that it has to do with the integer precision setting of the loop variable and then
		//later using that with another expected precision.
		/*
        "for (int i = 0; i < NUM_SAMPLES; ++i) {",
            "sum += sampleAO(ssC, C, n_C, ssDiskRadius, i, randomPatternRotationAngle);",
        "}",
        */
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 0, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 1, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 2, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 3, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 4, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 5, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 6, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 7, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 8, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 9, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 10, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 11, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 12, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 13, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 14, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 15, randomPatternRotationAngle);",
		"sum += sampleAO(ssC, C, n_C, ssDiskRadius, 16, randomPatternRotationAngle);",

        "float A = max(0.0, 1.0 - sum * intensityDivR6 * (5.0 / float(NUM_SAMPLES)));",

        // Bilateral box-filter over a quad for free, respecting depth edges
        // (the difference that this makes is subtle)
        //"if (abs(dFdx(C.z)) < 0.02) {",
        //    "A -= dFdx(A) * ((ssC.x & 1) - 0.5);",
        //"}",
        //"if (abs(dFdy(C.z)) < 0.02) {",
        //    "A -= dFdy(A) * ((ssC.y & 1) - 0.5);",
        //"}",
        //ARGH no integer ops in WebGL, fake the & 1 here
        "if (abs(dFdx(C.z)) < 0.02) {",
            "A -= dFdx(A) * (mod(float(ssC.x), 2.0) - 0.5);",
        "}",
        "if (abs(dFdy(C.z)) < 0.02) {",
            "A -= dFdy(A) * (mod(float(ssC.y), 2.0) - 0.5);",
        "}",

        "gl_FragColor.r = A;",
        "gl_FragColor.a = 1.0;",

        "}"

    ].join("\n")


};;
//Bilateral separable blur pass for SAO shader.

SAOBlurShader = {

    uniforms: {

        "tDiffuse":     { type: "t", value: null },
        "size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },
        "resolution":   { type: "v2", value: new THREE.Vector2( 1.0/512, 1.0/512) },
        "axis":         { type: "v2", value: new THREE.Vector2(1,0) }
    },

    vertexShader: [

        "varying vec2 vUv;",

        "void main() {",

            "vUv = uv;",

            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

    /** Increase to make depth edges crisper. Decrease to reduce flicker. */
    "#define EDGE_SHARPNESS     (1.0)",

    /** Step in 2-pixel intervals since we already blurred against neighbors in the
     first AO pass.  This constant can be increased while R decreases to improve
     performance at the expense of some dithering artifacts.

     Morgan found that a scale of 3 left a 1-pixel checkerboard grid that was
     unobjectionable after shading was applied but eliminated most temporal incoherence
     from using small numbers of sample taps.
     */
    "#define SCALE               (2)",

    /** Filter radius in pixels. This will be multiplied by SCALE. */
    "#define R                   (4)",


    //////////////////////////////////////////////////////////////////////////////////////////////

    /** Type of data to read from source.  This macro allows
     the same blur shader to be used on different kinds of input data. */
    "#define VALUE_TYPE        float",

    /** Swizzle to use to extract the channels of source. This macro allows
     the same blur shader to be used on different kinds of input data. */
    "#define VALUE_COMPONENTS   r",

    "#define VALUE_IS_KEY       0",

    /** Channel encoding the bilateral key value (which must not be the same as VALUE_COMPONENTS) */
    "#define KEY_COMPONENTS     gb",


    "#if __VERSION__ >= 330",
    // Gaussian coefficients
        "const float gaussian[R + 1] =",
    //    float[](0.356642, 0.239400, 0.072410, 0.009869);
    //    float[](0.398943, 0.241971, 0.053991, 0.004432, 0.000134);  // stddev = 1.0
        "float[](0.153170, 0.144893, 0.122649, 0.092902, 0.062970);  // stddev = 2.0",
    //      float[](0.111220, 0.107798, 0.098151, 0.083953, 0.067458, 0.050920, 0.036108); // stddev = 3.0
    "#endif",

    "uniform sampler2D   tDiffuse;",
    "uniform vec2 size;",
    "uniform vec2 resolution;",

    /** (1, 0) or (0, 1)*/
    "uniform vec2       axis;",
    "ivec2 axisi = ivec2(axis);",

    "#define  result         gl_FragColor.VALUE_COMPONENTS",
    "#define  keyPassThrough gl_FragColor.KEY_COMPONENTS",

    /** Returns a number on (0, 1) */
    "float unpackKey(vec2 p) {",
        "return p.x * (256.0 / 257.0) + p.y * (1.0 / 257.0);",
    "}",

    "varying vec2 vUv;",

    "void main() {",

        "#   if __VERSION__ < 330",
            "float gaussian[R + 1];",
        "#       if R == 3",
            "gaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902;  // stddev = 2.0",
        "#       elif R == 4",
        "gaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902; gaussian[4] = 0.062970;  // stddev = 2.0",
        "#       elif R == 6",
        "gaussian[0] = 0.111220; gaussian[1] = 0.107798; gaussian[2] = 0.098151; gaussian[3] = 0.083953; gaussian[4] = 0.067458; gaussian[5] = 0.050920; gaussian[6] = 0.036108;",
        "#       endif",
        "#   endif",

        "ivec2 ssC = ivec2(gl_FragCoord.xy);",
        //"vec4 temp = texelFetch(source, ssC, 0);",
        "vec4 temp = texture2D(tDiffuse, vUv);",

        "gl_FragColor.gb = temp.KEY_COMPONENTS;",
        "gl_FragColor.a = temp.a;",

        "VALUE_TYPE sum = temp.VALUE_COMPONENTS;",

        "if (temp.a == 0.0) {",
            // Sky pixel (we encoded that flag in the A component in the SAO shader)
            "result = sum;",
            "return;",
        "}",

        "float key = unpackKey(keyPassThrough);",

        // Base weight for depth falloff.  Increase this for more blurriness,
        // decrease it for better edge discrimination
        "float BASE = gaussian[0];",
        "float totalWeight = BASE;",
        "sum *= totalWeight;",

		//NOTE: The loop below is unrolled in extremely ugly way, in order to avoid a Chrome/Windows codegen
		//issue that results in linker errors when the loop is not unrolled. My best guess
		//is that it has to do with the integer precision setting of the loop variable and then
		//later using that with another expected precision.
		          /*
        "for (int r = -R; r <= R; ++r) {",
            // We already handled the zero case above.  This loop should be unrolled and the static branch optimized out,
            // so the IF statement has no runtime cost
            "if (r != 0) {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[r<0?-r:r];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
        "}",
        */
            "int r = -4; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[4];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = -3; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[3];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = -2; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[2];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r=-1; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[1];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = 1; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[1];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = 2; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[2];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = 3; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[3];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",
            "r = 4; {",
                //"temp = texelFetch(source, ssC + axis * (r * SCALE), 0);",
                "vec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;",
                "temp = texture2D(tDiffuse, ssUV);",
                "float      tapKey = unpackKey(temp.KEY_COMPONENTS);",
                "VALUE_TYPE value  = temp.VALUE_COMPONENTS;",

                // spatial domain: offset gaussian tap
                //"float weight = 0.3 + gaussian[abs(r)];",
                "float weight = 0.3 + gaussian[4];",

                // range domain (the "bilateral" weight). As depth difference increases, decrease weight.
                "float dz = tapKey - key;",
                "weight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));",

                "sum += value * weight;",
                "totalWeight += weight;",
            "}",

        "const float epsilon = 0.0001;",
        "result = sum / (totalWeight + epsilon);",

    "}"

    ].join("\n")

};;

//Shader used to convert the normals+depth texture into a smaller texture containing only depth
//Since it packs depth into RGBA8 target it also maps it to the range 0-1 then packs that float
//into an RGBA using magic.
SAOMinifyFirstShader = {

    uniforms: {
        "tDiffuse": { type: "t", value: null }, //Initial normals+depth texture

        "cameraNear":   { type: "f", value: 1 },
        "cameraInvNearFar":    { type: "f", value: 100 },

        "resolution":   { type: "v2", value: new THREE.Vector2( 1.0/512, 1.0/512) } //1/size of lower mip level
    },

    vertexShader: [

        "varying vec2 vUv;",

        "void main() {",

        "vUv = uv;",
        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform sampler2D tDiffuse;",
        "uniform vec2 resolution;",
        "uniform float cameraNear;",
        "uniform float cameraInvNearFar;",

        "varying vec2 vUv;",

        //Packs a float in the range 0-1 to an RGBA8
        "vec4 packDepth( const in float depth ) {",
            "vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;",
            "enc = fract(enc);",
            "enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);",
            "return enc;",
        "}",


        "void main() {",

        // Rotated grid subsampling to avoid XY directional bias or Z precision bias while downsampling.
        // On WebGL, the bit-and must be implemented with floating-point modulo........
        //"ivec2 ssP = ivec2(gl_FragCoord.xy);",
        //gl_FragColor = texelFetch2D(texture, clamp(ssP * 2 + ivec2(ssP.y & 1, ssP.x & 1), ivec2(0), textureSize(texture, previousMIPNumber) - ivec2(1)), previousMIPNumber);

        "vec2 ssP = vec2(gl_FragCoord.xy);",
        "ssP = ssP * 2.0 + mod(ssP, 2.0);",
        "ssP = (ssP + 0.5) * resolution * 0.5;",

//            "depth = texture2D(tDiffuse, vUv).z;",
        "float depth = texture2D(tDiffuse, ssP).z;",

        "if (depth != 0.0)",
            "depth = (depth + cameraNear) * cameraInvNearFar;",
        "gl_FragColor = packDepth(depth);",

        "}"

    ].join("\n")

};

//Shader used to generate mip levels for the depth texture (used by the SAO shader)
SAOMinifyShader = {

    uniforms: {
        "tDiffuse": { type: "t", value: null }, //Lower mip level
        "resolution":   { type: "v2", value: new THREE.Vector2( 1.0/512, 1.0/512) } //1/size of lower mip level
    },

    vertexShader: [

        //"varying vec2 vUv;",

        "void main() {",

        //"vUv = uv;",
        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform sampler2D tDiffuse;",
        "uniform vec2 resolution;",

        //"varying vec2 vUv;",

        "void main() {",

        // Rotated grid subsampling to avoid XY directional bias or Z precision bias while downsampling.
        // On WebGL, the bit-and must be implemented with floating-point modulo........
        //"ivec2 ssP = ivec2(gl_FragCoord.xy);",
        //gl_FragColor = texelFetch2D(texture, clamp(ssP * 2 + ivec2(ssP.y & 1, ssP.x & 1), ivec2(0), textureSize(texture, previousMIPNumber) - ivec2(1)), previousMIPNumber);


        "vec2 ssP = vec2(gl_FragCoord.xy);",
        "ssP = ssP * 2.0 + mod(ssP, 2.0);",
        "ssP = (ssP + 0.5) * resolution * 0.5;",
        "gl_FragColor = texture2D(tDiffuse, ssP);",

//            "gl_FragColor = texture2D(tDiffuse, vUv);",

        "}"

    ].join("\n")

};
;
FireflyPhongShader = {

        uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "bump" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "lights" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) },

				"offsetRepeatBump" : { type: "v4", value: new THREE.Vector4(0, 0, 1, 1) },
				"offsetRepeatAlpha" : { type: "v4", value: new THREE.Vector4(0, 0, 1, 1) },

				"irradianceMap": { type : "t", value: null },
                "exposureBias" : { type:"f", value: 1.0 }

			}

        ] ),

        vertexShader: [

			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;",



            "#if defined( USE_MAP ) || defined( USE_SPECULARMAP )",
                "varying vec2 vUv;",
                "uniform vec4 offsetRepeat;",
            "#endif",

            "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
                "varying vec2 vUvBump;",
                "uniform vec4 offsetRepeatBump;",
            "#endif",

            "#if defined( USE_ALPHAMAP ) || defined( USE_ALPHAMAP )",
                "varying vec2 vUvAlpha;",
                "uniform vec4 offsetRepeatAlpha;",
            "#endif",

            "#if defined( USE_ENVMAP )",
                "#if ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",
                    "uniform float refractionRatio;",
                    "uniform bool useRefract;",
                "#endif",
            "#endif",


            "#if MAX_SPOT_LIGHTS > 0",
                "varying vec3 vWorldPosition;",
            "#endif",

            "#ifdef USE_COLOR",
                "varying vec3 vColor;",
            "#endif",

//TODO: vFragDepth and depth varyings are basicallt the same ( vFragDepth = 1.0 - depth ) so they can be combined into one
			"#ifdef USE_LOGDEPTHBUF",
				"#ifdef USE_LOGDEPTHBUF_EXT",
					"varying float vFragDepth;",
				"#endif",
				"uniform float logDepthBufFC;",
			"#endif",

            "#ifdef MRT_NORMALS",
                "varying float depth;",
            "#endif",

			"void main() {",

                "#if defined( USE_MAP ) || defined( USE_SPECULARMAP )",
                    "vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",
                "#endif",

                "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
                    "vUvBump = uv * offsetRepeatBump.zw + offsetRepeatBump.xy;",
                "#endif",

                "#if defined( USE_ALPHAMAP )",
                    "vUvAlpha = uv * offsetRepeatAlpha.zw + offsetRepeatAlpha.xy;",
                "#endif",


                "#ifdef USE_COLOR",
                    "#ifdef GAMMA_INPUT",
                        "vColor = color * color;",
                    "#else",
                        "vColor = color;",
                    "#endif",
                "#endif",


                "vec3 objectNormal = normal;",

                "#ifdef FLIP_SIDED",
                    "objectNormal = -objectNormal;",
                "#endif",

                "vec3 transformedNormal = normalMatrix * objectNormal;",

				"vNormal = normalize( transformedNormal );",


                "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

                "gl_Position = projectionMatrix * mvPosition;",

				"vViewPosition = -mvPosition.xyz;",

                "#if MAX_SPOT_LIGHTS > 0",
                    "vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
                    "vWorldPosition = worldPosition.xyz;",
                "#endif",

//TODO: vFragDepth and depth varyings are basically the same ( vFragDepth = 1.0 - depth ) so they can be combined into one
				"#ifdef USE_LOGDEPTHBUF",
					"if (projectionMatrix[3][3] == 0.0) {",
						"gl_Position.z = log2(max(1.0e-6, gl_Position.w + 1.0)) * logDepthBufFC;",
						"#ifdef USE_LOGDEPTHBUF_EXT",
							"vFragDepth = 1.0 + gl_Position.w;",
						"#else",
							"gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;",
						"#endif",
					"} else {", //Ortho projection -- do we really want log here, or can we just go with linear depth?
						//"gl_Position.z = log2(max(1e-6, vViewPosition.z + 1.0)) * logDepthBufFC;",
						"#ifdef USE_LOGDEPTHBUF_EXT",
							"vFragDepth = 1.0 + vViewPosition.z;",
						"#else",
							//"gl_Position.z = (gl_Position.z - 1.0) * vViewPosition.z;",
						"#endif",
					"}",
				"#endif",

                "#ifdef MRT_NORMALS",
                    "depth = mvPosition.z;",
                "#endif",

			"}"


        ].join("\n"),

        fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",

            "#ifdef USE_COLOR",
                "varying vec3 vColor;",
            "#endif",



            "#if defined( USE_MAP ) || defined( USE_SPECULARMAP )",
                "varying vec2 vUv;",
            "#endif",

            "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",
                "varying vec2 vUvBump;",
            "#endif",

            "#if defined( USE_ALPHAMAP )",
                "varying vec2 vUvAlpha;",
            "#endif",

            "#ifdef USE_MAP",
                "uniform sampler2D map;",
            "#endif",

            // Inverse M matrix, for decoding
            "const mat3 InverseM = mat3(",
              "6.0014, -2.7008, -1.7996,",
              "-1.3320,  3.1029, -5.7721,",
              "0.3008, -1.0882,  5.6268);",

            "vec3 LogLuvDecode(in vec4 vLogLuv) {",
                "float Le = vLogLuv.b * 255.0 + vLogLuv.a;",
                "vec3 Xp_Y_XYZp;",
                "Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);",
                "Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.g;",
                "Xp_Y_XYZp.x = vLogLuv.r * Xp_Y_XYZp.z;",
                //"vec3 vRGB = Xp_Y_XYZp * InverseM;",
                "vec3 vRGB = InverseM * Xp_Y_XYZp;",
                "return max(vRGB, vec3(0.0));",
            "}",

            "#ifdef USE_ENVMAP",
                "uniform float reflectivity;",
                "uniform samplerCube envMap;",
                "uniform float flipEnvMap;",
                "uniform int combine;",

                "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

                    "uniform bool useRefract;",
                    "uniform float refractionRatio;",

                "#endif",
            "#endif",


            "uniform vec3 ambientLightColor;",

            "#if MAX_DIR_LIGHTS > 0",

                "uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
                "uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

            "#endif",

            "#if MAX_POINT_LIGHTS > 0",

                "uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",

                "uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
                "uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

            "#endif",

            "#if MAX_SPOT_LIGHTS > 0",

                "uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
                "uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
                "uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
                "uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
                "uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",

                "uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

            "#endif",

            "#ifdef USE_IRRADIANCEMAP",
                "uniform samplerCube irradianceMap;",
            "#endif",

            "#if MAX_SPOT_LIGHTS > 0",
                "varying vec3 vWorldPosition;",
            "#endif",

            "#ifdef WRAP_AROUND",
                "uniform vec3 wrapRGB;",
            "#endif",

            "varying vec3 vViewPosition;",
            "varying vec3 vNormal;",


            "#ifdef USE_BUMPMAP",

                "uniform sampler2D bumpMap;",
                "uniform float bumpScale;",

                // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen
                //	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html

                // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

                "vec2 dHdxy_fwd() {",

                    "vec2 dSTdx = dFdx( vUvBump );",
                    "vec2 dSTdy = dFdy( vUvBump );",

                    "float Hll = bumpScale * texture2D( bumpMap, vUvBump ).x;",
                    "float dBx = bumpScale * texture2D( bumpMap, vUvBump + dSTdx ).x - Hll;",
                    "float dBy = bumpScale * texture2D( bumpMap, vUvBump + dSTdy ).x - Hll;",

                    "return vec2( dBx, dBy );",

                "}",

                "vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",

                    "vec3 vSigmaX = dFdx( surf_pos );",
                    "vec3 vSigmaY = dFdy( surf_pos );",
                    "vec3 vN = surf_norm;",		// normalized

                    "vec3 R1 = cross( vSigmaY, vN );",
                    "vec3 R2 = cross( vN, vSigmaX );",

                    "float fDet = dot( vSigmaX, R1 );",

                    "vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
                    "return normalize( abs( fDet ) * surf_norm - vGrad );",

                "}",

            "#endif",


            "#ifdef USE_NORMALMAP",

                "uniform sampler2D normalMap;",
                "uniform vec2 normalScale;",

                // Per-Pixel Tangent Space Normal Mapping
                // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

                "vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",

                    "vec3 q0 = dFdx( eye_pos.xyz );",
                    "vec3 q1 = dFdy( eye_pos.xyz );",
                    "vec2 st0 = dFdx( vUvBump.st );",
                    "vec2 st1 = dFdy( vUvBump.st );",

                    "vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
                    "vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
                    "vec3 N = normalize( surf_norm );",

                    "vec3 mapN = texture2D( normalMap, vUvBump ).xyz * 2.0 - 1.0;",
                    "mapN.xy = normalScale * mapN.xy;",
                    "mat3 tsn = mat3( S, T, N );",
                    "return normalize( tsn * mapN );",

                "}",

            "#endif",


            "#ifdef USE_SPECULARMAP",
                "uniform sampler2D specularMap;",
            "#endif",

            "#ifdef USE_ALPHAMAP",
                "uniform sampler2D alphaMap;",
            "#endif",

            "#ifdef MRT_NORMALS",
                (typeof _isIE11 !== "undefined" && _isIE11) ? "" : "#extension GL_EXT_draw_buffers : require",
                "varying float depth;",
                "#define gl_FragColor gl_FragData[0]",
            "#endif",

            "#ifdef TONEMAP_OUTPUT",
                "uniform float exposureBias;",
            	TonemapShaderChunk,
            "#endif",

			"#ifdef USE_LOGDEPTHBUF",
				"uniform float logDepthBufFC;",
				"#ifdef USE_LOGDEPTHBUF_EXT",
					"#extension GL_EXT_frag_depth : enable",
					"varying float vFragDepth;",
				"#endif",
			"#endif",

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

                "#ifdef USE_MAP",
                    "vec4 texelColor = texture2D( map, vUv );",
                    "#ifdef GAMMA_INPUT",
                        "texelColor.xyz *= texelColor.xyz;",
                    "#endif",

                    "gl_FragColor = gl_FragColor * texelColor;",
                "#endif",

                "#ifdef USE_ALPHAMAP",
                    "vec4 texelAlpha = texture2D( alphaMap, vUvAlpha );",
                    "gl_FragColor.a *= texelAlpha.r;",
                "#endif",

                "#ifdef ALPHATEST",
                    "if ( gl_FragColor.a < ALPHATEST ) discard;",
                "#endif",

                "float specularStrength;",

                "#ifdef USE_SPECULARMAP",
                    "vec4 texelSpecular = texture2D( specularMap, vUv );",
                    "specularStrength = texelSpecular.r;",
                "#else",
                    "specularStrength = 1.0;",
                "#endif",


                "vec3 normal = normalize( vNormal );",
                "vec3 geomNormal = normal;",
                "vec3 viewPosition = normalize( vViewPosition );",

                "#ifdef DOUBLE_SIDED",
                    "normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
                "#endif",

                "#ifdef USE_NORMALMAP",
                    "normal = perturbNormal2Arb( -vViewPosition, normal );",
                "#elif defined( USE_BUMPMAP )",
                    "normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",
                "#endif",


                "vec3 totalDiffuse = vec3( 0.0 );",
                "vec3 totalSpecular = vec3( 0.0 );",


                "#if MAX_POINT_LIGHTS > 0",

                    "vec3 pointDiffuse  = vec3( 0.0 );",
                    "vec3 pointSpecular = vec3( 0.0 );",

                    "for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

                        "vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
                        "vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

                        "float lDistance = 1.0;",
                        "if ( pointLightDistance[ i ] > 0.0 )",
                            "lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

                        "lVector = normalize( lVector );",

                        // diffuse

                        "float dotProduct = dot( normal, lVector );",

                        "#ifdef WRAP_AROUND",

                            "float pointDiffuseWeightFull = max( dotProduct, 0.0 );",
                            "float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

                            "vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

                        "#else",

                            "float pointDiffuseWeight = max( dotProduct, 0.0 );",

                        "#endif",

                        "pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;",

                        // specular

                        "vec3 pointHalfVector = normalize( lVector + viewPosition );",
                        "float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",

                        "float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",
                        "float specularNormalization = shininess * 0.125 + 0.25;", //(shininess+2)/8
                        "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( lVector, pointHalfVector ), 0.0), 5.0 );",
                        "pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization ;",

                    "}",

                    "totalDiffuse += pointDiffuse;",
                    "totalSpecular += pointSpecular;",

                "#endif",

                "#if MAX_SPOT_LIGHTS > 0",

                    "vec3 spotDiffuse  = vec3( 0.0 );",
                    "vec3 spotSpecular = vec3( 0.0 );",

                    "for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

                        "vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
                        "vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

                        "float lDistance = 1.0;",
                        "if ( spotLightDistance[ i ] > 0.0 )",
                            "lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

                        "lVector = normalize( lVector );",

                        "float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

                        "if ( spotEffect > spotLightAngleCos[ i ] ) {",

                            "spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

                            // diffuse

                            "float dotProduct = dot( normal, lVector );",

                            "#ifdef WRAP_AROUND",

                                "float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
                                "float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

                                "vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

                            "#else",

                                "float spotDiffuseWeight = max( dotProduct, 0.0 );",

                            "#endif",

                            "spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;",

                            // specular

                            "vec3 spotHalfVector = normalize( lVector + viewPosition );",
                            "float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
                            "float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

                            "float specularNormalization = shininess * 0.125 + 0.25;", //(shininess+2)/8
                            "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( lVector, spotHalfVector ), 0.0), 5.0 );",
                            "spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;",
                        "}",

                    "}",

                    "totalDiffuse += spotDiffuse;",
                    "totalSpecular += spotSpecular;",

                "#endif",

                "#if MAX_DIR_LIGHTS > 0",

                    "vec3 dirDiffuse  = vec3( 0.0 );",
                    "vec3 dirSpecular = vec3( 0.0 );" ,

                    "for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

                        "vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
                        "vec3 dirVector = normalize( lDirection.xyz );",

                        // diffuse

                        "float dotProduct = dot( normal, dirVector );",

                        "#ifdef WRAP_AROUND",

                            "float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
                            "float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

                            "vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",

                        "#else",

                            "float dirDiffuseWeight = max( dotProduct, 0.0 );",

                        "#endif",

                        "dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;",

                        // specular

                        "vec3 dirHalfVector = normalize( dirVector + viewPosition );",
                        "float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
                        "float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

                        "float specularNormalization = shininess * 0.125 + 0.25;", //(shininess+2)/8
                        "vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( dirVector, dirHalfVector ), 0.0), 5.0 );",

                        "dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

                    "}",

                    "totalDiffuse += dirDiffuse;",
                    "totalSpecular += dirSpecular;",

                "#endif",



                "#ifdef USE_IRRADIANCEMAP",
                    "vec3 worldNormal = mat3( viewMatrixInverse[ 0 ].xyz, viewMatrixInverse[ 1 ].xyz, viewMatrixInverse[ 2 ].xyz ) * normal;",

                    "vec4 cubeColor4 = textureCube(irradianceMap, worldNormal);",

                    "#ifdef IRR_LOGLUV",
                        "vec3 indirectDiffuse = LogLuvDecode(cubeColor4);",
                    "#else",

                        "vec3 indirectDiffuse = cubeColor.xyz;",

                        "#ifdef GAMMA_INPUT",
                            "indirectDiffuse.xyz *= indirectDiffuse.xyz;",
                        "#endif",

                    "#endif",

                    "totalDiffuse += diffuse * indirectDiffuse;",
                "#endif",


                "#ifdef METAL",
                    "gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );",
                "#else",
                    "gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",
                "#endif",


                //Modulate base color with vertex color, if any
                "#ifdef USE_COLOR",
                    "gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );",
                "#endif",



                "#if defined(USE_ENVMAP)",

                    "vec3 reflectVec;",


                    "#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

                        "vec3 cameraToVertex = normalize( -vViewPosition );",

                        "if ( useRefract ) {",
                            "reflectVec = refract( cameraToVertex, normal, refractionRatio );",
                        "} else { ",
                            "reflectVec = reflect( cameraToVertex, normal );",
                        "}",

                    "#else",

                        "vec3 cameraToVertex = normalize( -vViewPosition );",

                        "reflectVec = reflect( cameraToVertex, vNormal );",

                    "#endif",

                    "reflectVec = mat3( viewMatrixInverse[ 0 ].xyz, viewMatrixInverse[ 1 ].xyz, viewMatrixInverse[ 2 ].xyz ) * reflectVec;",

                    "float logShiny = log(max(1.0+1e-10, shininess));",

                    "#ifdef ENV_LOGLUV",

                        //In the LogLuv code path, we do this:
                        //The environment cube map is blurred with the assumption that
                        //max shininess is 2048 and every mip drops that by a factor of 4
                        //NOTE that the computation is correct in case textureCubeLOD is used,
                        //but here we have to use textureCube with a bias instead, since WebGL doesn't
                        //support the -LOD variants.
                        //"float MipmapIndex = log(shininess / 2048.0) / log(0.25);",
                        //The simplification below was given in the original source for this method.
                        //However, it does not seem to match the equation above, so we use a corrected one.
                        //"float MipmapIndex = max(0.0, -1.66096404744368 * logShiny + 5.5);",
                        "float MipmapIndex = max(0.0, -0.72134752 * logShiny + 5.5);",

                        "vec4 envTexColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ), MipmapIndex );",

                        "vec3 cubeColor = LogLuvDecode(envTexColor);",

                    "#else",

                        "vec4 envTexColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

                        "vec3 cubeColor = envTexColor.xyz;",

                        "#ifdef GAMMA_INPUT",

                            "cubeColor.xyz *= cubeColor.xyz;",

                        "#endif",

                    "#endif",

                    "float facing = dot( viewPosition, normal );",

                    //If the normal of the pixel is below the horizon (e.g. due to massive bump map perturbation)
                    //Make the facing 1.0 so that the Fresnel effect is zeroed out completely.
                    "if (facing < 0.0) {",
                        "facing = 1.0;",
                    "}",

                    "vec4 speca = vec4(specular, gl_FragColor.a);",

                    "#ifdef METAL",

                        //Metals do not generally have Fresnel reflection, so for them we just relfect using the specular
                        "vec4 schlickRefl = speca;",
                        "gl_FragColor.xyz += cubeColor.xyz * specularStrength * schlickRefl.xyz;",
                        "gl_FragColor.a = speca.a;",

                    "#else",

                        "#ifdef CLEARCOAT",

                            "vec3 cubeColorClearcoat;",
                            "vec3 reflectVecClearcoat = reflect( -vViewPosition, vNormal );",
                            "reflectVecClearcoat = mat3( viewMatrixInverse[ 0 ].xyz, viewMatrixInverse[ 1 ].xyz, viewMatrixInverse[ 2 ].xyz ) * reflectVecClearcoat;",


                            "#ifdef ENV_LOGLUV",

                                "vec4 envTexColorClearcoat = textureCube( envMap, vec3( flipEnvMap * reflectVecClearcoat.x, reflectVecClearcoat.yz ));",
                                "cubeColorClearcoat = LogLuvDecode(envTexColorClearcoat);",

                            "#else",

                                "vec4 envTexColorClearcoat = textureCube( envMap, vec3( flipEnvMap * reflectVecClearcoat.x, reflectVecClearcoat.yz ) );",
                                "cubeColorClearcoat = envTexColorClearcoat.xyz;",

                                "#ifdef GAMMA_INPUT",
                                    "cubeColorClearcoat.xyz *= cubeColorClearcoat.xyz;",
                                "#endif",

                            "#endif",

                            //Add in the specular of the base paint
                            "gl_FragColor.xyz += cubeColor.xyz * specularStrength * speca.xyz;",

                            //Fresnel for the clearcoat
                            "float schlickRefl = reflectivity + ( 1.0 - reflectivity ) * pow( max(1.0 - facing, 0.0), 5.0 );",
                            //"schlickRefl *= max(0.0, 1.0 - 2.0 / logShiny);",

                            //Mix in specular of the clearcoat -- note the 0.5 factor is hardcoded
                            //from the Prism paint material.
                            "gl_FragColor.xyz = mix(gl_FragColor.xyz, cubeColorClearcoat * schlickRefl, 0.5);",

                        "#else",

                            //Nonmetals reflect using Fresnel -- so they reflect a lot at grazing angles
                            "vec4 schlickRefl = speca + ( 1.0 - speca ) * pow( max(1.0 - facing, 0.0), 5.0 );",

                            //Prevent overly bright Fresnel reflection -- this is a side effect of the illumination model
                            //We use the log of the glossiness as a proxy for material roughness, to reduce the
                            //Schlick term by some amount that increases with roughness.
                            "schlickRefl.rgb *= max(0.0, 1.0 - 2.0 / logShiny);",

                            "if ( combine == 1 ) {",

                                "gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * schlickRefl.xyz );",
                                "gl_FragColor.a = schlickRefl.a;",

                            "} else if ( combine == 2 ) {",

                                "gl_FragColor.xyz += cubeColor.xyz * specularStrength * schlickRefl.xyz;",
                                "gl_FragColor.a = schlickRefl.a;",

                            "} else {",

                                "gl_FragColor = mix( gl_FragColor, vec4(gl_FragColor.xyz * cubeColor.xyz, gl_FragColor.a), specularStrength * schlickRefl );",

                            "}",

                        "#endif",

                    "#endif",

                    //DEBUG
                    //"gl_FragColor.xyz = cubeColor.xyz;",

                "#endif",


                "#ifdef GAMMA_OUTPUT",
                    "gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",
                "#endif",

                "#ifdef TONEMAP_OUTPUT",
                	"gl_FragColor.xyz = toneMapCanonFilmic_WithGamma( exposureBias * gl_FragColor.xyz );",
               	"#endif",

				"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)",
					"gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;",
				"#endif",

                "#ifdef MRT_NORMALS",
                    //Move the normal to the range 0-1. This is expected by our SAO shader
                    "geomNormal = geomNormal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
                    //We cannot avoid blending in the depth target when blending
                    //to the color target is on, so
                    //we pack the normal and depth in the first three elements
                    //and use 0 or 1 as the alpha.
                    "gl_FragData[1] = vec4(geomNormal.x, geomNormal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);",
                "#endif",

			"}"


        ].join("\n")

};

THREE.ShaderLib['firefly_phong'] = FireflyPhongShader;;

NormalsShader = {

        uniforms: {

            //"opacity" : { type: "f", value: 1.0 }

        },

        vertexShader: [

            "varying vec3 vNormal;",
            "varying float depth;",

            "void main() {",

            "vNormal = normalize( normalMatrix * normal );",

            "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            "depth = mvPosition.z;",

            "vec4 p_Position = projectionMatrix * mvPosition;",
            "gl_Position = p_Position;",

            "}"

        ].join("\n"),

        fragmentShader: [

            "varying vec3 vNormal;",
            "varying float depth;",

            "void main() {",

            "vec3 n = vNormal;",
            //Invert normal in case of back side
            //"#ifdef DOUBLE_SIDED",
            "n = n * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
            //"#endif",

            //TODO: it's possible that we have to clamp the values
            //to range 0-1 -- check no weaker GL ES platforms.
            "n = normalize( n );",
            "gl_FragColor = vec4(n.x, n.y, depth, 1.0);",

            "}"

        ].join("\n")

};
;
BackgroundShader = {

    uniforms: {

        "color1": {type: "v4", value: new THREE.Vector4(1.0/255.0,2.0/255.0,3.0/255.0,1) },
        "color2": {type: "v4", value: new THREE.Vector4(41.0/255.0,76.0/255.0,120.0/255.0,1) },
        "luminance" : {type: "f", value: 1 },
        "linearize" : {type: "i", value: 0 }
    },

    vertexShader: [
        "uniform vec4 color1;",
        "uniform vec4 color2;",
        "uniform float luminance;",
        "uniform int linearize;",

        "varying vec4 vcolor;",
        //"varying vec2 vUv;",

        "void main() {",

        "if (uv.y == 0.0)",
            "vcolor = color1;",
        "else",
            "vcolor = color2;",
        //"vUv = uv;",

        "if (linearize != 0)",
            "vcolor *= vcolor;",

        "vcolor *= luminance;",

        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

        //Matrix for 4x4 ordered dithering. (http://en.wikipedia.org/wiki/Ordered_dithering)
        "const vec4 c0 = vec4(1.0, 13.0, 4.0, 16.0);",
        "const vec4 c1 = vec4(9.0, 5.0, 12.0, 8.0);",
        "const vec4 c2 = vec4(3.0, 15.0, 2.0, 14.0);",
        "const vec4 c3 = vec4(11.0, 7.0, 10.0, 6.0);",

        "varying vec4 vcolor;",
        //"varying vec2 vUv;",

        "void main() {",

            "vec4 c = vcolor;",

            //No integer & in WebGL, otherwise we would do &3...
            "int i = int(mod(float(gl_FragCoord.x), 4.0));",
            "int j = int(mod(float(gl_FragCoord.y), 4.0));",

            //Ideally we would index i*4+j into an array of 16 floats, but WebGL doesn't allow
            //access with non-constant index. Using a texture for a 4x4 seems like overkill.
            "vec4 col;",
            "if (i==0) col = c0; else if (i==1) col = c1; else if (i==2) col = c2; else col = c3;",
            "float bias;",
            "if (j==0) bias = col.x; else if (j==1) bias = col.y; else if (j==2) bias = col.z; else bias = col.w;",

            "c.xyz += bias * (1.0/(17.0*256.0));",
            "gl_FragColor = c;",
            //"gl_FragColor = mix(color1, color2, vUv.y);",

        "}"

    ].join("\n")

};

;/**
 * Created by stanevt on 4/26/14.
 */


LineShader = {

        uniforms: {

            "pixelsPerUnit" : { type: "f", value: 1.0 },
            "unitsPerPixel" : { type: "f", value: 1.0 },
            "tLayerMask":   { type: "t", value: null },
            "tRaster": { type: "t", value: null},
            "tSelectionTexture": { type: "t", value: null},
            "vSelTexSize" : {type: "v2", value: new THREE.Vector2(4096,1) }

            //This is handled as special case by the renderer, like all other camera matrices
            //since it's shared between material instances
            //"mvpMatrix" : {type: "m4", value: new THREE.Matrix4() }
        },

        attributes: {
            "fields1" : 0,
            "fields2" : 0,
            "color4b" : 0,
            "dbId4b" : 0,
            "flags4b" : 0,
            "extraParams": 0,
            "instFlags4b" : 0
        },

        defines : {
            //"MRT_ID_BUFFER" : "1",
            //"ID_COLOR" : "1",
            //"SELECTION_RENDERER" : 1,
            //"HAS_RASTER_QUADS": 1,
            //"HAS_ELLIPTICALS": 1
            //"HAS_CIRCLES" : 1
            //"HAS_TRIANGLE_GEOMS" : 1
        },

        vertexShader: [

            "#define TAU 6.28318530718",
            "#define PI 3.14159265358979",
            "#define HALF_PI 1.57079632679",

            "#define VBB_LINE_SEGMENT     16.0", //0x10
            "#define VBB_ARC_CIRCULAR     32.0", //0x20
            "#define VBB_ARC_ELLIPTICAL   48.0", //0x30
            "#define VBB_TEX_QUAD         64.0", //0x40
            "#define VBB_ONE_TRIANGLE     80.0", //0x50

            "#define VBB_INSTANCED_FLAG   0.0",
            "#define VBB_SEG_START_RIGHT  1.0",
            "#define VBB_SEG_START_LEFT   2.0",
            "#define VBB_SEG_END_RIGHT    3.0",
            "#define VBB_SEG_END_LEFT     4.0",

            "attribute vec3 fields1;",
            "attribute vec3 fields2;",
            "attribute vec4 color4b;",
            "attribute vec4 dbId4b;",
            "attribute vec4 flags4b;",

        "#ifdef HAS_ELLIPTICALS",
            "attribute vec3 extraParams;",
        "#endif",

            "attribute vec4 instFlags4b;",

            "uniform mat4 mvpMatrix;",

            "uniform float pixelsPerUnit;",
            "uniform float unitsPerPixel;",

            //The layer and object selection mask textures
            //can be sampled in the vertex shader since they only vary per geometry.
            //So far we have not encountered a device that fails
            //on this, but if we do, we may have to move those to the fragment shader.

            "uniform sampler2D tLayerMask;",

        "#ifdef SELECTION_RENDERER",
            "uniform sampler2D tSelectionTexture;",
            "uniform vec2 vSelTexSize;",
        "#endif",

            "varying vec4 outColor;",
            "varying vec4 dbId;",

            "varying vec2 centralVertex;",
            "varying vec2 offsetPosition;",
            "varying vec4 multipurpose;",

            "varying float halfWidth;",

            "void strokeLineSegment(float vertexId) {",

                "float distanceAlong = fields2.x;",

                "float isStartCapVertex = (vertexId < VBB_SEG_END_RIGHT) ? -1.0 : 1.0;",

                "float isLeftSide = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT) ? 1.0 : -1.0;",

                //Apply transverse line width offset
                "float angleTransverse = fields1.z + isLeftSide * HALF_PI;",
                "float st = sin(angleTransverse);",
                "float ct = cos(angleTransverse);",
                "float lwAdjustment = halfWidth + 0.5 * unitsPerPixel;",
                "vec2 transverseOffset = vec2(ct, st) * lwAdjustment;",
                "offsetPosition.xy += transverseOffset;",

                //Apply start/end-cap extension offsets if needed
                "vec2 moveOffset = isStartCapVertex * isLeftSide * vec2(-transverseOffset.y, transverseOffset.x);",
                "offsetPosition.xy -= moveOffset;",
                "centralVertex.xy -= moveOffset;",

                //Compute end point based on start point plus segment length and direction
                //This is because the line segment's 4 vertices are all equal to the start
                //point to begin with. Note for the start point, we just move by 0, to avoid doing an if().
                "float distanceFromStart = max(isStartCapVertex, 0.0) * distanceAlong;",
                "vec2 along = distanceFromStart * vec2(cos(fields1.z), sin(fields1.z));",
                "offsetPosition.xy += along;",
                "centralVertex.xy += along;",

                //Distance we care about beyond the actual line segment vertex.
                //For start vertex, this is negative and equal to half a line weight
                //For end vertex this is the segment length plus the half line weight adjustment.
                "multipurpose.x = (isStartCapVertex * lwAdjustment) + distanceFromStart;", //distance after end point that we want to fill with cap/join

                "multipurpose.y = distanceAlong;",
                "multipurpose.z = 0.0;",
            "}",


        "#ifdef HAS_TRIANGLE_GEOMS",
            "void strokeOneTriangle(float vertexId) {",

                //Mark as triangle for the fragment shader
                "halfWidth = 0.0;",

                //this is already done at the beginning of main()
                //so we skip it here
                //"offsetPosition.xy = fields1.xy;",

                "if (vertexId == VBB_SEG_END_RIGHT)",
                    "offsetPosition.xy = vec2(fields1.z, fields2.x);",
                "else if (vertexId == VBB_SEG_END_LEFT)",
                    "offsetPosition.xy = fields2.yz;",
            "}",
        "#endif",


            //The vertex format used for quads is very similar to line segments,
            //with the start point being the left middle of the quad, and the width
            //mapping to segment length and height to line weight.
        "#ifdef HAS_RASTER_QUADS",
            "void strokeTexQuad(float vertexId) {",

                "float distanceAlong = fields2.x;",

                "bool isStartCapVertex = (vertexId < VBB_SEG_END_RIGHT);",

                "float isLeftSide = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT) ? 1.0 : -1.0;",

                "float angleTransverse = fields1.z + isLeftSide * HALF_PI;",

                "multipurpose.y = distanceAlong;",

                "float st = sin(angleTransverse);",
                "float ct = cos(angleTransverse);",

                "float moveDist = halfWidth;",

                "vec2 offset = vec2(ct, st) * moveDist;",

                //Apply line width
                "offsetPosition.xy += offset;",


                //Mark as polytriangle for the fragment shader
                "multipurpose.z = 1.0;",
                "halfWidth = 0.0;",

                "if (isStartCapVertex) {",
                    "offsetPosition.xy += isLeftSide * vec2(0.0, offset.x);",

                    //Tex coords
                    "multipurpose.x = 0.0;",
                    "multipurpose.y = max(0.0, isLeftSide);",
                "}",
                "else {",
                    //Compute end point based on start point plus segment length and direction
                    //This is because the line segment's 4 vertices are all equal to the start
                    //point to begin with
                    "vec2 along = vec2(cos(fields1.z), sin(fields1.z));",
                    "offsetPosition.xy += distanceAlong * along;",
                    "centralVertex.xy += distanceAlong * along;",

                    "offsetPosition.xy += isLeftSide * vec2(0.0, -offset.x);",

                    //Tex coords
                    "multipurpose.x = 1.0;",
                    "multipurpose.y = max(0.0, isLeftSide);",
                "}",

            "}",
        "#endif", //HAS_RASTER_QUADS

        "#ifdef HAS_CIRCLES",

            "void strokeCircularArc(float vertexId) {",

                "vec2 angles = vec2(fields1.z, fields2.x);",

                "float r = fields2.z;",
                "if (r * pixelsPerUnit < 0.125)",
                   "r = 0.125 * unitsPerPixel;",

                "float isStart = (vertexId < VBB_SEG_END_RIGHT) ? -1.0 : 1.0;",
                "float isLeft = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT) ? -1.0 : 1.0;",

                //Compute a tighter bounding quad for arcs if possible,
                //to avoid massive overdraw in case of very small angular range
                "vec2 minPt;",
                "vec2 maxPt;",

                "vec2 endsX = vec2(fields1.x) + r * cos(angles);",
                "vec2 endsY = vec2(fields1.y) + r * sin(angles);",
                "minPt = maxPt = vec2(endsX.x, endsY.x);",
                "minPt = min(minPt, vec2(endsX.y, endsY.y));",
                "maxPt = max(maxPt, vec2(endsX.y, endsY.y));",

                "float start = angles.x;",
                "float end = angles.y;",

                "if (end > start) {",
                    "if (start < (0.5 * PI) && end > (0.5 * PI)) {",
                        "minPt = min(minPt, vec2(fields1.x, fields1.y + r));",
                        "maxPt = max(maxPt, vec2(fields1.x, fields1.y + r));",
                    "}",
                    "if (start < PI && end > PI) {",
                        "minPt = min(minPt, vec2(fields1.x - r, fields1.y));",
                        "maxPt = max(maxPt, vec2(fields1.x - r, fields1.y));",
                    "}",
                    "if (start < (1.5 * PI) && end > (1.5 * PI)) {",
                        "minPt = min(minPt, vec2(fields1.x, fields1.y - r));",
                        "maxPt = max(maxPt, vec2(fields1.x, fields1.y - r));",
                    "}",

                "}",
                "else {",

                    //In this case, CW arcs, we know it passes through angle 0:
                    "minPt = min(minPt, vec2(fields1.x + r, fields1.y));",
                    "maxPt = max(maxPt, vec2(fields1.x + r, fields1.y));",

                    //All other checks are also reversed
                    //TODO: verify this logic -- it might be overestimating
                    "if (start < (0.5 * PI) || end > (0.5 * PI)) {",
                        "minPt = min(minPt, vec2(fields1.x, fields1.y + r));",
                        "maxPt = max(maxPt, vec2(fields1.x, fields1.y + r));",
                    "}",
                    "if (start < PI || end > PI) {",
                        "minPt = min(minPt, vec2(fields1.x - r, fields1.y));",
                        "maxPt = max(maxPt, vec2(fields1.x - r, fields1.y));",
                    "}",
                    "if (start < (1.5 * PI) || end > (1.5 * PI)) {",
                        "minPt = min(minPt, vec2(fields1.x, fields1.y - r));",
                        "maxPt = max(maxPt, vec2(fields1.x, fields1.y - r));",
                    "}",

                "}",

                "minPt -= halfWidth + 0.5 * unitsPerPixel;",
                "maxPt += halfWidth + 0.5 * unitsPerPixel;",

                "if (isStart<0.0)",
                    "offsetPosition.x = minPt.x;",
                "else",
                    "offsetPosition.x = maxPt.x;",

                "if (isLeft<0.0)",
                    "offsetPosition.y = minPt.y;",
                "else",
                    "offsetPosition.y = maxPt.y;",

            //Whole box code path (slow, used for debugging)
            /*
                "float expandedRadius = r + halfWidth + 0.5 * unitsPerPixel;",
                "vec2 offset = vec2(expandedRadius * isStart, expandedRadius * isLeft);",
                "offsetPosition.xy += offset;",
             */
                "multipurpose.x = angles.x;",
                "multipurpose.y = -r;",
                "multipurpose.z = angles.y;",
                "multipurpose.w = -r;",
            "}",

        "#endif", //HAS_CIRCLES

        "#ifdef HAS_ELLIPTICALS",
            "void strokeEllipticalArc(float vertexId) {",

                "vec2 angles = vec2(fields1.z, fields2.x);",

                "float isStart = (vertexId < VBB_SEG_END_RIGHT) ? -1.0 : 1.0;",
                "float isLeft = (vertexId == VBB_SEG_END_LEFT || vertexId == VBB_SEG_START_LEFT) ? -1.0 : 1.0;",

                "float major = fields2.z;",
                "float minor = extraParams.x;",

                //TODO: rotation
                //"float tilt = extraParams.y;",

                //Compute a tighter bounding quad for arcs if possible,
                //to avoid massive overdraw in case of very small angular range

                "vec2 minPt;",
                "vec2 maxPt;",

                "vec2 endsX = vec2(fields1.x) + major * cos(angles);",
                "vec2 endsY = vec2(fields1.y) + minor * sin(angles);",
                "minPt = maxPt = vec2(endsX.x, endsY.x);",
                "minPt = min(minPt, vec2(endsX.y, endsY.y));",
                "maxPt = max(maxPt, vec2(endsX.y, endsY.y));",

                "float start = angles.x;",
                "float end = angles.y;",

                "if (end > start) {",
                    "if (start < (0.5 * PI) && end > (0.5 * PI)) {",
                        "minPt = min(minPt, vec2(fields1.x, fields1.y + minor));",
                        "maxPt = max(maxPt, vec2(fields1.x, fields1.y + minor));",
                    "}",
                    "if (start < PI && end > PI) {",
                        "minPt = min(minPt, vec2(fields1.x - major, fields1.y));",
                        "maxPt = max(maxPt, vec2(fields1.x - major, fields1.y));",
                    "}",
                    "if (start < (1.5 * PI) && end > (1.5 * PI)) {",
                        "minPt = min(minPt, vec2(fields1.x, fields1.y - minor));",
                        "maxPt = max(maxPt, vec2(fields1.x, fields1.y - minor));",
                    "}",

                "}",
                "else {",

                    //In this case, CW arcs, we know it passes through angle 0:
                    "minPt = min(minPt, vec2(fields1.x + major, fields1.y));",
                    "maxPt = max(maxPt, vec2(fields1.x + major, fields1.y));",

                    //All other checks are also reversed
                    //TODO: verify this logic -- it might be overestimating
                    "if (start < (0.5 * PI) || end > (0.5 * PI)) {",
                        "minPt = min(minPt, vec2(fields1.x, fields1.y + minor));",
                        "maxPt = max(maxPt, vec2(fields1.x, fields1.y + minor));",
                    "}",
                    "if (start < PI || end > PI) {",
                        "minPt = min(minPt, vec2(fields1.x - major, fields1.y));",
                        "maxPt = max(maxPt, vec2(fields1.x - major, fields1.y));",
                    "}",
                    "if (start < (1.5 * PI) || end > (1.5 * PI)) {",
                        "minPt = min(minPt, vec2(fields1.x, fields1.y - minor));",
                        "maxPt = max(maxPt, vec2(fields1.x, fields1.y - minor));",
                    "}",

                "}",

                "minPt -= halfWidth + 0.5 * unitsPerPixel;",
                "maxPt += halfWidth + 0.5 * unitsPerPixel;",

                "if (isStart < 0.0)",
                    "offsetPosition.x = minPt.x;",
                "else",
                    "offsetPosition.x = maxPt.x;",

                "if (isLeft < 0.0)",
                    "offsetPosition.y = minPt.y;",
                "else",
                    "offsetPosition.y = maxPt.y;",

                //Whole box code path (slow, used for debugging)
                //"vec2 offset = vec2((major + halfWidth + 0.5 * unitsPerPixel) * isStart, (minor + halfWidth + 0.5 * unitsPerPixel) * isLeft);",
                //"offsetPosition.xy += offset;",

                "multipurpose.x = angles.x;",
                "multipurpose.y = -major;",
                "multipurpose.z = angles.y;",
                "multipurpose.w = minor;",

            "}",
        "#endif", //HAS_ELLIPTICALS

        "#ifdef SELECTION_RENDERER",
            "bool isSelected() {",
                //This math assumes that vSelTexSize.x = 4096 (byte and a half) for easy computation.

                //Denormalize the dbId -- we use it normalized in the ID buffer so that's how it's bound
                "vec3 oid = dbId4b.rgb * 255.0;",

                //A byte and a half for the horizontal coord
                "float id01 = oid.r + oid.g * 256.0;",
                "float t = (id01 + 0.5) * (1.0 / 4096.0);",
                "float flrt = floor(t);",
                "float texU = t - flrt;",

                //A byte and a half for the vertical coord
                "float id23 = oid.b * (65536.0 / 4096.0) + flrt;",
                "t = (id23 + 0.5) / vSelTexSize.y;",
                "float texV = fract(t);",

                "vec4 selBit = texture2D(tSelectionTexture, vec2(texU, texV));",
                "return selBit.r == 1.0;",
            "}",
        "#endif", //SELECTION_RENDERER

            "bool isLayerOff() {",
                "vec4 layerBit = texture2D(tLayerMask, flags4b.ba / 255.0);",
                "return layerBit.r == 0.0;",
            "}",

            "void main() {",

                "centralVertex = offsetPosition = fields1.xy;",

                //Check layer visibility
                "if (isLayerOff()) {",
                    "outColor = vec4(0.0);",
                "}",
                "else {",

                    //Sigh... Can we get integer ops support in WebGL please?
                    "float vertexId = mod(flags4b.x, 16.0);",
                    "float geomType = flags4b.x - vertexId;",

                    //VertexId is either in the vertex itself or in the separate flags
                    //attribute in case of instancing, in which case the in-vertex value is set to 0.
                    "vertexId = max(instFlags4b.x, vertexId);",

                    "float lineWeight = fields2.y;",

                    "if (lineWeight > 0.0) {",
                        //Do not go below a line width of one pixel
                        //Since we store, half-widths, the comparison is to 0.5 instead of 1.0
                        "if (lineWeight * pixelsPerUnit < 0.5)",
                           "lineWeight = 0.5 * unitsPerPixel;",
                    "}",
                    "else {",
                        //Negative line weight means device space (pixel) width.
                        //Currently used for antialiasing of polygon outlines.
                        "lineWeight = abs(lineWeight) * unitsPerPixel;",
                    "}",

                "#ifdef SELECTION_RENDERER",
                    "if (isSelected())",
                        //Item is selected -- draw it with selection highlight color
                        "outColor = vec4(0.0,0.0,1.0,1.0);",
                    "else",
                        "outColor = vec4(0.0);",
                "#else",
                    "outColor = color4b;",
                "#endif",

                    "halfWidth = lineWeight;",
                    "dbId = dbId4b;",

                    "if (geomType == VBB_LINE_SEGMENT)",
                        "strokeLineSegment(vertexId);",
                "#ifdef HAS_CIRCLES",
                    "else if (geomType == VBB_ARC_CIRCULAR)",
                        "strokeCircularArc(vertexId);",
                "#endif",
                "#ifdef HAS_ELLIPTICALS",
                    "else if (geomType == VBB_ARC_ELLIPTICAL)",
                        "strokeEllipticalArc(vertexId);",
                "#endif",
                "#ifdef HAS_RASTER_QUADS",
                    "else if (geomType == VBB_TEX_QUAD)",
                        "strokeTexQuad(vertexId);",
                "#endif",
                "#ifdef HAS_TRIANGLE_GEOMS",
                    "else if (geomType == VBB_ONE_TRIANGLE)",
                        "strokeOneTriangle(vertexId);",
                "#endif",
                    "else {",
                        "halfWidth = 0.0;", //just plain triangles
                        "multipurpose.z = 0.0;",
                    "}",
               "}",

                //Now apply MVP matrix
                "gl_Position = mvpMatrix * vec4( offsetPosition.xy, 0.0, 1.0 );",

            "}"

        ].join("\n"),

        fragmentShader: [

            //"#extension GL_OES_standard_derivatives : enable",

            "#define TAU 6.28318530717958",
            "#define PI  3.14159265358979",

            "uniform float pixelsPerUnit;",
            "uniform float unitsPerPixel;",
            "float aaRange = 0.5 * unitsPerPixel;",

        "#ifdef HAS_RASTER_QUADS",
            "uniform sampler2D tRaster;",
        "#endif",

            "varying vec4 outColor;",
            "varying vec4 dbId;",

        "#ifdef MRT_ID_BUFFER",
            "#extension GL_EXT_draw_buffers : enable",
        	"#define gl_FragColor gl_FragData[0]",
        "#endif",

            "varying vec2 centralVertex;",
            "varying vec2 offsetPosition;",

            "varying vec4 multipurpose;",


            "varying float halfWidth;",


            //Gaussian falloff function
            "float curveGaussian(float r, float invWidth) {",
                "float amt = clamp(r * invWidth, 0.0, 1.0);",

                "float exponent = amt * 3.5;",

                "return exp(-exponent*exponent);",

            //Below is the full original from AutoCAD:
            /*
                "float amt = clamp(abs(r / (width * 1.0)), 0.0, 1.0);",
                "amt = max(amt - 0.0, 0.0);",

                "float exponent = amt * 3.5;",

                "return clamp(exp(-exponent*exponent), 0.0, 1.0);",
                */
            "}",



            "void fillLineSegment() {",

                "float radius = halfWidth;",
                "float parametricDistance = multipurpose.x;",
                "float segmentLength = multipurpose.y;",

                //Check for end cap or join region -- here we reduce
                ///allowed distance from centerline in a circular way
                //to get a round cap/join
                /*
                "if (parametricDistance < 0.0) {",
                     "radius = sqrt(max(0.0, radius * radius - parametricDistance * parametricDistance));",
                "} else if (parametricDistance >= segmentLength) {",
                    "float d = parametricDistance - segmentLength;",
                     "radius = sqrt(max(0.0, radius * radius - d * d));",
                "}",
                */
                //Branchless version of the above ifs (because who doesn't like to do boolean logic with float ops?):
                "float ltz = max(0.0, sign(parametricDistance));",
                "float gtsl = max(0.0, sign(parametricDistance - segmentLength));",
                "float d = (1.0 - ltz + gtsl) * (parametricDistance - ltz * segmentLength);",
                "radius = sqrt(max(0.0, radius * radius - d * d));",

                "float dist = distance(centralVertex, offsetPosition);",
                "float range =  dist - radius;",

                //pixel is too far out of the line center
                //so discard it
                "if (range > aaRange) {",
                    "discard;",
                "}",
                //Non-branching discard (by setting alpha to zero if pixel is outside the line)
                //But can only be used if we don't care about z-writes.
                //"float makeTransparent = 1.0 - max(0.0, sign(range - aaRange));",
                //gl_FragColor.a *= makeTransparent;

                //The geometry covers this pixel -- do AA.
                "gl_FragColor = outColor;",
                "gl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);",
            "}",

        "#ifdef HAS_CIRCLES",
            "void fillCircularArc() {",

                "float dist = distance(centralVertex, offsetPosition);",
                "float radius = abs(multipurpose.y);",
                "float range =  abs(dist - radius);",
                "range -= halfWidth;",

                //pixel is too far out of the line center
                //so discard it
                "if (range > aaRange) {",
                    "discard;",
                "}",

                "vec2 angles = multipurpose.xz;", /* (start, end) angles */

                "vec2 direction = offsetPosition - centralVertex;",
                "float angle = atan(direction.y, direction.x);",

                //Handle clockwise arcs, which happpen when the arc
                //crosses the X axis -- convert to CCW arc starting
                //at negative angle instead.
                "if (angles.x > angles.y)",
                    "angles.x -= TAU;",
                "else if (angle < 0.0)",
                    "angle += TAU;",

                //Are we in the exact range of the arc?
                "if (angle > angles.x && angle < angles.y) {",
                    "gl_FragColor = outColor;",
                    "gl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);",
                "}",

                "else {",
                    "discard;",
                "}",

            "}",
        "#endif",


/*
            "float DistancePointEllipseApprox(vec2 e, vec2 pos) { ",

                //Get position derivatives
                "vec2 dx = dFdx(pos);",
                "vec2 dy = dFdy(pos);",

                //Preparatory calculations for the ellipse equation
                "vec2 esqr = e * e;",
                "vec2 possqr = pos * pos;",
                "vec2 posDivEsqr = pos / esqr;",
                "vec2 pos2DivE2 = pos * posDivEsqr;",

                //Ellipse function derivative with chain rule
                "vec2 dPos = 2.0 * posDivEsqr;",
                "vec2 dPosx = dPos * dx;",
                "vec2 dPosy = dPos * dy;",
                "vec2 dfdxy = vec2(dPosx.x + dPosx.y, dPosy.x + dPosy.y);",

                // Approximate signed distance from curve with f(u,v) / |gradient(f(u,v))|
                "float sd = (pos2DivE2.x + pos2DivE2.y - 1.0) / length(dfdxy);",

                "return abs(sd) * unitsPerPixel * 0.745;",
            "}",
*/


//============================================================================
// Iterative distance to ellipse from Geometric Tools by Eberly
// See Page 11 of the document:
// http://www.geometrictools.com/Documentation/DistancePointEllipseEllipsoid.pdf

        "#ifdef HAS_ELLIPTICALS",
            //----------------------------------------------------------------------------
            // The ellipse is (x0/e0)^2 + (x1/e1)^2 = 1 with e0 >= e1. The query point is
            // (y0,y1) with y0 >= 0 and y1 >= 0. The function returns the distance from
            // the query point to the ellipse. It also computes the ellipse point (x0,x1)
            // in the first quadrant that is closest to (y0,y1).
            //----------------------------------------------------------------------------
            "float DistancePointEllipseSpecial (vec2 e, vec2 y, out vec2 x, float width, float aaRange) {",
                "float dist;",

                // Bisect to compute the root of F(t) for t >= -e1*e1.
                "vec2 esqr = e * e;",
                "vec2 ey = e * y;",
                "float t0 = -esqr[1] + ey[1];",
                "float t1 = -esqr[1] + length(ey);",
                "float t;",
                "vec2 r;",

                //Do a few initial iterations without loop break checks
                //to get approximately close to the result
                "for (int i = 0; i < 6; ++i) {",
                    "t = mix(t0, t1, 0.5);//0.5*(t0 + t1);",
                    "r = ey / (vec2(t) + esqr);",

                    "vec2 rsq = r * r;",
                    "float f = rsq[0] + rsq[1] - 1.0;",

                    "float fsign = sign(f);",
                    "t0 = mix(t0, t, max(0.0, fsign));",
                    "t1 = mix(t1, t, max(0.0, -fsign));",
                "}",

                "x = e * r;",
                "dist = distance(x, y);",

                //Early out -- point is going to be too far to matter for the ellipse outline
                "if (dist > max(2.0 * (width + aaRange), e[0] * 0.05))",
                    "return dist;",

                //Do a few more iterations to get really close to the result...
                "for (int i = 0; i < 6; ++i) {",
                    "t = mix(t0, t1, 0.5);//0.5*(t0 + t1);",
                    "r = ey / (vec2(t) + esqr);",

                    "vec2 rsq = r * r;",
                    "float f = rsq[0] + rsq[1] - 1.0;",

                    "float fsign = sign(f);",
                    "t0 = mix(t0, t, max(0.0, fsign));",
                    "t1 = mix(t1, t, max(0.0, -fsign));",
                "}",

                "x = e * r;",
                "dist = distance(x, y);",

                //Early out -- point is too far to matter for the ellipse outline
                //The bigger the eccentricity, the worse the estimate, so increse
                //the tolerance based on that.
                "float ecc = 1.0 +  0.1 * e[0] / e[1];",

                "if (dist > max(ecc * (width + aaRange), e[0] * 0.001))",
                    "return dist;",
                "if (dist < (width - aaRange) / ecc)",
                    "return dist;",


                //Finally get an almost exact answer since
                //we are near the line width boundary
                "for (int i = 0; i < 10; ++i) {",
                    "t = mix(t0, t1, 0.5);//0.5*(t0 + t1);",
                    "r = ey / (vec2(t) + esqr);",

                    "vec2 rsq = r * r;",
                    "float f = rsq[0] + rsq[1] - 1.0;",

                    "float fsign = sign(f);",
                    "t0 = mix(t0, t, max(0.0, fsign));",
                    "t1 = mix(t1, t, max(0.0, -fsign));",
                "}",

                "x = e * r;", //nearest point on ellipse
                "dist = distance(x, y);",

                "return dist;",
            "}",

            //----------------------------------------------------------------------------
            // The ellipse is (x0/e0)^2 + (x1/e1)^2 = 1. The query point is (y0,y1).
            // The function returns the distance from the query point to the ellipse.
            // It also computes the ellipse point (x0,x1) that is closest to (y0,y1).
            //----------------------------------------------------------------------------
            "float DistancePointEllipse(vec2 e, vec2 y, out vec2 locX, float width, float aaRange) {",
                "vec2 locE, locY;",
/*
                "locE = e; locY = y;",
                "if (e[0] < e[1]) {",
                    // Determine the axis order for decreasing extents
                    "locE.xy = locE.yx;",
                    "locY.xy = locY.yx;",
                "}",
*/

                //This will not works if e[0] == e[1], but that would be a circle
                //and should not be going thru this code path.
                "float diff = sign(e[0] - e[1]);",
                "vec2 swizzle = vec2(max(diff, 0.0), -min(diff, 0.0));",
                "locE.x = dot(e, swizzle.xy);",
                "locE.y = dot(e, swizzle.yx);",
                "locY.x = dot(y, swizzle.xy);",
                "locY.y = dot(y, swizzle.yx);",

                // Determine reflections for y to the first quadrant.
                "vec2 refl = sign(locY);",
                "locY *= refl;",

                "vec2 x;",
                "float distance = DistancePointEllipseSpecial(locE, locY, x, width, aaRange);",

                "x *= refl;",
/*
                "if (e[0] < e[1]) {",
                    "x.xy = x.yx;",
                "}",
                 "locX = x;",
*/
                "locX.x = dot(x, swizzle.xy);",
                "locX.y = dot(x, swizzle.yx);",

                "return distance;",
            "}",

//============================================================================




            "void fillEllipticalArc() {",
                "vec2 radii = abs(multipurpose.yw);",
                "vec2 dir = offsetPosition - centralVertex;",

                //TODO: Handle arc rotation
/*
                //Quick cull of the inside circle
                "float lenDirSq = dot(dir, dir);",
                "float minRad = min(radii.x, radii.y) - (halfWidth + aaRange);",
                "if (lenDirSq < minRad * minRad)",
                    "discard;",
*/
                //"float range = DistancePointEllipseApprox(radii, dir);",
                "vec2 pos;",
                "float range = DistancePointEllipse(radii, dir, pos, halfWidth, aaRange);",
                "range -= halfWidth;",

                "if (range > aaRange)",
                    "discard;",

                "float ar = radii[0] / radii[1];", //TODO: can be done in the vertex shader or otherwise precomputed
                "vec2 angles = multipurpose.xz;", // (start, end) angles

                //Get the parametric angle at the ellipse intersection point
                // -- note that for ellipses this is not just atan of the direction,
                //and needs to be scaled by aspect ratio.
                "float angle = atan(ar * pos.y, pos.x);",

                //Handle clockwise arcs, which happpen when the arc
                //crosses the X axis -- convert to CCW arc starting
                //at negative angle instead.
                "if (angles.x > angles.y)",
                    "angles.x -= TAU;",
                "else if (angle < 0.0)",
                    "angle += TAU;",

                //Are we in the exact range of the arc?
                "if (angle > angles.x && angle < angles.y) {",
                    "gl_FragColor = outColor;",
                    "gl_FragColor.a *= curveGaussian(range+aaRange, pixelsPerUnit);",
                "}",
                "else {",
                    "discard;",
                "}",
            "}",
        "#endif", //HAS_ELLIPTICALS


            "void main() {",

                //Is visibility off?
                "if (outColor.a == 0.0) {",
                    "discard;",
                "}",

                //Filled triangle, not a line, no need for extra math
                "if (halfWidth == 0.0) {",
            "#ifdef HAS_RASTER_QUADS",
                    "if (multipurpose.z != 0.0)",
                        "gl_FragColor = texture2D(tRaster, multipurpose.xy);",
                    "else",
            "#endif",
                        "gl_FragColor = outColor;",
                "}",
                "else if (multipurpose.y < 0.0) {",
                    "#ifdef HAS_CIRCLES",
                    "#ifdef HAS_ELLIPTICALS",
                        "if (multipurpose.y == multipurpose.w)",
                    "#endif",
                            "fillCircularArc();",
                    "#endif",
                    "#ifdef HAS_ELLIPTICALS",
                     "#ifdef HAS_CIRCLES",
                        "else",
                     "#endif",
                            "fillEllipticalArc();",
                    "#endif",
                "}",
                "else",
                    "fillLineSegment();",

            "#ifdef MRT_ID_BUFFER",
                //When using MRT, we have to set the alpha channel to 1
                //in order to override alpha blending (which cannot be individually controlled per target
                //and we need it for the color target)
                "gl_FragData[1] = vec4(dbId.rgb, 1.0);",
            "#elif defined(ID_COLOR)",
                //here we assume that in case we are only rendering
                //to an ID target, blending is off, so we can use
                //the alpha channel as well (which is usually 0 for IDs and will cause the pixels to be discarded).
                "gl_FragColor = vec4(dbId.rgba);",
            "#endif",

            "}"

        ].join("\n")

};
;//Based on THREE.WebGLProgram, with some defines added / removed.
FireflyWebGLProgram = ( function () {

	var programIdCount = 0;

	var generateDefines = function ( defines ) {

		var value, chunk, chunks = [];

		for ( var d in defines ) {

			value = defines[ d ];
			if ( value === false ) continue;

			chunk = "#define " + d + " " + value;
			chunks.push( chunk );

		}

		return chunks.join( "\n" );

	};

	var cacheUniformLocations = function ( gl, program, identifiers ) {

		var uniforms = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			uniforms[ id ] = gl.getUniformLocation( program, id );

		}

		return uniforms;

	};

	var cacheAttributeLocations = function ( gl, program, identifiers ) {

		var attributes = {};

		for ( var i = 0, l = identifiers.length; i < l; i ++ ) {

			var id = identifiers[ i ];
			attributes[ id ] = gl.getAttribLocation( program, id );

		}

		return attributes;

	};

	return function ( renderer, code, material, parameters ) {

		var _this = renderer;
		var _gl = _this.context;

		var defines = material.defines;
		var uniforms = material.__webglShader.uniforms;
		var attributes = material.attributes;

		var vertexShader = material.__webglShader.vertexShader;
		var fragmentShader = material.__webglShader.fragmentShader;

		var index0AttributeName = material.index0AttributeName;

		if ( index0AttributeName === undefined && parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0

			index0AttributeName = 'position';

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		// console.log( "building new program " );

		//

		var customDefines = generateDefines( defines );

		//

		var program = _gl.createProgram();

		var prefix_vertex, prefix_fragment;

		if ( material instanceof THREE.RawShaderMaterial ) {

			prefix_vertex = '';
			prefix_fragment = '';

		} else {

			prefix_vertex = [

				"precision " + parameters.precision + " float;",
				"precision " + parameters.precision + " int;",

				customDefines,

				parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

				parameters.mrtNormals ? "#define MRT_NORMALS" : "", //FY

				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

				"#define MAX_SHADOWS " + parameters.maxShadows,

				"#define MAX_BONES " + parameters.maxBones,

				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.irradianceMap ? "#define USE_IRRADIANCEMAP" : "", //FY
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",

				parameters.skinning ? "#define USE_SKINNING" : "",
				parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",

				parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
				parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",

				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

				parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

				parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
				parameters.useFragDepthExt ? "#define USE_LOGDEPTHBUF_EXT" : "",


				"uniform mat4 modelMatrix;",
				"uniform mat4 modelViewMatrix;",
				"uniform mat4 projectionMatrix;",
				"uniform mat4 viewMatrix;",
				"uniform mat3 normalMatrix;",
				"uniform vec3 cameraPosition;",

				"attribute vec3 position;",
				"attribute vec3 normal;",
				"attribute vec2 uv;",
				"attribute vec2 uv2;",

				"#ifdef USE_COLOR",

				"	attribute vec3 color;",

				"#endif",

				""

			].join( '\n' );

			prefix_fragment = [

				"precision " + parameters.precision + " float;",
				"precision " + parameters.precision + " int;",

				( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",

				customDefines,

				"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
				"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
				"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
				"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

				"#define MAX_SHADOWS " + parameters.maxShadows,

				parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

				_this.gammaInput ? "#define GAMMA_INPUT" : "",
				_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

				parameters.mrtNormals ? "#define MRT_NORMALS" : "", //FY
				parameters.tonemapOutput ? "#define TONEMAP_OUTPUT" : "",

				( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
				( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

				parameters.map ? "#define USE_MAP" : "",
				parameters.envMap ? "#define USE_ENVMAP" : "",
				parameters.irradianceMap ? "#define USE_IRRADIANCEMAP" : "", //FY
				parameters.envLogLuv ? "#define ENV_LOGLUV": "", //FY
				parameters.irrLogLuv ? "#define IRR_LOGLUV": "", //FY
				parameters.lightMap ? "#define USE_LIGHTMAP" : "",
				parameters.bumpMap ? "#define USE_BUMPMAP" : "",
				parameters.normalMap ? "#define USE_NORMALMAP" : "",
				parameters.specularMap ? "#define USE_SPECULARMAP" : "",
				parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
				parameters.vertexColors ? "#define USE_COLOR" : "",

				parameters.metal ? "#define METAL" : "",
				parameters.clearcoat ? "#define CLEARCOAT": "",
				parameters.wrapAround ? "#define WRAP_AROUND" : "",
				parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
				parameters.flipSided ? "#define FLIP_SIDED" : "",

				parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
				parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
				parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
				parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

				parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
				parameters.useFragDepthExt ? "#define USE_LOGDEPTHBUF_EXT" : "",

				"uniform mat4 viewMatrix;",
				"uniform vec3 cameraPosition;",

	            "#ifdef USE_ENVMAP",

                	"uniform mat4 viewMatrixInverse;",

            	"#endif",

				""

			].join( '\n' );

		}

		var glVertexShader = new THREE.WebGLShader( _gl, _gl.VERTEX_SHADER, prefix_vertex + vertexShader );
		var glFragmentShader = new THREE.WebGLShader( _gl, _gl.FRAGMENT_SHADER, prefix_fragment + fragmentShader );

		_gl.attachShader( program, glVertexShader );
		_gl.attachShader( program, glFragmentShader );

		if ( index0AttributeName !== undefined ) {

			// Force a particular attribute to index 0.
			// because potentially expensive emulation is done by browser if attribute 0 is disabled.
			// And, color, for example is often automatically bound to index 0 so disabling it

			_gl.bindAttribLocation( program, 0, index0AttributeName );

		}

		_gl.linkProgram( program );

		if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

			console.error( 'THREE.WebGLProgram: Could not initialise shader.' );
			console.error( 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );
			console.error( 'gl.getError()', _gl.getError() );

		}

		if ( _gl.getProgramInfoLog( program ) !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', _gl.getProgramInfoLog( program ) );

		}

		// clean up

		_gl.deleteShader( glVertexShader );
		_gl.deleteShader( glFragmentShader );

		// cache uniform locations

		var identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
			'viewMatrixInverse', 'mvpMatrix' //FY

		];

		if ( parameters.logarithmicDepthBuffer ) {

			identifiers.push('logDepthBufFC');

		}


		for ( var u in uniforms ) {

			identifiers.push( u );

		}

		this.uniforms = cacheUniformLocations( _gl, program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"lineDistance"

		];

		for ( var a in attributes ) {

			identifiers.push( a );

		}

		this.attributes = cacheAttributeLocations( _gl, program, identifiers );

		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	};

} )();
;/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 *
 * @author stanevt -- Modified for Autodesk LMV web viewer
 */

FireflyWebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),

	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : true, //change it to true for the screen capture api
	_logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false,


	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	var opaqueObjects = [];
	var transparentObjects = [];


	// public properties

	this.domElement = _canvas;
	this.context = null;
	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				? parameters.devicePixelRatio
				: self.devicePixelRatio !== undefined
					? self.devicePixelRatio
					: 1;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// physically based shading

	this.gammaInput = false;
	this.gammaOutput = false;

	// shadow map

	this.shadowMapEnabled = false;
	this.shadowMapAutoUpdate = true;
	this.shadowMapType = THREE.PCFShadowMap;
	this.shadowMapCullFace = THREE.CullFaceFront;
	this.shadowMapDebug = false;
	this.shadowMapCascade = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// custom render plugins

	this.renderPluginsPre = [];
	this.renderPluginsPost = [];

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		}

	};

	// internal properties

	var _this = this,

	_programs = [],

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = -1,
	_currentCamera = null,
	_currentGeometryGroupHash = null,
	_currentCamera = null,
	_geometryGroupCounter = 0,

	_usedTextureUnits = 0,

	// GL state cache

	_oldDoubleSided = -1,
	_oldFlipSided = -1,

	_oldBlending = -1,

	_oldBlendEquation = -1,
	_oldBlendSrc = -1,
	_oldBlendDst = -1,

	_oldDepthTest = -1,
	_oldDepthWrite = -1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	_newAttributes = new Uint8Array( 16 ),
	_enabledAttributes = new Uint8Array( 16 ),

    _dynamicBuffers = {}, //gl buffers used for streaming draw

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_viewInverseEnv = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors: [], positions: [] },
		point: { length: 0, colors: [], positions: [], distances: [] },
		spot: { length: 0, colors: [], positions: [], distances: [], directions: [], anglesCos: [], exponents: [] },
		hemi: { length: 0, skyColors: [], groundColors: [], positions: [] }

	};

	// initialize

	var _gl;

	var _glExtensionTextureFloat;
    var _glExtensionTextureHalfFloat;
	var _glExtensionTextureFloatLinear;
	var _glExtensionStandardDerivatives;
	var _glExtensionTextureFilterAnisotropic;
	var _glExtensionCompressedTextureS3TC;
	var _glExtensionElementIndexUint;
	var _glExtensionFragDepth;

    var _glExtensionDrawBuffers;
    var _glExtensionInstancedArrays;
    var _drawBuffersWorks = false;

	initGL();

	setDefaultGLState();

	this.context = _gl;

	// GPU capabilities

	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

	var _supportsVertexTextures = ( _maxVertexTextures > 0 );
	var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;

	var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];

	//

	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

	// clamp precision to maximum available

	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

	if ( _precision === "highp" && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precision = "mediump";
			console.warn( "WebGLRenderer: highp not supported, using mediump" );

		} else {

			_precision = "lowp";
			console.warn( "WebGLRenderer: highp and mediump not supported, using lowp" );

		}

	}

	if ( _precision === "mediump" && ! mediumpAvailable ) {

		_precision = "lowp";
		console.warn( "WebGLRenderer: mediump not supported, using lowp" );

	}

	// API

	this.getContext = function () {

		return _gl;

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.supportsFloatTextures = function () {

		return _glExtensionTextureFloat;

	};

	this.supportsStandardDerivatives = function () {

		return _glExtensionStandardDerivatives;

	};

	this.supportsCompressedTextureS3TC = function () {

		return _glExtensionCompressedTextureS3TC;

	};

    this.supportsMRT = function() {
        return _drawBuffersWorks;
    }

	this.getMaxAnisotropy  = function () {

		return _maxAnisotropy;

	};

	this.getPrecision = function () {

		return _precision;

	};

	this.setSize = function ( width, height, updateStyle ) {

		_canvas.width = width * this.devicePixelRatio;
		_canvas.height = height * this.devicePixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

    this.setViewport = function ( x, y, width, height ) {

        _viewportX = x * this.devicePixelRatio;
        _viewportY = y * this.devicePixelRatio;

        _viewportWidth = width * this.devicePixelRatio;
        _viewportHeight = height * this.devicePixelRatio;

        _gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

    };

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor( x, y, width, height );

	};

	this.enableScissorTest = function ( enable ) {

		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

	};

	// Clearing

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.setClearColorHex = function ( hex, alpha ) {

		console.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getClearColor = function () {

		return _clearColor;

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Plugins

	this.addPostPlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPost.push( plugin );

	};

	this.addPrePlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPre.push( plugin );

	};

	// Rendering

	this.updateShadowMap = function ( scene, camera ) {

		_currentProgram = null;
		_oldBlending = -1;
		_oldDepthTest = -1;
		_oldDepthWrite = -1;
		_currentGeometryGroupHash = -1;
		_currentMaterialId = -1;
		_lightsNeedUpdate = true;
		_oldDoubleSided = -1;
		_oldFlipSided = -1;

		initObjects( scene );

		this.shadowMapPlugin.update( scene, camera );

	};

	// Internal functions

	// Buffer allocation

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		_this.info.memory.geometries ++;

	};

	// Events

	var onGeometryDispose = function ( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

	};

	var onTextureDispose = function ( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_this.info.memory.textures --;


	};

	var onRenderTargetDispose = function ( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_this.info.memory.textures --;

	};

	var onMaterialDispose = function ( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	};

	// Buffer deallocation

	var deleteBuffers = function ( geometry ) {

		if ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );
		if ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );
		if ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );
		if ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );
		if ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );
		if ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );

		if ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );
		if ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );

		if ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );
		if ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );

		if ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );
		// custom attributes

		if ( geometry.__webglCustomAttributesList !== undefined ) {

			for ( var id in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );

			}

		}

		_this.info.memory.geometries --;

	};

	var deallocateGeometry = function ( geometry ) {

		geometry.__webglInit = undefined;

		if ( geometry instanceof THREE.BufferGeometry ) {

            if (geometry.vbbuffer !== undefined)
                _gl.deleteBuffer(geometry.vbbuffer);

			var attributes = geometry.attributes;

			for ( var key in attributes ) {

				if ( attributes[ key ].buffer !== undefined ) {

					_gl.deleteBuffer( attributes[ key ].buffer );
		
				}

			}

			_this.info.memory.geometries --;

		} else {

			if ( geometry.geometryGroups !== undefined ) {

				for ( var i = 0,l = geometry.geometryGroupsList.length; i<l;i++ ) {

					var geometryGroup = geometry.geometryGroupsList[ i ];

					if (geometryGroup.numMorphTargets !== undefined) {

						for (var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m++) {

							_gl.deleteBuffer(geometryGroup.__webglMorphTargetsBuffers[ m ]);

						}

					}

					if (geometryGroup.numMorphNormals !== undefined) {

						for (var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m++) {

							_gl.deleteBuffer(geometryGroup.__webglMorphNormalsBuffers[ m ]);

						}

					}

					deleteBuffers(geometryGroup);

				}

			} else {

				deleteBuffers( geometry );

			}

		}

	};

	var deallocateTexture = function ( texture ) {

		if ( texture.image && texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

		} else {

			// 2D texture

			if ( ! texture.__webglInit ) return;

			texture.__webglInit = false;
			_gl.deleteTexture( texture.__webglTexture );

		}

	};

	var deallocateRenderTarget = function ( renderTarget ) {

		if ( !renderTarget || ! renderTarget.__webglTexture ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

        _gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
        _gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

	};

	var deallocateMaterial = function ( material ) {

		var program = material.program.program;

		if ( program === undefined ) return;

		material.program = undefined;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il, programInfo;
		var deleteProgram = false;

		for ( i = 0, il = _programs.length; i < il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.program === program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes === 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram === true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program !== program ) {

					newPrograms.push( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			_this.info.memory.programs --;

		}

	};

	// Buffer initialization

	function initCustomAttributes ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		var material = object.material;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				var attribute = material.attributes[ a ];

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if ( attribute.type === "v2" ) size = 2;
					else if ( attribute.type === "v3" ) size = 3;
					else if ( attribute.type === "v4" ) size = 4;
					else if ( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	};

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,

			nvertices = faces3.length * 3,
			ntris     = faces3.length * 1,
			nlines    = faces3.length * 3,

			material = getBufferMaterial( object, geometryGroup ),

			uvType = bufferGuessUVType( material ),
			normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material );

		// console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );

		if ( normalType ) {

			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( vertexColorType ) {

			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );

		}

		if ( uvType ) {

			if ( geometry.faceVertexUvs.length > 0 ) {

				geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			}

			if ( geometry.faceVertexUvs.length > 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		var UintArray = _glExtensionElementIndexUint !== null && ntris > 21845 ? Uint32Array : Uint16Array; // 65535 / 3

		geometryGroup.__typeArray = UintArray;
		geometryGroup.__faceArray = new UintArray( ntris * 3 );
		geometryGroup.__lineArray = new UintArray( nlines * 2 );

		var m, ml;

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ a ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if( attribute.type === "v2" ) size = 2;
					else if( attribute.type === "v3" ) size = 3;
					else if( attribute.type === "v4" ) size = 4;
					else if( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	};

	function getBufferMaterial( object, geometryGroup ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ geometryGroup.materialIndex ]
			: object.material;

	};

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	};

	function bufferGuessNormalType ( material ) {

		// only MeshBasicMaterial and MeshDepthMaterial don't need normals

		if ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {

			return false;

		}

		if ( materialNeedsSmoothNormals( material ) ) {

			return THREE.SmoothShading;

		} else {

			return THREE.FlatShading;

		}

	};

	function bufferGuessVertexColorType( material ) {

		if ( material.vertexColors ) {

			return material.vertexColors;

		}

		return false;

	};

	function bufferGuessUVType( material ) {

		// material must use some texture to require uvs

		if ( material.map ||
		     material.lightMap ||
		     material.bumpMap ||
		     material.normalMap ||
		     material.specularMap ||
             material.alphaMap ||
		     material instanceof THREE.ShaderMaterial ) {

			return true;

		}

		return false;

	};

	//

	function initDirectBuffers( geometry ) {

        //Geometries that will draw directly
        //from system memory skip alocations of
        //GPU side GL buffers.
        if (geometry.streamingDraw) {

            //Do we want just the index buffer on the GPU?
            if (!geometry.streamingIndex) {
                var index = geometry.attributes['index'];
                if (index) {
                    index.buffer = _gl.createBuffer();
                    _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );
                    _gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, index.array, _gl.STATIC_DRAW );
                }
            }

            return;
        }


        //Does the geometry have an interleaved
        //vertex buffer?
        if (geometry.vb) {

            geometry.vbbuffer = _gl.createBuffer();

            _gl.bindBuffer(_gl.ARRAY_BUFFER, geometry.vbbuffer);
            _gl.bufferData(_gl.ARRAY_BUFFER, geometry.vb, _gl.STATIC_DRAW);
        }

		var a, attribute, type;

		for ( a in geometry.attributes ) {

			attribute = geometry.attributes[ a ];

            //If the attribute is in interleaved VB, it will not have an array
            //and we skip it here.
            if (attribute.array) {

                if ( a === "index" ) {

                    type = _gl.ELEMENT_ARRAY_BUFFER;

                } else {

                    type = _gl.ARRAY_BUFFER;

                }

                attribute.buffer = _gl.createBuffer();

                _gl.bindBuffer( type, attribute.buffer );
                _gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );

            }

		}

	};

	// Buffer setting


	function setLineBuffers ( geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d < dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
					   customAttribute.boundTo === "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	};

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var normalType = bufferGuessNormalType( material ),
		vertexColorType = bufferGuessVertexColorType( material ),
		uvType = bufferGuessUVType( material ),

		needsSmoothNormals = ( normalType === THREE.SmoothShading );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3, c4,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ],

		obj_colors = geometry.colors;

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}


		if ( dirtyColors && vertexColorType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals && normalType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				faceArray[ offset_face ] 	 = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === "c" ) {

						pp = [ "r", "g", "b" ];

					} else {

						pp = [ "x", "y", "z" ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	};



	function setDirectBuffers ( geometry, hint, dispose ) {

        if (geometry.streamingDraw)
            return;

		var attributes = geometry.attributes;
        var vbNeedsUpdate = false;

		var attributeName, attributeItem;

		for ( attributeName in attributes ) {

			attributeItem = attributes[ attributeName ];

			if ( attributeItem.needsUpdate ) {

				if ( attributeName === 'index' ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer );
					_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint );

				} else {

                    if (attributeItem.array) {
                        _gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
                        _gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, hint );
                    }
                    else {
                        vbNeedsUpdate = true; //The interleaved array needs to be updated
                    }
				}

				attributeItem.needsUpdate = false;

			}

		}

        //Update the common interleaved vb if needed
        if (vbNeedsUpdate) {

            _gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.vbbuffer);
            _gl.bufferData( _gl.ARRAY_BUFFER, geometry.vb, hint);

        }

	};

	// Buffer rendering

    function setupVertexAttributes( material, programAttributes, geometry, startIndex) {

        var attributeItem, attributePointer, attributeName;
        var hasNonInterleaved = false;

        if (geometry.vb) {
            if (geometry.streamingDraw) {
                var buffer = _dynamicBuffers['interleavedVB'];
                if (!buffer) {
                    buffer = _gl.createBuffer();
                    _dynamicBuffers['interleavedVB'] = buffer;
                }

                _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer);
                _gl.bufferData( _gl.ARRAY_BUFFER, geometry.vb, _gl.STREAM_DRAW);
            }
            else
                _gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.vbbuffer );


            var stride = geometry.vbstride;

            //Set attributes which are part of the interleaved buffer
            for ( attributeName in programAttributes ) {

                //Index is bound outside this function, only in the
                //case of indexed draw.
                if (attributeName == 'index')
                    continue;

                attributePointer = programAttributes[ attributeName ];
                attributeItem = geometry.attributes[ attributeName ];

                if ( attributePointer >= 0 ) {

                    if ( attributeItem ) {

                        if (attributeItem.itemOffset !== undefined) //it's part of the interleaved VB, so process it here
                        {
                            var type = _gl.FLOAT;
                            if (attributeItem.bytesPerItem === 1) {
                                type = _gl.UNSIGNED_BYTE;
                            }

                            enableAttribute( attributePointer );
                            _gl.vertexAttribPointer( attributePointer, attributeItem.itemSize, type, attributeItem.normalize, stride * 4, (attributeItem.itemOffset + startIndex * stride) * 4 );

                            if (_glExtensionInstancedArrays)
                                _glExtensionInstancedArrays.vertexAttribDivisorANGLE(attributePointer, attributeItem.divisor || 0);

                        }
                        else
                            hasNonInterleaved = true;

                    }
                }
            }
        } else {
            hasNonInterleaved = true;
        }

        //Bail early if there are no attributes that require individual binding
        if (!hasNonInterleaved) {
			disableUnusedAttributes();
			return;
		}

        for ( attributeName in programAttributes ) {

            //Index is bound outside this function, only in the
            //case of indexed draw.
            if (attributeName == 'index')
                continue;

            attributePointer = programAttributes[ attributeName ];
            attributeItem = geometry.attributes[ attributeName ];

            if ( attributePointer >= 0 ) {

                if ( attributeItem ) {

                    if (attributeItem.itemOffset === undefined) //it's not part of the interleaved VB, so bind it here
                    {
                        if (geometry.streamingDraw) {
                            var buffer = _dynamicBuffers[attributeName];
                            if (!buffer) {
                                buffer = _gl.createBuffer();
                                _dynamicBuffers[attributeName] = buffer;
                            }

                            _gl.bindBuffer( _gl.ARRAY_BUFFER, buffer);
                            _gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, _gl.DYNAMIC_DRAW);
                        }
                        else
                            _gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );

                        var type = _gl.FLOAT;
                        if (attributeItem.bytesPerItem === 1) {
                            type = _gl.UNSIGNED_BYTE;
                        }

                        enableAttribute( attributePointer );
                        _gl.vertexAttribPointer( attributePointer, attributeItem.itemSize, type, attributeItem.normalize, 0, startIndex * attributeItem.itemSize * 4 ); // 4 bytes per Float32

                        if (_glExtensionInstancedArrays)
                            _glExtensionInstancedArrays.vertexAttribDivisorANGLE(attributePointer, attributeItem.divisor || 0);
                    }

                } else if ( material.defaultAttributeValues ) {

                    var attr = material.defaultAttributeValues[ attributeName ];

                    if ( attr && attr.length === 2 ) {

                        _gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

                    } else if ( attr && attr.length === 3 ) {

                        _gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

                    }

                }

            }
        }

		disableUnusedAttributes();

    }


	// Buffer rendering

	this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

		if ( material.visible === false ) return;

		var program = setProgram( camera, lights, fog, material, object );

		var programAttributes = program.attributes;
		var geometryAttributes = geometry.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			initAttributes();

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var index = geometryAttributes[ "index" ];

			// indexed triangles

			if ( index ) {

				var type, size;

				if ( index.array instanceof Uint32Array ) {

					type = _gl.UNSIGNED_INT;
					size = 4;

				} else {

					type = _gl.UNSIGNED_SHORT;
					size = 2;

				}


				var offsets = geometry.offsets;

				// if there is more than 1 chunk
				// must set attribute pointers to use new offsets for each chunk
				// even if geometry and materials didn't change

				if ( offsets && offsets.length > 1 ) updateBuffers = true;

                var i = 0;
                do
                {
                    var startIndex, startOffset, count;
                    if (offsets && offsets.length)
                    {
                        startIndex = offsets[ i ].index;
                        startOffset = offsets[ i ].start;
                        count = offsets[ i ].count;
                    }
                    else
                    {
                        startIndex = 0;
                        startOffset = 0;
                        count = index.array.length;
                    }

                    if ( updateBuffers ) {

                        setupVertexAttributes(material, programAttributes, geometry, startIndex);

                        // indices (they can have a VBO even if the geometry part is streamed)
                        if (!index.buffer && geometry.streamingDraw) {
                            var buffer = _dynamicBuffers['index'];
                            if (!buffer) {
                                buffer = _gl.createBuffer();
                                _dynamicBuffers['index'] = buffer;
                            }

                            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, null);
                            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, buffer);
                            _gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, index.array, _gl.DYNAMIC_DRAW);
                        }
                        else
                            _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

                    }

                    // render indexed triangles
                    if (geometry.numInstances)
                        _glExtensionInstancedArrays.drawElementsInstancedANGLE( geometry.isLines ? _gl.LINES : _gl.TRIANGLES, count, type, startOffset * size, geometry.numInstances ); // 2 bytes per Uint16
                    else
                        _gl.drawElements( geometry.isLines ? _gl.LINES : _gl.TRIANGLES, count, type, startOffset * size ); // 2 bytes per Uint16
                        
                } while(offsets && ++i < offsets.length);

			// non-indexed triangles

			} else {

				if ( updateBuffers ) {

                    setupVertexAttributes(material, programAttributes, geometry, startIndex);
				}

				var position = geometry.attributes[ "position" ];

				// render non-indexed triangles
                if (geometry.numInstances)
    				_glExtensionInstancedArrays.drawArraysInstancedANGLE( geometry.isLines ? _gl.LINE_STRIP : _gl.TRIANGLES, 0, position.array.length / 3, geometry.numInstances );
    		    else
    				_gl.drawArrays( geometry.isLines ? _gl.LINE_STRIP : _gl.TRIANGLES, 0, position.array.length / 3 );

			}
		}
        else
        {
            console.log ("Only THREE.Mesh can be rendered by the Firefly renderer. Use THREE.Mesh to draw lines.");
        }

	};

	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.visible === false ) return;

		var linewidth, a, attribute, i, il;

		var program = setProgram( camera, lights, fog, material, object );

		var attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			initAttributes();

		}

		// vertices

		if ( !material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

				}

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes.normal );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes.tangent );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				if ( object.geometry.faceVertexUvs[0] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					enableAttribute( attributes.uv );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

				}

			}

			if ( attributes.uv2 >= 0 ) {

				if ( object.geometry.faceVertexUvs[1] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					enableAttribute( attributes.uv2 );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

				}

			}

			// line distances

			if ( attributes.lineDistance >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes.lineDistance );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

			}

		}

		disableUnusedAttributes();


		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var type = geometryGroup.__typeArray === Uint32Array ? _gl.UNSIGNED_INT : _gl.UNSIGNED_SHORT;

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );
				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, type, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, type, 0 );

			}

		// render lines

		} else if ( object instanceof THREE.Line ) {

			var mode = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( mode, 0, geometryGroup.__webglLineCount );

		// render particles

		}

	};

	function initAttributes() {

		for ( var i = 0, l = _newAttributes.length; i < l; i ++ ) {

			_newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		_newAttributes[ attribute ] = 1;

		if ( _enabledAttributes[ attribute ] === 0 ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ attribute ] = 1;

		}

	}

	function disableUnusedAttributes() {

		for ( var i = 0, l = _enabledAttributes.length; i < l; i ++ ) {

			if ( _enabledAttributes[ i ] !== _newAttributes[ i ] ) {

				_gl.disableVertexAttribArray( i );
				_enabledAttributes[ i ] = 0;

			}

		}

	}


	// Sorting

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	};

	function reversePainterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	};

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	};


	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var lights = scene.__lights,
		fog = scene.fog;

		// reset caching for this frame

		_currentMaterialId = -1;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

        if (camera.worldUpTransform)
            _viewInverseEnv.multiplyMatrices(camera.worldUpTransform, camera.matrixWorld);
        else
            _viewInverseEnv.copy(camera.matrixWorld);

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// update WebGL objects

		initObjects( scene );


		opaqueObjects.length = 0;
		transparentObjects.length = 0;

		projectObject( scene, scene, camera );

		if ( _this.sortObjects === true ) {

			//opaqueObjects.sort( painterSortStable );
			//transparentObjects.sort( reversePainterSortStable );
			opaqueObjects.sort( reversePainterSortStable );
			transparentObjects.sort( painterSortStable );

		}

		// custom render plugins (pre pass)

		renderPlugins( this.renderPluginsPre, scene, camera );

		resetStates();

		//

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}


		if ( scene.overrideMaterial ) {

			var material = scene.overrideMaterial;

			this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			this.setDepthTest( material.depthTest );
			this.setDepthWrite( material.depthWrite );
			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			renderObjects( opaqueObjects, camera, lights, fog, true, material );
			renderObjects( transparentObjects, camera, lights, fog, true, material );

		} else {

			var material = null;

			// opaque pass (front-to-back order)

			this.setBlending( THREE.NoBlending );

			renderObjects( opaqueObjects, camera, lights, fog, false, material );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, camera, lights, fog, true, material );

		}

		// custom render plugins (post pass)

		renderPlugins( this.renderPluginsPost, scene, camera );

		resetStates();

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		this.setDepthTest( true );
		this.setDepthWrite( true );

		// _gl.finish();

	};

    this.endFrame = function() {
        //_gl.finish();
        //_gl.flush();
    };


	function projectObject(scene, object,camera){

		if ( object.visible === false ) return;

		var webglObjects = scene.__webglObjects[ object.id ];

		if ( webglObjects && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

			updateObject( scene, object );

			for ( var i = 0, l = webglObjects.length; i < l; i ++ ) {

				var webglObject = webglObjects[i];

				unrollBufferMaterial( webglObject );

				webglObject.render = true;

				if ( _this.sortObjects === true ) {

					if ( object.renderDepth !== null ) {

						webglObject.z = object.renderDepth;

					} else {

						_vector3.setFromMatrixPosition( object.matrixWorld );
						_vector3.applyProjection( _projScreenMatrix );

						webglObject.z = _vector3.z;

					}

				}

			}

		}

		if (object.children) {

			for ( var i = 0, l = object.children.length; i < l; i ++ ) {

				projectObject( scene, object.children[ i ], camera );

			}

		}

	}

	function resetStates()
    {
		_currentProgram = null;
		_currentCamera = null;

		_oldBlending = -1;
		_oldDepthTest = -1;
		_oldDepthWrite = -1;
		_oldDoubleSided = -1;
		_oldFlipSided = -1;
		_currentGeometryGroupHash = -1;
		_currentMaterialId = -1;

		_lightsNeedUpdate = true;
    }


	function renderPlugins( plugins, scene, camera ) {

		if ( ! plugins.length ) return;

		for ( var i = 0, il = plugins.length; i < il; i ++ ) {

			// reset state for plugin (to start from clean slate)
			resetStates();

			plugins[ i ].render( scene, camera, _currentWidth, _currentHeight );

			// reset state after plugin (anything could have changed)

		}

	};

	function renderObjects( renderList, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, buffer, material;

		//TODO: we have to iterate upwards in order to preserve draw order for 2d
		//without having to sort the scene. Figure out how to keep the reverse iteration so that
		//we are consistent with three.js
		for ( var i = 0, iEnd = renderList.length; i < iEnd; i ++ ) {
		//for ( var i = renderList.length - 1; i !== - 1; i -- ) {

			webglObject = renderList[ i ];

			object = webglObject.object;
			buffer = webglObject.buffer;

			setupMatrices( object, camera );

			if ( overrideMaterial ) {

				material = overrideMaterial;

			} else {

				material = webglObject.material;

				if ( ! material ) continue;

				if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

				_this.setDepthTest( material.depthTest );
				_this.setDepthWrite( material.depthWrite );
				setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			}

			_this.setMaterialFaces( material );

			if ( buffer instanceof THREE.BufferGeometry ) {

				_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

			} else {

				_this.renderBuffer( camera, lights, fog, material, buffer, object );

			}

		}

	};


	function unrollBufferMaterial ( globject ) {

		var object = globject.object;
		var buffer = globject.buffer;

		var geometry = object.geometry;
		var material = object.material;

		if ( material instanceof THREE.MeshFaceMaterial ) {

			var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

			material = material.materials[ materialIndex ];

			if ( material.transparent ) {

				globject.material = material;
				transparentObjects.push( globject );

			} else {

				globject.material = material;
				opaqueObjects.push( globject );

			}

		} else {

			if ( material ) {

				if ( material.transparent ) {

					globject.material = material;
					transparentObjects.push( globject );

				} else {

					globject.material = material;
					opaqueObjects.push( globject );

				}

			}

		}

	};


	// Objects refresh

	var initObjects = function ( scene ) {

		if ( ! scene.__webglObjects ) {

			scene.__webglObjects = {};
			scene.__webglObjectsImmediate = [];

		}

		while ( scene.__objectsAdded.length ) {

			addObject( scene.__objectsAdded[ 0 ], scene );
			scene.__objectsAdded.splice( 0, 1 );

		}

		while ( scene.__objectsRemoved.length ) {

			removeObject( scene.__objectsRemoved[ 0 ], scene );
			scene.__objectsRemoved.splice( 0, 1 );

		}

	};

	// Objects adding

	function addObject( object, scene ) {

		var g, geometry, geometryGroup;

		if ( object.__webglInit === undefined ) {

			object.__webglInit = true;

			object._modelViewMatrix = new THREE.Matrix4();
			object._normalMatrix = new THREE.Matrix3();

		}

		geometry = object.geometry;

		if ( geometry === undefined ) {

			// ImmediateRenderObject

		} else if ( geometry.__webglInit === undefined ) {

			geometry.__webglInit = true;
			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry instanceof THREE.BufferGeometry ) {

				initDirectBuffers( geometry );

			} else if ( object instanceof THREE.Mesh ) {

				if ( object.__webglActive !== undefined ) {

					removeObject( object, scene );

				}

				initGeometryGroups(scene, object, geometry);

			} else if ( object instanceof THREE.Line ) {

				if ( ! geometry.__webglVertexBuffer ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			}

		}

		if ( object.__webglActive === undefined) {

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;

				if ( geometry instanceof THREE.BufferGeometry ) {

					addBuffer( scene.__webglObjects, geometry, object );

				} else if ( geometry instanceof THREE.Geometry ) {

					for ( var i = 0,l = geometry.geometryGroupsList.length; i<l;i++ ) {

						geometryGroup = geometry.geometryGroupsList[ i ];
						addBuffer( scene.__webglObjects, geometryGroup, object );

					}
				}

			} else if ( object instanceof THREE.Line ) {

				geometry = object.geometry;
				addBuffer( scene.__webglObjects, geometry, object );

			}

			object.__webglActive = true;

		}

	};

	function initGeometryGroups( scene, object, geometry ) {

		var g, geometryGroup, material,addBuffers = false;
		material = object.material;

		if ( geometry.geometryGroups === undefined || geometry.groupsNeedUpdate ) {

			delete scene.__webglObjects[object.id];
			geometry.makeGroups( material instanceof THREE.MeshFaceMaterial, _glExtensionElementIndexUint ? 4294967296 : 65535  );
			geometry.groupsNeedUpdate = false;

		}

		// create separate VBOs per geometry chunk

		for ( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {

			geometryGroup = geometry.geometryGroupsList[ i ];

			// initialise VBO on the first access

			if ( ! geometryGroup.__webglVertexBuffer ) {

				createMeshBuffers( geometryGroup );
				initMeshBuffers( geometryGroup, object );

				geometry.verticesNeedUpdate = true;
				geometry.morphTargetsNeedUpdate = true;
				geometry.elementsNeedUpdate = true;
				geometry.uvsNeedUpdate = true;
				geometry.normalsNeedUpdate = true;
				geometry.tangentsNeedUpdate = true;
				geometry.colorsNeedUpdate = true;

				addBuffers = true;

			} else {

				addBuffers = false;

			}

			if ( addBuffers || object.__webglActive === undefined ) {
				addBuffer( scene.__webglObjects, geometryGroup, object );
			}

		}

		object.__webglActive = true;

	}

	function addBuffer( objlist, buffer, object ) {

		var id = object.id;
		objlist[id] = objlist[id] || [];
		objlist[id].push(
			{
				id: id,
				buffer: buffer,
				object: object,
				material: null,
				z: 0
			}
		);

	};

	function addBufferImmediate( objlist, object ) {

		objlist.push(
			{
				id: null,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	// Objects updates

	function updateObject(scene, object ) {

		var geometry = object.geometry,
			geometryGroup, customAttributesDirty, material;

		if ( geometry instanceof THREE.BufferGeometry ) {

			setDirectBuffers( geometry, _gl.DYNAMIC_DRAW );

		} else if ( object instanceof THREE.Mesh ) {

			// check all geometry groups
			if ( geometry.buffersNeedUpdate || geometry.groupsNeedUpdate ) {

				if ( geometry instanceof THREE.BufferGeometry ) {

					initDirectBuffers( geometry );

				} else if ( object instanceof THREE.Mesh ) {

					initGeometryGroups(scene, object,geometry);

				}

			}

			for ( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {

				geometryGroup = geometry.geometryGroupsList[ i ];

				material = getBufferMaterial( object, geometryGroup );

				if ( geometry.buffersNeedUpdate || geometry.groupsNeedUpdate) {

					initMeshBuffers( geometryGroup, object );

				}

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, ! geometry.dynamic, material );

				}

			}

			geometry.verticesNeedUpdate = false;
			geometry.morphTargetsNeedUpdate = false;
			geometry.elementsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.tangentsNeedUpdate = false;

			geometry.buffersNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Line ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		}

	};

	// Objects updates - custom attributes check

	function areCustomAttributesDirty( material ) {

		for ( var a in material.attributes ) {

			if ( material.attributes[ a ].needsUpdate ) return true;

		}

		return false;

	};

	function clearCustomAttributes( material ) {

		for ( var a in material.attributes ) {

			material.attributes[ a ].needsUpdate = false;

		}

	};

	// Objects removal

	function removeObject( object, scene ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.Line ) {

			removeInstancesWebglObjects( scene.__webglObjects, object );

		}

		delete object.__webglActive;

	};



	function removeInstancesWebglObjects( objlist, object ) {

		delete objlist[ object.id ];

	};

	function removeInstances( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	// Materials

	this.initMaterial = function ( material, lights, fog, object ) {

		material.addEventListener( 'dispose', onMaterialDispose );

		var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;

		if ( material instanceof THREE.MeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

            console.log("MeshNormalMaterial is turned off.");
			//shaderID = 'normal';

		} else if ( material instanceof THREE.MeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

            console.log("MeshLambertMaterial is turned off.");
			//shaderID = 'lambert';

		} else if ( material instanceof THREE.MeshPhongMaterial ) {

            shaderID = 'firefly_phong';
			//shaderID = 'phong';

		} else if ( material instanceof THREE.LineBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			shaderID = 'dashed';

		}

		if ( shaderID ) {

			var shader = THREE.ShaderLib[ shaderID ];

			material.__webglShader = {
				uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader
			}

		} else {

			material.__webglShader = {
				uniforms: material.uniforms,
				vertexShader: material.vertexShader,
				fragmentShader: material.fragmentShader
			}
		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		maxLightCount = allocateLights( lights );

		maxShadows = allocateShadows( lights );

		maxBones = 0;//allocateBones( object );

		parameters = {

            precision: _precision,
			supportsVertexTextures: _supportsVertexTextures,

			map: !!material.map,
			envMap: !!material.envMap,
            irradianceMap: !!material.irradianceMap,
            envIsSpherical: (material.envMap && material.envMap.mapping instanceof THREE.SphericalReflectionMapping),
            envLogLuv: material.envMap && material.envMap.LogLuv,
            irrLogLuv: material.irradianceMap && material.irradianceMap.LogLuv,
			lightMap: !!material.lightMap,
			bumpMap: _glExtensionStandardDerivatives && !!material.bumpMap,
			normalMap: _glExtensionStandardDerivatives && !!material.normalMap,
			specularMap: !!material.specularMap,
            alphaMap: !!material.alphaMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: _logarithmicDepthBuffer,
			useFragDepthExt : _glExtensionFragDepth,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: maxShadows,
			shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow,
			shadowMapType: this.shadowMapType,
			shadowMapDebug: this.shadowMapDebug,
			shadowMapCascade: this.shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
            clearcoat: material.clearcoat,
			wrapAround: material.wrapAround,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide,

            mrtNormals: (_drawBuffersWorks && material.mrtNormals),
            tonemapOutput : material.tonemapOutput
		};


		var chunks = [];

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( material.fragmentShader );
			chunks.push( material.vertexShader );

		}

		for ( var d in material.defines ) {

			chunks.push( d );
			chunks.push( material.defines[ d ] );

		}

		for ( var p in parameters ) {

			chunks.push( p );
			chunks.push( parameters[ p ] );

		}

		var code = chunks.join();

		var program;

		// Check if code has been already compiled

		for ( var p = 0, pl = _programs.length; p < pl; p ++ ) {

			var programInfo = _programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				program.usedTimes ++;

				break;

			}

		}

		if ( program === undefined ) {

			program = new FireflyWebGLProgram( this, code, material, parameters );
			_programs.push( program );

			_this.info.memory.programs = _programs.length;

		}

		material.program = program;


		material.uniformsList = [];

		for ( u in material.__webglShader.uniforms ) {

			var location = material.program.uniforms[ u ];

			if ( location ) {
				material.uniformsList.push( [ material.__webglShader.uniforms[ u ], location ] );
			}

		}

	};


	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program ) deallocateMaterial( material );

			_this.initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}


		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			if ( _currentMaterialId === -1 ) refreshLights = true;
			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( _logarithmicDepthBuffer ) {

				_gl.uniform1f( p_uniforms.logDepthBufFC, 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( camera !== _currentCamera ) _currentCamera = camera;


			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== null ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

                //NOTE: viewMatrixInverse is only used for transforming normal vectors
                //for sampling environment textures. This is why we do not use camera.matrixWorld here,
                //but a combination of camera.matrixWorld plus a rotation to make Y the up vector, so that
                //the top of the scene (whichever axis is up) results in sampling the top of the environment map.
                //If viewMatrixInverse is needed for other things in the shader, then we will need a second
                //uniform that does not include the world-up rotation, or apply a consistent world up rotation
                //to all geometries in the scene.
				if ( p_uniforms.viewMatrixInverse !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrixInverse, false, _viewInverseEnv.elements );

				}


				if ( p_uniforms.mvpMatrix ) {

					_gl.uniformMatrix4fv( p_uniforms.mvpMatrix, false, _projScreenMatrix.elements );

				}


			}

		}


		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					refreshLights = true;
					setupLights( lights );
					_lightsNeedUpdate = false;

				}

				if ( refreshLights ) {
					refreshUniformsLights( m_uniforms, _lights );
					markUniformsLightsNeedsUpdate( m_uniforms, true );
				} else {
					markUniformsLightsNeedsUpdate( m_uniforms, false );
				}

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( material.uniformsList );

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== null ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	};

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( _this.gammaInput ) {

			uniforms.diffuse.value.copyGammaToLinear( material.color );

		} else {

			uniforms.diffuse.value.copy(material.color);

		}

		uniforms.map.value = material.map;
		uniforms.lightMap.value = material.lightMap;
		uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//	1. color map
		//	2. specular map
		//	3. normal map
		//	4. bump map
        //  5. alpha map

        //NOTE: We deviate from Three.js in that we allow
        //separate scales for diffuse/specular, alpha, and bump

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		}
        else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

        if ( uvScaleMap !== undefined ) {

            var offset = uvScaleMap.offset;
            var repeat = uvScaleMap.repeat;

            uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

        var uvScaleMapBump;

        if ( material.normalMap ) {

			uvScaleMapBump = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMapBump = material.bumpMap;

		}

        if ( uvScaleMapBump !== undefined ) {

            var offset = uvScaleMapBump.offset;
            var repeat = uvScaleMapBump.repeat;

            uniforms.offsetRepeatBump.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }

        if (material.alphaMap) {

            var offset = material.alphaMap.offset;
            var repeat = material.alphaMap.repeat;

           uniforms.offsetRepeatAlpha.value.set( offset.x, offset.y, repeat.x, repeat.y );

        }


		uniforms.envMap.value = material.envMap;
		//uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;
		if (uniforms.irradianceMap) {
			uniforms.irradianceMap.value = material.irradianceMap;
		}
		if ( _this.gammaInput ) {

			uniforms.reflectivity.value = material.reflectivity * material.reflectivity;

		} else {

			uniforms.reflectivity.value = material.reflectivity;

		}

		uniforms.refractionRatio.value = material.refractionRatio;
		uniforms.combine.value = material.combine;
		uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

	};

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	};

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	};

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	};

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.shininess.value = material.shininess;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );
			uniforms.specular.value.copyGammaToLinear( material.specular );
		} else {

			uniforms.ambient.value.copy(material.ambient);
			uniforms.emissive.value.copy(material.emissive);
			uniforms.specular.value.copy(material.specular);

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

		uniforms.exposureBias.value = material.exposureBias;

	};

	function refreshUniformsLambert ( uniforms, material ) {

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );

		} else {

			uniforms.ambient.value.copy(material.ambient);
			uniforms.emissive.value.copy(material.emissive);

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	};

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	};

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate ( uniforms, boolean ) {

		uniforms.ambientLightColor.needsUpdate = boolean;

		uniforms.directionalLightColor.needsUpdate = boolean;
		uniforms.directionalLightDirection.needsUpdate = boolean;

		uniforms.pointLightColor.needsUpdate = boolean;
		uniforms.pointLightPosition.needsUpdate = boolean;
		uniforms.pointLightDistance.needsUpdate = boolean;

		uniforms.spotLightColor.needsUpdate = boolean;
		uniforms.spotLightPosition.needsUpdate = boolean;
		uniforms.spotLightDistance.needsUpdate = boolean;
		uniforms.spotLightDirection.needsUpdate = boolean;
		uniforms.spotLightAngleCos.needsUpdate = boolean;
		uniforms.spotLightExponent.needsUpdate = boolean;

		uniforms.hemisphereLightSkyColor.needsUpdate = boolean;
		uniforms.hemisphereLightGroundColor.needsUpdate = boolean;
		uniforms.hemisphereLightDirection.needsUpdate = boolean;

	};

	function refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

					uniforms.shadowMap.value[ j ] = light.shadowMap;
					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
					uniforms.shadowBias.value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	};

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

		}

	};

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= _maxTextures ) {

			console.warn( "WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + _maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	};

	function loadUniformsGeneric ( uniforms ) {

		var texture, textureUnit, offset;

		for ( var j = 0, jl = uniforms.length; j < jl; j ++ ) {

			var uniform = uniforms[ j ][ 0 ];

			// needsUpdate property is not added to all uniforms.
			if ( uniform.needsUpdate === false ) continue;

			var type = uniform.type;
			var value = uniform.value;
			var location = uniforms[ j ][ 1 ];

			switch ( type ) {

				case '1i':
					_gl.uniform1i( location, value );
					break;

				case '1f':
					_gl.uniform1f( location, value );
					break;

				case '2f':
					_gl.uniform2f( location, value[ 0 ], value[ 1 ] );
					break;

				case '3f':
					_gl.uniform3f( location, value[ 0 ], value[ 1 ], value[ 2 ] );
					break;

				case '4f':
					_gl.uniform4f( location, value[ 0 ], value[ 1 ], value[ 2 ], value[ 3 ] );
					break;

				case '1iv':
					_gl.uniform1iv( location, value );
					break;

				case '3iv':
					_gl.uniform3iv( location, value );
					break;

				case '1fv':
					_gl.uniform1fv( location, value );
					break;

				case '2fv':
					_gl.uniform2fv( location, value );
					break;

				case '3fv':
					_gl.uniform3fv( location, value );
					break;

				case '4fv':
					_gl.uniform4fv( location, value );
					break;

				case 'Matrix3fv':
					_gl.uniformMatrix3fv( location, false, value );
					break;

				case 'Matrix4fv':
					_gl.uniformMatrix4fv( location, false, value );
					break;

				//

				case 'i':

					// single integer
					_gl.uniform1i( location, value );

					break;

				case 'f':

					// single float
					_gl.uniform1f( location, value );

					break;

				case 'v2':

					// single THREE.Vector2
					_gl.uniform2f( location, value.x, value.y );

					break;

				case 'v3':

					// single THREE.Vector3
					_gl.uniform3f( location, value.x, value.y, value.z );

					break;

				case 'v4':

					// single THREE.Vector4
					_gl.uniform4f( location, value.x, value.y, value.z, value.w );

					break;

				case 'c':

					// single THREE.Color
					_gl.uniform3f( location, value.r, value.g, value.b );

					break;

				case 'iv1':

					// flat array of integers (JS or typed array)
					_gl.uniform1iv( location, value );

					break;

				case 'iv':

					// flat array of integers with 3 x N size (JS or typed array)
					_gl.uniform3iv( location, value );

					break;

				case 'fv1':

					// flat array of floats (JS or typed array)
					_gl.uniform1fv( location, value );

					break;

				case 'fv':

					// flat array of floats with 3 x N size (JS or typed array)
					_gl.uniform3fv( location, value );

					break;

				case 'v2v':

					// array of THREE.Vector2

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 2 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 2;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;

					}

					_gl.uniform2fv( location, uniform._array );

					break;

				case 'v3v':

					// array of THREE.Vector3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 3 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 3;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;

					}

					_gl.uniform3fv( location, uniform._array );

					break;

				case 'v4v':

					// array of THREE.Vector4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 4 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						offset = i * 4;

						uniform._array[ offset ]   = value[ i ].x;
						uniform._array[ offset + 1 ] = value[ i ].y;
						uniform._array[ offset + 2 ] = value[ i ].z;
						uniform._array[ offset + 3 ] = value[ i ].w;

					}

					_gl.uniform4fv( location, uniform._array );

					break;

				case 'm3':

					// single THREE.Matrix3
					_gl.uniformMatrix3fv( location, false, value.elements );

					break;

				case 'm3v':

					// array of THREE.Matrix3

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 9 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 9 );

					}

					_gl.uniformMatrix3fv( location, false, uniform._array );

					break;

				case 'm4':

					// single THREE.Matrix4
					_gl.uniformMatrix4fv( location, false, value.elements );

					break;

				case 'm4v':

					// array of THREE.Matrix4

					if ( uniform._array === undefined ) {

						uniform._array = new Float32Array( 16 * value.length );

					}

					for ( var i = 0, il = value.length; i < il; i ++ ) {

						value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

					}

					_gl.uniformMatrix4fv( location, false, uniform._array );

					break;

				case 't':

					// single THREE.Texture (2d or cube)

					texture = value;
					textureUnit = getTextureUnit();

					_gl.uniform1i( location, textureUnit );

					if ( ! texture ) continue;

					if ( texture instanceof THREE.CubeTexture ||
					   ( texture.image instanceof Array && texture.image.length === 6 ) ) { // CompressedTexture can have Array in image :/

						setCubeTexture( texture, textureUnit );

					} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

						setCubeTextureDynamic( texture, textureUnit );

					} else {

						_this.setTexture( texture, textureUnit );

					}

					break;

				case 'tv':

					// array of THREE.Texture (2d)

					if ( uniform._array === undefined ) {

						uniform._array = [];

					}

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						uniform._array[ i ] = getTextureUnit();

					}

					_gl.uniform1iv( location, uniform._array );

					for ( var i = 0, il = uniform.value.length; i < il; i ++ ) {

						texture = uniform.value[ i ];
						textureUnit = uniform._array[ i ];

						if ( ! texture ) continue;

						_this.setTexture( texture, textureUnit );

					}

					break;

				default:

					console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	};

	function setupMatrices ( object, camera ) {

		object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

	};

	//

	function setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	};

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	};

	function setupLights ( lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( _this.gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				if ( _this.gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				pointPositions[ pointOffset ]     = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				spotPositions[ spotOffset ]     = _vector3.x;
				spotPositions[ spotOffset + 1 ] = _vector3.y;
				spotPositions[ spotOffset + 2 ] = _vector3.z;

				spotDistances[ spotLength ] = distance;

				_direction.copy( _vector3 );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.normalize();

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( _this.gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	};

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			_gl.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		}

	};

	this.setMaterialFaces = function ( material ) {

		var doubleSided = material.side === THREE.DoubleSide;
		var flipSided = material.side === THREE.BackSide;

		if ( _oldDoubleSided !== doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				_gl.enable( _gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided !== flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if ( depthTest ) {

				_gl.enable( _gl.DEPTH_TEST );

			} else {

				_gl.disable( _gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	};

	function setLineWidth ( width ) {

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	};

	function setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( _gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( _gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	};

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

		if ( blending !== _oldBlending ) {

			if ( blending === THREE.NoBlending ) {

				_gl.disable( _gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				_gl.enable( _gl.BLEND );

			} else {

				_gl.enable( _gl.BLEND );
				_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
				_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			if ( blendEquation !== _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	};


	// Textures


	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}

		if ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {

			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

				_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );
				texture.__oldAnisotropy = texture.anisotropy;

			}

		}

	};

	this.setTexture = function ( texture, slot ) {

		if ( texture.needsUpdate ) {

			if ( ! texture.__webglInit ) {

				texture.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				texture.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

			}

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = texture.image,
			isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				for( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					if ( texture.format!==THREE.RGBAFormat ) {
						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
					} else {
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
					}

				}

			} else { // regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate ) texture.onUpdate();

		} else {

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width <= maxSize && image.height <= maxSize ) {

			return image;

		}

		// Warning: Scaling through the canvas will only work with images that use
		// premultiplied alpha.

		var maxDimension = Math.max( image.width, image.height );
		var newWidth = Math.floor( image.width * maxSize / maxDimension );
		var newHeight = Math.floor( image.height * maxSize / maxDimension );

		var canvas = document.createElement( 'canvas' );
		canvas.width = newWidth;
		canvas.height = newHeight;

		var ctx = canvas.getContext( "2d" );
		ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );

		return canvas;

	}

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					texture.image.__webglTextureCube = _gl.createTexture();

					_this.info.memory.textures ++;

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture,
				isDataTexture = texture.image[0] instanceof THREE.DataTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[i].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type)

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo && glType != _gl.FLOAT);

				for ( var i = 0; i < 6; i ++ ) {

					if( !isCompressed ) {

                        if (isDataTexture) {
                            _gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data );
                        }
                        else {
						    _gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
                        }

					} else {
						
						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];
							if ( texture.format!==THREE.RGBAFormat ) {

								_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {
								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
							}

						}
					}
				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	};

	// Render targets

    this.initFrameBufferMRT = function ( renderTargets, verifyFrameBufferWorks ) {

        var primaryTarget = renderTargets[0];
        var clearState = false;

        //For MRT, the frame and depth buffer are owned
        //by the first target.
        if ( primaryTarget && ! primaryTarget.__webglFramebuffer ) {

            if ( primaryTarget.depthBuffer === undefined ) primaryTarget.depthBuffer = true;
            if ( primaryTarget.stencilBuffer === undefined ) primaryTarget.stencilBuffer = true;

            primaryTarget.__webglFramebuffer = _gl.createFramebuffer();

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, primaryTarget.__webglFramebuffer );

            var renderbuffer;

            //Allocate depth buffer if needed

            if (primaryTarget.shareDepthFrom) {

                renderbuffer = primaryTarget.__webglRenderbuffer = primaryTarget.shareDepthFrom.__webglRenderbuffer;

            } else {

                if ( primaryTarget.depthBuffer && ! primaryTarget.stencilBuffer ) {

                    renderbuffer = primaryTarget.__webglRenderbuffer = _gl.createRenderbuffer();

                    _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

                    _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, primaryTarget.width, primaryTarget.height );

                } else if ( primaryTarget.depthBuffer && primaryTarget.stencilBuffer ) {

                    renderbuffer = primaryTarget.__webglRenderbuffer = _gl.createRenderbuffer();

                    _gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

                    _gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, primaryTarget.width, primaryTarget.height );

                } else {

                    //_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, primaryTarget.width, primaryTarget.height );

                }

            }

            //Bind depth buffer

            if ( primaryTarget.depthBuffer && ! primaryTarget.stencilBuffer ) {

                _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

            } else if ( primaryTarget.depthBuffer && primaryTarget.stencilBuffer ) {

                _gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

            } else {

            }

            clearState = true;
        }

        var tmpBuf = _currentFramebuffer;
        _gl.bindFramebuffer(_gl.FRAMEBUFFER, primaryTarget.__webglFramebuffer);

        //Create backing textures for all the targets and attach them
        //to the frame buffer.
        for (var i=0; i<renderTargets.length; i++) {
            var rt = renderTargets[i];

            if (!rt.__webglTexture) {

                var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( rt.width ) && THREE.Math.isPowerOfTwo( rt.height ),
                    glFormat = paramThreeToGL( rt.format ),
                    glType = paramThreeToGL( rt.type );

                rt.addEventListener( 'dispose', onRenderTargetDispose );

                rt.__webglTexture = _gl.createTexture();

                _this.info.memory.textures ++;

                _gl.bindTexture( _gl.TEXTURE_2D, rt.__webglTexture );

                setTextureParameters( _gl.TEXTURE_2D, rt, isTargetPowerOfTwo );

                _gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, rt.width, rt.height, 0, glFormat, glType, null );

                if ( isTargetPowerOfTwo && rt.generateMipmaps)
                    _gl.generateMipmap( _gl.TEXTURE_2D );
            }

            _gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, rt.__webglTexture, 0 );

        }

        if (_drawBuffersWorks && renderTargets.length > 1) {

            _glExtensionDrawBuffers.drawBuffersWEBGL([
                _glExtensionDrawBuffers.COLOR_ATTACHMENT0_WEBGL, // gl_FragData[0]
                _glExtensionDrawBuffers.COLOR_ATTACHMENT1_WEBGL, // gl_FragData[1]
                //_glExtensionDrawBuffers.COLOR_ATTACHMENT2_WEBGL, // gl_FragData[2]
                //_glExtensionDrawBuffers.COLOR_ATTACHMENT3_WEBGL  // gl_FragData[3]
            ]);
        }


        if (verifyFrameBufferWorks) {
            var status = _gl.checkFramebufferStatus(_gl.FRAMEBUFFER);
            if (status !== _gl.FRAMEBUFFER_COMPLETE) {
                console.log("Can't use multiple render targets. Falling back to two passes. " + status);
                delete primaryTarget.__webglFramebuffer;
                verifyFrameBufferWorks = false;
            }
        }

        _gl.bindFramebuffer(_gl.FRAMEBUFFER, tmpBuf);


        if (clearState) {
            // Release everything
            _gl.bindTexture( _gl.TEXTURE_2D, null );
            _gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
            _gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
        }

        return verifyFrameBufferWorks;
    };


    this.setRenderTarget = function(renderTargets) {

        var renderTarget;

        if (Array.isArray(renderTargets)) {
            this.initFrameBufferMRT(renderTargets);
            renderTarget = renderTargets[0];
        } else if (renderTargets) {
            this.initFrameBufferMRT([renderTargets]);
            renderTarget = renderTargets;
        }

        var framebuffer, width, height, vx, vy;

        if ( renderTarget ) {


            framebuffer = renderTarget.__webglFramebuffer;


            width = renderTarget.width;
            height = renderTarget.height;

            vx = 0;
            vy = 0;

        } else {

            framebuffer = null;

            width = _viewportWidth;
            height = _viewportHeight;

            vx = _viewportX;
            vy = _viewportY;

        }

        if ( framebuffer !== _currentFramebuffer ) {

            _gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
            _gl.viewport( vx, vy, width, height );

            _currentFramebuffer = framebuffer;

        }

        _currentWidth = width;
        _currentHeight = height;

    };


    this.readPixels = function(target, x, y, w, h, buf) {

        this.setRenderTarget(target);

        _gl.readPixels(x, y, w, h, _gl.RGBA, _gl.UNSIGNED_BYTE, buf);

    };


    //We need to use more than WebGL 1.0 technically allows -- we use
    //different bit depth sizes for the render targets, which is not
    //legal WebGL 1.0, but will work eventually and some platforms/browsers
    //already allow it. For others, we have to try, check for failure, and disable use of MRT dynamically.
    this.verifyMRTWorks = function(renderTargets) {
        if (_glExtensionDrawBuffers) {
            _drawBuffersWorks = this.initFrameBufferMRT(renderTargets, true);
        }
        return _drawBuffersWorks;
    };


	function updateRenderTargetMipmap ( renderTarget ) {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

	};

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	};

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;
        if ( p === THREE.HalfFloatType) return 0x8D61;//_gl.HALF_FLOAT_OES;

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		if ( _glExtensionCompressedTextureS3TC !== undefined && _glExtensionCompressedTextureS3TC !== null ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		return 0;

	};

	// Allocations

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.onlyShadow ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };

	};

	function allocateShadows( lights ) {

		var maxShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight ) maxShadows ++;
			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	};

	// Initialization

	function initGL() {

		try {

			var attributes = {
				alpha: _alpha,
				premultipliedAlpha: _premultipliedAlpha,
				antialias: _antialias,
				stencil: _stencil,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

			if ( _gl === null ) {

				throw 'Error creating WebGL context.';

			}

		} catch ( error ) {

			console.error( error );

		}

		_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );
        _glExtensionTextureHalfFloat = _gl.getExtension( 'OES_texture_half_float' );
		_glExtensionTextureFloatLinear = _gl.getExtension( 'OES_texture_float_linear' );
		_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );
        _glExtensionDrawBuffers = _gl.getExtension( 'WEBGL_draw_buffers' );
        _glExtensionElementIndexUint = _gl.getExtension('OES_element_index_uint');
        _glExtensionInstancedArrays = _gl.getExtension('ANGLE_instanced_arrays');
        _drawBuffersWorks = !!_glExtensionDrawBuffers;

		_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );

		_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );

		if ( ! _glExtensionTextureFloat ) {

			console.log( 'THREE.WebGLRenderer: Float textures not supported.' );

		}

        if ( ! _glExtensionTextureHalfFloat ) {

            console.log( 'THREE.WebGLRenderer: Half float textures not supported.' );

        }


		if ( ! _glExtensionStandardDerivatives ) {

			console.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );

		}

		if ( ! _glExtensionTextureFilterAnisotropic ) {

			console.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );

		}

		if ( ! _glExtensionCompressedTextureS3TC ) {

			console.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );

		}

        if (! _glExtensionDrawBuffers ) {

            console.log( 'THREE.WebGLRenderer: Multiple render targets not supported.' );

        }

        if (! _glExtensionInstancedArrays) {

            console.log( 'THREE.WebGLRenderer: Hardware instancing not supported.' );

        }

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function() {

				return {
					"rangeMin"  : 1,
					"rangeMax"  : 1,
					"precision" : 1
				};

			}
		}

		if ( _logarithmicDepthBuffer ) {

			_glExtensionFragDepth = _gl.getExtension( 'EXT_frag_depth' );

		}

	};

	function setDefaultGLState () {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );
		
		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	// default plugins (order is important)

	//this.shadowMapPlugin = new THREE.ShadowMapPlugin();
	//this.addPrePlugin( this.shadowMapPlugin );

};
;
AutodeskNamespace('Autodesk.Viewing.Private');

(function () {

    var avp = Autodesk.Viewing.Private;

    avp.BackgroundPresets = {
        "Fusion Grey":   [230,230,230, 150,150,150],
        //"Sky Blue":      [200,233,255, 100,116,127],
        "Sky Blue":      [226,244,255, 156,172,180],
        "Midnight":      [ 41, 76,120,   1,  2,  3],
        "White":         [255,255,255, 255,255,255],
        "AutoCADModel":  [ 30, 40, 48,  30, 40, 48],
        "Dark Grey":     [ 51, 51, 51,  51, 51, 51],
        "Infinity Pool": [164,175,179, 164,175,179],
        "Tranquility":   [  0, 84,166,  0, 84, 166],
        "Grey Room":     [129,129,129, 129,129,129],
        "Photo Booth":   [237,237,237, 237,237,237],
        "RaaS SBS":      [  1,  1,  1,  90, 90, 90],

        //This will get modified when the user changes the background
        //using the color picker.
        "Custom":        [230,230,230, 150,150,150]
    };

    var bg = avp.BackgroundPresets;

    avp.LightPresets = [
        //Notes: tonemap = which tone map method to use. Any tonemap method other than zero will cause colors to be linearized before use.
        //              0 = None, 1 = Linear, 2 = Reinhard, 3 = Filmic, 4 = Exponential, 5 = OGS Canon filmic
        //       exposure = exponential bias to use as pre-tonemap multiplier for all rendered colors, including background
        //       lightMultiplier = linear scale of direct light intensity (diffuse only, not ambient)
        //       bgColorGradient = which background color preset to use as default for the environment map

        //Image-based lighting from RaaS. Initial exposure is empirically obtained.
        //These do not normally require any extra lights, because they have the lights fully baked into
        //the environment maps.

        //Simple ***non-HDR*** environment.
        {
            name: "Simple Grey",
            path:null,
            tonemap:0,
            E_bias:0,
            directLightColor: [1.0, 0.84, 0.67],
            ambientColor:     [0.8, 0.9,  1.0],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: false
        },

        //Fusion Environments which require extra lights
        {
            name: "Sharp Highlights",
            path:"studio_01",
            tonemap:1,
            E_bias:-9.0,
            directLightColor: [0.5,0.5,0.5],
            ambientColor: [0.25,0.25,0.25],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Photo Booth"],
            darkerFade: true
        },

        {
            name: "Dark Sky",     // "Dark Sky",
            path:"DarkSky",
            tonemap:1,
            E_bias:-2,
            directLightColor: [1,1,1],
            ambientColor: [0,0,0],
            lightMultiplier: 2.5,
            bgColorGradient: bg["Dark Grey"],
            darkerFade: false
        },

        {
            name: "Grey Room",    // "Grey Room",
            path:"GreyRoom",
            tonemap:1,
            E_bias:1,
            directLightColor: [1,1,1],
            ambientColor: [0,0,0],
            lightMultiplier: 0.0,
            bgColorGradient: bg["Grey Room"],
            darkerFade: true
        },

        {
            name: "Photo Booth",     // "Photo Booth",
            path:"PhotoBooth",
            tonemap:1,
            E_bias:0,
            directLightColor: [1,1,1],
            ambientColor: [0.125,0.125,0.125],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Photo Booth"],
            darkerFade: true
        },

        {
            name: "Tranquility",     // "Tranquility",
            path:"TranquilityBlue",
            tonemap:1,
            E_bias:-2,
            directLightColor: [1,1,1],
            ambientColor: [0,0,0],
            lightMultiplier: 4.0,
            bgColorGradient: bg["Tranquility"],
            darkerFade: false
        },

        {
            name: "Infinity Pool",     // "Infinity Pool",
            path: "InfinityPool",
            tonemap:1,
            E_bias:-1,
            directLightColor: [1.0, 0.84, 0.67],
            ambientColor: [0,0,0],
            lightMultiplier: 2.5,
            bgColorGradient: bg["Infinity Pool"],
            darkerFade: false
        },

        // Non fusion environments

        //White background, no HDR -- for cases like SIM360 models
        {
            name:  "Simple White",     //"Simple White",
            path:null,
            tonemap:0,
            E_bias:0,
            directLightColor: [1,1,1],
            ambientColor: [0.9,0.9,0.9],
            lightMultiplier: 1.0,
            bgColorGradient: bg["White"],
            saoRadius: 0.06,
            saoIntensity: 0.15,
            darkerFade: true
        },
/*
        {
            name: "Simple Black",
            path:null,
            tonemap:0,
            E_bias:0,
            directLightColor: [1.0, 0.84, 0.67],
            ambientColor:     [0.8, 0.9,  1.0],
            lightMultiplier: 1.0,
            bgColorGradient: bg["AutoCADModel"],
            darkerFade: false
        },
  */
        //RaaS environments
        {
            name:  "Riverbank",     // "Riverbank",
            path:"riverbank",
            tonemap:1,
            E_bias:-5.7,
            directLightColor: [1,1,1],
            lightMultiplier: 0.0,
            bgColorGradient: bg["Sky Blue"],
            darkerFade: false
        },

        {
            name:  "Contrast",     // "Contrast",
            path:"IDViz",
            tonemap:1,
            E_bias:0,
            directLightColor: [1,1,1],
            lightMultiplier: 0.0,
            bgColorGradient: bg["Midnight"],
            darkerFade: false
        },

        {
            name: "Rim Highlights",
            path:"RimHighlights",
            tonemap:1,
            E_bias:-9.0,
            directLightColor: [0.5,0.5,0.5],
            ambientColor: [0.25,0.25,0.25],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Photo Booth"],
            darkerFade: true
        },
        {
            name:  "Cool Light",     // "Soft Light",
            path:"CoolLight",
            tonemap:1,
            E_bias:-9.0,
            directLightColor: [0.5,0.5,0.5],
            ambientColor: [0.25,0.25,0.25],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true
        },

        {
            name:  "Warm Light",     // "Warm Light",
            path:"WarmLight",
            tonemap:1,
            E_bias:-9.0,
            directLightColor: [0.5,0.5,0.5],
            ambientColor: [0.25,0.25,0.25],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true
        },

        {
            name:  "Soft Light",     // "Soft Light",
            path:"SoftLight",
            tonemap:1,
            E_bias:-9.0,
            directLightColor: [0.5,0.5,0.5],
            ambientColor: [0.25,0.25,0.25],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true
        },

        {
            name:  "Grid Light",     // "Grid Light",
            path:"GridLight",
            tonemap:1,
            E_bias:-9.0,
            directLightColor: [0.5,0.5,0.5],
            ambientColor: [0.25,0.25,0.25],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Fusion Grey"],
            darkerFade: true
        },

        {
            name: "Plaza",             //  "Plaza",
            path:"Plaza",
            tonemap:1,
            E_bias:-13,
            directLightColor: [1,1,1],
            ambientColor: [0.25,0.25,0.25],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Sky Blue"],
            darkerFade: false
        },

        {
            name: "Snow Field",            //  "Snow Field",
            path:"SnowField",
            tonemap:1,
            E_bias:-11.5,
            directLightColor: [0.8,0.8,0.8],
            ambientColor: [0.25,0.25,0.25],
            lightMultiplier: 1.0,
            bgColorGradient: bg["Sky Blue"],
            darkerFade: false
        }
    ];

    avp.DebugEnvironments = [
             //More RaaS ones

        {
                name: "Field",            //  "Field",
                path:"field",
                tonemap:1,
                E_bias:-2.9,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Sky Blue"],
                darkerFade: false
            },
            {
                name: "Crossroads",         //  "Crossroads",
                path:"crossroads",
                tonemap:1,
                E_bias:-5.5,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Sky Blue"],
                darkerFade: false
            },

            {
                name: "Seaport",            //  "Seaport",
                path:"seaport",
                tonemap:1,
                E_bias:-6.5,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Sky Blue"],
                darkerFade: false
            },

            {
                name: "Glacier",            //  "Glacier",
                path:"glacier",
                tonemap:1,
                E_bias:0,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Midnight"],
                darkerFade: false
            },

            {
                name: "Boardwalk",           //  "Boardwalk",
                path:"boardwalk",
                tonemap:1,
                E_bias:-7.0,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["Sky Blue"],
                darkerFade: false
            },

            {
                name: "RaaS Test Env",
                path:"Reflection",
                tonemap:2,
                E_bias:-1.5,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["RaaS SBS"],
                darkerFade: false
            },

            {
                name: "RaaS Test Env 2",
                path:"ReflectionBlinn",
                tonemap:2,
                E_bias:-1.5,
                directLightColor: [1,1,1],
                lightMultiplier: 0.0,
                bgColorGradient: bg["RaaS SBS"],
                darkerFade: false
            },

//            { name: "Sepulveda",    path:"Sepulveda",    tonemap:3, E_bias:0.7,     lightMultiplier: 0.0, bgColorGradient: bg["Sky Blue"] },
    ];

    if (ENABLE_DEBUG) {
        avp.LightPresets = avp.LightPresets.concat(avp.DebugEnvironments);
    }


    avp.CreateCubeMapFromColors = function(ctop, cbot) {
        var r1 = ctop.x * 255, g1 = ctop.y * 255, b1 = ctop.z * 255,
            r2 = cbot.x * 255, g2 = cbot.y * 255, b2 = cbot.z * 255;

        var pixelsTop = new Uint8Array(16);
        var pixelsBot = new Uint8Array(16);
        var pixelsSide = new Uint8Array(16);

        for (var i=0; i<4; i++) {
            pixelsTop[i*4] = r1;
            pixelsTop[i*4+1] = g1;
            pixelsTop[i*4+2] = b1;
            pixelsTop[i*4+3] = 255;

            pixelsBot[i*4] = r2;
            pixelsBot[i*4+1] = g2;
            pixelsBot[i*4+2] = b2;
            pixelsBot[i*4+3] = 255;

            if (0 | (i / 2)) {
                pixelsSide[i*4] = r1;
                pixelsSide[i*4+1] = g1;
                pixelsSide[i*4+2] = b1;
                pixelsSide[i*4+3] = 255;
            }
            else {
                pixelsSide[i*4] = r2;
                pixelsSide[i*4+1] = g2;
                pixelsSide[i*4+2] = b2;
                pixelsSide[i*4+3] = 255;
            }
        }

        var x_neg = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );
        var x_pos = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );
        var y_neg = new THREE.DataTexture( pixelsBot, 2, 2, THREE.RGBAFormat );
        var y_pos = new THREE.DataTexture( pixelsTop, 2, 2, THREE.RGBAFormat );
        var z_neg = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );
        var z_pos = new THREE.DataTexture( pixelsSide, 2, 2, THREE.RGBAFormat );

        var texture = new THREE.Texture(null, new THREE.CubeReflectionMapping(),
                                        THREE.RepeatWrapping, THREE.RepeatWrapping,
                                        THREE.LinearFilter, THREE.LinearFilter,
                                        //THREE.NearestFilter, THREE.NearestFilter,
                                        THREE.RGBAFormat);
        texture.image = [x_pos, x_neg, y_pos, y_neg, z_pos, z_neg];
        texture.needsUpdate = true;

        return texture;
    };


    avp.DefaultLightPreset = 1;
    avp.DefaultLightPreset2d = 0;


})();
;AutodeskNamespace('Autodesk.Viewing.Private');


/** @constructor */
Autodesk.Viewing.Private.MaterialManager = function (viewer)
{
    var _viewer = viewer;
    var avp = Autodesk.Viewing.Private;
    var _this = this;

    var _materials = this.materials = {};
    this.textures = {};
    this.layerMaskTex = null;
    this.reflectionCube = null;
    this.irradianceMap = null;
    var _texturesToUpdate = [];

    this.defaultMaterial = new THREE.MeshPhongMaterial({
                    ambient: 0x030303,
                    color: 0x777777,
                    specular: 0x333333,
                    shininess: 30,
                    shading: THREE.SmoothShading
                });

    //Maps a relative resource path (like a pack file or texture)
    //to an absolute URL (possibly signed).
    //TODO: Duplicated from SvfLoader temporarily. Needs to be unified somewhere
    //in a common location
    function pathToURL(path) {

        if (path.substr(0,7) == "http://" ||
            path.substr(0,8) == "https://" ||
            path.substr(0,8) == "file:///" ||
            path.substr(0,4) == "urn:") {
            return path;
        }

        var rootRelPath = window.location.pathname;
        //chop off the index.html part
        var lastSlash = rootRelPath.lastIndexOf("/");
        rootRelPath = rootRelPath.substr(0, lastSlash+1);
        var absPath = window.location.protocol + "//" + window.location.host + rootRelPath + path;
        //stderr(absPath);
        return absPath;
    }


    function is2dMaterial(name) {
        return name.indexOf("__lineMaterial__") != -1;
    }


    function getMaterialHash(svf, name) {

        if (is2dMaterial(name))
            return name;

        //In the Protein file, the materials have unhelpful names
        //like 0, 1, 2, so we prefix them with the SVF path to make them unique
        return svf.basePath + "|mat|" + name;
    }

    this.findMaterial = function(model, name) {
        var mat = _materials[getMaterialHash(model, name)];

        //It's not expected that the material is null here, but in case
        //it is, warn and pick the first one available.
        if (!mat) {
            stderr("Unknown material " + name + ". Using default.");
            mat = this.defaultMaterial;
        }

        return mat;
    };

    //Convert from LMV materials json to THREE.js materials
    this.convertMaterials = function(svf) {

        if (!svf.materials) {
            return;
        }

        //get outer Protein materials block
        var prmats = svf.materials["materials"];

        for (var p in prmats) {
            var simplemat = svf.simplemats[p];

            var matName = getMaterialHash(svf, p);

            if (simplemat) {
                //The type of the color does not survive the transfer
                //from the web worker, so we restore it. The other properties
                //of the material are ok.
                simplemat.color = new THREE.Color().copy(simplemat.color);
                simplemat.ambient = new THREE.Color().copy(simplemat.ambient);
                simplemat.specular = new THREE.Color().copy(simplemat.specular);
                simplemat.emissive = new THREE.Color().copy(simplemat.emissive);

                //Remember the uris of all the textures too, we need that
                //for the material heuristics.
                var phongMat = new THREE.MeshPhongMaterial(simplemat);

                //Things we store into the materials for our own purposes
                phongMat.proteinType = simplemat.proteinType;
                phongMat.proteinMat = prmats[p];
                phongMat.tag = simplemat.tag;

                phongMat.metal = simplemat.metal;

                if ( !_isIE11
                     && (simplemat.doubleSided || svf.doubleSided)) //TODO: do we want to check the global flag or drop that and rely on material only?
                {
                    phongMat.side = THREE.DoubleSide;
                }

                for (var uri in simplemat) {
                    if (uri.indexOf("uri_") == 0) {
                        phongMat[uri] = simplemat[uri];
                    }
                    if (uri.indexOf("uscale_") == 0) {
                        phongMat[uri] = simplemat[uri];
                    }
                    if (uri.indexOf("vscale_") == 0) {
                        phongMat[uri] = simplemat[uri];
                    }
                }

                this.addMaterial(matName, phongMat);
            } else {
                var phongMat = new THREE.MeshPhongMaterial({
                    ambient: 0x030303,
                    color: 0x777777,
                    specular: 0x333333,
                    shininess: 30,
                    shading: THREE.SmoothShading
                });

                phongMat.proteinMat = prmats[p];

                //Unknown material
                this.addMaterial(matName, phongMat);
            }
        }
    };

    //Called at the beginning of every frame, to perform pending
    //operations like texture updates. This function also
    //has a chance to request full repaint at that time.
    this.updateMaterials = function() {

        while(_texturesToUpdate.length)
        {
            var def = _texturesToUpdate.pop();
            for (var j=0; j<def.mats.length; j++) {
                def.mats[j][def.slot] = def.tex;
                def.mats[j].needsUpdate = true;

                //If we knew that there are no transparent materials in the scene,
                //we could just do a needsRender here instead of needsClear, to avoid flashing the model
                //while loading textures.
                _viewer.invalidate(true/*clear*/, false/*render*/, false/*overlay*/);
            }
        }

    };



    function loadTextureWithSecurity(path, mapping, callback) {

        if (auth) {
            // CORS with credentials is only supported by viewing service ITEM API.
            // So check if we are using ITEM API and if we do, enable credentials.
            //TODO: This check is a bit of a hack -- we should do something more robust
            if (path.indexOf('/items/') != -1) {
                THREE.ImageUtils.crossOrigin = "use-credentials";
            } else {
                THREE.ImageUtils.crossOrigin = "";
            }
        }

        return THREE.ImageUtils.loadTexture(path, mapping, callback);
    }

    //Textures delayed until all geometry is loaded,
    //hence not done in convertMaterials
    this.loadTextures = function(svf) {
        var scope = _this;

        for (var p in _materials) {
            var material = _materials[p];
            if (material) {

                var onTexLoad = function(tex) {
                    //Texture loaded successfully
                    var def = scope.textures[tex.name];

                    //Set it on all materials that use it
                    for (var i=0; i<def.mats.length; i++)
                        def.mats[i][def.slots[i]] = tex;

                    //Keep track of materials that need updating on the
                    //next frame. We can use this to throttle texture GPU upload
                    _texturesToUpdate.push(def);
                };

                var maps = ["map", "bumpMap", "specularMap", "normalMap", "alphaMap" /*, "envMap"*/];

                if (material.bumpScale && material.bumpScale >= 1.0)
                    material.bumpScale = 0.03;

                for (var i=0; i<maps.length; i++) {
                    var uriField = "uri_"+maps[i];
                    var uri = material[uriField];

                    if (uri) {
                        if (scope.textures[uri]) {
                            scope.textures[uri].mats.push(material);
                            scope.textures[uri].slots.push(maps[i]);
                        } else {
                            var isEnvMap = (maps[i] == "envMap");

                            //Some materials come with backslashes in the
                            //relative texture path. Until this is fixed on the
                            //translation side, we have to handle it here.
                            uri = uri.replace(/\\/g, "/");

                            var texPath = pathToURL(svf.basePath + uri);

                            // URL encode the 'urn:foo' part of texture path which might contain
                            // URL hostile chars that would fail viewing service.

                            var index = texPath.indexOf('urn:');
                            if (index != -1) {
                                texPath = texPath.substr(0, index) + encodeURIComponent(texPath.substr(index));
                                texPath += "?domain=" + window.location.hostname;
                            }

                            var texture;
                            var uScale = material["uscale_"+maps[i]];
                            var vScale = material["vscale_"+maps[i]];
                            if (!uScale) uScale = 1;
                            if (!vScale) vScale = 1;


                            if (isEnvMap)
                                texture = loadTextureWithSecurity(texPath, new THREE.SphericalReflectionMapping(), onTexLoad);
                            else
                                texture = loadTextureWithSecurity(texPath, new THREE.UVMapping(), onTexLoad);

                            texture.name = uri;
                            scope.textures[uri] = { mats: [material], slots: [maps[i]], tex: texture };

                            if (maps[i] == "alphaMap")
                                material.transparent = true;

                            if (maps[i] == "bumpMap" || maps[i] == "normalMap") {
                                texture.anisotropy = 0;

                                //Linear makes Protein grass materials look better,
                                //but ruins Prism paint... so let's bias for Prism for now.
                                //texture.minFilter = THREE.LinearFilter;
                                //texture.magFilter = THREE.LinearFilter;
                            }
                            else {

                                texture.anisotropy = _viewer.renderer().getMaxAnisotropy();
                            }

                            texture.repeat.set(uScale, vScale);
                            texture.wrapS = THREE.RepeatWrapping;
                            texture.wrapT = THREE.RepeatWrapping;
                            texture.flipY = !isEnvMap;

                            //Remember the original env map in case
                            //we need to reset the view
                            if (isEnvMap)
                                svf.envMap = texture;
                        }
                    }
                }
            }
        }
    };


    this.create2DMaterial = function(material, isIdMaterial, isSelectionMaterial) {

        //Create a hash string of the material to see if we have
        //already created it
        var hash = "__lineMaterial__";
        if (material.image)
            hash += "|image:" + material.image.name;
        if (material.clip)
            hash += "|clip:" + JSON.stringify(material.clip);
        if (isIdMaterial)
            hash += "|id";
        if (isSelectionMaterial)
            hash += "|selection";
        if (material.skipEllipticals)
            hash += "|skipEllipticals";
        if (material.skipCircles)
            hash += "|skipCircles";
        if (material.skipTriangleGeoms)
            hash += "|skipTriangleGeoms";

        hash = getMaterialHash(null, hash);

        if (!_materials.hasOwnProperty(hash))
        {
            var lineMaterial = new THREE.ShaderMaterial(
                {
                    fragmentShader: LineShader.fragmentShader,
                    vertexShader: LineShader.vertexShader,
                    uniforms: THREE.UniformsUtils.clone( LineShader.uniforms ),
                    attributes: LineShader.attributes,
                    defines: THREE.UniformsUtils.clone(LineShader.defines),
                    transparent: true
                }
            );

            lineMaterial.depthWrite = false;
            lineMaterial.depthTest = false;
            lineMaterial.side = THREE.DoubleSide;
            lineMaterial.blending = THREE.NormalBlending;

            if (isIdMaterial) {
                //Is the caller requesting the special case of
                //shader that outputs just IDs (needed when MRT not available)?
                lineMaterial.defines["ID_COLOR"] = 1;
                lineMaterial.blending = THREE.NoBlending;
            }
            else if (isSelectionMaterial) {
                lineMaterial.defines["SELECTION_RENDERER"] = 1;
            }
            else if (_viewer.renderer().hasMRT()){
                //If the renderer can do MRT, enable it in the shader
                //so we don't have to draw the ID buffer separately.
                lineMaterial.defines["MRT_ID_BUFFER"] = 1;
            }

            if (!material.skipEllipticals) {
                lineMaterial.defines["HAS_ELLIPTICALS"] = 1;
            }

            if (!material.skipCircles) {
                lineMaterial.defines["HAS_CIRCLES"] = 1;
            }

            if (!material.skipTriangleGeoms) {
                lineMaterial.defines["HAS_TRIANGLE_GEOMS"] = 1;
            }

            lineMaterial.uniforms["tLayerMask"].value = _this.layerMaskTex;

            if (material.image) {

                lineMaterial.defines["HAS_RASTER_QUADS"] = 1;

                function onTexLoad(texture) {
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.anisotropy = 1;
                    texture.flipY = true;

                    texture.needsUpdate = true;

                    lineMaterial.uniforms["tRaster"].value = texture;
                    if (material.image.dataURI.indexOf("png") != -1)
                        lineMaterial.transparent = true;
                    lineMaterial.needsUpdate = true;
                    _viewer.invalidate(false, true, false);
                }

                loadTextureWithSecurity(material.image.dataURI, new THREE.UVMapping(), onTexLoad);
            }

            _materials[hash] = lineMaterial;
        }

        return hash;
    };


//TODO: unify this logic with inittMaterials
    this.addMaterial = function(name, mat, skipHeuristics) {

        //Using post-gamma luminance, since input colors are assumed to
        //have gamma (non-linearized).
        function luminance(c) {
            return (0.299 * c.r) + (0.587 * c.g) + (0.114 * c.b);
        }

        var proteinMaterial = mat.proteinMat ? mat.proteinMat : null;
        var isPrism = (mat.proteinType && mat.proteinType.indexOf("Prism") != -1);

        //apply various modifications to fit our rendering pipeline
        if (!skipHeuristics){

            //This pile of crazy hacks maps the various flavors of materials
            //to the shader parameters that we can handle.

            if (mat.metal) {

                if (!mat.reflectivity) {
                    mat.reflectivity = luminance(mat.specular);
                }

                //Special handling for Protein and Prism metals
                if (proteinMaterial)
                {
                    //For Prism metals, reflectivity is set to 1 and
                    //the magnitude of the specular component acts
                    //as reflectivity.
                    if (mat.reflectivity === 1)
                        mat.reflectivity = luminance(mat.specular);

                    if (mat.color.r === 0 && mat.color.g === 0 && mat.color.b === 0) {
                        //Prism metals have no diffuse at all, but we need a very small
                        //amount of it to look reasonable
                        //mat.color.r = mat.specular.r * 0.1;
                        //mat.color.g = mat.specular.g * 0.1;
                        //mat.color.b = mat.specular.b * 0.1;
                    }
                    else {
                        //For Protein metals, we get a diffuse that is full powered, so we
                        //scale it down
                        mat.color.r *= 0.1;
                        mat.color.g *= 0.1;
                        mat.color.b *= 0.1;
                    }
                }
            }
            else if (!proteinMaterial) {

                //This section covers materials coming from ***DWF*** translation

                if (mat.reflectivity)
                {
                    //If reflectivity is set explicitly, but metal is not, assume
                    //the material is metallic anyway and set specular=diffuse

                    mat.metal = true;
                    mat.specular.r = mat.color.r * mat.reflectivity;
                    mat.specular.g = mat.color.g * mat.reflectivity;
                    mat.specular.b = mat.color.b * mat.reflectivity;

                    mat.color.r *= 0.1;
                    mat.color.g *= 0.1;
                    mat.color.b *= 0.1;
                }
                else if (mat.color.r === 1 && mat.color.g === 1 && mat.color.b === 1
                    && mat.specular.r === 1 && mat.specular.g === 1 && mat.specular.b === 1
                    && !mat.uri_map && !mat.uri_specularMap)
                {
                    //Detect metal materials based on diffuse = specular = 1
                    mat.metal = true;
                    mat.reflectivity = 0.7;
                    mat.specular.r = mat.specular.g = mat.specular.b = mat.reflectivity;

                    mat.color.r *= 0.1;
                    mat.color.g *= 0.1;
                    mat.color.b *= 0.1;
                }
            }
            else {
                //Non-metal materials

                if (isPrism)
                {
                    var isMetallic = false;

                    if (mat.proteinType == "PrismLayered")
                    {
                        //For layered materials, the Prism->Simple translator
                        //stores something other than reflectivity in the
                        //reflectivity term. We also do special handling
                        //for paint clearcoat, and metallic paint. Longer term,
                        //the good solution is to add things we do support to the Simple
                        //representation, or failing that, support native Prism definitions.
                        mat.clearcoat = true;
                        mat.reflectivity = 0.06;

                        if (proteinMaterial) {
                            var matDef = proteinMaterial["materials"][proteinMaterial["userassets"][0]];
                            var cats = matDef.categories;
                            if (cats && cats.length && cats[0].indexOf("Metal") != -1)
                            {
                                isMetallic = true;
                            }
                        }
                    }

                    //De-linearize this value in case of Prism, since there it
                    //seems to be physical (unlike the color values)
                    mat.reflectivity = Math.sqrt(mat.reflectivity);

                    if (isMetallic)
                    {
                        //metallic paint has specular = diffuse in Prism.
                        mat.specular.copy(mat.color);
                    }
                    else
                    {
                        //Prism non-metals just leave the specular term as 1,
                        //relying on reflectivity alone, but our shader needs
                        //both in different code paths.
                        mat.specular.r = mat.reflectivity;
                        mat.specular.g = mat.reflectivity;
                        mat.specular.b = mat.reflectivity;
                    }
                }
                else
                {
                    //Get a reasonable reflectivity value if there isn't any
                    if (!mat.reflectivity)
                    {
                        //For non-metallic materials, reflectivity
                        //varies very little in the range 0.03-0.06 or so
                        //and is never below 0.02.
                        mat.reflectivity = 0.01 + 0.06 * luminance(mat.specular);
                    }

                    //For non-metals, reflectivity is either set
                    //correctly or we estimate it above, and the specular color
                    //just carries the hue
                    //Note: Protein (but not Prism) seems to have consistently high reflectivity
                    //values for its non-metals.
                    mat.specular.r *= mat.reflectivity;
                    mat.specular.g *= mat.reflectivity;
                    mat.specular.b *= mat.reflectivity;
                }
            }

            //Set ambient to be a portion of diffuse -- this is generally
            //a good heuristic when using physically motivated shaders.
            //Note: this will only matter in case ambient light is turned on.
            mat.ambient.copy(mat.color);
            mat.ambient.r *= 0.3;
            mat.ambient.g *= 0.3;
            mat.ambient.b *= 0.3;

            //We want to add the environment reflection to the direct light.
            //TODO: does it make more sense to use a mix operation for non-metals?
            //mat.combine = THREE.AddOperation;
            mat.combine = THREE.MixOperation;

            //Alpha test for materials with textures that are potentially opacity maps
            if (mat.transparent
            || (mat.uri_map && mat.uri_map.toLowerCase().indexOf(".png") != -1)
            || mat.uri_opacityMap) {
                mat.alphaTest = 0.01;
            }
        }

        if (mat.uri_normalMap)
        {
            var scale = mat.bumpScale;
            if (scale === undefined || scale >= 1)
                scale = 1;

            mat.normalScale = new THREE.Vector2(scale, scale);
        }
        else
        {
            if (mat.bumpScale === undefined && (mat.uri_map || mat.uri_bumpMap))
                mat.bumpScale = 0.03; //seems like a good subtle default if not given
            else if (mat.bumpScale >= 1) //Protein generic mat sometimes comes with just 1.0 which can't be right...
                mat.bumpScale = 0.03;
        }

        //mat.shininess *= 0.25;

        if (_this.reflectionCube)
            mat.envMap = _this.reflectionCube;

        if (_this.irradianceMap)
            mat.irradianceMap = _this.irradianceMap;

        mat.exposureBias = Math.pow(2.0, _viewer.renderer().getExposureBias());
        mat.tonemapOutput = _viewer.renderer().getToneMapMethod();

        mat.mrtNormals = _viewer.renderer().hasMRT() && _viewer.renderer().settings.sao;

        //if (mat.opacity < 1.0 || mat.uri_opacityMap)
        //    mat.side = THREE.DoubleSide;

        if (mat.side == THREE.DoubleSide)
            _viewer.renderer().toggleTwoSided(true);

        _materials[name] = mat;
    };


    this.togglePolygonOffset = function(state) {

        for (var p in _materials) {
            var mat = _materials[p];
            if (mat instanceof THREE.MeshPhongMaterial) {
                mat.polygonOffset = true;
                mat.polygonOffsetFactor = state ? 1 : 0;
                mat.polygonOffsetUnits = state ? 1 : 0;
                mat.needsUpdate = true;
            }
        }

    };

    //Certain material properties only become available
    //once we see a geometry that uses the material. Here,
    //we modify the material based on a given geometry that's using it.
    this.applyGeometryFlagsToMaterial = function(material, threegeom) {

        if (threegeom.attributes.color) {
            //TODO: Are we likely to get the same
            //material used both with and without vertex colors?
            //If yes, then we need two versions of the material.
            material.vertexColors = THREE.VertexColors;
            material.needsUpdate = true;
        }

        //If we detect a repeating texture in the geometry, we assume
        //it is some kind of material roughness pattern and reuse
        //the texture as a low-perturbation bump map as well.
        if (!material.proteinType && threegeom.attributes.uv && threegeom.attributes.uv.isPattern) {
            if (material.map && !material.bumpMap) {
                material.bumpMap = material.map;
                material.needsUpdate = true;
            }
            if (material.uri_map && !material.uri_bumpMap) {
                material.uri_bumpMap = material.uri_map;
                material.needsUpdate = true;
            }
        }

    };

    //Turns MRT rendering on/off in each material's shader
    this.toggleMRTSetting = function(state) {

        for (var p in _materials) {
            var m = _materials[p];
            if (m.mrtNormals !== state) {
                m.mrtNormals = state;
                m.needsUpdate = true;
            }
        }

    };

    this.updatePixelScale = function(pixelsPerUnit) {

        var mats = _materials;
        for (var p in mats) {
            if (is2dMaterial(p)) {
                mats[p].uniforms["unitsPerPixel"].value = 1.0 / pixelsPerUnit;
                mats[p].uniforms["pixelsPerUnit"].value = pixelsPerUnit;
            }
        }

    };



    this.setCubeMapFromColors = function(ctop, cbot) {

        var texture = avp.CreateCubeMapFromColors(ctop, cbot);

        _this.reflectionCube = texture;
        _this.reflectionCube.isBgColor = true;

        for (var p in _materials) {
            var m = _materials[p];
            m.envMap = texture;
            m.needsUpdate = true;
        }

        _viewer.invalidate(true);
    };

    this.setCubeMap = function(path) {

        var scope = _this;
        var texLoadDone = function(map) {

            //Case where we use environment from the SVF model
            //Not currently supported all the way through
            //var svf = scope.model ? scope.model.getData() : null;
            //scope.reflectionCube = (map === undefined) && svf ? svf.envMap : map;
            scope.reflectionCube = map;

            if (scope.reflectionCube)
            {
                for (var p in _materials) {
                    var m = _materials[p];
                    m.envMap = scope.reflectionCube;
                    m.needsUpdate = true;
                }
            }
            else
            {
                scope.setCubeMapFromColors(_viewer.clearColorTop, _viewer.clearColorBottom);
            }

            _viewer.invalidate(true);
        };

        if (Array.isArray(path)) {
             _this.reflectionCube = THREE.ImageUtils.loadTextureCube(path, new THREE.CubeReflectionMapping(), texLoadDone);
             _this.reflectionCube.format = THREE.RGBFormat;
        }
        else if (typeof path == "string") {
            if (path.toLowerCase().indexOf(".dds") != -1) {
                _this.reflectionCube = new THREE.DDSLoader().load(path, texLoadDone);
                _this.reflectionCube.mapping = new THREE.CubeReflectionMapping();
                //_this.reflectionCube = THREE.ImageUtils.loadCompressedTextureCube(path, new THREE.CubeReflectionMapping(), texLoadDone);
                _this.reflectionCube.LogLuv = path.indexOf("logluv") != -1;
            }
            else {
                _this.reflectionCube = THREE.ImageUtils.loadTexture(path, new THREE.SphericalReflectionMapping(), texLoadDone);
                _this.reflectionCube.format = THREE.RGBFormat;
            }
        } else if (path) {
            //here we assume path is already a texture object
            texLoadDone(path);
        }
        else {
            texLoadDone(null);
        }
    };


    this.setIrradianceMap = function(path) {
        var scope = _this;

        var texLoadDone = function(map) {

            if (map)
            {
                for (var p in _materials) {
                    var m = _materials[p];
                    m.irradianceMap = map;
                    m.needsUpdate = true;
                }

                scope.irradianceMap = map;
            }
            else
            {
                if (scope.irradianceMap)
                {
                    for (var p in _materials) {
                        var m = _materials[p];
                        m.irradianceMap = null;
                        m.needsUpdate = true;
                    }

                    scope.irradianceMap = null;
                }
            }

            _viewer.invalidate(true);
        };

        THREE.ImageUtils.crossOrigin = "";

        if (Array.isArray(path)) {
             _this.irradianceMap = THREE.ImageUtils.loadTextureCube(path, new THREE.CubeReflectionMapping(), texLoadDone);
             _this.irradianceMap.format = THREE.RGBFormat;
        }
        else if (typeof path == "string") {
            if (path.toLowerCase().indexOf(".dds") != -1) {
                _this.irradianceMap = new THREE.DDSLoader().load(path, texLoadDone);
                _this.irradianceMap.mapping = new THREE.CubeReflectionMapping();
                _this.irradianceMap.LogLuv = path.indexOf("logluv") != -1;
            }
        } else if (path) {
            //here we assume path is already a texture object
            texLoadDone(path);
        }
        else {
            texLoadDone(null);
        }

    };


    this.setTonemapMethod = function(method) {

        for (var p in _materials) {
            var m = _materials[p];
            m.tonemapOutput = method;
            m.needsUpdate = true;
        }

    };

    this.setExposureBias = function(exposureBias) {

        var bias = Math.pow(2.0, exposureBias);

        for (var p in _materials) {
            var m = _materials[p];
            m.exposureBias = bias;
            m.needsUpdate = true;
        }

    };


    //Creates a texture where each pixel corresponds to the visibility
    //of a 2D layer. The LineShader samples the texture to determine if
    //a geometry is visible based on its layer visibility.
    this.initLayersTexture = function(model) {

        //TODO: Once arbitrary layer texture size works
        //we can base the allocation size on the layerCount
        var count = model.getData().layerCount;
        var tw = 256;

        //TODO: Currently the shader math is limited to
        //a square 256x256 layers mask, since it just does a
        //scale of the two layer bytes by 1/255. We would need to
        //send the height of the layer texture to do something smarter,
        //or wait for texture size query in WebGL 2.
        //var th = 0 | Math.ceil((layersList.length) / 256.0);
        var th = 256;

        var layerMask = new Uint8Array(tw * th);
        for (var l= 0, lEnd = count; l<lEnd; l++) {
            layerMask[l] = 0xff;
        }

        var layerMaskTex = new THREE.DataTexture(layerMask, tw, th,
                                                 THREE.LuminanceFormat,
                                                 THREE.UnsignedByteType,
                                                 new THREE.UVMapping(),
                                                 THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
                                                 THREE.NearestFilter, THREE.NearestFilter, 0);
        layerMaskTex.generateMipmaps = false;
        layerMaskTex.flipY = false;
        layerMaskTex.needsUpdate = true;

        //TODO: These are per-model, so we will need
        //to remember multiple sets in case we support
        //multi-drawing views.
        this.layerMaskTex = layerMaskTex;
        this.layersMap = model.getData().layersMap;

    };


    this.initSelectionMaterial = function(model) {

        var numObj = model.myData.maxObjectNumber || 1;
        var tw = 4096; //NOTE: This size is assumed in the shader, so update the shader if this changes!
        var th = 0 | Math.ceil(numObj / tw);
        var p2 = 1;
        while (p2 < th)
            p2 *= 2;
        th = p2;

        var selectionMask = new Uint8Array(tw*th);
        for (var i= 0; i<numObj; i++) {
            selectionMask[i] = 0;
        }

        //selectionMask[384] = 0xff;

        var selectionTex = new THREE.DataTexture(selectionMask, tw, th,
                                                 THREE.LuminanceFormat,
                                                 THREE.UnsignedByteType,
                                                 new THREE.UVMapping(),
                                                 THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
                                                 THREE.NearestFilter, THREE.NearestFilter, 0);
        selectionTex.generateMipmaps = false;
        selectionTex.flipY = false;
        selectionTex.needsUpdate = true;

        this.selectionTex = selectionTex;

        var hash = this.create2DMaterial({}, false, true);
        var m = _materials[hash];

        m.uniforms["tSelectionTexture"].value = this.selectionTex;
        m.uniforms["vSelTexSize"].value.set(tw, th);
        m.needsUpdate = true;

        return m;
    };

    //Toggles 2D layer visibility by setting the corresponding
    //pixel in the layers texture.
    this.setLayerVisible = function(layerIndexes, visible){
        var layerMaskTex = this.layerMaskTex,
            layerMaskData = layerMaskTex.image.data,
            layersMap = this.layersMap,
            mask = visible ? 0xff : 0;

        for (var i = 0; i < layerIndexes.length; ++i) {
            var layerIndex = layerIndexes[i];
            layerMaskData[layersMap[layerIndex]] = mask;
        }

        layerMaskTex.needsUpdate = true;

        for (var p in _materials) {
            if (is2dMaterial(p))
                _materials[p].needsUpdate = true;
        }

        _viewer.invalidate(true);
    };

    this.isLayerVisible = function (layerIndex) {
        return !!this.layerMaskTex.image.data[this.layersMap[layerIndex]];
    };

    //Meshes for 2d drawings contain many objects in a single mesh.
    //So we use a mask texture to pick out which object specifically
    //to highlight. The shader samples this texture to deside whether
    //to draw or not.
    this.highlightObject2D = function(dbId, state) {

        var data = this.selectionTex.image.data;

        data[dbId] = state ? 0xff : 0;

        //TODO: partial texture update using TexSubImage possible?
        this.selectionTex.needsUpdate = true;

        _viewer.invalidate(false, false, true);

    };



    //Register the default material
    this.addMaterial("__defaultMaterial__", this.defaultMaterial);


};
;AutodeskNamespace('Autodesk.Viewing.Private');

Autodesk.Viewing.Private.INTERPOLATION_TYPE = {
    LINEAR: 0,
    CATMULLROM: 1,
    CATMULLROM_FORWARD: 2,
};

Autodesk.Viewing.Private.AnimationHandler = function() {
    this.animations = [];
};

Autodesk.Viewing.Private.AnimationHandler.prototype.init = function(data) {
    // return same data if initialized
    if (data.initialized === true) return data;

    // loop through all keys
    for (var h = 0; h < data.hierarchy.length; h++) {
        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
            // remove minus times
            if (data.hierarchy[h].keys[k].time < 0 ) {
                 data.hierarchy[h].keys[k].time = 0;
            }

            // create quaternions
            if (data.hierarchy[h].keys[k].rot !== undefined &&
              ! (data.hierarchy[h].keys[k].rot instanceof THREE.Quaternion)) {
                var quat = data.hierarchy[h].keys[k].rot;
                data.hierarchy[h].keys[k].rot = new THREE.Quaternion().fromArray(quat);
            }
        }

        // remove all keys with same time
        for (var k = 1; k < data.hierarchy[h].keys.length; k++) {
            if (data.hierarchy[h].keys[k].time === data.hierarchy[h].keys[k - 1].time) {
                data.hierarchy[h].keys.splice(k, 1);
                k--;
            }
        }

        // set index
        for (var k = 0; k < data.hierarchy[h].keys.length; k++) {
            data.hierarchy[h].keys[k].index = k;
        }
    }
    data.initialized = true;
    return data;    
};

Autodesk.Viewing.Private.AnimationHandler.prototype.parse = function(root) {
    function parseRecurseHierarchy(root, hierarchy) {
        hierarchy.push(root);

        // check Object3D.children if not defined
        // do not animate camera's light node
        if (root.children && !(root instanceof THREE.Camera)) {
            for(var c = 0; c < root.children.length; c++)
                parseRecurseHierarchy(root.children[c], hierarchy);
        }
    }
    var hierarchy = [];
    parseRecurseHierarchy( root, hierarchy );
    return hierarchy;
};

Autodesk.Viewing.Private.AnimationHandler.prototype.play = function(animation) {
    if (this.animations.indexOf(animation) === -1) {
        this.animations.push(animation);
    }
};

Autodesk.Viewing.Private.AnimationHandler.prototype.stop = function(animation) {
    var index = this.animations.indexOf(animation);
    if (index !== -1) {
        this.animations.splice(index, 1);
    }
};

Autodesk.Viewing.Private.AnimationHandler.prototype.update = function(deltaTimeMS) {
    for (var i = 0; i < this.animations.length; i++) {
        this.animations[i].update(deltaTimeMS);
    }
};

Autodesk.Viewing.Private.Animation = function(root, data, animator) {
    this.root = root;
    this.handler = animator.animationHandler;
    this.data = this.handler.init(data);
    this.hierarchy = this.handler.parse(root);
    this.viewer = animator.viewer;
    this.animator = animator;

    this.currentTime = 0;
    this.timeScale = 1;

    this.isPlaying = false;
    this.isPaused = true;
    this.loop = false;
    this.delta = 0.5;

    this.interpolationType = Autodesk.Viewing.Private.INTERPOLATION_TYPE.LINEAR;

    if (this.hierarchy.length > 0) {
        // root of hierarchy should have key time covering animation
        var keys = this.data.hierarchy[0].keys;
        this.startKeyTime = keys[0].time;
        this.endKeyTime = keys[keys.length-1].time;
    } else {
        this.startKeyTime = this.endKeyTime = 0;
    }
};

Autodesk.Viewing.Private.Animation.prototype.keyTypes = [];
Autodesk.Viewing.Private.Animation.prototype.defaultKey = {};

Autodesk.Viewing.Private.Animation.prototype.play = function(startTime) {
    this.currentTime = startTime !== undefined ? startTime : 0;
    this.isPlaying = true;
    this.isPaused = false;
    this.reset();
    this.handler.play(this);
};

Autodesk.Viewing.Private.Animation.prototype.pause = function() {
    if (this.isPaused === true) {
        this.handler.play(this);
    } else {
        this.handler.stop(this);
    }
    this.isPaused = !this.isPaused;
};

Autodesk.Viewing.Private.Animation.prototype.stop = function() {
    this.isPlaying = false;
    this.isPaused  = false;
    this.handler.stop(this);
};

Autodesk.Viewing.Private.Animation.prototype.goto = function(time) {
    if (!this.isPlaying) this.play();
    if (!this.isPaused) this.pause();
    var delta = time - this.currentTime;
    this.update(delta);
};

Autodesk.Viewing.Private.Animation.prototype.reset = function() {
    for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
        var object = this.hierarchy[h];

        if (object.animationCache === undefined) {
            object.animationCache = {};
        }

        if (object.animationCache[this.data.name] === undefined) {
            object.animationCache[this.data.name] = {};
            object.animationCache[this.data.name].prevKey = this.defaultKey;
            object.animationCache[this.data.name].nextKey = this.defaultKey;
            object.animationCache[this.data.name].originalMatrix = object.matrix;
        }

        // get keys to match our current time
        var animationCache = object.animationCache[this.data.name];
        for (var t = 0; t < this.keyTypes.length; t++) {
            var type = this.keyTypes[t];
            var prevKey = this.data.hierarchy[h].keys[0];
            var nextKey = this.getNextKeyWith(type, h, 1);
            while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                prevKey = nextKey;
                nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
            }
            animationCache.prevKey[type] = prevKey;
            animationCache.nextKey[type] = nextKey;
        }
    }
};

Autodesk.Viewing.Private.Animation.prototype.getNextKeyWith = function (type, h, key) {
    var keys = this.data.hierarchy[h].keys;
    if (this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM ||
        this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
        key = key < keys.length - 1 ? key : keys.length - 1;
    } else {
        key = key % keys.length;
    }

    for (; key < keys.length; key++) {
        if (keys[key][type] !== undefined) {
            return keys[key];
        }
    }
    return this.data.hierarchy[h].keys[0];
};

Autodesk.Viewing.Private.Animation.prototype.getPrevKeyWith = function (type, h, key) {
    var keys = this.data.hierarchy[h].keys;
    if (this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM ||
        this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
        key = key > 0 ? key : 0;
    } else {
        key = key >= 0 ? key : key + keys.length;
    }

    for (; key >= 0; key--) {
        if (keys[key][type] !== undefined) {
            return keys[key];
        }
    }
    return this.data.hierarchy[h].keys[keys.length - 1];
};

Autodesk.Viewing.Private.Animation.prototype.isPlayingOutOfRange = function() {
    return (this.isPaused === false && (this.currentTime < this.startKeyTime - this.delta ||
            this.currentTime > this.endKeyTime + this.delta))
};

Autodesk.Viewing.Private.MeshAnimation = function(root, data, animator) {
    Autodesk.Viewing.Private.Animation.call(this, root, data, animator);
    this.originalMatrix = root.matrix.clone();
    this.localMatrix = new THREE.Matrix4();
};

Autodesk.Viewing.Private.MeshAnimation.prototype = Object.create(Autodesk.Viewing.Private.Animation.prototype);
Autodesk.Viewing.Private.MeshAnimation.prototype.constructor = Autodesk.Viewing.Private.MeshAnimation;
Autodesk.Viewing.Private.MeshAnimation.prototype.keyTypes = ["pos", "rot", "scl"];
Autodesk.Viewing.Private.MeshAnimation.prototype.defaultKey = {pos: 0, rot: 0, scl: 0};

Autodesk.Viewing.Private.MeshAnimation.prototype.update = (function() {
    var points = [];
    var target = new THREE.Vector3();
    var newVector = new THREE.Vector3();
    var newQuat = new THREE.Quaternion();
    
    return function(delta) {
        if (this.isPlaying === false) return;
    
        this.currentTime += delta * this.timeScale;

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;
    
        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];
    
            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t ++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];
    
                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);
    
                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }
    
                var prevXYZ = prevKey[type];
                var nextXYZ = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevXYZ === undefined || nextXYZ === undefined) continue;
    
                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;
    
                // interpolate
                if (type === "pos") {    
                    if (this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.LINEAR) {
                        newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                        newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                        newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                        object.position.copy(newVector);
                    } else if (this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM ||
                        this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                        points[0] = this.getPrevKeyWith("pos", h, prevKey.index - 1)["pos"];
                        points[1] = prevXYZ;
                        points[2] = nextXYZ;
                        points[3] = this.getNextKeyWith("pos", h, nextKey.index + 1)["pos"];
    
                        scale = scale * 0.33 + 0.33;
    
                        var currentPoint = interpolateCatmullRom(points, scale);
                        newVector.x = currentPoint[0];
                        newVector.y = currentPoint[1];
                        newVector.z = currentPoint[2];
                        object.position.copy(newVector);
    
                        if (this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                            var forwardPoint = interpolateCatmullRom(points, scale * 1.01);
    
                            target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                            target.sub(vector);
                            target.y = 0;
                            target.normalize();
    
                            var angle = Math.atan2(target.x, target.z);
                            object.rotation.set(0, angle, 0);
                        }
                    }
                } else if (type === "rot") {
                    THREE.Quaternion.slerp(prevXYZ, nextXYZ, newQuat, scale);
                    object.quaternion.copy(newQuat);
                } else if (type === "scl") {
                    newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                    newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                    newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                    object.scale.copy(newVector);
                }
            }
            // compose local transform and multiply to original transform
            this.localMatrix.compose(object.position, object.quaternion, object.scale);
            object.matrix.multiplyMatrices(this.localMatrix, this.originalMatrix);
            object.matrixAutoUpdate = false;
            object.matrixWorldNeedsUpdate = true;

            // update world matrix so scene bounds can be set correctly
            object.updateMatrixWorld();
        }
    };
})();

Autodesk.Viewing.Private.CameraAnimation = function(root, data, animator) {
    Autodesk.Viewing.Private.Animation.call(this, root, data, animator);
};

Autodesk.Viewing.Private.CameraAnimation.prototype = Object.create(Autodesk.Viewing.Private.Animation.prototype);
Autodesk.Viewing.Private.CameraAnimation.prototype.constructor = Autodesk.Viewing.Private.CameraAnimation;
Autodesk.Viewing.Private.CameraAnimation.prototype.keyTypes = ["pos", "up", "target", "fov"];
Autodesk.Viewing.Private.CameraAnimation.prototype.defaultKey = {pos: 0, up: 0, target: 0, fov: 0};

Autodesk.Viewing.Private.CameraAnimation.prototype.update = (function() {
    var points = [];
    var target = new THREE.Vector3();
    var newVector = new THREE.Vector3();
    
    return function(delta) {
        if (this.isPlaying === false) return;

        this.currentTime += delta * this.timeScale;

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;
    
        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];
    
            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t ++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];
    
                if (nextKey.time <= this.currentTime  || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);
    
                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }
    
                var prevXYZ = prevKey[type];
                var nextXYZ = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevXYZ === undefined || nextXYZ === undefined) continue;
    
                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;
    
                // interpolate
                var vector;
                if (type === "pos") {
                    vector = object.position;
                } else if (type === "up") {   
                    vector = object.up;
                } else if (type === "target") {
                    vector = object.target;
                } else if (type === "fov") {
                    object.setFov(prevXYZ + (nextXYZ - prevXYZ) * scale);
                    continue;
                }

                if (this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.LINEAR) {
                    newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                    newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                    newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                    vector.copy(newVector);
                } else if (this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM ||
                    this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                    points[0] = this.getPrevKeyWith(type, h, prevKey.index - 1)[type];
                    points[1] = prevXYZ;
                    points[2] = nextXYZ;
                    points[3] = this.getNextKeyWith(type, h, nextKey.index + 1)[type];

                    scale = scale * 0.33 + 0.33;

                    var currentPoint = interpolateCatmullRom(points, scale);
                    newVector.x = currentPoint[0];
                    newVector.y = currentPoint[1];
                    newVector.z = currentPoint[2];
                    vector.copy(newVector);

                    if (this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                        var forwardPoint = interpolateCatmullRom(points, scale * 1.01);

                        target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                        target.sub(vector);
                        target.y = 0;
                        target.normalize();

                        var angle = Math.atan2(target.x, target.z);
                        object.rotation.set(0, angle, 0);
                    }
                }
            }
            object.matrixAutoUpdate = true;
            object.matrixWorldNeedsUpdate = true;
        }
        object.lookAt(object.target);
        this.animator.updateFlag |= this.animator.UPDATE_CAMERA;
    };
})();

Autodesk.Viewing.Private.VisibilityAnimation = function(root, data, node, animator) {
    Autodesk.Viewing.Private.Animation.call(this, root, data, animator);
    this.node = node;
    this.epsilon = 0.1;
};

Autodesk.Viewing.Private.VisibilityAnimation.prototype = Object.create(Autodesk.Viewing.Private.Animation.prototype);
Autodesk.Viewing.Private.VisibilityAnimation.prototype.constructor = Autodesk.Viewing.Private.VisibilityAnimation;
Autodesk.Viewing.Private.VisibilityAnimation.prototype.keyTypes = ["vis", "opa"];
Autodesk.Viewing.Private.VisibilityAnimation.prototype.defaultKey = {viz: 1, opa: 1};

Autodesk.Viewing.Private.VisibilityAnimation.prototype.update = (function() {
    return function(delta) {
        if (this.isPlaying === false) return;
    
        this.currentTime += delta * this.timeScale;

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;
    
        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];
            
            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t ++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevVis = prevKey[type];
                var nextVis = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevVis === undefined || nextVis === undefined) continue;
    
                if (type === "vis") {
                    var vis = Math.abs(this.currentTime - nextKey.time) < this.epsilon ? nextVis : prevVis;
                    this.viewer.visibilityManager.setVisibilityOnNode(this.node, vis);
                } else if (type === "opa") {
                    var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                    if (scale < 0) scale = 0;
                    if (scale > 1) scale = 1;
                    var opacity = prevVis + (nextVis - prevVis) * scale;
                    object.material.transparent = (opacity === 1? false : true);
                    object.material.opacity = opacity;
                    if (opacity > 0) this.viewer.visibilityManager.setVisibilityOnNode(this.node, 1);
                }
            }
        }
    };
})();

Autodesk.Viewing.Private.AnnotationAnimation = function(root, data, animator) {
    function createAnnotation(name, viewer, state) {
        var container = document.createElement('div');
        container.id = name;
        container.style.cursor = "pointer";
        container.style.visibility = state;

        var text = document.createElement('div');
        text.id = name + '-txt';
        text.style.cssText = 'display: none;position: absolute;z-index: 1;color: #eeeeee;font-family: consolas,courier,monospace;font-size: 14px;background: rgba(34,34,34,0.8);padding: 6px 6px 6px 6px;';
        container.appendChild(text);

        var icon = document.createElement('img');
        icon.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAABoZJREFUeNrEl1uMVVcZx39r329nnzNzzlwYBgq0BAhIQ4iKvShM2xgeDCY02kbl2Rol+GBiE5940QcfjI0xTRMTqm1DFFu5WGwLtqECsY5UNEpLEQiFYZjDmcvZZ++zb2v7MGcI1TntDDXpTtbD3lkr/9/61v/79rdEURR8ko/CJ/xo830UQnRdcNe2/kHFUHYKwSMIsVJAbwENiuJiUfCqTOSBy3+8cb3b+v+OuJjvCOYDWPZgX4/uqHt8v/TEpnvX22tW32P29pRV13VEqxUWjanp/N3zF+Izf/tHND3d/Hka5j+5cmJi8v8BIFY8PDCiGepz2z7/Oe/B+7Y4Sd4SURqS5jG5zAGJqmg4ho9nVoo3T70VHnv9zSCNs69dem38OFDcKYC4a6R/q+1Z+x/b+aXy8hWDRtCeRhEqumqgCAVZSNI8Js4i4qyNqij0+UsZuzKZ/Gr/gemoFX/j0rHxV+YgFgWg2aq1Ylv/5ccf/XJl2Yo+o522sHUPx/SxdAdFUZEyp52GhPEMQTxNlAYA9PtD3ByPkmf2PTf1/qn6ivZkEs0H8GFZoAzfX/v+lk9vdlbePWSEyQy27lF2alS9QWqlIfr8YWqlIareIGWnhmeWMTUbKXMmmmMML+8ztj3wgDO4uefJblpdAarr/F7Hs7418oX73MnWDTTFwDF9fLuXittHj9dPj9tPj9dPxe3Dt3txTB9Ts1EVjSxPmWhe5YsPbXMdz/lmdZ3fuxgAxR2wdmzcsM6SIhF5kaOrJpbuYBsejlnCMUqYmoVjlHDMErbhYekOumqiKLPZ3U4ipGiLz27aZLkD1o759LoBaIomRtasvscM4mkoQBEKiqKiqjqqon9gsqroqKqOoqgoQkEw66ECSStt8qn1601FEyPz1Z1uALpQxcbhoSVaOw0pKJCFRMqcPE/JZfqByblMyfMUKXNkISk6WScQJFmblcuWa0IVGwF9QZUQ0ISg5pdK4kaYogiVNI9ppyFREmDG9q2d5zIljJtESUC7UxukzGZ3pygIoFKuCCGozaenfcg/IhOAEAq5zIiziDCeQVcNAOI0QlV18jwlSgJmogZhPEOcReQyQwiBqmpomo6mal0jrnUt2ZJGq9VeYuqWGsYBcRYRxNMApHnStQ7EWURBga7qGJqJbbgEQVgUksaCf0aAlJm8dLMxtbbUV1bjLCLPM6I0QBY5cRbNuv1/KuHs7lVVxdBNLMPBsytcuzKWyUy+B8iFmjDPovzEP8+9m1a9AUzdRlVVcpkRJQHN9iRTUZ3JcIKpqE6zPUmUBLfETd3CMT1cy6NiVxk9ezbNovwEkC0UIGucD46cHv1LbCl+UXGrWIaNrukgIJMpSRYRZyFJFpHJFATomo5l2LhWCc/2KTs11MIq3jh1Im6cD44sBiCN6vHETD14/sirx8Lh6irKbhXXLmFbDqZhoms6mqahazqmYWJbDq5douRU8N0KZbeXPn8pvz78UjRdb74Q1eMJIF2wB4DW1ZM3f/pK6bXHN6xdp9+9epVxM7hGlIRkWUouMwoKBAJVmXW7qVtYhoNrleh1Bzn3zoXk4B8OR2N/bjwFtBbjAYC4kEVj5v3wez/7xdOt61ca+bLqavrLQ/SUavSW+m6Nufcer0a11M+Av5zLF6+lP3rqx63mtejJPJF1IJ63+/qIfsAE+nrXlL69ZE3tu1/ZsdPYPvIImYiIspA8Tyko0BQVQ3NwDA+lMIsXf/+79vMv7Y+a18K9429PHQAm5gAW3ZAALvCd428c/8HR04ect945Wdz/mS3p5o2blKVDQ2rJLYlWq1VcvT6Wj/79TPry8aPx2OUbv62fm3m23Uj+DdSBdreGRFtA47p29+7dI8NLhp2vPvx1/nX6/OgzTz974Zc9LyxXNGVYKLiFpCUzeSUN879OX2wdao23LwJTQBNIbm/JFmrC2z2yZdeuXVsajQb1er116MXDR4HfAAOA13F2AMwA053R6oQ8v6O2/Lbw37tnz54dlUrFC4KAffv2vQ28BzzUEZ8ELgNXgfGOaLoQ4YV4QAWeGB0d/aGU0qvX663t27e/3AmrBMaAY8AZIOyIyo8SXIwHnOHh4Q3VatVLkoS9e/deB3ygARwH/tSBiRYqvtgI2MBjW7dufdT3/drBgwfPAieB128TnjvnBV8wF5OGBlABVnVS8VLHbHMGyxYjfCcASueIzLkGpZNSdyT8sa5mnVF8HOFuAP8ZACU8JwMXmnEcAAAAAElFTkSuQmCC";
        icon.id = name + '-img';
        icon.style.cssText = 'display: block;position: absolute;z-index: 1;';
        container.appendChild(icon);

        viewer.api.container.appendChild(container);

        container.addEventListener('click', function () {
            text.style.display = text.style.display === 'none'? 'block' : 'none';
        });

        var color = 0x007F00;
        var opacity = 0.6;
        var geometry = new THREE.SphereGeometry(0.01);
        var materialPre = new THREE.MeshPhongMaterial({color:color, ambient:color, opacity:opacity, transparent:true});
        var materialPost = new THREE.MeshPhongMaterial({color:color, ambient:color, opacity:opacity, transparent:true});
        var mesh = new THREE.Mesh(geometry, materialPost);
        mesh.visible = false;

        // add annotation to an overlay scene
        if (viewer.overlayScenes["annotation"] === undefined) {
            viewer.createOverlayScene("annotation", materialPre, materialPost);
        }
        viewer.addOverlay("annotation", mesh);

        return mesh;
    }

    if (root === null) {
        root = createAnnotation(data.name, animator.viewer, 'hidden');
    }
    Autodesk.Viewing.Private.Animation.call(this, root, data, animator);
    this.id = data.name;
    this.text = "";
    this.state = 'hidden';
    var that = this;
    this.viewer.api.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, function(evt) {
        that.updateText(root.position, that.text);
    });
};

Autodesk.Viewing.Private.AnnotationAnimation.prototype = Object.create(Autodesk.Viewing.Private.Animation.prototype);
Autodesk.Viewing.Private.AnnotationAnimation.prototype.constructor = Autodesk.Viewing.Private.AnnotationAnimation;
Autodesk.Viewing.Private.AnnotationAnimation.prototype.keyTypes = ["pos", "text", "vis"];
Autodesk.Viewing.Private.AnnotationAnimation.prototype.defaultKey = {pos: 0, text: "", vis: 1};

Autodesk.Viewing.Private.AnnotationAnimation.prototype.updateText = function(position, text) {
    function projectToScreen(position, camera, canvas) {
        var pos = position.clone();
        var projScreenMat = new THREE.Matrix4();
        camera.updateMatrixWorld();
        camera.matrixWorldInverse.getInverse(camera.matrixWorld);
        projScreenMat.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        pos.applyProjection(projScreenMat);

        return {x: (pos.x + 1) * canvas.width / 2 + canvas.offsetLeft,
                y: (-pos.y + 1) * canvas.height / 2 + canvas.offsetTop};
    }
    var coord = projectToScreen(position, this.viewer.camera, this.viewer.canvas);
    var element = document.getElementById(this.id + '-txt');
    if (element) {
        element.innerHTML = text;
        element.style.left = coord.x + 'px';
        element.style.top = coord.y + 'px';
        this.text = text;
    }
    element = document.getElementById(this.id + '-img');
    if (element) {
        element.style.left = coord.x + 'px';
        element.style.top = coord.y - 24 + 'px'; // adjust based on image height
    }
};

Autodesk.Viewing.Private.AnnotationAnimation.prototype.update = (function() {
    var points = [];
    var target = new THREE.Vector3();
    var newVector = new THREE.Vector3();
    
    return function(delta) {
        if (this.isPlaying === false) return;
    
        this.currentTime += delta * this.timeScale;

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;
    
        // restore and return if paused before start key
        if (this.isPaused && this.currentTime < this.startKeyTime) {
            var element = document.getElementById(this.id);
            if (element) element.style.visibility = this.state;
            return;
        }

        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];
    
            // loop through keys
            for (var t = 0; t < this.keyTypes.length; t++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];
    
                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);
    
                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }
    
                var prevXYZ = prevKey[type];
                var nextXYZ = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevXYZ === undefined || nextXYZ === undefined) continue;
    
                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;
    
                // interpolate
                if (type === "pos") {
                    if (this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.LINEAR) {
                        newVector.x = prevXYZ[0] + (nextXYZ[0] - prevXYZ[0]) * scale;
                        newVector.y = prevXYZ[1] + (nextXYZ[1] - prevXYZ[1]) * scale;
                        newVector.z = prevXYZ[2] + (nextXYZ[2] - prevXYZ[2]) * scale;
                        object.position.copy(newVector);
                    } else if (this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM ||
                        this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                        points[0] = this.getPrevKeyWith("pos", h, prevKey.index - 1)["pos"];
                        points[1] = prevXYZ;
                        points[2] = nextXYZ;
                        points[3] = this.getNextKeyWith("pos", h, nextKey.index + 1)["pos"];
    
                        scale = scale * 0.33 + 0.33;
    
                        var currentPoint = interpolateCatmullRom(points, scale);
                        newVector.x = currentPoint[0];
                        newVector.y = currentPoint[1];
                        newVector.z = currentPoint[2];
                        object.position.copy(newVector);
    
                        if (this.interpolationType === Autodesk.Viewing.Private.INTERPOLATION_TYPE.CATMULLROM_FORWARD) {
                            var forwardPoint = interpolateCatmullRom(points, scale * 1.01);
    
                            target.set(forwardPoint[0], forwardPoint[1], forwardPoint[2]);
                            target.sub(vector);
                            target.y = 0;
                            target.normalize();
    
                            var angle = Math.atan2(target.x, target.z);
                            object.rotation.set(0, angle, 0);
                        }
                    }
    
                } else if (type === "text") {
                    this.updateText(object.position, scale < 0.5? prevXYZ : nextXYZ);
                } else if (type === "vis") {
                    var element = document.getElementById(this.id);
                    if (element) {
                        var visible = scale < 0.5? prevXYZ : nextXYZ;
                        element.style.visibility = visible? 'visible' : 'hidden';
                    }
                }
            }
            object.matrixAutoUpdate = true;
            object.matrixWorldNeedsUpdate = true;
        }
    };
})();

Autodesk.Viewing.Private.PolylineAnimation = function(root, data, animator) {
    this.viewer = animator.viewer;
    if (root === null) {
        root = this.createPolyline([]);
    }
    Autodesk.Viewing.Private.Animation.call(this, root, data, animator);
    this.epsilon = 0.1;
};

Autodesk.Viewing.Private.PolylineAnimation.prototype = Object.create(Autodesk.Viewing.Private.Animation.prototype);
Autodesk.Viewing.Private.PolylineAnimation.prototype.constructor = Autodesk.Viewing.Private.PolylineAnimation;
Autodesk.Viewing.Private.PolylineAnimation.prototype.keyTypes = ["points", "vis"];
Autodesk.Viewing.Private.PolylineAnimation.prototype.defaultKey = {points: [], vis: 1};

Autodesk.Viewing.Private.PolylineAnimation.prototype.update = (function() {
    function removePolyline(anim) {
        if (anim.root) {
            anim.viewer.removeOverlay("polyline", anim.root);
            anim.root = null;
        }
    }

    return function(delta) {
        if (this.isPlaying === false) return;
    
        this.currentTime += delta * this.timeScale;

        // bail out if out of range when playing
        if (this.isPlayingOutOfRange()) return;

        // restore and return if paused before start key
        if (this.isPaused && this.currentTime < this.startKeyTime) {
            removePolyline(this);
            return;
        }
    
        for (var h = 0, hl = this.hierarchy.length; h < hl; h++) {
            var object = this.hierarchy[h];
            var animationCache = object.animationCache[this.data.name];
            
            // loop thru keys
            for (var t = 0; t < this.keyTypes.length; t++) {
                var type = this.keyTypes[t];
                var prevKey = animationCache.prevKey[type];
                var nextKey = animationCache.nextKey[type];

                if (nextKey.time <= this.currentTime || prevKey.time >= this.currentTime) {
                    prevKey = this.data.hierarchy[h].keys[0];
                    nextKey = this.getNextKeyWith(type, h, 1);

                    while (nextKey.time < this.currentTime && nextKey.index > prevKey.index) {
                        prevKey = nextKey;
                        nextKey = this.getNextKeyWith(type, h, nextKey.index + 1);
                    }
                    animationCache.prevKey[type] = prevKey;
                    animationCache.nextKey[type] = nextKey;
                }

                var prevPoints = prevKey[type];
                var nextPoints = nextKey[type];

                // skip if no key or no change in key values
                if (nextKey.time === prevKey.time || prevPoints === undefined || nextPoints === undefined) continue;

                var scale = (this.currentTime - prevKey.time) / (nextKey.time - prevKey.time);
                if (scale < 0) scale = 0;
                if (scale > 1) scale = 1;

                if (type === "points") {
                    // interpolate start and end points
                    var points = scale < 0.5? prevPoints : nextPoints;
                    this.viewer.removeOverlay("polyline", this.root);
                    this.root = null;
                    var vertices = [];
                    for (var i = 0; i < points.length; i++) {
                        var pt = points[i].slice();
                        if (i === 0) {
                            pt[0] = prevPoints[i][0] + (nextPoints[i][0] - prevPoints[i][0]) * scale;
                            pt[1] = prevPoints[i][1] + (nextPoints[i][1] - prevPoints[i][1]) * scale;
                            pt[2] = prevPoints[i][2] + (nextPoints[i][2] - prevPoints[i][2]) * scale;
                        }
                        else if (i === points.length-1) {
                            var p = prevPoints.length - 1;
                            var n = nextPoints.length - 1;
                            pt[0] = prevPoints[p][0] + (nextPoints[n][0] - prevPoints[p][0]) * scale;
                            pt[1] = prevPoints[p][1] + (nextPoints[n][1] - prevPoints[p][1]) * scale;
                            pt[2] = prevPoints[p][2] + (nextPoints[n][2] - prevPoints[p][2]) * scale;
                        }
                        var newpt = new THREE.Vector3(pt[0], pt[1], pt[2]);
                        vertices.push(newpt);
                    }
                    this.root = this.createPolyline(vertices);
                } else if (type === "vis") {
                    var vis = Math.abs(this.currentTime - nextKey.time) < this.epsilon ? nextPoints : prevPoints;
                    this.root.visible = vis;
                    if (!vis) removePolyline(this);
                }
            }
        }
    };
})();

Autodesk.Viewing.Private.PolylineAnimation.prototype.createPolyline = function(points) {
    var geometry = new THREE.Geometry();
    for (var i = 0; i < points.length; i++) {
        geometry.vertices.push(points[i]);
    }
    geometry.computeLineDistances();

    var materialPre = new THREE.LineDashedMaterial({color: 0x0, dashSize:1, gapSize:0.5, linewidth:1});
    var materialPost = null;
    var line = new THREE.Line(geometry, materialPre, THREE.LineStrip);

    // add polyline to an overlay scene
    if (this.viewer.overlayScenes["polyline"] === undefined) {
        this.viewer.createOverlayScene("polyline", materialPre, materialPost);
    }
    this.viewer.addOverlay("polyline", line);

    return line;
};

// Catmull-Rom spline
Autodesk.Viewing.Private.interpolateCatmullRom = function(points, scale) {
    function interpolate(p0, p1, p2, p3, t, t2, t3) {
        var v0 = (p2 - p0) * 0.5,
            v1 = (p3 - p1) * 0.5;

        return (2 * (p1 - p2) + v0 + v1) * t3 + (- 3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
    }

    var c = [], v3 = [],
    point, intPoint, weight, w2, w3,
    pa, pb, pc, pd;

    point = (points.length - 1) * scale;
    intPoint = Math.floor(point);
    weight = point - intPoint;

    c[0] = intPoint === 0 ? intPoint : intPoint - 1;
    c[1] = intPoint;
    c[2] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
    c[3] = intPoint > points.length - 3 ? intPoint : intPoint + 2;

    pa = points[c[0]];
    pb = points[c[1]];
    pc = points[c[2]];
    pd = points[c[3]];

    w2 = weight * weight;
    w3 = weight * w2;

    v3[0] = interpolate(pa[0], pb[0], pc[0], pd[0], weight, w2, w3);
    v3[1] = interpolate(pa[1], pb[1], pc[1], pd[1], weight, w2, w3);
    v3[2] = interpolate(pa[2], pb[2], pc[2], pd[2], weight, w2, w3);

    return v3;
};
;AutodeskNamespace('Autodesk.Viewing.Private');

/**
 *  This is the keyframe animator class that performs keyframe animation
 *
 *  @constructor
 *  @param {Viewer3DImpl} viewer The viewer
 *  @param {number} duration The duration of the animation in seconds
 */
Autodesk.Viewing.Private.KeyFrameAnimator = function(viewer, duration) {
    this.animations = [];
    this.viewer = viewer;
    this.keys = [];
    this.isPlaying = false;
    this.isPaused = true;
    this.updateFlag = 0;
    this.duration = duration;
    this.currentTime = 0;
    this.onPlayCallback = null;
    this.animationHandler = new Autodesk.Viewing.Private.AnimationHandler();
    this.areCameraAnimationsPaused = false;
    this.UPDATE_SCENE = 1;
    this.UPDATE_CAMERA = 2;
};

/**
 * Add an animation to the keyframe animator
 *
 * @param {object} animation The animation object to add
 */
Autodesk.Viewing.Private.KeyFrameAnimator.prototype.add = function(animation) {
    // return if animation has no hierarchy data or less than two keys
    if (!animation.hierarchy || animation.hierarchy.length < 1 || !animation.hierarchy[0].keys ||
        animation.hierarchy[0].keys.length < 2)
        return;

    var anim = null;
    var that = this;
    if (animation.type === "camera") {
        anim = new Autodesk.Viewing.Private.CameraAnimation(that.viewer.camera, animation, that);
        that.animations.push(anim);
    }
    else if (animation.type === "annotation") {
        anim = new Autodesk.Viewing.Private.AnnotationAnimation(null, animation, that);
        that.animations.push(anim);
    }
    else if (animation.type === "polyline") {
        anim = new Autodesk.Viewing.Private.PolylineAnimation(null, animation, that);
        that.animations.push(anim);
    }
    else if (animation.type === "mesh" || animation.type === "visibility") {
        var nodes = that.viewer.model.getNodesByIds([animation.id]);
        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            (function makeAnimationRec(node) {
                var fragIds = node.fragIds;
                if (fragIds !== undefined) {
                    if (!Array.isArray(fragIds))
                        fragIds = [fragIds];
                    
                    for (var j = 0; j < fragIds.length; j++) {
                        var mesh = that.viewer.getRenderProxy(that.viewer.model, fragIds[j]);
                        if (mesh) {
                            mesh.updateMatrixWorld();
                            // meshes of the node will share same data
                            if (animation.type === "mesh")
                                anim = new Autodesk.Viewing.Private.MeshAnimation(mesh, animation, that);
                            else
                                anim = new Autodesk.Viewing.Private.VisibilityAnimation(mesh, animation, node, that);
                            that.animations.push(anim);
                        }
                    }
                }

                if (node.children) {
                    for (var k = 0; k < node.children.length; k++)
                        makeAnimationRec(node.children[k]);
                }
            })(node);
        }
    }

    if (anim) {
        // add keys
        for (var h = 0, hl = animation.hierarchy.length; h < hl; h ++) {
            var keys = animation.hierarchy[h].keys;
            for (var i = 0; i < keys.length; i++) {
                // add user defined (non extra) keys
                if (keys[i].xk === undefined)
                    that.keys.push(keys[i].time);
            }
        }
        // sort and remove duplicates
        function sortAndRemoveDuplicateKeys(keys) {
            function removeDuplicates(a,b,c) {
                b=a.length;while(c=--b)while(c--)a[b]!==a[c]||a.splice(c,1);
            }

            // sort keys
            keys.sort(function(a, b) {return a-b});    

            // remove duplicates
            removeDuplicates(keys);
        }
        sortAndRemoveDuplicateKeys(that.keys);
    }

    this.updateFlag |= this.UPDATE_SCENE;
};

/**
 * Update all animations in the keyframe animator
 *
 * @param {number} time The time in second to advance
 * @return {number} 0 for no update, 1 for scene, 2 for camera, 3 for both
 */
Autodesk.Viewing.Private.KeyFrameAnimator.prototype.update = function(time) {
    this.animationHandler.update(time);
    var update = this.updateFlag;
    if (this.isPlaying && !this.isPaused) {
        this.currentTime += time;
        this.currentTime = Math.min(this.currentTime, this.duration);
        if (this.onPlayCallback) {
            // send playback percentage
            this.onPlayCallback(this.duration > 0? this.currentTime / this.duration * 100 : 0);    
        }
        if (this.currentTime >= this.duration) {
            this.pause();
        }
        update |= this.UPDATE_SCENE;
    }
    this.updateFlag = 0;
    return update;
};

/**
 * Play all animations
 *
 * @param {number} startTime The time in second to start
 */
Autodesk.Viewing.Private.KeyFrameAnimator.prototype.play = function(startTime, onPlayCallback) {
    this.onPlayCallback = onPlayCallback;

    // auto-rewind and play if reached the end
    if (this.currentTime >= this.duration) {
        this.goto(0);
    }

    if (this.isPlaying) {
        this.pause();
        return;
    }

    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.play(startTime);
    }

    this.isPlaying = true;
    this.isPaused = false;
};

/**
 * Pause all animations
 *
 */
Autodesk.Viewing.Private.KeyFrameAnimator.prototype.pause = function() {
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        // pause sync with same state
        if (animation.isPaused === this.isPaused) {
            animation.pause();
        }
    }

    this.isPaused = !this.isPaused;
    this.areCameraAnimationsPaused = this.isPaused;
};

/**
 * Pause camera animations
 *
 */
Autodesk.Viewing.Private.KeyFrameAnimator.prototype.pauseCameraAnimations = function() {
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        if (animation instanceof Autodesk.Viewing.Private.CameraAnimation) {
            animation.pause();
        }
    }

    this.areCameraAnimationsPaused = !this.areCameraAnimationsPaused;
};

/**
 * Stop all animations
 *
 */
Autodesk.Viewing.Private.KeyFrameAnimator.prototype.stop = function() {
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.stop();
    }

    this.isPlaying = false;
    this.isPaused  = false;
};

/**
 * Goto specific time in the animation
 *
 * @param {number} time The specific time in second
 */
Autodesk.Viewing.Private.KeyFrameAnimator.prototype.goto = function(time) {
    if (time === undefined) return;
    for (var i = 0; i < this.animations.length; i++) {
        var animation = this.animations[i];
        animation.goto(time);
    }

    this.isPlaying = true;
    this.isPaused  = true;
    this.currentTime = time;
    this.updateFlag |= this.UPDATE_SCENE;
};

/**
 * Step forward to next key
 *
 */
Autodesk.Viewing.Private.KeyFrameAnimator.prototype.next = function() {
    // find next key time
    function findNextKey(time, keys) {
        var key = -1;
        for (var t = 0; t < keys.length; t++) {
            if (keys[t] > time) {
                key = keys[t];
                break;
            }
        }
        return (key < 0? keys[keys.length-1] : key);
    }
    var time = findNextKey(this.currentTime, this.keys);
    this.goto(time);
};

/**
 * Step backward to previous key
 *
 */
Autodesk.Viewing.Private.KeyFrameAnimator.prototype.prev = function() {
    // find previous key time
    function findPrevKey(time, keys) {
        var key = -1;
        for (var t = keys.length-1; t > -1; t--) {
            if (keys[t] < time) {
                key = keys[t];
                break;
            }
        }
        return (key < 0? keys[0] : key);
    }
    var time = findPrevKey(this.currentTime, this.keys);
    this.goto(time);
};
;AutodeskNamespace('Autodesk.Viewing.Private');

if (ENABLE_DEBUG === undefined)
    var ENABLE_DEBUG = true;

if (ENABLE_TRACE === undefined)
    var ENABLE_TRACE = true;

if (RENDER_CONTEXT_CLASS === undefined)
    var RENDER_CONTEXT_CLASS = RenderContext;

/** @constructor */
Autodesk.Viewing.Private.Viewer3DImpl = function (thecanvas, theapi, createControlsCallback)
{
    var _this = this;
    var avp = Autodesk.Viewing.Private;

    //Frame time cutoff for turning on progressive rendering
    var MAX_FRAME_TIME = 1000/20.0, //milliseconds per frame to try to maintain

    //If rendering is faster than this rate over several frames, we will
    //attempt to shift some nodes from progressive to permanent draw
        MIN_FRAME_TIME = 1000/40.0;


	var RENDER_NORMAL = 0,
	    RENDER_HIGHLIGHTED = 1,
	    RENDER_HIDDEN = 2,
	    RENDER_FINISHED = 3,
	    RENDER_IDBUFFER = 4;

 	var _phase = RENDER_NORMAL;

    var _currentLightPreset = avp.DefaultLightPreset;

    var _projector = new THREE.Projector();

    var _lastTickMoved = false;

    var _worldUp = new THREE.Vector3(0,1,0);

    var _reqid, _needsResize, _newWidth, _newHeight, _modelQueue, _renderer, _materials;

    var _needsClear = false, _needsRender = false, _overlayDirty = false;

    var _idsDirty = false;

    var _cameraUpdated;

    var _explodeScale = 0;

    var _lastBeginFrameTimeStamp = 0, _beginFrameAvg = 0;

    var _lastHighResTimeStamp = 0;

    //Main animation loop -- update camera,
    //advance animations, render if needed.
    function tick(highResTimeStamp)
    {
        var stats = _this.stats;
        if (stats)
            stats.begin();

        if (_needsResize) {
            _this.controls.handleResize();
            _this.camera.aspect = _newWidth/_newHeight;
            _renderer.setSize(_newWidth,_newHeight);
            _needsRender = true;
            _needsClear = true;
            // Overlay dirty fixes the issue of screen black on selection, but makes resizing a lot buggier
            _overlayDirty = true;
            _needsResize = false;
            _this.api.fireEvent({
                type: Autodesk.Viewing.VIEWER_RESIZE_EVENT
            });
        }

        _materials.updateMaterials();

        if (_this.keyFrameAnimator) {
            var delta = _lastHighResTimeStamp > 0 ? (highResTimeStamp - _lastHighResTimeStamp) / 1000 : 0;
            var needsUpdate = _this.keyFrameAnimator.update(delta);
            if (needsUpdate) {
                _modelQueue.visibleBoundsDirty = true;
                _needsClear = true;
                _overlayDirty = true;
                if (needsUpdate & _this.keyFrameAnimator.UPDATE_CAMERA)
                    _cameraUpdated = true;
            }
        }

        var moved = _this.controls.update(highResTimeStamp) || _cameraUpdated;
        var clearAllBuffers = moved || _needsClear;

        _cameraUpdated = false;
        _overlayDirty = _overlayDirty || moved;


        var loadDone = _this.model && _this.model.isLoadDone();
        var isBeginFrame = clearAllBuffers || _needsRender;
        var q = _modelQueue;
        var frameBudget = _this.progressiveRender ? 0.5 * (_this.maxFrameTime + _this.minFrameTime) : 1e10;
        var frameRemaining = frameBudget;


        if (isBeginFrame) {

            if (loadDone)
                _this.signalProgress(0, null); //zero out the progress bar for when rendering begins

            //Measure actual frame time between two consecutive initial frames.
            //This is used to correct measured per-scene times to what they actually take
            //once the async processing of the graphics thread is taken into account.
            if (_lastBeginFrameTimeStamp > 0) {
                var delta = highResTimeStamp - _lastBeginFrameTimeStamp;
                _beginFrameAvg = 0.75 * _beginFrameAvg + 0.25 * delta;
            }
            _lastBeginFrameTimeStamp = highResTimeStamp;


            _this.updateCameraMatrices();

            _renderer.beginScene(_this.scene, _this.camera, clearAllBuffers);

            if (moved) {
                _this.api.fireEvent(_this.cameraChangedEvent);
            }

            if (_this.needGhostedPass) {
                q.setOverrideMaterial(null);
            }

            _idsDirty = true;

            if (q) {
                if (q.hasHighlighted()) {
                    //If we have objects in the render queue that are set
                    //to draw as "highlighted", render them first
                    _phase = RENDER_HIGHLIGHTED;
                    q.reset(_this.camera);
                    q.drawHighlightedObjectsOnly();
                    q.setOverrideMaterial(_this.highlightMaterial);
                } else {
                    // If nothing is highlighted just skip the highlighted phase
                    _phase = RENDER_NORMAL;
                    q.reset(_this.camera, _beginFrameAvg);
                    q.drawNormalObjectsOnly();
                    q.setOverrideMaterial(null);
                }
            }
        } else {
            _lastBeginFrameTimeStamp = -1;
        }

        //Render some meshes until we run out of time
        if (q && !q.isDone()) {

            function cb(scene) {
                //Ideally, here we only want the piece of the
                //render function that specifically renders geometries,
                //and none of the camera update stuff that we already do
                //once in beginProgressive() -- but this requires
                //some refactoring of THREE.WebGLRenderer.
                var phase = _phase;
                var wantColor = phase != RENDER_IDBUFFER;
                var wantSAO = phase == RENDER_NORMAL;
                var wantID = phase == RENDER_IDBUFFER;
                _renderer.renderScenePart(scene, wantColor, wantSAO, wantID);
            }

            frameRemaining = q.renderSome(cb, frameRemaining);

            if (q.isDone() && _phase === RENDER_HIGHLIGHTED) {
                _phase = RENDER_NORMAL;
                q.reset(_this.camera);
                q.drawNormalObjectsOnly();
                q.setOverrideMaterial(null);

                // Allow the use of the remaining frame time to draw normal objects.
                frameRemaining = q.renderSome(cb, frameRemaining);
            }

            //if needed apply post-process to copy render target to screen
            if (!moved && !_overlayDirty)
                 _renderer.composeFinalFrame();

            if (q.isDone()) {
                if (_phase === RENDER_NORMAL
                    && !q.areAllVisible()
                    && _this.showGhosting)
                {
                    _phase = RENDER_HIDDEN;
                    q.reset(_this.camera);
                    q.drawHiddenObjectsOnly();
                    q.setOverrideMaterial(_this.fadeMaterial);
                }
                else if (_phase == RENDER_IDBUFFER) {
                    //If we were doing an ID buffer pass, we do not have
                    //to compute the final frame again, as the ID buffer
                    //does not affect that currently.
                    _phase = RENDER_FINISHED;
                    _idsDirty = false;
                }
                else
                {
                    _phase = RENDER_FINISHED;
                    _renderer.composeFinalFrame(moved && _this.skipAOWhenMoving);
                }

                if (loadDone)
                    _this.signalProgress(100.0, null);
            }
            else {
                if (loadDone)
                    _this.signalProgress(100.0 * q.getRenderProgress(), null);
            }
        }

        if (_overlayDirty) {
            if ((q && q.isDone()) || _this.showOverlaysWhileMoving) {
                _this.renderOverlays();

                //During progressive rendering, we want to
                //continue rendering overlays until the queue is done
                //because adding more to the scene will affect the z buffer
                //which would change which parts of the overlays is visible.
                if (q && !q.isDone())
                    _overlayDirty = true;
            } else {
                _renderer.clearAllOverlays();
            }
            _renderer.composeFinalFrame(moved && _this.skipAOWhenMoving);
        }

        //In case we have to render the ID buffer in a separate pass
        //trigger that pass once we are done with the regular color pass.
        if (_phase == RENDER_FINISHED
            && _idsDirty) {

            if (!_renderer.hasMRT()) {
                _phase = RENDER_IDBUFFER;
                q.reset(_this.camera);
                q.drawNormalObjectsOnly();
                q.setOverrideMaterial(_this.idMaterial);
            }
            else {
                //In case we are using MRT, the ID and color buffers are never out of
                //sync, so this is a no-op
                _idsDirty = false;
            }
        }

        if (frameRemaining < frameBudget && stats)
            stats.end();

        if (_lastTickMoved && !moved && _this.skipAOWhenMoving)
            _renderer.composeFinalFrame();
        _lastTickMoved = moved;

        _lastHighResTimeStamp = highResTimeStamp;

        _needsRender = false;
        _needsClear = false;
    }


    this.run = function() {
        //Begin the render loop
        _reqid = 0;
        (function animloop(highResTimeStamp) {
            _reqid = window.requestAnimationFrame(animloop);
            tick(highResTimeStamp);
        })();
    };

    this.toggleProgressive = function(value) {
        this.progressiveRender = value;
        _needsClear = true;
    };


    this.toggleGhosting = function(value) {
        this.showGhosting = value;
        _needsClear = true;
    };

    this.toggleOverlaysWhileMoving = function(value) {
        this.showOverlaysWhileMoving = value;
    };

    this.togglePostProcess = function(useSAO, useFXAA, useIDBuffer) {

        _renderer.initPostPipeline(useSAO, useFXAA, useIDBuffer);
        this.fireRenderOptionChanged();
        _needsClear = true;
    };

    this.setOptimizeNavigation = function(value) {
        this.skipAOWhenMoving = value;
    };


    this.renderOverlays = function() {

        //The overlays (selection, pivot, etc) get lighted using
        //the default lights, even if IBL is on
        var lightsOn = this.lightsOn;
        if (!lightsOn)
            this.toggleLights(true, true);

        if (this.dir_light1) {
            var oldIntensity = this.dir_light1.intensity;
            this.dir_light1.intensity = 1;
        }

        _renderer.renderOverlays(this.overlayScenes);

        if (!lightsOn)
            this.toggleLights(false, true);

        if (this.dir_light1)
            this.dir_light1.intensity = oldIntensity;

        _overlayDirty = false;
    };

    this.setLayerVisible = function (layerIndexes, visible) {
        this.matman().setLayerVisible(layerIndexes, visible);
    };

    this.isLayerVisible = function (layerIndex) {
        return this.matman().isLayerVisible(layerIndex);
    };

    this.updateCameraMatrices = function() {
        var camera = this.camera;

        //TODO: Those are both done in each render() call of the renderer
        //and we need to refactor the renderer to avoid it.
        camera.updateMatrixWorld();
        camera.matrixWorldInverse.getInverse( camera.matrixWorld );

        //TODO: Would be nice if this got called by the world up tool instead,
        //so that we don't have to update it every frame.
        if (camera.worldup)
            this.setWorldUp(camera.worldup);

        //Fix near and far to fit the current view
        if (this.model) {
            var worldBox = this.getVisibleBounds(true, true);

            //Transform the world bounds to camera space
            //to estimate the near/far planes we need for this frame
            //TODO: this can be optimized by caching the box and
            var tmpBox = new THREE.Box3();
            tmpBox.copy(worldBox).applyMatrix4(camera.matrixWorldInverse);

            //Expand the range by a small amount to avoid clipping when
            //the object is perfectly aligned with the axes and has faces at its boundaries.
            var sz = 1e-5 * (tmpBox.max.z - tmpBox.min.z);

            var dMin = -(tmpBox.max.z+sz);
            var dMax = -(tmpBox.min.z-sz);

            //Camera is inside the model?
            if (camera.isPerspective)
                dMin = Math.max(dMin, Math.min(1, Math.abs(dMax - dMin) * 1e-4));
            else {
                //TODO:
                //Do nothing in case of ortho. While this "fixes" near plane clipping too early,
                //it effectively disallows moving through walls to go inside the object.
                //So we may need some heuristic based on how big we want the object to be
                //on screen before we let it clip out.
                //dMin = Math.max(dMin, 0);
            }

            //The whole thing is behind us -- nothing will display anyway?
            dMax = Math.max(dMax, dMin);

            camera.near = dMin;
            camera.far = dMax;
            camera.updateProjectionMatrix();

            //stderr("near " + dMin + " far " + dMax + " top " + camera.top);

            //Update the line width scale with the
            //new pixels per unit scale
            if (this.model.is2d())
            {
                //Here we base pixel scale on the point at the center of the view.
                //However, this might not always be the most appropriate point,
                //e.g. at oblique angles or when the drawing is off to one side.
                //It might make more sense to base the scale on the distance of the
                //camera to the nearest part of the world bounding box, which requires
                //a more generic ray-aabb test.
                var groundPt = this.intersectGroundViewport(new THREE.Vector3(0,0,1));

                var distance;
                if (groundPt)
                    distance = camera.position.distanceTo(groundPt);
                else
                    distance = camera.position.distanceTo(worldBox.center()); //degenerate case: camera direction is parallel to the ground plane

                //NOTE: In case of ortho projection, we set FOV such that tan(fov/2) = 0.5,
                //so here we don't need separate code path for ortho.
                var pixelsPerUnit = _renderer.settings.deviceHeight / (2 * distance * Math.tan(THREE.Math.degToRad(camera.fov * 0.5)));

                //Heuristic line width beautification factor.
                //TODO: tweak this to give best results on multiple display densities.
                //Something between 0.5 and 1.0 seems good (1.0 being theoretically correct).
                //Probably related to Retina vs. non-Retina density...
                pixelsPerUnit *= 0.5;

                _materials.updatePixelScale(pixelsPerUnit);
            }

        }
    };


    this.initLights = function(dist)
    {
        var lightIntensity = avp.LightPresets[_currentLightPreset].lightMultiplier;

        this.lightNode = new THREE.Object3D();

        this.dir_light1 = new THREE.DirectionalLight( new THREE.Color().setRGB(
            1.0, 1.0, 1.0),//Note this color will be overridden by various light presets
            lightIntensity );

        this.dir_light1.position.set( -1, 0, 1 );
        //for whatever reason we need to move the light far out to make it draw correctly,
        //even though it's a directional light
        this.dir_light1.position.multiplyScalar(dist * 1000);
        this.lightNode.add( this.dir_light1 );

        //Note this color will be overridden by various light presets
        this.amb_light = new THREE.AmbientLight( new THREE.Color().setRGB(1, 1, 1 ));
        this.scene.add(this.amb_light);

        this.toggleLights(lightIntensity != 0);
    };

    this.toggleLights = function(state, isForOverlay) {

        //This can happen during initial construction
        if (!this.amb_light || !this.lightNode)
            return;

        //Light on or off? Add/remove from the scene accordingly.
        if (state && !this.lightsOn)
        {
            this.scene.add(this.amb_light);
            this.camera.add(this.lightNode);

            this.lightsOn = true;
        }
        else if (!state && this.lightsOn)
        {
            if (this.amb_light)
                this.scene.remove(this.amb_light);
            if (this.lightNode)
                this.camera.remove(this.lightNode);
            this.lightsOn = false;
        }

        //Update the light colors based on the current preset
        var preset = avp.LightPresets[_currentLightPreset];
        var ac = preset.ambientLightColor;
        var dc = preset.directLightColor;

        if (this.lightsOn) {
            if (isForOverlay && this.amb_light)
                this.amb_light.color.setRGB(dc[0]*0.5,dc[1]*0.5,dc[2]*0.5);
            else if (ac && this.amb_light)
                this.amb_light.color.setRGB(ac[0],ac[1],ac[2]);
            if (dc && this.dir_light1)
                this.dir_light1.color.setRGB(dc[0],dc[1],dc[2]);
        }
        else
        {
            //Restores the ambient for the main scene after drawing overlays
            if (ac && this.amb_light && isForOverlay)
                this.amb_light.color.setRGB(ac[0],ac[1],ac[2]);
        }
    };

    //Forces the view controller to update when the camera
    //changes programmatically (instead of via mouse events).
    this.syncCamera = function(syncWorldUp)
    {
        this.camera.updateProjectionMatrix();

        if( syncWorldUp )
            this.setWorldUp( this.api.navigation.getWorldUpVector() );

        _cameraUpdated = true;
    };

    // Given a THREE.Vector3, return the nearest world-axis.
    //
    function getNearestAxis(v) {

        var newv = v.clone();

        if (newv.x < 0) newv.x = -newv.x;
        if (newv.y < 0) newv.y = -newv.y;
        if (newv.z < 0) newv.z = -newv.z;

        if (newv.x > newv.y && newv.x > newv.z)
            newv.set(newv.x > 0 ? 1 : -1, 0, 0);
        else if (newv.y > newv.x && newv.y > newv.z)
            newv.set(0, newv.y > 0 ? 1 : -1, 0);
        else
            newv.set(0, 0, newv.z > 0 ? 1 : -1);

        return newv;
    }


    this.setViewFromFile = function(model, skipTransition) {

        var camera;

        var defaultCamera = model.getDefaultCamera();

        if (defaultCamera) {

            camera = defaultCamera;

        } else {

            //Model has no default view. Make one up based on the bounding box.

            camera = {};

            var bbox = model.getBoundingBox();
            var size = bbox.size();
            camera.target = bbox.center();

            if (!model.is2d())
            {
                camera.isPerspective = true;
                camera.fov = this.camera.fov;
                camera.up = this.camera.up.clone();

                camera.position = camera.target.clone();
                camera.position.z += Math.max(size.x, size.y, size.z);
            }
            else {
                camera.isPerspective = false;

                var pageAspect = size.x / size.y;
                var screenAspect = this.camera.aspect;

                //Fit the page to the screen
                if (screenAspect > pageAspect)
                    camera.orthoScale = size.y;
                else
                    camera.orthoScale = size.x / screenAspect;

                //2D case -- ground plane / up vector is Z
                camera.up = new THREE.Vector3(0,0,1);

                camera.position = camera.target.clone();
                camera.position.z += camera.orthoScale;

                //This is to avoid freaking out the camera / controller with co-linear up and direction
                camera.target.y += 1e-6 * size.y;

            }

        }

        this.setViewFromCamera(camera, skipTransition);
    };

  //Camera is expected to have the properties of a THREE.Camera.
    this.setViewFromCamera = function(camera, skipTransition)
    {

        //Sometimes (Revit) the camera target is unspecified/infinite
        //for ortho. So we pick target and distance such that
        //initial view and orbit is about right
        if (!camera.isPerspective && this.model) {
            var bbox = this.model.getBoundingBox();
            var size = bbox.size();

            var at = camera.target.clone().sub(camera.position);
            if (at.length() > 1000 * size.length()) {
                //We will try to set a target point that is a similar
                //distance away as camera->bbox center, but is in the
                //direction of the at vector (which is not necessarily looking at the center)
                var dist = camera.position.distanceTo(bbox.center());
                camera.target.copy(camera.position).add(at.normalize().multiplyScalar(dist));
            }
            else {
                //TODO: UnifiedCamera does not actually look at the orthoScale property. It bases
                //the ortho projection on value derived from the position-target distance and an
                //assumed field of view. Here we apply the inverse so that the initial view is
                //right, without affecting the initial orbit target.
                camera.position.copy(camera.target).add(at.normalize().multiplyScalar(-camera.orthoScale));
            }
        }

        //If up vector is given explicitly (in world space)
        //then use that instead
        //TODO: Is that desired now that we allow heads-down situations?
        //or should we accept the camera exactly as given.
        var upVectorArray = this.model ? this.model.getUpVector() : null;

        var up;
        if (upVectorArray)
            up = new THREE.Vector3().fromArray(upVectorArray);
        else
            up = getNearestAxis(new THREE.Vector3(camera.up.x, camera.up.y, camera.up.z));

        camera.up = up;


        var navapi = this.api.navigation;

        if (!skipTransition) {
            this.camera.isPerspective = camera.isPerspective;
            up = navapi.computeOrthogonalUp(camera.position, camera.target);
            navapi.setRequestTransitionWithUp(true, camera.position, camera.target, camera.fov, up, camera.up);
        }
        else {
            //This code path used during initial load -- it sets the view directly
            //without doing a transition. Transitions require that the camera is set explicitly

            var tc = this.camera;
            tc.up.copy(camera.up);
            tc.position.copy(camera.position);
            tc.target.copy(camera.target);
            if( camera.isPerspective ) {
                tc.fov = camera.fov;
            }
            else {
                tc.saveFov = camera.fov;    // Stash original fov
                tc.fov = Autodesk.Viewing.UnifiedCamera.ORTHO_FOV;
            }
            tc.isPerspective = camera.isPerspective;
            tc.orthoScale = camera.orthoScale;
            tc.dirty = true;

            navapi.setWorldUpVector(tc.up);
            navapi.setView(tc.position, tc.target);

            this.syncCamera(true);
        }
        _cameraUpdated = true;
    };

    this.setViewFromViewBox = function(viewbox, skipTransition)
    {
        if (!this.model.is2d()) {
            return;
        }

        // TODO: Actually have the viewbox fit inside the view. Waiting on translator bug.

        var camera = {};

        var bbox = this.model.getBoundingBox();

        var box = {
            width: viewbox[2] - viewbox[0],
            height: viewbox[3] - viewbox[1]
        };
        box.aspect = box.width / box.height;
        box.centerX = viewbox[0] + box.width / 2;
        box.centerY = viewbox[1] + box.height / 2;

        var screenAspect = this.camera.aspect;

        //Fit the viewbox to the screen
        if (screenAspect > box.aspect)
            camera.orthoScale = box.height;
        else
            camera.orthoScale = box.height / screenAspect;

        camera.isPerspective = false;
        camera.position = new THREE.Vector3(box.centerX, box.centerY, bbox.center().z + camera.orthoScale);
        camera.target = new THREE.Vector3(box.centerX, box.centerY, bbox.center().z);
        camera.target.y += 1e-6 * box.height;

        camera.up = new THREE.Vector3(0,0,1);

        this.setViewFromCamera(camera, skipTransition);
    };

    this.setWorldUp = function(v) {

        if (_worldUp.equals(v))
            return;

        _worldUp.copy(v);

        var upAxis = 0;
        var maxVal = Math.abs(v.x);
        if (Math.abs(v.y) > maxVal) {
            upAxis = 1;
            maxVal = Math.abs(v.y);
        }
        if (Math.abs(v.z) > maxVal)
            upAxis = 2;

        this.camera.worldUpTransform = null;
        if (upAxis == 2)
        {
            var upMatrix = this.camera.worldUpTransform = new THREE.Matrix4();
            var e = upMatrix.elements;
            e[0] = 1; e[1] =  0;  e[ 2] = 0;
            e[4] = 0; e[5] =  0;  e[ 6] = -1;
            e[8] = 0; e[9] =  1;  e[10] = 0;
        }
        else if (upAxis == 0)
        {
            var upMatrix = this.camera.worldUpTransform = new THREE.Matrix4();
            var e = upMatrix.elements;
            e[0] = 0; e[1] =  1;  e[ 2] = 0;
            e[4] = -1; e[5] =  0;  e[ 6] = 0;
            e[8] = 0; e[9] =  0;  e[10] = 1;
        }
    };

    this.setModel = function(model)
    {
        if (model) {
            this.model = model;
            this.selector.model = this.model;
            this.visibilityManager.model = this.model;

            this.model.setLoader( this.svfloader );
            this.initScene();
        }
    };

    //Called when an SVF index is loaded (but before geometry
    //packs are loaded).
    this.initScene = function()
    {
        if (!this.model)
            return;

        var m = this.model;
        var bbox = m.getBoundingBox();

		//stderr("Unit scale " + m.getUnitScale());
		_renderer.setUnitScale(m.getUnitScale());

        //In case of a 2D drawing
        //initialize the common line shader
        //and the layers texture
        var is2d = m.is2d();
        if (is2d)
        {
            this.enter2DMode();
        }
        this.api.navigation.setIs2D(is2d);
        this.api.setActiveNavigationTool(is2d ? "pan" : "orbit");


/*
        var size = bbox.size();
        var maxdim = Math.max(size.x, size.y, size.z);

        var plane = new THREE.BufferGeometry();
        var p = new Float32Array(12);
        p[0] = -maxdim; p[1] = 0; p[2] = -maxdim;
        p[3] =  maxdim; p[4] = 0; p[5] = -maxdim;
        p[6] =  maxdim; p[7] = 0; p[8] =  maxdim;
        p[9] = -maxdim; p[10] = 0; p[11] =  maxdim;


        var n = new Float32Array(12);
        n[0] = n[3] = n[6] = n[9] = 0;
        n[1] = n[4] = n[7] = n[10] = 1;
        n[2] = n[5] = n[8] = n[11] = 0;

        var index = new Uint16Array(6);
        index[0] = 0, index[1] = 2, index[2] = 1,
        index[3] = 0, index[4] = 3, index[5] = 2;

        plane.attributes.position = {
            itemSize : 3,
            array    : p
        };

        plane.attributes.normal = {
            itemSize : 3,
            array: n
        };

        plane.attributes.index = {
            itemSize: 1,
            array: index
        };

        plane.offsets = [ { start: 0,
            index: 0,
            count: index.length } ];

        var surroundMat = new THREE.MeshPhongMaterial({color:new THREE.Color().setRGB(0.99,0.99,0.99),
                                                       specular:new THREE.Color().setRGB(0,0,0),
                                                       reflectivity:0.0,
                                                       opacity:1,
                                                       transparent:true,
                                                       shininess: 2}
                                                      );

        _materials.addMaterial("__surroundMat__", surroundMat, true);
        var boxMesh = new THREE.Mesh(plane, surroundMat, true);
        var center = bbox.center();
        var mPos = new THREE.Matrix4().makeTranslation(center.x, bbox.min.y, center.z);
        boxMesh.matrixWorld.copy(mPos);
        boxMesh.matrixWorldNeedsUpdate = true;
        boxMesh.matrixAutoUpdate = false;
        this.scene.add(boxMesh);
*/


        //Create a render list for progressive rendering of the
        //scene fragments
        _modelQueue = new RenderQueue(m.getData().fragments.length, this.scene, bbox, m.is2d() ? 50 : 0);

        this.setViewFromFile(m, true);

        this.controls.recordHomeView();

        //Currently the lights need to know
        //the overall size of the scene
        //since they are point lights
        var radius = 0.5 * bbox.size().length();
        this.initLights(radius);

        // grab the environment preset data from the file.
        if (!is2d && !this.setLightPresetFromFile())
            this.setLightPreset(_currentLightPreset, true);

        this.invalidate(true);
    };

    this.addMeshInstance = function(threegeom, fragId, materialId, matrix)
    {
        var svf = this.model.getData();

        if (fragId === 0 && svf.basePath.indexOf("SaRang") != -1)
            return;

        var m;

        // Check if this geometry is to be rendered with a line mesh
        if ( threegeom.isLines ) {
            // Check to see if there are vertex colors
            var vertexColors = !!threegeom.attributes.color;
            // Create a new LineBasicMaterial with vertexColors true/false depending on above
            //TODO: this material also needs to be added to the materials set, but first
            //make sure this will not cause line display side effects.
            var material = new THREE.LineBasicMaterial({ vertexColors: vertexColors });

            // If there are no vertex colors, default to the material color
            if(!vertexColors){
                var svfmat = _materials.findMaterial(svf, materialId);
                material.color = svfmat.color;
            }
            // Use line mesh
            m = new THREE.Mesh(threegeom, material, !svf.animations);
            m.isLine = true;

            svf.hasLines = true;
        } else {
            var material = _materials.findMaterial(svf, materialId);

            _materials.applyGeometryFlagsToMaterial(material, threegeom);

            m = new THREE.Mesh(threegeom, material, !svf.animations);

            if (threegeom.is2d)
                m.is2d = true;
        }

        if (matrix) {
            if (m.matrix)
                m.matrix.copy(matrix);
            m.matrixWorld.copy(matrix);
        }
        m.matrixAutoUpdate = false;

        _modelQueue.addMesh(fragId, m);
    };

    this.onLoadComplete = function ()
    {
        this.signalProgress(100, "");

        // Fire the event so we know the geometry is done loading.
        this.api.fireEvent({
            type: Autodesk.Viewing.GEOMETRY_LOADED_EVENT
        });

        //In the case of 2d drawing, initialize the dbIds texture
        //to be used for selection highlighting. Initially,
        //nothing is highlighted
        if (this.is2d) {
            this.selectionMaterial2d = _materials.initSelectionMaterial(this.model);
            this.createOverlayScene("selection2d", this.selectionMaterial2d);
        }

        //If the model has line geometries
        //set polygon offset on the solid materials
        //so that we avoid z-fighting between solids and
        //their outlines.
        if (this.model.getData().hasLines) {
            _materials.togglePolygonOffset(true);
        }

    };

    this.signalProgress = function(percent, message)
    {
        this.api.fireEvent({type:Autodesk.Viewing.PROGRESS_UPDATE_EVENT, percent:percent, message:message});
    };

    this.resize = function(w, h) {
        _needsResize = true;
        _newWidth = w;
        _newHeight = h;
    };

    this.enter2DMode = function()
    {
        this.is2d = true;

        _materials.initLayersTexture(this.model);

        var idMatName = _materials.create2DMaterial({}, true);
        this.idMaterial = _materials.findMaterial(null, idMatName);

        _renderer.enter2DMode(this.idMaterial);

        this.setLightPreset(avp.DefaultLightPreset2d);

        var svf = this.model.getData();
        if (svf.hidePaper) {
            var bg = svf.bgColor;
            var r = (bg>>16)&0xff;
            var g = (bg >>8)&0xff;
            var b = bg&0xff;
            this.setClearColors(r,g,b,r,g,b );
        }

        this.togglePostProcess(false, false, true);
    };

    this.loadSvf = function(path, ids, propertyDbPath, onSuccess, onError)
    {
        return this.svfloader.loadSvf(path, ids, propertyDbPath, onSuccess, onError);
    };

    this.createOverlayScene = function(name, materialPre, materialPost, cam) {

        if (materialPre) {
            materialPre.depthWrite = false;
            materialPre.depthTest = true;
        }

        if (materialPost) {
            materialPost.depthWrite = false;
            materialPost.depthTest = false;
        }

        var s = new THREE.Scene(true);
        s.__lights = this.scene.__lights;
        this.overlayScenes[name] = {
                                    scene : s,
                                    camera: cam,
                                    materialPre : materialPre,
                                    materialPost : materialPost
                                    };
    };

    this.removeOverlayScene = function (name) {

        var overlay = this.overlayScenes[name];
        if (overlay) {
            delete this.overlayScenes[name];
        }
    };

    this.addOverlay = function(overlayName, mesh) {
        this.overlayScenes[overlayName].scene.add(mesh);
        _overlayDirty = true;
    };

    this.removeOverlay = function(overlayName, mesh) {
        this.overlayScenes[overlayName].scene.remove(mesh);
        _overlayDirty = true;
    };

    this.clearOverlay = function(overlayName) {
        //TODO: Implement correctly, Scene has no 'clear' method
        this.overlayScenes[overlayName].scene.clear();
        _overlayDirty = true;
    };

    this.setClearColors = function(r,g,b, r2, g2, b2) {
        this.clearColorTop = new THREE.Vector4(r/255.0,g/255.0,b/255.0, 1);
        this.clearColorBottom = new THREE.Vector4(r2/255.0,g2/255.0,b2/255.0, 1);

        //If we are using the background color as environment also,
        //create an environment map texture from the new colors
        if (!_materials.reflectionCube || _materials.reflectionCube.isBgColor)
            _materials.setCubeMapFromColors(this.clearColorTop, this.clearColorBottom);

        _renderer.setClearColors(this.clearColorTop, this.clearColorBottom);
        _needsClear = true;
        this.fireRenderOptionChanged();
    };

    this.getOverlayBounds = function() {
        var bounds = new THREE.Box3();
        var overlays = this.overlayScenes;
        for (var key in overlays) {
            if (!overlays.hasOwnProperty(key))
                continue;

            var box = new THREE.Box3();
            box.setFromObject(overlays[key].scene);

            bounds.union(box);
        }
        return bounds;
    };

    this.getVisibleBounds = function(includeGhosted, includeOverlays) {
        var result = null;
        if (_modelQueue) {
            result = _modelQueue.getVisibleBounds(includeGhosted);

            if( includeOverlays ) {
                result = this.getOverlayBounds().union(result);
            }
        }
        return result;
    };

    this.getFitBounds = function( ignoreSelection )
    {
        var bounds;
        
        // If there is a valid selection, use its bounds
        // unless this is a 2d file
        //
        if (this.is2d) {
            ignoreSelection = true;
        }
        if( !ignoreSelection && this.selector !== null) {
            bounds = this.selector.getSelectionBounds();
        }

        // Otherwise, if there is a valid isolation, use its bounds
        if(!bounds || bounds.empty()) {
            bounds = this.getVisibleBounds();
        }

        return bounds;
    }; 
    
    this.getRenderProxy = function(model, fragId) {
        //currently there is a single model so the mapping
        //of fragId to render mesh is 1:1.
        return _modelQueue ? _modelQueue.getVizmesh(fragId) : null;
    };

    this.setFragmentVisibility = function(model, fragId, value) {
        //currently there is a single model so the mapping
        //of fragId to render mesh is 1:1.
        if (_modelQueue) {
            _modelQueue.setVisibility(fragId, value);
        }
    };

    this.setModelVisibility = function(model, value) {
        //currently there is a single model so we just change visibility
        //for the entire render queue
        if (_modelQueue) {
            _modelQueue.setAllVisibility(value);
        }
    };

    this.isWholeModelVisible = function(model) {
        return _modelQueue ? _modelQueue.areAllVisible() : true;
    };

    this.resetIsolation = function(model) {
        if (_modelQueue) {
            _modelQueue.setOverrideMaterial(null);
            this.needGhostedPass = false;
            _needsClear = true;
        }
    };

    this.highlightObjectNode = function(model, object, value, simpleHighlight) {

        var fragIds = object.fragIds;
        if (typeof fragIds != "undefined") {
            if (!Array.isArray(fragIds))
                fragIds = [fragIds]; //could be just single fragment index in the node, in which case it's not an array

            for (var i = 0; i < fragIds.length; ++i) {
                var fragId = fragIds[i];

                var mesh = this.getRenderProxy(model, fragId);
                var overlayName = mesh.is2d ? "selection2d" : "selection";

                if (mesh.is2d) {
                    _materials.highlightObject2D(object.dbId, value); //update the 2d object id texture
                }
                else if (simpleHighlight || !value) {
                    _modelQueue.setHightlighted(fragId, value); //or update the vizflags in the render queue for 3D objects
                }

                //And also add a mesh to the overlays in case we need that.
                //For 2D that is always the case, while for 3D it's done
                //for "fancy" single-selection where we draw an outline for the object
                //as post-processing step.
                if (value)
                {
                    if (!simpleHighlight || mesh.is2d) {
                        mesh.selectionProxy = new THREE.Mesh(mesh.geometry, mesh.material, true);
                        mesh.selectionProxy.matrixWorld = mesh.matrixWorld;
                        this.addOverlay(overlayName, mesh.selectionProxy);
                    }
                }
                else
                {
                    if (mesh.selectionProxy) {
                        this.removeOverlay(overlayName, mesh.selectionProxy);
                        mesh.selectionProxy = null;
                    } else if (!mesh.is2d) {
                        //Case where highlighting was done directly in the primary render queue
                        //and we need to repaint to clear it. This happens when multiple
                        //nodes are highlighted using e.g. right click in the tree view
                        this.invalidate(true);
                    }
                }
            }
        }
    };

    //TODO: somehow unify highlightFragment (3D) and highlightObject (2D)
    this.highlightFragment = function(model, fragId, value) {

        if (this.is2d) {
            _materials.highlightObject2D(fragId, value);
        }
        else {
            //currently there is a single model so the mapping
            //of fragId to render mesh is 1:1.
            _modelQueue.setHightlighted(fragId,value);
        }
    };

    this.explode = function(scale) {
        if(scale == _explodeScale || !this.model) {
            return;
        }
        
        _explodeScale = scale;
        
        var model = this.model;
        var svf = model.getData();

        var mc = this.getVisibleBounds(true).center();

    //var t0 = Date.now();

        var frags = svf.fragments;
        var transforms = frags.transforms;
        var scaledExplodeDepth = scale * (svf.maxTreeDepth - 1) + 1;
        var explodeDepth = 0 | scaledExplodeDepth;
        var currentSegmentFraction = scaledExplodeDepth - explodeDepth;

        //Input scale is in the range 0-1, where 0
        //means no displacement, and 1 maximum reasonable displacement.
        scale *= 2;

        //If we have a full part hierarchy we can use a
        //better grouping strategy when exploding
        if (svf.instanceTree && svf.instanceBoxes && scale != 0) {
            var nodeBoxes = svf.instanceBoxes;

            (function explodeRec(node, depth, cx, cy, cz, ox, oy, oz) {

                var oscale = scale*2; //TODO: also possibly related to depth
                if (depth == explodeDepth)
                    oscale *= currentSegmentFraction; //smooth transition of this tree depth from non-exploded to exploded state

                var box_offset = node.dbId * 6;
                var mycx = 0.5 * (nodeBoxes[box_offset] + nodeBoxes[box_offset+3]);
                var mycy = 0.5 * (nodeBoxes[box_offset+1] + nodeBoxes[box_offset+4]);
                var mycz = 0.5 * (nodeBoxes[box_offset+2] + nodeBoxes[box_offset+5]);

                if (depth > 0 && depth <= explodeDepth) {
                    var dx = (mycx - cx) * oscale;
                    var dy = (mycy - cy) * oscale;
                    var dz = (mycz - cz) * oscale;

                    //var omax = Math.max(dx, Math.max(dy, dz));
                    ox += dx;
                    oy += dy;
                    oz += dz;
                }

                var children = node.children;
                if (children) {
                    //Inner node

                    //Recursively move each child relative to this node
                    for (var i= 0, iEnd=children.length; i<iEnd; i++) {
                        explodeRec(children[i], depth+1, mycx, mycy, mycz, ox, oy, oz)
                    }
                }

                var fragIds = node.fragIds;
                if (fragIds !== undefined) {
                    //Leaf
                    if (!Array.isArray(fragIds)) {
                        var frag = fragIds | 0;


                        var mtx = _this.getRenderProxy(model, frag).matrixWorld.elements;
                        var mtx_offset = frag * 16;

                        mtx[12] = transforms[mtx_offset+12] + ox;
                        mtx[13] = transforms[mtx_offset+13] + oy;
                        mtx[14] = transforms[mtx_offset+14] + oz;
                    }
                    else {
                        for (var j=0; j<fragIds.length; j++) {
                            var frag = 0 | fragIds[j];
                            var mtx_offset = frag * 16;

                            var mtx = _this.getRenderProxy(model, frag).matrixWorld.elements;
                            mtx[12] = transforms[mtx_offset+12] + ox;
                            mtx[13] = transforms[mtx_offset+13] + oy;
                            mtx[14] = transforms[mtx_offset+14] + oz;
                        }
                    }
                }

            })(svf.instanceTree, 0, mc.x, mc.y, mc.x, 0, 0, 0);
        }
        else {
            var boxes = frags.boxes;

            for (var i= 0, iEnd=frags.length; i<iEnd; i++) {
                var box_offset = i * 6;
                var mtx_offset = i * 16;

                var cx = 0.5 * (boxes[box_offset]+boxes[box_offset+3]);
                var cy = 0.5 * (boxes[box_offset+1]+boxes[box_offset+4]);
                var cz = 0.5 * (boxes[box_offset+2]+boxes[box_offset+5]);

                cx = scale * (cx - mc.x);
                cy = scale * (cy - mc.y);
                cz = scale * (cz - mc.z);

                var mtx = _this.getRenderProxy(model, i).matrixWorld.elements;
                mtx[12] = transforms[mtx_offset+12] + cx;
                mtx[13] = transforms[mtx_offset+13] + cy;
                mtx[14] = transforms[mtx_offset+14] + cz;
            }
        }

    //var t1 = Date.now();
    //stderr(t1 - t0);

        // Mark the scene bounds for update
        _modelQueue.visibleBoundsDirty = true;

        //force a repaint and a clear
        _needsClear = true;
        _overlayDirty = true;

        this.api.fireEvent({type:Autodesk.Viewing.EXPLODE_CHANGE_EVENT});
    };
    
    /**
     * Gets the last applied explode scale
     */
    this.getExplodeScale = function()
    {
        return _explodeScale;
    }


    /* simple function to set the brightness of the ghosting.
     * Simply sets another colour that is better for brighter environments
     */
    this.setGhostingBrightness = function(darkerFade)
    {
        if (darkerFade) {
            this.fadeMaterial.color = new THREE.Color(0x101010);
        }
        else {
            this.fadeMaterial.color =  new THREE.Color(0xffffff);
        }
        this.fadeMaterial.needsUpdate = true;
    };


    this.setLightPreset = function(index, forceUpdate)
    {
        if (_currentLightPreset == index && !forceUpdate)
            return;

        // Reset index in cases the index out of range.
        // This could happen, if we update the light preset list and user
        // has a local web storage which stores the last accessed preset index which is potentially
        // out of range with respect to the new preset list.
        if (index < 0 || avp.LightPresets.length <= index) {
            index = avp.DefaultLightPreset;
        }

        _currentLightPreset = index;
        var preset = avp.LightPresets[index];
        if (preset && preset.path) {
            var pathPrefix = RESOURCE_ROOT + "environments/" + preset.path;
            var reflPath = pathPrefix + "_mipdrop.logluv.dds";
            var irrPath =  pathPrefix + "_irr.logluv.dds";

            _materials.setIrradianceMap(irrPath);
            _materials.setCubeMap(reflPath);

            this.setExposureBias(preset.E_bias);
            this.setTonemapMethod(preset.tonemap);

            this.setGhostingBrightness(preset.darkerFade);
        }
        else {
            _materials.setIrradianceMap(null);
            _materials.setCubeMap(null);

            this.setExposureBias(0);
            this.setTonemapMethod(0);

            this.setGhostingBrightness(false);
        }


        //To begin with, get the SAO defaults from the shader uniforms definition
        //Note the scaling we apply to inverse scaling done by the setAOOptions API internally.
        var saoRadius = SAOShader.uniforms.radius.value;
        var saoIntensity = SAOShader.uniforms.intensity.value;

        //Check if the preset overrides the SAO settings
        if (preset.hasOwnProperty("saoRadius"))
            saoRadius = preset.saoRadius;
        if (preset.hasOwnProperty("saoIntensity"))
            saoIntensity = preset.saoIntensity;
        _renderer.setAOOptions(saoRadius, saoIntensity);

        //if the light preset has a specific background color, set that
        var c = preset.bgColorGradient;
        if (!c)
            c = avp.BackgroundPresets["Custom"];
        this.setClearColors(c[0], c[1], c[2], c[3], c[4], c[5]);

        var lightIntensity = 1;
        if (preset.lightMultiplier !== null && preset.lightMultiplier !== undefined) {
            lightIntensity = preset.lightMultiplier;
        }

        if (this.dir_light1) {
            this.toggleLights(lightIntensity != 0);
            this.dir_light1.intensity = lightIntensity;
        }

        _needsClear = true;
        _overlayDirty = true;

        this.fireRenderOptionChanged();
    };

    this.setLightPresetFromFile = function()
    {

        var style = this.model.getMetadata('renderEnvironmentStyle', 'value', null);

        if ((style === null) || (style ===""))
            return false;

        // TODO Not really sure what to do with the bg colour will need to see real examples.
        //var bgcolor = this.getMetadata('renderEnvironmentBackgroundColor', 'value', null);
        //[default value = 1,1,1,1]
        // TODO add more control for environments
        // the user cannot set anything expect the style from current UI
        // currently only the style can be selected.
        // TODO We cannot control these values so comment out for now
        //var envRotation = this.getMetadata('renderEnvironmentRotation', 'value', null);
        //default value = 0
        //var bgEnvironment = this.getMetadata('renderEnvironmentBackgroundFromEnvironment', 'value', null);
        // default value = false
        //var grndReflection = this.getMetadata('renderEnvironmentGroundReflection', 'value', null);
        // default value = false
        //var grndShadow = this.getMetadata('renderEnvironmentGroundShadow', 'value', null);
        // default value = false

        var exposureBias = this.model.getMetadata('renderEnvironmentExposureBias', 'value', null);
        var exposureBase = this.model.getMetadata('renderEnvironmentExposureBase', 'value', null);


        for (var i=0; i<avp.LightPresets.length; i++) {
            if (style === avp.LightPresets[i].name) {
                if (exposureBias !== null && exposureBase !== null ) {
                    avp.LightPresets[i].E_bias = exposureBias + exposureBase;
                }
                this.setLightPreset(i, true);
                return true;
            }
        }

        return false;
    };


    this.setTonemapMethod = function (index) {

        if (index == _renderer.getToneMapMethod())
            return;

        _renderer.setTonemapMethod(index);
        _materials.setTonemapMethod(index);

        this.fireRenderOptionChanged();
        this.invalidate(true);
    };

    this.setExposureBias = function (bias) {

        if (bias == _renderer.getExposureBias())
            return;

        _renderer.setExposureBias(bias);
        _materials.setExposureBias(bias);

        this.fireRenderOptionChanged();
        this.invalidate(true);
    };


    this.uninitialize = function() {
        window.cancelAnimationFrame(_reqid);

        this.controls.uninitialize();
        this.controls = null;
        this.canvas = null;

        this.svfloader.uninitialize();
        this.svfloader = null;

        this.selector.uninitialize();
        this.selector = null;

        this.model = null;
        this.visibilityManager = null;

        _modelQueue = null;
        _renderer = null;
        _materials = null;
    };

    this.hideLines = function(hide){
        if (_modelQueue) {
            _modelQueue.hideLines(hide);
            //force a clear
            _needsClear = true;
            return true;
        }
        return false;
    };


    this.fireRenderOptionChanged = function() {

        //If SAO is changing and we are using multiple
        //render targets in the main material pass, we have
        //to update the materials accordingly.
        var useSAO = _renderer.hasMRT() && _renderer.settings.sao;

        _materials.toggleMRTSetting(useSAO);

        this.api.fireEvent({type:Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT});
    };

    this.castRayViewport = function (vpVec, ignoreTransparent) {
        if (!_modelQueue) {
            return {};
        }

        var vector = vpVec;
        var camera = this.camera;

        // set two vectors with opposing z values
        vector.z = -1.0;
        var end = new THREE.Vector3( vector.x, vector.y, 1.0 );
        _projector.unprojectVector( vector, camera );
        _projector.unprojectVector( end, camera );

        // find direction from vector to end
        end.sub( vector ).normalize();

        var result = _modelQueue.rayIntersect(!camera.isPerspective ? vector : camera.position, end, ignoreTransparent);
        var object = result[0], intersectPoint = result[1];

        var dbNode = null;
        if (object) {

            var svf = this.model.getData();

            var frags = svf ? svf.fragments : null;
            var fragId = object.fragId;

            if (frags.fragToDbNode && frags.fragToDbNode[fragId])
                dbNode = frags.fragToDbNode[fragId];
            else {
                //Case where there is no object tree hierarchy. Create a 'virtual' node
                //with node Id = fragment Id, so that selection works like
                //each scene fragment is a scene node by itself.
                dbNode = { "dbId":fragId, fragIds: fragId };
            }
        }

        return {"node":dbNode, "intersectPoint":intersectPoint} ;

    };

    this.clientToViewport = function (clientX, clientY)
    {
        var rect = _this.canvas.getBoundingClientRect();
        return new THREE.Vector3(
            ((clientX + 0.5 - rect.left) / rect.width) * 2 - 1,
           -((clientY + 0.5 - rect.top) / rect.height) * 2 + 1, 1 );
    };

    this.viewportToClient = function (viewportX, viewportY)
    {
        var rect = _this.canvas.getBoundingClientRect();
        return new THREE.Vector3(
            (viewportX + 1) * 0.5 * rect.width  + rect.left -0.5,
            (viewportY - 1) *-0.5 * rect.height + rect.top  -0.5, 0 );
    };

    this.castRay = function (clientX, clientY, ignoreTransparent) {
        // Use the offsets based on the client rectangle, which is relative to the browser's client
        // rectangle, unlike offsetLeft and offsetTop, which are relative to a parent element.
        //
        return this.castRayViewport(this.clientToViewport(clientX, clientY),ignoreTransparent);
    };


    this.intersectGroundViewport = function(vpVec) {

        var camera = this.camera;

        var worldUp = "z";

        //In 2D mode, the roll tool can be used to change the orientation
        //of the sheet, which will also set the world up vector to the new orientation.
        //However, this is not what we want in case of a 2d sheet -- its ground plane is always Z.
        //TODO: It's not clear if checking here or in setWorldUp is better. Also I don't see
        //a way to generalize the math in a way to make it work without such check (e.g. by using camera up only).
        if (!this.is2d) {
            if (_worldUp.x == 1)
                worldUp = "x";
            else if (_worldUp.y == 1)
                worldUp = "y";
        }

        var vector = vpVec;

        // set two vectors with opposing z values
        vector.z = -1.0;
        var end = new THREE.Vector3( vector.x, vector.y, 1.0 );
        _projector.unprojectVector( vector, camera );
        _projector.unprojectVector( end, camera );

        // find direction from vector to end
        end.sub( vector ).normalize();

        var dir = end;

        //Is the direction parallel to the ground plane?
        //Then we fail.
        if (Math.abs(dir[worldUp]) < 1e-6)
            return null;

        var baseElev = this.model ? this.model.getBoundingBox().min[worldUp] : 0;

        var distance = (baseElev - camera.position[worldUp]) / dir[worldUp];

        //2D drawing, intersect the plane
        dir.multiplyScalar(distance);
        dir.add(camera.position);

        return dir;
    };

    this.intersectGround = function(clientX, clientY) {
        return this.intersectGroundViewport(this.clientToViewport(clientX, clientY));
    };


    this.hitTestViewport = function(vpVec, ignoreTransparent) {

        var result;

        if (_this.is2d) {

            var dbId = _renderer.idAtPixel(vpVec.x, vpVec.y);

            //Note this function will destructively modify vpVec,
            //so it's unusable after that.
            var point = this.intersectGroundViewport(vpVec);

            var node = dbId ? { dbId : dbId, fragIds : _this.model.getData().fragments.dbId2fragId[dbId] } : null;
            result = { intersectPoint : point, node: node };

            if (dbId) {
                stderr("dbId " + dbId);
                //result.node = ... get the node for the dbId here
            }

        }
        else {

            result = this.castRayViewport(vpVec, ignoreTransparent);

        }

        return result;
    };


    this.hitTest = function(clientX, clientY, ignoreTransparent) {

        return _this.hitTestViewport(this.clientToViewport(clientX, clientY), ignoreTransparent);

    };


    //Used for rollover highlighting using pre-computed ID buffer
    //Currently only the 2D code path can do this.
    this.rolloverObjectViewport = function(vpVec) {

        //Got to wait for a valid id buffer.
        if (_idsDirty)
            return;

        _renderer.rolloverObjectViewport(vpVec.x, vpVec.y);
        _overlayDirty = true;
    };

    this.rolloverObject = function(clientX, clientY) {
        this.rolloverObjectViewport(this.clientToViewport(clientX, clientY));
    };

    //This accessor is only used for debugging purposes a.t.m.
    this.modelQueue = function() { return _modelQueue; };

    this.renderer = function() { return _renderer; };

    this.invalidate = function(needsClear, needsRender, overlayDirty) {
        _needsClear = needsClear;
        _needsRender = needsRender;
        _overlayDirty = overlayDirty;
    };

    this.currentLightPreset = function() { return _currentLightPreset; };

    this.matman = function() { return _materials; };

    //========================================================================

    this.api = theapi;
    this.canvas = thecanvas;

    this.svfloader = new avp.SvfLoader(this);

    _renderer = new RENDER_CONTEXT_CLASS();

    _renderer.init(thecanvas);

    _materials = new avp.MaterialManager(this);


    //stderr("dpr: " + window.devicePixelRatio);

    // create a WebGL renderer, camera
    // and a scene
    //this.camera = new THREE.CombinedCamera( w, h, VIEW_ANGLE, NEAR, FAR, NEAR, FAR);
    // this.camera = new THREE.PerspectiveCamera( VIEW_ANGLE, thecanvas.clientWidth/thecanvas.clientHeight, NEAR, FAR);
    // this.cameraChangedEvent = {type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: this.camera};

    // create a WebGL renderer, camera
    // and a scene
    //this.camera = new THREE.CombinedCamera( w, h, VIEW_ANGLE, NEAR, FAR, NEAR, FAR);
    this.camera = new Autodesk.Viewing.UnifiedCamera(thecanvas.clientWidth, thecanvas.clientHeight);
    // this.camera = this.unicam.getOrthographicCamera();
    this.cameraChangedEvent = this.camera.getCameraChangedEvent();


    //This scene will just hold the camera and lights, while
    //we keep groups of progressively rendered geometry in
    //separate geometry scenes.
    this.scene = new THREE.Scene();

    // add the camera to the scene
    this.scene.add(this.camera);

    this.overlayScenes = {};

    this.selectionMaterialBase = new THREE.MeshPhongMaterial({color:0x6699ff, specular:0x080808, emissive:0x334c77, ambient:0, opacity:1.0, transparent:false});
    this.selectionMaterialTop = new THREE.MeshPhongMaterial({color:0x6699ff, specular:0x080808, emissive:0x334c77, ambient:0, opacity:.15, transparent:true});
    this.selectionMaterial2d = null;

    this.createOverlayScene("selection", this.selectionMaterialBase, this.selectionMaterialTop);

    this.fadeMaterial = new THREE.MeshPhongMaterial({color:0xffffff, opacity:0.1, reflectivity: 0, transparent:true});
    _materials.addMaterial("__fadeMaterial__", this.fadeMaterial, true);

    this.highlightMaterial = new THREE.MeshPhongMaterial({color:0x6699ff, specular:0x080808, emissive:0x334c77, ambient:0, opacity:1.0, transparent:false});
    _materials.addMaterial("__highlightMaterial__", this.highlightMaterial, true);

    this.idMaterial = null; //2d selection (id buffer) renderer material.

    //Settings exposed to GUI:
    this.progressiveRender = true;

    this.maxFrameTime = MAX_FRAME_TIME;
    this.minFrameTime = MIN_FRAME_TIME;
    //this.targetFrameRate = 2000 / (MIN_FRAME_TIME + MAX_FRAME_TIME);


    // If a callback was provided to create the controls, use it.
    // Otherwise instantiate the old default controller.
    if (createControlsCallback)
        this.controls = createControlsCallback(this);

    if (!this.controls) {
        //this.controls = new THREE.OrbitControls(this.camera, this.canvas);
        this.controls = new THREE.TrackballControls(this.camera, this.canvas);
        this.controls.rotateSpeed = 1.0;
        this.controls.zoomSpeed = 1.0;
        this.controls.panSpeed = 0.5;
        this.controls.dynamicDampingFactor = 0.5;
        this.controls.owner = this;
    }
    this.selector = new avp.Selector(this);
    this.controls.setSelector(this.selector);

	this.visibilityManager = new avp.VisibilityManager(this);

    this.showGhosting = true;
	this.showOverlaysWhileMoving = true;
    this.skipAOWhenMoving = false;

    this.keyFrameAnimator = null;

    this.setClearColors(230.0,230.0,230.0,150.0,150.0,150.0);
    //this.setClearColors(200.0,233.0,255.0,100.0,116.0,127.0);

    //just meant to do an initial clear to the background color we want.
    _renderer.beginScene(this.scene, this.camera, true);
    _renderer.composeFinalFrame();

    // Record fragments transformation in explode mode for RaaS rendering
    //this.fragTransformConfig = [];

};

Autodesk.Viewing.Private.Viewer3DImpl.prototype.constructor = Autodesk.Viewing.Private.Viewer3DImpl;
;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

/**
 * This is the Tessera document API for design content.
 * @ignore
 */
AutodeskNamespace('Autodesk.Viewing.Private');

/**
 * Responsible for creating and restoring viewer states.
 *
 * @param {Autodesk.Viewing.Viewer3D} viewer
 * @constructor
 */
Autodesk.Viewing.Private.ViewerState = function( viewer )
{
    /**
     * All-inclusive filter constant used when no filter is provided.
     * @type {boolean}
     */
    var FILTER_ALL = true;


    function makeRandom() {
        // TODO: think a better way to get random numbers (Math.random is not a good random function).
        var random = Math.round(Math.random() * 0xffffffff);
        var timestamp = Date.now();

        return random.toString(16) + timestamp.toString(16);
    }


    /**
     * Return a viewer state Object for the current Viewer.
     *
     * Check wiki for more information:
     *   - https://wiki.autodesk.com/pages/viewpage.action?pageId=160643881 -
     *
     * @param {Object} [filter] - Object with a structure similar to the output where
     *                          values are replaced with Booleans true/false indicating
     *                          whether they should be stored or not.
     * @param {Object} [baseObject] - When supplied, baseObject will be returned with viewer
     *                                state data injected to it. No additional structure changes,
     *                                preserves all non-viewer state data fields intact.
     * @returns {Object} - Describing the state of the viewer.
     */
    this.getState = function( filter, baseObject ) {

        var nav = viewer.navigation;
        var avp = Autodesk.Viewing.Private;
        var viewerState = baseObject || {};


        // Adding level-0 properties
        viewerState["guid"] = makeRandom();
        viewerState["seedURN"] = viewer.impl.svfloader.svfUrn;
        viewerState["overrides"] = this.getTransformsOverrides();


        // Object set, contains selection, isolation and explode value.
        var objectSet = viewerState["objectSet"];
        if (!Array.isArray(objectSet)) {
            viewerState["objectSet"] = objectSet = [];
        }
        // Spec call for these elements to grouped in an Object at an Array's index 0.
        objectSet[0] = {
            id: this.getSelectedNodes(),
            isolated: this.getIsolatedNodes(),
            explodeScale: viewer.getExplodeScale()
        };


        // Viewport
        var viewport = viewerState["viewport"];
        if (!viewport) {
            viewport = viewerState["viewport"] = {};
        }
        var bPerspectiveCam = nav.getCamera().isPerspective;
        viewport["name"] = ""; // TODO: Populate accordingly; Requested by the mobile team.
        viewport["eye"] = nav.getPosition().toArray();
        viewport["target"] = nav.getTarget().toArray();
        viewport["up"] = nav.getCameraUpVector().toArray();
        viewport["worldUpVector"] = nav.getWorldUpVector().toArray();
        viewport["pivotPoint"] = nav.getPivotPoint().toArray();
        viewport["distanceToOrbit"] = nav.getPivotPlaneDistance();
        viewport["aspectRatio"] = this.getAspectRatio();
        viewport["projection"] = bPerspectiveCam ? "perspective" : "orthographic";
        viewport["isOrthographic"] = !bPerspectiveCam;
        if (bPerspectiveCam) {
            viewport["fieldOfView"] = nav.getVerticalFov();
        } else {
            viewport["orthographicHeight"] = this.getOrthographicHeight();
        }


        // Render Options
        var renderOptions = viewerState["renderOptions"];
        if (!renderOptions) {
            renderOptions = viewerState["renderOptions"] = {};
        }
        renderOptions["environment"] = avp.LightPresets[viewer.impl.currentLightPreset()].name;
        renderOptions["ambientOcclusion"] = {
            enabled: viewer.impl.renderer().settings.sao,
            radius: viewer.impl.renderer().getAORadius(),
            intensity: viewer.impl.renderer().getAOIntensity()
        };
        renderOptions["toneMap"] = {
            method: viewer.impl.renderer().getToneMapMethod(),
            exposure: viewer.impl.renderer().getExposureBias(),
            lightMultiplier: this.getToneMapIntensity()
        };
        renderOptions["appearance"] = {
            ghostHidden: viewer.impl.showGhosting,
            ambientShadow: viewer.prefs.ambientShadows,
            antiAliasing: viewer.impl.renderer().settings.antialias,
            progressiveDisplay: viewer.prefs.progressiveRendering,
            displayLines: viewer.prefs.lineRendering
        };


        // Allow extensions to inject their state data
        for (var extensionName in viewer.loadedExtensions) {
            viewer.loadedExtensions[extensionName].getState(viewerState);
        }

        // Filter out values the user doesn't want to consume before returning.
        if (filter && filter !== FILTER_ALL) {
            this.applyFilter(viewerState, filter);
        }
        return viewerState;
    };


    /**
     * Restores the viewer with a given viewerState object.
     *
     * @param {Object} viewerState
     * @param {Object} [filter] - Similar in structure to viewerState used to filter out values
     *                            that should not be restored.
     * @param {boolean} [immediate] - Whether the state should be apply with (false)
     *                                or without (true) a smooth transition
     *
     * @returns {boolean} true, if the operation was successful.
     */
    this.restoreState = function( viewerState, filter, immediate ) {

        if (!viewerState) {
            stderr("restoreState has no viewer state to restore from.");
            return false;
        }

        if (filter && filter !== FILTER_ALL) {
            this.applyFilter(viewerState, filter);
        }

        // Abort if we are still animating
        var nav = viewer.navigation;
        if( nav.getTransitionActive() ) {
            stderr("Abort restoreState, animation in progress...");
            return false;

        }

        // Objectset
        if (Array.isArray(viewerState.objectSet) && viewerState.objectSet.length > 0) {
            var objectSet = viewerState.objectSet[0];

            // Selection
            var selector = viewer.impl ? viewer.impl.selector : null;
            var selectionIds = objectSet.id;
            if (selectionIds && selector) {
                selector.setSelectionIds(selectionIds);
            }

            // Isolation
            var isolatedIds = objectSet.isolated || [];
            viewer.isolateById(isolatedIds);

            // Explode scale
            if ("explodeScale" in objectSet) {
                var explodeScale = parseFloat(objectSet.explodeScale);
                if( viewer.explode && viewer.explodeslider ) {
                    viewer.explode(explodeScale);
                    viewer.explodeslider.value = explodeScale * 100;
                }
            }
        }

        var viewport = viewerState.viewport;
        if (viewport) {

            var eye = this.getVector3FromArray(viewport.eye, nav.getPosition());
            var up = this.getVector3FromArray(viewport.up, nav.getCamera().up);
            var target = this.getVector3FromArray(viewport.target, nav.getTarget());
            var fov = ("fieldOfView" in viewport) ? parseFloat(viewport.fieldOfView) : nav.getVerticalFov();
            var pivot = this.getVector3FromArray(viewport.pivotPoint, nav.getPivotPoint());

            nav.setCameraUpVector(up);

            if ("isOrthographic" in viewport) {
                if (viewport.isOrthographic) {
                    nav.toOrthographic();
                } else {
                    nav.toPerspective();
                }
            }

            if (immediate) {
                nav.setVerticalFov(fov, false);
                nav.setView(eye, target);
            } else {
                nav.setRequestTransition(true, eye, target, fov, false);
            }

            nav.setPivotPoint(pivot);
            nav.setPivotSetFlag(true);
        }


        // Render option state
        var renderOptions = viewerState.renderOptions;
        if (renderOptions) {

            // current values
            var saoEnabled = viewer.prefs.ambientShadows;
            var antiAliasing = viewer.prefs.antialiasing;

            var sao = renderOptions.ambientOcclusion;
            if (sao) {
                if ("enabled" in sao) {
                    saoEnabled = sao.enabled;
                }
                var saoRadius = ("radius" in sao) ? sao.radius : null;
                var saoIntensity = ("intensity" in sao) ? sao.intensity : null;
                if (saoRadius !== null && saoIntensity !== null) {
                    viewer.impl.renderer().setAOOptions(saoRadius, saoIntensity);
                    viewer.impl.renderer().composeFinalFrame(false);
                }
            }

            if ("environment" in renderOptions) {
                var lightPresetIndex = this.getLightPresetIndex(renderOptions.environment);
                if (lightPresetIndex !== -1) {
                    viewer.setLightPreset(lightPresetIndex);
                }
            }

            // ToneMap values are overrides to the environment settings.
            var toneMap = renderOptions.toneMap;
            if (toneMap) {
                var lightMultiplier = "lightMultiplier" in toneMap ?  toneMap.lightMultiplier : null;
                var exposure = "exposure" in toneMap ? toneMap.exposure : null;
                if (lightMultiplier !== null && exposure !== null) {
                    if (viewer.impl.dir_light1) {
                        viewer.impl.dir_light1.intensity = Math.pow(2.0, lightMultiplier);
                    }
                    viewer.impl.renderer().setExposureBias(exposure, lightMultiplier);
                    viewer.impl.invalidate(true);
                }
            }

            var appearance = renderOptions.appearance;
            if (appearance) {
                if ("antiAliasing" in appearance) {
                    antiAliasing = appearance.antiAliasing;
                }
                if ("progressiveDisplay" in appearance) {
                    viewer.setProgressiveRendering(appearance.progressiveDisplay);
                }
                if ("ghostHidden" in appearance) {
                    viewer.setGhosting(appearance.ghostHidden);
                }
                if ("displayLines" in appearance) {
                    viewer.hideLines(!appearance.displayLines);
                }
            }

            // SAO and AA at the end.
            viewer.setQualityLevel(saoEnabled, antiAliasing);
        }

        // Allow extensions to restore their data
        for (var extensionName in viewer.loadedExtensions) {
            viewer.loadedExtensions[extensionName].restoreState(viewerState, immediate);
        }

        return true;
    };

    /**
     * Returns whether the current URN and the viewerState URN match.
     *
     * @param {Object} viewerState - created with getState() method.
     * @returns {boolean}
     */
    this.isValidState = function( viewerState ) {

        if (!viewerState) {
            return false;
        }

        // Special case for when there's no seedURN defined, we take that as an okay case.
        if (!"seedURN" in viewerState) {
            return true;
        }

        var currURN = viewer.impl.svfloader.svfUrn;
        return (currURN === viewerState.seedURN);
    };

    /**
     * Given a viewer state, extracts the selected nodes.
     *
     * @param {Object} viewerState - for example, the result of this.getState().
     * @return {Array} containing the ids of the selected nodes.
     */
    this.extractSelectedNodeIds = function( viewerState ) {

        if (viewerState && Array.isArray(viewerState.objectSet) && viewerState.objectSet.length > 0) {
            var objectSet = viewerState.objectSet[0];
            if (Array.isArray(objectSet.id)) {
                return objectSet.id;
            }
        }
        return [];
    };

    /**
     * Given a viewer state, extracts the isolated nodes.
     *
     * @param {Object} viewerState - for example, the result of this.getState().
     * @return {Array} containing ids of the isolated nodes.
     */
    this.extractIsolatedNodeIds = function( viewerState ) {

        if (viewerState && Array.isArray(viewerState.objectSet) && viewerState.objectSet.length > 0) {
            var objectSet = viewerState.objectSet[0];
            if (Array.isArray(objectSet.isolated)) {
                return objectSet.isolated;
            }
        }
        return [];
    };

    /**
     * Helper method that constructs a Vector3 from a given Array.
     * If Array is not well-formed, then the failValue is return instead.
     *
     * @param {Array} array - An array with 3 values
     * @param {THREE.Vector3} failValue - If array param is invalid, failValue will be returned instead.
     *
     * @returns {THREE.Vector3} either a new Vector with values coming from 'array' or failValue.
     */
    this.getVector3FromArray = function(array, failValue) {

        if (array instanceof Array && array.length > 2) {

            // Some array values are exported as string-of-numbers. Fix that here.
            array[0] = parseFloat(array[0]);
            array[1] = parseFloat(array[1]);
            array[2] = parseFloat(array[2]);
            return new THREE.Vector3().fromArray(array);
        }
        return failValue;
    };

    /**
     * Helper function that returns selected node ids in an array.
     * @returns {Array}
     * @private
     */
    this.getSelectedNodes = function() {

        var selection = viewer.impl && viewer.impl.selector ? viewer.impl.selector.getSelection() : [];
        var selectionCount = selection.length;
        var selectionIds = [];
        for(var i = 0; i < selectionCount; ++i) {
            selectionIds.push(selection[i].dbId);
        }
        return selectionIds;
    };

    /**
     * Helper function that returns isolated node ids in an array.
     * @returns {Array}
     * @private
     */
    this.getIsolatedNodes = function() {

        var isolatedItems = viewer.getIsolatedNodes();
        for (var j = 0, len = isolatedItems.length; j < len; ++j) {
            isolatedItems[j] = isolatedItems[j].dbId;
        }
        return isolatedItems;
    };

    /**
     * Gets the aspect ratio.
     *
     * @returns {number} aspect ratio
     */
    this.getAspectRatio = function() {
        var viewport = viewer.navigation.getScreenViewport();
        var aspect = viewport.width / viewport.height;
        return aspect;
    };

    /**
     * Returns world height when in orthographic camera mode.
     * @returns {number}
     */
    this.getOrthographicHeight = function() {
        var cam = viewer.navigation.getCamera();
        if (cam.isPerspective) return 0;
        return Math.abs(2 * cam.orthographicCamera.top);
    };

    /**
     * TODO: Add proper comment
     * @returns {{}}
     * @private
     */
    this.getTransformsOverrides = function() {

        // TODO: Add proper implementation.
        return  { transformations: [] };
    };

    /**
     * Returns the slider value for the viewer's current light intensity
     * @returns {number}
     */
    this.getToneMapIntensity = function () {

        // Original code from RenderOptionsPanel.js
        // Should probably live elsewhere in the api.
        var intensity = 0.0;
        if (viewer.impl.dir_light1) {
            if (viewer.impl.dir_light1.intensity != 0)
                intensity = Math.log(viewer.impl.dir_light1.intensity)/Math.log(2.0);
            else
                intensity = -1e-20;
        }
        return intensity;
    };

    /**
     * Returns the index of the LightPreset with a matching name value.
     * @param environmentName
     * @returns {number} index of LightPreset, or -1 if not found.
     */
    this.getLightPresetIndex = function ( environmentName ) {

        var avp = Autodesk.Viewing.Private;
        for (var i=0; i<avp.LightPresets.length; i++) {
            if (avp.LightPresets[i].name === environmentName) {
                return i;
            }
        }
        return -1;
    };

    /**
     * Filters out key/value pairs from the viewerState.
     *
     * @note To get all of the values available use FILTER_ALL. If no filter is provided FILTER_ALL will be used.
     *       It is encourage for consumers to define their specialized filters.
     *
     * @param {Object} viewerState - Object to be filtered.
     * @param {Object} filter - Object with a similar structure to viewerState, where values are Booleans signaling which
     *                          elements should be included (true) and which ones should not (false).
*                               If a viewerState key is not found in the filter, we assume that it is non-wanted.
     */
    this.applyFilter = function( viewerState, filter ) {

        // Check the 'ALL' filter
        if (filter === true) return;

        // Filtering only 1 level depth keys
        // Additional levels are checked recursively.
        for (var key in viewerState) {

            if (!viewerState.hasOwnProperty(key)) {
                continue;
            }

            // Try to find the key in the filter object
            var filterValue = filter[key];

            if (filterValue === undefined) {

                // key not enabled in filter, remove key/value pair from viewerState.
                delete viewerState[key];
                stderr("[applyFilter] C - skipping key [" + key + "] from viewerState; unspecified in filter.");
            }
            else if (typeof(filterValue) === 'boolean') {

                if (filterValue === false) {
                    // key explicitly flagged for removal, remove key/value pair from viewerState.
                    delete viewerState[key];
                    stderr("[applyFilter] D - skipping key [" + key + "] from viewerState; explicit filtering.");
                }
            }
            else if (filterValue instanceof Object) {

                if (viewerState[key] instanceof Object) {
                    // Both are Objects, recursive call on them.
                    this.applyFilter(viewerState[key], filter[key]);
                } else {
                    // This case signals a miss-match between filter and value.
                    // Since it's an undefined case, we'll be inclusive for the time being.
                    // *** Keep the value in viewerState ***
                    stderr("[applyFilter] A - Invalid filter Object for key [" + key + "]");
                }
            }
            else {

                // Note: Every other value for filter is invalid.
                // For now, we'll keep the key/value in viewerState.
                stderr("[applyFilter] B - Invalid filter value for key [" + key + "]");
            }

        }
    };

};

Autodesk.Viewing.Private.ViewerState.prototype.constructor = Autodesk.Viewing.Private.ViewerState;
;// i18next, v1.7.3
// Copyright (c)2014 Jan Mhlemann (jamuhl).
// Distributed under MIT license
// http://i18next.com

AutodeskNamespace('Autodesk.Viewing.i18n');

(function() {

    // add indexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.indexOf) {
        Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = 0;
            if (arguments.length > 0) {
                n = Number(arguments[1]);
                if (n != n) { // shortcut for verifying if it's NaN
                    n = 0;
                } else if (n != 0 && n != Infinity && n != -Infinity) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            if (n >= len) {
                return -1;
            }
            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
            for (; k < len; k++) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        }
    }
    
    // add lastIndexOf to non ECMA-262 standard compliant browsers
    if (!Array.prototype.lastIndexOf) {
        Array.prototype.lastIndexOf = function(searchElement /*, fromIndex*/) {
            "use strict";
            if (this == null) {
                throw new TypeError();
            }
            var t = Object(this);
            var len = t.length >>> 0;
            if (len === 0) {
                return -1;
            }
            var n = len;
            if (arguments.length > 1) {
                n = Number(arguments[1]);
                if (n != n) {
                    n = 0;
                } else if (n != 0 && n != (1 / 0) && n != -(1 / 0)) {
                    n = (n > 0 || -1) * Math.floor(Math.abs(n));
                }
            }
            var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);
            for (; k >= 0; k--) {
                if (k in t && t[k] === searchElement) {
                    return k;
                }
            }
            return -1;
        };
    }
    
    // Add string trim for IE8.
    if (typeof String.prototype.trim !== 'function') {
        String.prototype.trim = function() {
            return this.replace(/^\s+|\s+$/g, ''); 
        }
    }

    var root = this
      , $ = root.jQuery || root.Zepto
      , i18n = {}
      , resStore = {}
      , currentLng
      , replacementCounter = 0
      , languages = []
      , initialized = false;

    // Export the i18next object for **CommonJS**. 
    // If we're not in CommonJS, add `i18n` to the
    // global object or to jquery.
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = i18n;
    } else {
        if ($) {
            $.i18n = $.i18n || i18n;
        }
        root.i18n = root.i18n || i18n;
    }
    // defaults
    var o = {
        lng: undefined,
        load: 'all',
        preload: [],
        lowerCaseLng: false,
        returnObjectTrees: false,
        fallbackLng: ['dev'],
        fallbackNS: [],
        detectLngQS: 'setLng',
        ns: 'translation',
        fallbackOnNull: true,
        fallbackOnEmpty: false,
        fallbackToDefaultNS: false,
        nsseparator: ':',
        keyseparator: '.',
        selectorAttr: 'data-i18n',
        debug: false,
        
        resGetPath: 'locales/__lng__/__ns__.json',
        resPostPath: 'locales/add/__lng__/__ns__',
    
        getAsync: true,
        postAsync: true,
    
        resStore: undefined,
        useLocalStorage: false,
        localStorageExpirationTime: 7*24*60*60*1000,
    
        dynamicLoad: false,
        sendMissing: false,
        sendMissingTo: 'fallback', // current | all
        sendType: 'POST',
    
        interpolationPrefix: '__',
        interpolationSuffix: '__',
        reusePrefix: '$t(',
        reuseSuffix: ')',
        pluralSuffix: '_plural',
        pluralNotFound: ['plural_not_found', Math.random()].join(''),
        contextNotFound: ['context_not_found', Math.random()].join(''),
        escapeInterpolation: false,

        defaultValueFromContent: true,
        useDataAttrOptions: false,
        cookieExpirationTime: undefined,
        useCookie: true,
        cookieName: 'i18next',
        cookieDomain: undefined,
    
        objectTreeKeyHandler: undefined,
        postProcess: undefined,
        parseMissingKey: undefined,
    
        shortcutFunction: 'sprintf' // or: defaultValue
    };

    function _extend(target, source) {
        if (!source || typeof source === 'function') {
            return target;
        }
    
        for (var attr in source) { target[attr] = source[attr]; }
        return target;
    }
    
    function _each(object, callback, args) {
        var name, i = 0,
            length = object.length,
            isObj = length === undefined || Object.prototype.toString.apply(object) !== '[object Array]' || typeof object === "function";
    
        if (args) {
            if (isObj) {
                for (name in object) {
                    if (callback.apply(object[name], args) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.apply(object[i++], args) === false) {
                        break;
                    }
                }
            }
    
        // A special, fast, case for the most common use of each
        } else {
            if (isObj) {
                for (name in object) {
                    if (callback.call(object[name], name, object[name]) === false) {
                        break;
                    }
                }
            } else {
                for ( ; i < length; ) {
                    if (callback.call(object[i], i, object[i++]) === false) {
                        break;
                    }
                }
            }
        }
    
        return object;
    }
    
    var _entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': '&quot;',
        "'": '&#39;',
        "/": '&#x2F;'
    };
    
    function _escape(data) {
        if (typeof data === 'string') {
            return data.replace(/[&<>"'\/]/g, function (s) {
                return _entityMap[s];
            });
        }else{
            return data;
        }
    }


    // This is taken from https://github.com/sindresorhus/strip-json-comments
    //
    var stripJsonComments = function( str ) {

        var currentChar;
        var nextChar;
        var insideString = false;
        var insideComment = false;
        var ret = '';

        for (var i = 0; i < str.length; i++) {
            currentChar = str[i];
            nextChar = str[i + 1];

            if (!insideComment && str[i - 1] !== '\\' && currentChar === '"') {
                insideString = !insideString;
            }

            if (insideString) {
                ret += currentChar;
                continue;
            }

            if (!insideComment && currentChar + nextChar === '//') {
                insideComment = 'single';
                i++;
            } else if (insideComment === 'single' && currentChar + nextChar === '\r\n') {
                insideComment = false;
                i++;
            } else if (insideComment === 'single' && currentChar === '\n') {
                insideComment = false;
            } else if (!insideComment && currentChar + nextChar === '/*') {
                insideComment = 'multi';
                i++;
                continue;
            } else if (insideComment === 'multi' && currentChar + nextChar === '*/') {
                insideComment = false;
                i++;
                continue;
            }

            if (insideComment) {
                continue;
            }

            ret += currentChar;
        }
        return ret;
    };

    function _ajax(options) {
    
        // v0.5.0 of https://github.com/goloroden/http.js
        var getXhr = function (callback) {
            // Use the native XHR object if the browser supports it.
            if (window.XMLHttpRequest) {
                return callback(null, new XMLHttpRequest());
            } else if (window.ActiveXObject) {
                // In Internet Explorer check for ActiveX versions of the XHR object.
                try {
                    return callback(null, new ActiveXObject("Msxml2.XMLHTTP"));
                } catch (e) {
                    return callback(null, new ActiveXObject("Microsoft.XMLHTTP"));
                }
            }
    
            // If no XHR support was found, throw an error.
            return callback(new Error());
        };
    
        var encodeUsingUrlEncoding = function (data) {
            if(typeof data === 'string') {
                return data;
            }
    
            var result = [];
            for(var dataItem in data) {
                if(data.hasOwnProperty(dataItem)) {
                    result.push(encodeURIComponent(dataItem) + '=' + encodeURIComponent(data[dataItem]));
                }
            }
    
            return result.join('&');
        };
    
        var utf8 = function (text) {
            text = text.replace(/\r\n/g, '\n');
            var result = '';
    
            for(var i = 0; i < text.length; i++) {
                var c = text.charCodeAt(i);
    
                if(c < 128) {
                        result += String.fromCharCode(c);
                } else if((c > 127) && (c < 2048)) {
                        result += String.fromCharCode((c >> 6) | 192);
                        result += String.fromCharCode((c & 63) | 128);
                } else {
                        result += String.fromCharCode((c >> 12) | 224);
                        result += String.fromCharCode(((c >> 6) & 63) | 128);
                        result += String.fromCharCode((c & 63) | 128);
                }
            }
    
            return result;
        };
    
        var base64 = function (text) {
            var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    
            text = utf8(text);
            var result = '',
                    chr1, chr2, chr3,
                    enc1, enc2, enc3, enc4,
                    i = 0;
    
            do {
                chr1 = text.charCodeAt(i++);
                chr2 = text.charCodeAt(i++);
                chr3 = text.charCodeAt(i++);
    
                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;
    
                if(isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if(isNaN(chr3)) {
                    enc4 = 64;
                }
    
                result +=
                    keyStr.charAt(enc1) +
                    keyStr.charAt(enc2) +
                    keyStr.charAt(enc3) +
                    keyStr.charAt(enc4);
                chr1 = chr2 = chr3 = '';
                enc1 = enc2 = enc3 = enc4 = '';
            } while(i < text.length);
    
            return result;
        };
    
        var mergeHeaders = function () {
            // Use the first header object as base.
            var result = arguments[0];
    
            // Iterate through the remaining header objects and add them.
            for(var i = 1; i < arguments.length; i++) {
                var currentHeaders = arguments[i];
                for(var header in currentHeaders) {
                    if(currentHeaders.hasOwnProperty(header)) {
                        result[header] = currentHeaders[header];
                    }
                }
            }
    
            // Return the merged headers.
            return result;
        };

        //
        var ajax = function (method, url, options, callback) {
            // Adjust parameters.
            if(typeof options === 'function') {
                callback = options;
                options = {};
            }
    
            // Set default parameter values.
            options.cache = options.cache || false;
            options.data = options.data || {};
            options.headers = options.headers || {};
            options.jsonp = options.jsonp || false;
            options.async = options.async === undefined ? true : options.async;

            // Merge the various header objects.
            var headers = mergeHeaders({
                'accept': '*/*',
                'content-type': 'application/x-www-form-urlencoded;charset=UTF-8'
            }, ajax.headers, options.headers);
    
            // Encode the data according to the content-type.
            var payload;
            if (headers['content-type'] === 'application/json') {
                payload = JSON.stringify(options.data);
            } else {
                payload = encodeUsingUrlEncoding(options.data);
            }
    
            // Specially prepare GET requests: Setup the query string, handle caching and make a JSONP call
            // if neccessary.
            if(method === 'GET') {
                // Setup the query string.
                var queryString = [];
                if(payload) {
                    queryString.push(payload);
                    payload = null;
                }
    
                // Handle caching.
                if(!options.cache) {
                    queryString.push('_=' + (new Date()).getTime());
                }
    
                // If neccessary prepare the query string for a JSONP call.
                if(options.jsonp) {
                    queryString.push('callback=' + options.jsonp);
                    queryString.push('jsonp=' + options.jsonp);
                }
    
                // Merge the query string and attach it to the url.
                queryString = queryString.join('&');
                if (queryString.length > 1) {
                    if (url.indexOf('?') > -1) {
                        url += '&' + queryString;
                    } else {
                        url += '?' + queryString;
                    }
                }
    
                // Make a JSONP call if neccessary.
                if(options.jsonp) {
                    var head = document.getElementsByTagName('head')[0];
                    var script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = url;
                    head.appendChild(script);
                    return;
                }
            }
    
            // Since we got here, it is no JSONP request, so make a normal XHR request.
            getXhr(function (err, xhr) {
                if(err) return callback(err);
    
                // Open the request.
                xhr.open(method, url, options.async);
    
                // Set the request headers.
                for(var header in headers) {
                    if(headers.hasOwnProperty(header)) {
                        xhr.setRequestHeader(header, headers[header]);
                    }
                }
    
                // Handle the request events.
                xhr.onreadystatechange = function () {
                    if(xhr.readyState === 4) {
                        var data = xhr.responseText || '';

                        // If no callback is given, return.
                        if(!callback) {
                            return;
                        }
    
                        // Return an object that provides access to the data as text and JSON.
                        callback(xhr.status, data );

                    }
                };
    
                // Actually send the XHR request.
                xhr.send(payload);
            });
        };
    
        // Define the external interface.
        var http = {
            authBasic: function (username, password) {
                ajax.headers['Authorization'] = 'Basic ' + base64(username + ':' + password);
            },
    
            connect: function (url, options, callback) {
                return ajax('CONNECT', url, options, callback);
            },
    
            del: function (url, options, callback) {
                return ajax('DELETE', url, options, callback);
            },
    
            get: function (url, options, callback) {
                return ajax('GET', url, options, callback);
            },
    
            head: function (url, options, callback) {
                return ajax('HEAD', url, options, callback);
            },
    
            headers: function (headers) {
                ajax.headers = headers || {};
            },
    
            isAllowed: function (url, verb, callback) {
                this.options(url, function (status, data) {
                    callback(data.text().indexOf(verb) !== -1);
                });
            },
    
            options: function (url, options, callback) {
                return ajax('OPTIONS', url, options, callback);
            },
    
            patch: function (url, options, callback) {
                return ajax('PATCH', url, options, callback);
            },
    
            post: function (url, options, callback) {
                return ajax('POST', url, options, callback);
            },
    
            put: function (url, options, callback) {
                return ajax('PUT', url, options, callback);
            },
    
            trace: function (url, options, callback) {
                return ajax('TRACE', url, options, callback);
            }
        };
    
    
        var methode = options.type ? options.type.toLowerCase() : 'get';
    
        http[methode](options.url, options, function (status, data) {
            if (status === 200) {
                options.success(data, status, null);
            } else {
                options.error(data, status, null);
            }
        });
    }
    
    var _cookie = {
        create: function(name,value,minutes,domain) {
            var expires;
            if (minutes) {
                var date = new Date();
                date.setTime(date.getTime()+(minutes*60*1000));
                expires = "; expires="+date.toGMTString();
            }
            else expires = "";
            domain = (domain)? "domain="+domain+";" : "";
            document.cookie = name+"="+value+expires+";"+domain+"path=/";
        },
    
        read: function(name) {
            var nameEQ = name + "=";
            var ca = document.cookie.split(';');
            for(var i=0;i < ca.length;i++) {
                var c = ca[i];
                while (c.charAt(0)==' ') c = c.substring(1,c.length);
                if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length,c.length);
            }
            return null;
        },
    
        remove: function(name) {
            this.create(name,"",-1);
        }
    };
    
    var cookie_noop = {
        create: function(name,value,minutes,domain) {},
        read: function(name) { return null; },
        remove: function(name) {}
    };
    
    
    
    // move dependent functions to a container so that
    // they can be overriden easier in no jquery environment (node.js)
    var f = {
        extend: $ ? $.extend : _extend,
        each: $ ? $.each : _each,
        ajax: $ ? $.ajax : (typeof document !== 'undefined' ? _ajax : function() {}),
        cookie: typeof document !== 'undefined' ? _cookie : cookie_noop,
        detectLanguage: detectLanguage,
        escape: _escape,
        log: function(str) {
            if (o.debug && typeof console !== "undefined") console.log(str);
        },
        toLanguages: function(lng) {
            var languages = [];
            if (typeof lng === 'string' && lng.indexOf('-') > -1) {
                var parts = lng.split('-');
    
                lng = o.lowerCaseLng ?
                    parts[0].toLowerCase() +  '-' + parts[1].toLowerCase() :
                    parts[0].toLowerCase() +  '-' + parts[1].toUpperCase();
    
                if (o.load !== 'unspecific') languages.push(lng);
                if (o.load !== 'current') languages.push(parts[0]);
            } else {
                languages.push(lng);
            }
    
            for (var i = 0; i < o.fallbackLng.length; i++) {
                if (languages.indexOf(o.fallbackLng[i]) === -1 && o.fallbackLng[i]) languages.push(o.fallbackLng[i]);
            }
    
            return languages;
        },
        regexEscape: function(str) {
            return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
        }
    };

    function init(options, cb) {
        
        if (typeof options === 'function') {
            cb = options;
            options = {};
        }
        options = options || {};
        
        // override defaults with passed in options
        f.extend(o, options);
        delete o.fixLng; /* passed in each time */
    
        // create namespace object if namespace is passed in as string
        if (typeof o.ns == 'string') {
            o.ns = { namespaces: [o.ns], defaultNs: o.ns};
        }
    
        // fallback namespaces
        if (typeof o.fallbackNS == 'string') {
            o.fallbackNS = [o.fallbackNS];
        }
    
        // fallback languages
        if (typeof o.fallbackLng == 'string' || typeof o.fallbackLng == 'boolean') {
            o.fallbackLng = [o.fallbackLng];
        }
    
        // escape prefix/suffix
        o.interpolationPrefixEscaped = f.regexEscape(o.interpolationPrefix);
        o.interpolationSuffixEscaped = f.regexEscape(o.interpolationSuffix);
    
        if (!o.lng) o.lng = f.detectLanguage(); 
        if (o.lng) {
            // set cookie with lng set (as detectLanguage will set cookie on need)
            if (o.useCookie) f.cookie.create(o.cookieName, o.lng, o.cookieExpirationTime, o.cookieDomain);
        } else {
            o.lng =  o.fallbackLng[0];
            if (o.useCookie) f.cookie.remove(o.cookieName);
        }
    
        languages = f.toLanguages(o.lng);
        currentLng = languages[0];
        f.log('currentLng set to: ' + currentLng);
    
        var lngTranslate = translate;
        if (options.fixLng) {
            lngTranslate = function(key, options) {
                options = options || {};
                options.lng = options.lng || lngTranslate.lng;
                return translate(key, options);
            };
            lngTranslate.lng = currentLng;
        }
    
        pluralExtensions.setCurrentLng(currentLng);

        // return immidiatly if res are passed in
        if (o.resStore) {
            resStore = o.resStore;
            initialized = true;
            if (cb) cb(lngTranslate);
            return;
        }
    
        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }
    
        // else load them
        Autodesk.Viewing.i18n.sync.load(lngsToLoad, o, function(err, store) {
            resStore = store;
            initialized = true;
    
            if (cb) cb(lngTranslate);
        });
    }

    function preload(lngs, cb) {
        if (typeof lngs === 'string') lngs = [lngs];
        for (var i = 0, l = lngs.length; i < l; i++) {
            if (o.preload.indexOf(lngs[i]) < 0) {
                o.preload.push(lngs[i]);
            }
        }
        return init(cb);
    }
    
    function addResourceBundle(lng, ns, resources) {
        if (typeof ns !== 'string') {
            resources = ns;
            ns = o.ns.defaultNs;
        } else if (o.ns.namespaces.indexOf(ns) < 0) {
            o.ns.namespaces.push(ns);
        }
    
        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = resStore[lng][ns] || {};
    
        f.extend(resStore[lng][ns], resources);
    }
    
    function removeResourceBundle(lng, ns) {
        if (typeof ns !== 'string') {
            ns = o.ns.defaultNs;
        }
    
        resStore[lng] = resStore[lng] || {};
        resStore[lng][ns] = {};
    }
    
    function setDefaultNamespace(ns) {
        o.ns.defaultNs = ns;
    }
    
    function loadNamespace(namespace, cb) {
        loadNamespaces([namespace], cb);
    }
    
    function loadNamespaces(namespaces, cb) {
        var opts = {
            dynamicLoad: o.dynamicLoad,
            resGetPath: o.resGetPath,
            getAsync: o.getAsync,
            customLoad: o.customLoad,
            ns: { namespaces: namespaces, defaultNs: ''} /* new namespaces to load */
        };
    
        // languages to load
        var lngsToLoad = f.toLanguages(o.lng);
        if (typeof o.preload === 'string') o.preload = [o.preload];
        for (var i = 0, l = o.preload.length; i < l; i++) {
            var pres = f.toLanguages(o.preload[i]);
            for (var y = 0, len = pres.length; y < len; y++) {
                if (lngsToLoad.indexOf(pres[y]) < 0) {
                    lngsToLoad.push(pres[y]);
                }
            }
        }
    
        // check if we have to load
        var lngNeedLoad = [];
        for (var a = 0, lenA = lngsToLoad.length; a < lenA; a++) {
            var needLoad = false;
            var resSet = resStore[lngsToLoad[a]];
            if (resSet) {
                for (var b = 0, lenB = namespaces.length; b < lenB; b++) {
                    if (!resSet[namespaces[b]]) needLoad = true;
                }
            } else {
                needLoad = true;
            }
    
            if (needLoad) lngNeedLoad.push(lngsToLoad[a]);
        }
    
        if (lngNeedLoad.length) {
            i18n.sync._fetch(lngNeedLoad, opts, function(err, store) {
                var todo = namespaces.length * lngNeedLoad.length;
    
                // load each file individual
                f.each(namespaces, function(nsIndex, nsValue) {
    
                    // append namespace to namespace array
                    if (o.ns.namespaces.indexOf(nsValue) < 0) {
                        o.ns.namespaces.push(nsValue);
                    }
    
                    f.each(lngNeedLoad, function(lngIndex, lngValue) {
                        resStore[lngValue] = resStore[lngValue] || {};
                        resStore[lngValue][nsValue] = store[lngValue][nsValue];
    
                        todo--; // wait for all done befor callback
                        if (todo === 0 && cb) {
                            if (o.useLocalStorage) i18n.sync._storeLocal(resStore);
                            cb();
                        }
                    });
                });
            });
        } else {
            if (cb) cb();
        }
    }
    
    function setLng(lng, options, cb) {
        if (typeof options === 'function') {
            cb = options;
            options = {};
        } else if (!options) {
            options = {};
        }
    
        options.lng = lng;
        return init(options, cb);
    }
    
    function lng() {
        return currentLng;
    }

    function applyReplacement(str, replacementHash, nestedKey, options) {
        if (!str) return str;
    
        options = options || replacementHash; // first call uses replacement hash combined with options
        if (str.indexOf(options.interpolationPrefix || o.interpolationPrefix) < 0) return str;
    
        var prefix = options.interpolationPrefix ? f.regexEscape(options.interpolationPrefix) : o.interpolationPrefixEscaped
          , suffix = options.interpolationSuffix ? f.regexEscape(options.interpolationSuffix) : o.interpolationSuffixEscaped
          , unEscapingSuffix = 'HTML'+suffix;
    
        f.each(replacementHash, function(key, value) {
            var nextKey = nestedKey ? nestedKey + o.keyseparator + key : key;
            if (typeof value === 'object' && value !== null) {
                str = applyReplacement(str, value, nextKey, options);
            } else {
                if (options.escapeInterpolation || o.escapeInterpolation) {
                    str = str.replace(new RegExp([prefix, nextKey, unEscapingSuffix].join(''), 'g'), value);
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), f.escape(value));
                } else {
                    str = str.replace(new RegExp([prefix, nextKey, suffix].join(''), 'g'), value);
                }
                // str = options.escapeInterpolation;
            }
        });
        return str;
    }
    
    // append it to functions
    f.applyReplacement = applyReplacement;
    
    function applyReuse(translated, options) {
        var comma = ',';
        var options_open = '{';
        var options_close = '}';
    
        var opts = f.extend({}, options);
        delete opts.postProcess;
    
        while (translated.indexOf(o.reusePrefix) != -1) {
            replacementCounter++;
            if (replacementCounter > o.maxRecursion) { break; } // safety net for too much recursion
            var index_of_opening = translated.lastIndexOf(o.reusePrefix);
            var index_of_end_of_closing = translated.indexOf(o.reuseSuffix, index_of_opening) + o.reuseSuffix.length;
            var token = translated.substring(index_of_opening, index_of_end_of_closing);
            var token_without_symbols = token.replace(o.reusePrefix, '').replace(o.reuseSuffix, '');
    
    
            if (token_without_symbols.indexOf(comma) != -1) {
                var index_of_token_end_of_closing = token_without_symbols.indexOf(comma);
                if (token_without_symbols.indexOf(options_open, index_of_token_end_of_closing) != -1 && token_without_symbols.indexOf(options_close, index_of_token_end_of_closing) != -1) {
                    var index_of_opts_opening = token_without_symbols.indexOf(options_open, index_of_token_end_of_closing);
                    var index_of_opts_end_of_closing = token_without_symbols.indexOf(options_close, index_of_opts_opening) + options_close.length;
                    try {
                        opts = f.extend(opts, JSON.parse(token_without_symbols.substring(index_of_opts_opening, index_of_opts_end_of_closing)));
                        token_without_symbols = token_without_symbols.substring(0, index_of_token_end_of_closing);
                    } catch (e) {
                    }
                }
            }
    
            var translated_token = _translate(token_without_symbols, opts);
            translated = translated.replace(token, translated_token);
        }
        return translated;
    }
    
    function hasContext(options) {
        return (options.context && (typeof options.context == 'string' || typeof options.context == 'number'));
    }
    
    function needsPlural(options) {
        return (options.count !== undefined && typeof options.count != 'string' && options.count !== 1);
    }
    
    function exists(key, options) {
        options = options || {};
    
        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options);
    
        return found !== undefined || found === notFound;
    }
    
    function translate(key, options) {
        options = options || {};
    
        if (!initialized) {
            f.log('i18next not finished initialization. you might have called t function before loading resources finished.');
            var colon = key.indexOf(":");
            if (colon < 0)
                colon = 0;
            else
                colon++;

            var stringToReturn = options.defaultValue || key.substr(colon);
            if (stringToReturn)
                stringToReturn = applyReplacement( stringToReturn, options );
            return stringToReturn;
        }
        replacementCounter = 0;
        return _translate.apply(null, arguments);
    }
    
    function _getDefaultValue(key, options) {
        return (options.defaultValue !== undefined) ? options.defaultValue : key;
    }
    
    function _injectSprintfProcessor() {
    
        var values = [];
    
        // mh: build array from second argument onwards
        for (var i = 1; i < arguments.length; i++) {
            values.push(arguments[i]);
        }
    
        return {
            postProcess: 'sprintf',
            sprintf:     values
        };
    }
    
    function _translate(potentialKeys, options) {
        if (options && typeof options !== 'object') {
            if (o.shortcutFunction === 'sprintf') {
                // mh: gettext like sprintf syntax found, automatically create sprintf processor
                options = _injectSprintfProcessor.apply(null, arguments);
            } else if (o.shortcutFunction === 'defaultValue') {
                options = {
                    defaultValue: options
                }
            }
        } else {
            options = options || {};
        }
    
        if (potentialKeys === undefined || potentialKeys === null) return '';
    
        if (typeof potentialKeys == 'string') {
            potentialKeys = [potentialKeys];
        }
    
        var key = potentialKeys[0];
    
        if (potentialKeys.length > 1) {
            for (var i = 0; i < potentialKeys.length; i++) {
                key = potentialKeys[i];
                if (exists(key, options)) {
                    break;
                }
            }
        }
    
        var notFound = _getDefaultValue(key, options)
            , found = _find(key, options)
            , lngs = options.lng ? f.toLanguages(options.lng) : languages
            , ns = options.ns || o.ns.defaultNs
            , parts;

        // split ns and key
        if (key.indexOf(o.nsseparator) > -1) {
            parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }

        if (found === undefined && o.sendMissing) {
            if (options.lng) {
                sync.postMissing(lngs[0], ns, key, notFound, lngs);
            } else {
                sync.postMissing(o.lng, ns, key, notFound, lngs);
            }
        }
    
        var postProcessor = options.postProcess || o.postProcess;
        if (found !== undefined && postProcessor) {
            if (postProcessors[postProcessor]) {
                found = postProcessors[postProcessor](found, key, options);
            }
        }
    
        // process notFound if function exists
        var splitNotFound = notFound;
        if (notFound.indexOf(o.nsseparator) > -1) {
            parts = notFound.split(o.nsseparator);
            splitNotFound = parts[1];
        }
        if (splitNotFound === key && o.parseMissingKey) {
            notFound = o.parseMissingKey(notFound);
        }
    
        if (found === undefined) {
            notFound = applyReplacement(notFound, options);
            notFound = applyReuse(notFound, options);
    
            if (postProcessor && postProcessors[postProcessor]) {
                var val = _getDefaultValue(key, options);
                found = postProcessors[postProcessor](val, key, options);
            }
        }
    
        return (found !== undefined) ? found : notFound;
    }
    
    function _find(key, options) {
        options = options || {};
    
        var optionWithoutCount, translated
            , notFound = _getDefaultValue(key, options)
            , lngs = languages;
    
        if (!resStore) { return notFound; } // no resStore to translate from
    
        // CI mode
        if (lngs[0].toLowerCase() === 'cimode') return notFound;
    
        // passed in lng
        if (options.lng) {
            lngs = f.toLanguages(options.lng);
    
            if (!resStore[lngs[0]]) {
                var oldAsync = o.getAsync;
                o.getAsync = false;
    
                Autodesk.Viewing.i18n.sync.load(lngs, o, function(err, store) {
                    f.extend(resStore, store);
                    o.getAsync = oldAsync;
                });
            }
        }
    
        var ns = options.ns || o.ns.defaultNs;
        if (key.indexOf(o.nsseparator) > -1) {
            var parts = key.split(o.nsseparator);
            ns = parts[0];
            key = parts[1];
        }
    
        if (hasContext(options)) {
            optionWithoutCount = f.extend({}, options);
            delete optionWithoutCount.context;
            optionWithoutCount.defaultValue = o.contextNotFound;
    
            var contextKey = ns + o.nsseparator + key + '_' + options.context;
    
            translated = translate(contextKey, optionWithoutCount);
            if (translated != o.contextNotFound) {
                return applyReplacement(translated, { context: options.context }); // apply replacement for context only
            } // else continue translation with original/nonContext key
        }
    
        if (needsPlural(options)) {
            optionWithoutCount = f.extend({}, options);
            delete optionWithoutCount.count;
            optionWithoutCount.defaultValue = o.pluralNotFound;
    
            var pluralKey = ns + o.nsseparator + key + o.pluralSuffix;
            var pluralExtension = pluralExtensions.get(lngs[0], options.count);
            if (pluralExtension >= 0) {
                pluralKey = pluralKey + '_' + pluralExtension;
            } else if (pluralExtension === 1) {
                pluralKey = ns + o.nsseparator + key; // singular
            }
    
            translated = translate(pluralKey, optionWithoutCount);
            if (translated != o.pluralNotFound) {
                return applyReplacement(translated, {
                    count: options.count,
                    interpolationPrefix: options.interpolationPrefix,
                    interpolationSuffix: options.interpolationSuffix
                }); // apply replacement for count only
            } // else continue translation with original/singular key
        }
    
        var found;
        var keys = key.split(o.keyseparator);
        for (var i = 0, len = lngs.length; i < len; i++ ) {
            if (found !== undefined) break;
    
            var l = lngs[i];
    
            var x = 0;
            var value = resStore[l] && resStore[l][ns];
            while (keys[x]) {
                value = value && value[keys[x]];
                x++;
            }
            if (value !== undefined) {
                var valueType = Object.prototype.toString.apply(value);
                if (typeof value === 'string') {
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (valueType === '[object Array]' && !o.returnObjectTrees && !options.returnObjectTrees) {
                    value = value.join('\n');
                    value = applyReplacement(value, options);
                    value = applyReuse(value, options);
                } else if (value === null && o.fallbackOnNull === true) {
                    value = undefined;
                } else if (value !== null) {
                    if (!o.returnObjectTrees && !options.returnObjectTrees) {
                        if (o.objectTreeKeyHandler && typeof o.objectTreeKeyHandler == 'function') {
                            value = o.objectTreeKeyHandler(key, value, l, ns, options);
                        } else {
                            value = 'key \'' + ns + ':' + key + ' (' + l + ')\' ' +
                                'returned an object instead of string.';
                            f.log(value);
                        }
                    } else if (valueType !== '[object Number]' && valueType !== '[object Function]' && valueType !== '[object RegExp]') {
                        var copy = (valueType === '[object Array]') ? [] : {}; // apply child translation on a copy
                        f.each(value, function(m) {
                            copy[m] = _translate(ns + o.nsseparator + key + o.keyseparator + m, options);
                        });
                        value = copy;
                    }
                }
    
                if (typeof value === 'string' && value.trim() === '' && o.fallbackOnEmpty === true)
                    value = undefined;
    
                found = value;
            }
        }
    
        if (found === undefined && !options.isFallbackLookup && (o.fallbackToDefaultNS === true || (o.fallbackNS && o.fallbackNS.length > 0))) {
            // set flag for fallback lookup - avoid recursion
            options.isFallbackLookup = true;
    
            if (o.fallbackNS.length) {
    
                for (var y = 0, lenY = o.fallbackNS.length; y < lenY; y++) {
                    found = _find(o.fallbackNS[y] + o.nsseparator + key, options);
    
                    if (found) {
                        /* compare value without namespace */
                        var foundValue = found.indexOf(o.nsseparator) > -1 ? found.split(o.nsseparator)[1] : found
                          , notFoundValue = notFound.indexOf(o.nsseparator) > -1 ? notFound.split(o.nsseparator)[1] : notFound;
    
                        if (foundValue !== notFoundValue) break;
                    }
                }
            } else {
                found = _find(key, options); // fallback to default NS
            }
        }
    
        return found;
    }
    function detectLanguage() {
        var detectedLng;
    
        // get from qs
        var qsParm = [];
        if (typeof window !== 'undefined') {
            (function() {
                var query = window.location.search.substring(1);
                var parms = query.split('&');
                for (var i=0; i<parms.length; i++) {
                    var pos = parms[i].indexOf('=');
                    if (pos > 0) {
                        var key = parms[i].substring(0,pos);
                        var val = parms[i].substring(pos+1);
                        qsParm[key] = val;
                    }
                }
            })();
            if (qsParm[o.detectLngQS]) {
                detectedLng = qsParm[o.detectLngQS];
            }
        }
    
        // get from cookie
        if (!detectedLng && typeof document !== 'undefined' && o.useCookie ) {
            var c = f.cookie.read(o.cookieName);
            if (c) detectedLng = c;
        }
    
        // get from navigator
        if (!detectedLng && typeof navigator !== 'undefined') {
            detectedLng =  (navigator.language) ? navigator.language : navigator.userLanguage;
        }
        
        return detectedLng;
    }
    var sync = {
    
        load: function(lngs, options, cb) {
            if (options.useLocalStorage) {
                sync._loadLocal(lngs, options, function(err, store) {
                    var missingLngs = [];
                    for (var i = 0, len = lngs.length; i < len; i++) {
                        if (!store[lngs[i]]) missingLngs.push(lngs[i]);
                    }
    
                    if (missingLngs.length > 0) {
                        sync._fetch(missingLngs, options, function(err, fetched) {
                            f.extend(store, fetched);
                            sync._storeLocal(fetched);
    
                            cb(null, store);
                        });
                    } else {
                        cb(null, store);
                    }
                });
            } else {
                sync._fetch(lngs, options, function(err, store){
                    cb(null, store);
                });
            }
        },
    
        _loadLocal: function(lngs, options, cb) {
            var store = {}
              , nowMS = new Date().getTime();
    
            if(window.localStorage) {
    
                var todo = lngs.length;
    
                f.each(lngs, function(key, lng) {
                    var local = window.localStorage.getItem('res_' + lng);
    
                    if (local) {
                        local = JSON.parse(local);
    
                        if (local.i18nStamp && local.i18nStamp + options.localStorageExpirationTime > nowMS) {
                            store[lng] = local;
                        }
                    }
    
                    todo--; // wait for all done befor callback
                    if (todo === 0) cb(null, store);
                });
            }
        },
    
        _storeLocal: function(store) {
            if(window.localStorage) {
                for (var m in store) {
                    store[m].i18nStamp = new Date().getTime();
                    window.localStorage.setItem('res_' + m, JSON.stringify(store[m]));
                }
            }
            return;
        },
    
        _fetch: function(lngs, options, cb) {
            var ns = options.ns
              , store = {};
            
            if (!options.dynamicLoad) {
                var todo = ns.namespaces.length * lngs.length
                  , errors;


                // Load each file individually.
                f.each(ns.namespaces, function(nsIndex, nsValue) {
                    f.each(lngs, function(lngIndex, lngValue) {
                        
                        // Call this once our translation has returned.
                        var loadComplete = function(err, data) {
                            if (err) {
                                errors = errors || [];
                                errors.push(err);
                            }
                            store[lngValue] = store[lngValue] || {};
                            store[lngValue][nsValue] = data;
    
                            todo--; // wait for all done befor callback
                            if (todo === 0) cb(errors, store);
                        };
                        
                        if(typeof options.customLoad == 'function'){
                            // Use the specified custom callback.
                            options.customLoad(lngValue, nsValue, options, loadComplete);
                        } else {
                            //~ // Use our inbuilt sync.
                            sync._fetchOne(lngValue, nsValue, options, loadComplete);
                        }
                    });
                });

            } else {
                // Call this once our translation has returned.
                var loadComplete = function(err, data) {
                    cb(null, data);
                };
    
                if(typeof options.customLoad == 'function'){
                    // Use the specified custom callback.
                    options.customLoad(lngs, ns.namespaces, options, loadComplete);
                } else {
                    var url = applyReplacement(options.resGetPath, { lng: lngs.join('+'), ns: ns.namespaces.join('+') });
                    // load all needed stuff once
                    url = RESOURCE_ROOT + url;

                    f.ajax({
                        url: url,
                        success: function(data, status, xhr) {
                            f.log('loaded: ' + url);
                            loadComplete(null, data.json());
                        },
                        error : function(xhr, status, error) {
                            f.log('failed loading: ' + url);
                            loadComplete('failed loading resource.json error: ' + error);
                        },
                        dataType: "text",
                        async : options.getAsync
                    });
                }    
            }
        },
    
        _fetchOne: function(lng, ns, options, done) {

            var url = applyReplacement(options.resGetPath, { lng: lng, ns: ns });
            url = RESOURCE_ROOT + url;

            f.ajax({
                url: url,
                success: function(data, status, xhr) {
                    f.log('loaded: ' + url);
                    var jsonData = stripJsonComments( data );
                    done(null, JSON.parse( jsonData ));
                },
                error : function(xhr, status, error) {
                    if ((status && status == 200) || (xhr && xhr.status && xhr.status == 200)) {
                        // file loaded but invalid json, stop waste time !
                        f.log('There is a typo in: ' + url);
                    } else if ((status && status == 404) || (xhr && xhr.status && xhr.status == 404)) {
                        f.log('Does not exist: ' + url);
                    } else {
                        var theStatus = status ? status : ((xhr && xhr.status) ? xhr.status : null);
                        f.log(theStatus + ' when loading ' + url);
                    }
                    
                    done(error, {});
                },
                dataType: "text",
                async : options.getAsync
            });
        },
    
        postMissing: function(lng, ns, key, defaultValue, lngs) {
            var payload = {};
            payload[key] = defaultValue;
    
            var urls = [];
    
            if (o.sendMissingTo === 'fallback' && o.fallbackLng[0] !== false) {
                for (var i = 0; i < o.fallbackLng.length; i++) {
                    urls.push({lng: o.fallbackLng[i], url: applyReplacement(o.resPostPath, { lng: o.fallbackLng[i], ns: ns })});
                }
            } else if (o.sendMissingTo === 'current' || (o.sendMissingTo === 'fallback' && o.fallbackLng[0] === false) ) {
                urls.push({lng: lng, url: applyReplacement(o.resPostPath, { lng: lng, ns: ns })});
            } else if (o.sendMissingTo === 'all') {
                for (var i = 0, l = lngs.length; i < l; i++) {
                    urls.push({lng: lngs[i], url: applyReplacement(o.resPostPath, { lng: lngs[i], ns: ns })});
                }
            }
    
            for (var y = 0, len = urls.length; y < len; y++) {
                var item = urls[y];
                f.ajax({
                    url: item.url,
                    type: o.sendType,
                    data: payload,
                    success: function(data, status, xhr) {
                        f.log('posted missing key \'' + key + '\' to: ' + item.url);
    
                        // add key to resStore
                        var keys = key.split('.');
                        var x = 0;
                        var value = resStore[item.lng][ns];
                        while (keys[x]) {
                            if (x === keys.length - 1) {
                                value = value[keys[x]] = defaultValue;
                            } else {
                                value = value[keys[x]] = value[keys[x]] || {};
                            }
                            x++;
                        }
                    },
                    error : function(xhr, status, error) {
                        f.log('failed posting missing key \'' + key + '\' to: ' + item.url);
                    },
                    dataType: "json",
                    async : o.postAsync
                });
            }
        }
    };

    // definition http://translate.sourceforge.net/wiki/l10n/pluralforms
    var pluralExtensions = {
    
        rules: {
            "ach": {
                "name": "Acholi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "af": {
                "name": "Afrikaans", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ak": {
                "name": "Akan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "am": {
                "name": "Amharic", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "an": {
                "name": "Aragonese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ar": {
                "name": "Arabic", 
                "numbers": [
                    0, 
                    1, 
                    2, 
                    3, 
                    11, 
                    100
                ], 
                "plurals": function(n) { return Number(n===0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5); }
            }, 
            "arn": {
                "name": "Mapudungun", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "ast": {
                "name": "Asturian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ay": {
                "name": "Aymar\u00e1", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "az": {
                "name": "Azerbaijani", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "be": {
                "name": "Belarusian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "bg": {
                "name": "Bulgarian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "bn": {
                "name": "Bengali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "bo": {
                "name": "Tibetan", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "br": {
                "name": "Breton", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "bs": {
                "name": "Bosnian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "ca": {
                "name": "Catalan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "cgg": {
                "name": "Chiga", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "cs": {
                "name": "Czech", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2); }
            }, 
            "csb": {
                "name": "Kashubian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "cy": {
                "name": "Welsh", 
                "numbers": [
                    1, 
                    2, 
                    3, 
                    8
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n==2) ? 1 : (n != 8 && n != 11) ? 2 : 3); }
            }, 
            "da": {
                "name": "Danish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "de": {
                "name": "German", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "dz": {
                "name": "Dzongkha", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "el": {
                "name": "Greek", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "en": {
                "name": "English", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "eo": {
                "name": "Esperanto", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "es": {
                "name": "Spanish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "es_ar": {
                "name": "Argentinean Spanish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "et": {
                "name": "Estonian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "eu": {
                "name": "Basque", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fa": {
                "name": "Persian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "fi": {
                "name": "Finnish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fil": {
                "name": "Filipino", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "fo": {
                "name": "Faroese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fr": {
                "name": "French", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "fur": {
                "name": "Friulian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "fy": {
                "name": "Frisian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ga": {
                "name": "Irish", 
                "numbers": [
                    1, 
                    2,
                    3,
                    7, 
                    11
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n==2 ? 1 : n<7 ? 2 : n<11 ? 3 : 4) ;}
            }, 
            "gd": {
                "name": "Scottish Gaelic", 
                "numbers": [
                    1, 
                    2, 
                    3,
                    20
                ], 
                "plurals": function(n) { return Number((n==1 || n==11) ? 0 : (n==2 || n==12) ? 1 : (n > 2 && n < 20) ? 2 : 3); }
            }, 
            "gl": {
                "name": "Galician", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "gu": {
                "name": "Gujarati", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "gun": {
                "name": "Gun", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "ha": {
                "name": "Hausa", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "he": {
                "name": "Hebrew", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hi": {
                "name": "Hindi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hr": {
                "name": "Croatian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "hu": {
                "name": "Hungarian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "hy": {
                "name": "Armenian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ia": {
                "name": "Interlingua", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "id": {
                "name": "Indonesian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "is": {
                "name": "Icelandic", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n%10!=1 || n%100==11); }
            }, 
            "it": {
                "name": "Italian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ja": {
                "name": "Japanese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "jbo": {
                "name": "Lojban", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "jv": {
                "name": "Javanese", 
                "numbers": [
                    0, 
                    1
                ], 
                "plurals": function(n) { return Number(n !== 0); }
            }, 
            "ka": {
                "name": "Georgian", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "kk": {
                "name": "Kazakh", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "km": {
                "name": "Khmer", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "kn": {
                "name": "Kannada", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ko": {
                "name": "Korean", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ku": {
                "name": "Kurdish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "kw": {
                "name": "Cornish", 
                "numbers": [
                    1, 
                    2, 
                    3,
                    4
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n==2) ? 1 : (n == 3) ? 2 : 3); }
            }, 
            "ky": {
                "name": "Kyrgyz", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "lb": {
                "name": "Letzeburgesch", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ln": {
                "name": "Lingala", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "lo": {
                "name": "Lao", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "lt": {
                "name": "Lithuanian", 
                "numbers": [
                    1, 
                    2,
                    10
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "lv": {
                "name": "Latvian", 
                "numbers": [
                    1, 
                    2, 
                    0
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n !== 0 ? 1 : 2); }
            }, 
            "mai": {
                "name": "Maithili", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mfe": {
                "name": "Mauritian Creole", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mg": {
                "name": "Malagasy", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mi": {
                "name": "Maori", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "mk": {
                "name": "Macedonian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n==1 || n%10==1 ? 0 : 1); }
            }, 
            "ml": {
                "name": "Malayalam", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mn": {
                "name": "Mongolian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "mnk": {
                "name": "Mandinka", 
                "numbers": [
                    0, 
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(0 ? 0 : n==1 ? 1 : 2); }
            }, 
            "mr": {
                "name": "Marathi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ms": {
                "name": "Malay", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "mt": {
                "name": "Maltese", 
                "numbers": [
                    1, 
                    2, 
                    11, 
                    20
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n===0 || ( n%100>1 && n%100<11) ? 1 : (n%100>10 && n%100<20 ) ? 2 : 3); }
            }, 
            "nah": {
                "name": "Nahuatl", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nap": {
                "name": "Neapolitan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nb": {
                "name": "Norwegian Bokmal", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ne": {
                "name": "Nepali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nl": {
                "name": "Dutch", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nn": {
                "name": "Norwegian Nynorsk", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "no": {
                "name": "Norwegian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "nso": {
                "name": "Northern Sotho", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "oc": {
                "name": "Occitan", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "or": {
                "name": "Oriya", 
                "numbers": [
                    2, 
                    1
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pa": {
                "name": "Punjabi", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pap": {
                "name": "Papiamento", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pl": {
                "name": "Polish", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "pms": {
                "name": "Piemontese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ps": {
                "name": "Pashto", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pt": {
                "name": "Portuguese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "pt_br": {
                "name": "Brazilian Portuguese", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "rm": {
                "name": "Romansh", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ro": {
                "name": "Romanian", 
                "numbers": [
                    1, 
                    2,
                    20
                ], 
                "plurals": function(n) { return Number(n==1 ? 0 : (n===0 || (n%100 > 0 && n%100 < 20)) ? 1 : 2); }
            }, 
            "ru": {
                "name": "Russian", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "sah": {
                "name": "Yakut", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "sco": {
                "name": "Scots", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "se": {
                "name": "Northern Sami", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "si": {
                "name": "Sinhala", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sk": {
                "name": "Slovak", 
                "numbers": [
                    1, 
                    2, 
                    5
                ], 
                "plurals": function(n) { return Number((n==1) ? 0 : (n>=2 && n<=4) ? 1 : 2); }
            }, 
            "sl": {
                "name": "Slovenian", 
                "numbers": [
                    5, 
                    1, 
                    2, 
                    3
                ], 
                "plurals": function(n) { return Number(n%100==1 ? 1 : n%100==2 ? 2 : n%100==3 || n%100==4 ? 3 : 0); }
            }, 
            "so": {
                "name": "Somali", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "son": {
                "name": "Songhay", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sq": {
                "name": "Albanian", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sr": {
                "name": "Serbian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "su": {
                "name": "Sundanese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "sv": {
                "name": "Swedish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "sw": {
                "name": "Swahili", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "ta": {
                "name": "Tamil", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "te": {
                "name": "Telugu", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "tg": {
                "name": "Tajik", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "th": {
                "name": "Thai", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ti": {
                "name": "Tigrinya", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "tk": {
                "name": "Turkmen", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "tr": {
                "name": "Turkish", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "tt": {
                "name": "Tatar", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "ug": {
                "name": "Uyghur", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "uk": {
                "name": "Ukrainian", 
                "numbers": [
                    1, 
                    2,
                    5
                ], 
                "plurals": function(n) { return Number(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2); }
            }, 
            "ur": {
                "name": "Urdu", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "uz": {
                "name": "Uzbek", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "vi": {
                "name": "Vietnamese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "wa": {
                "name": "Walloon", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n > 1); }
            }, 
            "wo": {
                "name": "Wolof", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }, 
            "yo": {
                "name": "Yoruba", 
                "numbers": [
                    1, 
                    2
                ], 
                "plurals": function(n) { return Number(n != 1); }
            }, 
            "zh": {
                "name": "Chinese", 
                "numbers": [
                    1
                ], 
                "plurals": function(n) { return 0; }
            }
        },
    
        // for demonstration only sl and ar is added but you can add your own pluralExtensions
        addRule: function(lng, obj) {
            pluralExtensions.rules[lng] = obj;    
        },
    
        setCurrentLng: function(lng) {
            if (!pluralExtensions.currentRule || pluralExtensions.currentRule.lng !== lng) {
                var parts = lng.split('-');
    
                pluralExtensions.currentRule = {
                    lng: lng,
                    rule: pluralExtensions.rules[parts[0]]
                };
            }
        },
    
        get: function(lng, count) {
            var parts = lng.split('-');
    
            function getResult(l, c) {
                var ext;
                if (pluralExtensions.currentRule && pluralExtensions.currentRule.lng === lng) {
                    ext = pluralExtensions.currentRule.rule; 
                } else {
                    ext = pluralExtensions.rules[l];
                }
                if (ext) {
                    var i = ext.plurals(c);
                    var number = ext.numbers[i];
                    if (ext.numbers.length === 2 && ext.numbers[0] === 1) {
                        if (number === 2) { 
                            number = -1; // regular plural
                        } else if (number === 1) {
                            number = 1; // singular
                        }
                    }//console.log(count + '-' + number);
                    return number;
                } else {
                    return c === 1 ? '1' : '-1';
                }
            }
                        
            return getResult(parts[0], count);
        }
    
    };
    var postProcessors = {};
    var addPostProcessor = function(name, fc) {
        postProcessors[name] = fc;
    };

    // sprintf support
    var sprintf = (function() {
        function get_type(variable) {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
        }
        function str_repeat(input, multiplier) {
            for (var output = []; multiplier > 0; output[--multiplier] = input) {/* do nothing */}
            return output.join('');
        }
    
        var str_format = function() {
            if (!str_format.cache.hasOwnProperty(arguments[0])) {
                str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
            }
            return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
        };
    
        str_format.format = function(parse_tree, argv) {
            var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
            for (i = 0; i < tree_length; i++) {
                node_type = get_type(parse_tree[i]);
                if (node_type === 'string') {
                    output.push(parse_tree[i]);
                }
                else if (node_type === 'array') {
                    match = parse_tree[i]; // convenience purposes only
                    if (match[2]) { // keyword argument
                        arg = argv[cursor];
                        for (k = 0; k < match[2].length; k++) {
                            if (!arg.hasOwnProperty(match[2][k])) {
                                throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));
                            }
                            arg = arg[match[2][k]];
                        }
                    }
                    else if (match[1]) { // positional argument (explicit)
                        arg = argv[match[1]];
                    }
                    else { // positional argument (implicit)
                        arg = argv[cursor++];
                    }
    
                    if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
                        throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));
                    }
                    switch (match[8]) {
                        case 'b': arg = arg.toString(2); break;
                        case 'c': arg = String.fromCharCode(arg); break;
                        case 'd': arg = parseInt(arg, 10); break;
                        case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
                        case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
                        case 'o': arg = arg.toString(8); break;
                        case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
                        case 'u': arg = Math.abs(arg); break;
                        case 'x': arg = arg.toString(16); break;
                        case 'X': arg = arg.toString(16).toUpperCase(); break;
                    }
                    arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
                    pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
                    pad_length = match[6] - String(arg).length;
                    pad = match[6] ? str_repeat(pad_character, pad_length) : '';
                    output.push(match[5] ? arg + pad : pad + arg);
                }
            }
            return output.join('');
        };
    
        str_format.cache = {};
    
        str_format.parse = function(fmt) {
            var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
            while (_fmt) {
                if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                    parse_tree.push(match[0]);
                }
                else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                    parse_tree.push('%');
                }
                else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                    if (match[2]) {
                        arg_names |= 1;
                        var field_list = [], replacement_field = match[2], field_match = [];
                        if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                            field_list.push(field_match[1]);
                            while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                                    field_list.push(field_match[1]);
                                }
                                else {
                                    throw('[sprintf] huh?');
                                }
                            }
                        }
                        else {
                            throw('[sprintf] huh?');
                        }
                        match[2] = field_list;
                    }
                    else {
                        arg_names |= 2;
                    }
                    if (arg_names === 3) {
                        throw('[sprintf] mixing positional and named placeholders is not (yet) supported');
                    }
                    parse_tree.push(match);
                }
                else {
                    throw('[sprintf] huh?');
                }
                _fmt = _fmt.substring(match[0].length);
            }
            return parse_tree;
        };
    
        return str_format;
    })();
    
    var vsprintf = function(fmt, argv) {
        argv.unshift(fmt);
        return sprintf.apply(null, argv);
    };
    
    addPostProcessor("sprintf", function(val, key, opts) {
        if (!opts.sprintf) return val;
    
        if (Object.prototype.toString.apply(opts.sprintf) === '[object Array]') {
            return vsprintf(val, opts.sprintf);
        } else if (typeof opts.sprintf === 'object') {
            return sprintf(val, opts.sprintf);
        }
    
        return val;
    });

    var localize = function() {
        // Parse data
        function parse( data ) {
            var attribute, value;

            var dataSplit = data.split(/\[|\]/);
            if (dataSplit.length === 1) {
                attribute = null;
                value = dataSplit[0];
            }
            else if (dataSplit.length===3) {
                attribute = dataSplit[1];
                value = dataSplit[2];
            }
            return [attribute, value];
        };

        Array.prototype.forEach.call (document.querySelectorAll ('[data-i18n]'), function (element){
            var dataToTranslate = element.getAttribute('data-i18n');
            var parsed  = parse( dataToTranslate );
            var attributeName  = parsed[0];
            var stringToTrans  = parsed[1];

            var translatedString = Autodesk.Viewing.i18n.translate(stringToTrans);
            if (translatedString)
            {
                if (attributeName) {
                    element.setAttribute( attributeName, translatedString );
                }
                else {
                    element.textContent = translatedString;
                }
            }
            else
            {
                if (attributeName) {
                    element.setAttribute( attributeName, stringToTrans );
                }
                else {
                    element.textContent = stringToTrans;
                }
            }
        });
    };

    // public api interface
    Autodesk.Viewing.i18n.init = init;
    Autodesk.Viewing.i18n.setLng = setLng;
    Autodesk.Viewing.i18n.preload = preload;
    Autodesk.Viewing.i18n.addResourceBundle = addResourceBundle;
    Autodesk.Viewing.i18n.removeResourceBundle = removeResourceBundle;
    Autodesk.Viewing.i18n.loadNamespace = loadNamespace;
    Autodesk.Viewing.i18n.loadNamespaces = loadNamespaces;
    Autodesk.Viewing.i18n.localize = localize;
    Autodesk.Viewing.i18n.setDefaultNamespace = setDefaultNamespace;
    Autodesk.Viewing.i18n.t = translate;
    Autodesk.Viewing.i18n.translate = translate;
    Autodesk.Viewing.i18n.exists = exists;
    Autodesk.Viewing.i18n.detectLanguage = f.detectLanguage;
    Autodesk.Viewing.i18n.pluralExtensions = pluralExtensions;
    Autodesk.Viewing.i18n.sync = sync;
    Autodesk.Viewing.i18n.functions = f;
    Autodesk.Viewing.i18n.lng = lng;
    Autodesk.Viewing.i18n.addPostProcessor = addPostProcessor;
    Autodesk.Viewing.i18n.options = o;
})();;/** @license Copyright (c) 2014 Autodesk Inc. */
/** Version : @buildnum@ */

AutodeskNamespace('Autodesk.Viewing.UI');

/**
 *  DockingPanel represents a UI panel that is movable and resizeable within
 *  the bounds of its parent container.
 *  @constructor
 *
 *  @param {HTMLElement} parentContainer - The container for this panel.
 *  @param {string} id - The id to assign this panel.
 *  @param {string} title - The title of this panel.
 *  @param {Object=} [options] - An optional dictionary of options.
 *  @param {boolean} [options.shadow=true] - When true, adds a drop shadow when dragging.
 *  @param {boolean} [options.localizeTitle=true] - When true, localization is attempted for the given title.
 * 
 * @example <caption>From DocumentExample.html</caption>
        // Example of a simple DockingPanel that displays the given content.
        // The titlebar and move behavior are overridden in initialize(), which also
        // creates a custom close button.
        //
        SimplePanel = function(parentContainer, id, title, content, x, y)
        {
            this.content = content;
            Autodesk.Viewing.UI.DockingPanel.call(this, parentContainer, id, '', {shadow:true});

            // Auto-fit to the content and don't allow resize.  Position at the coordinates given.
            //
            this.container.style.height = "auto";
            this.container.style.width = "auto";
            this.container.style.resize = "none";
            this.container.style.left = x + "px";
            this.container.style.top = y + "px";
        };

        SimplePanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
        SimplePanel.prototype.constructor = SimplePanel;

        SimplePanel.prototype.initialize = function()
        {
            // Override DockingPanel initialize() to:
            // - create a standard title bar
            // - click anywhere on the panel to move
            // - create a close element at the bottom right
            //
            this.title = this.createTitleBar(this.titleLabel || this.container.id);
            this.container.appendChild(this.title);

            this.container.appendChild(this.content);
            this.initializeMoveHandlers(this.container);

            this.closer = document.createElement("div");
            this.closer.className = "simplePanelClose";
            this.closer.textContent = "Close";
            this.initializeCloseHandler(this.closer);
            this.container.appendChild(this.closer);
        };
 */
Autodesk.Viewing.UI.DockingPanel = function (parentContainer, id, title, options) {

    // Constants
    this.kMinWdth   = 100;
    this.kMinHeight = 100;

    this.visibilityCallbacks = [];
    this.movedSinceLastClick = false;

    this.parentContainer = parentContainer;

    this.container = document.createElement("div");
    this.container.id = id;
    this.container.lastWidth = "";
    this.container.dockRight = false;
    this.container.dockBottom = false;
    this.titleLabel = title;

    // By default, localize the title.
    //
    options = options || {};
    if (!options.hasOwnProperty('localizeTitle')) {
        options.localizeTitle = true;
    }
    this.options = options;

    this.container.classList.add('dockingPanel');
    var addShadow = (options && options.shadow !== undefined) ? options.shadow : true;
    if (addShadow) {
        this.container.classList.add('shadow');
    }
    this.container.classList.add(('ontouchstart' in window) ? "touch" : "notouch");

    parentContainer.appendChild(this.container);
    this.listeners = [];

    this.initialize();

    // The panel is not visible initially.  The child class may still be constructing
    // the elements, so let it decide when to show.
    //
    this.setVisible(false);
};

/**
 *  Creates the sub-elements of this DockingPanel.  Override this in derived classes.
 *  The default implementation is to create a title bar with the title or id provided
 *  in the constructor.  The title bar also acts as the move handler for the DockingPanel.
 *  Finally, a close button is added to the top right corner.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.initialize = function () {
    this.title = this.createTitleBar(this.titleLabel || this.container.id);
    this.container.appendChild(this.title);
    this.initializeMoveHandlers(this.title);
    this.setTitle(this.titleLabel || this.container.id, this.options);

    this.closer = this.createCloseButton();
    this.container.appendChild(this.closer);
};

/**
 *  Performs any clean up necessary.  This can include disconnecting UI elements,
 *  unregistering event callbacks, etc.
 *
 */
Autodesk.Viewing.UI.DockingPanel.prototype.uninitialize = function () {
    // Remove all of the listeners we're aware of.
    //
    for (var i = 0; i < this.listeners.length; ++i) {
        var listener = this.listeners[i];
        listener.target.removeEventListener(listener.eventId, listener.callback);
    }
    this.listeners = [];
    this.visibilityCallbacks = [];

    // Disconnect our DOM tree from our parent.
    //
    this.parentContainer.removeChild(this.container);
    this.parentContainer = null;
    this.container = null;
    this.title = null;
    this.closer = null;
};

/**
 *  Adds a callback to call when this DockingPanel changes visibility.
 *
 *  @param {function} callback - A function that takes in a single boolean parameter
 *                               indicating the current visibility state.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.addVisibilityListener = function (callback) {
    this.visibilityCallbacks.push(callback);
};

/**
 *  Returns the current visibility state of the DockingPanel.
 *
 *  @returns {boolean} The current visibility state.
 *  @nosideeffects
 */
Autodesk.Viewing.UI.DockingPanel.prototype.isVisible = function () {
    return this.container.style.display !== "none" && this.container.style.display !== "";
};

/**
 *  Sets the new visibility state of this DockingPanel.
 *
 *  @param {boolean} show - The desired visibility state.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.setVisible = function (show) {
    this.container.style.display = show ? "block" : "none";

    if (show) {
        if (this.container.dockRight) {
            var screenw = this.parentContainer.getBoundingClientRect().width;
            var wi = this.container.style.width ? this.container.style.width : this.container.getBoundingClientRect().width;
            if (!wi) wi = this.container.lastWidth;
            var wi2 = (wi === "" ? 300 : parseInt(wi));
            this.container.style.left = (screenw - wi2) + "px";
        }
        if (this.container.dockBottom) {
            var screenh = this.parentContainer.getBoundingClientRect().height;
            var hi = this.container.style.height ? this.container.style.height : this.container.getBoundingClientRect().height;
            if (!hi) hi = this.container.lastHeight;
            var hi2 = (hi === "" ? 300 : parseInt(hi));
            this.container.style.top = (screenh - hi2) + "px";
        }

        var that = this;
        setTimeout(function () {
            that.container.classList.add('dockingPanelVisible');
            that.container.classList.remove('dockingPanelHidden');
        }, 400);
    }
    else {
        this.container.lastWidth = this.parentContainer.style.width;
        this.container.lastHeight = this.parentContainer.style.height;

        this.container.classList.remove('dockingPanelVisible');
        this.container.classList.add('dockingPanelHidden');
    }

    for (var i = 0; i < this.visibilityCallbacks.length; i++) {
        this.visibilityCallbacks[i](show);
    }
};

/**
 *  Gets the new visibility state of this DockingPanel.
 *
 *  return {boolean} - Whether or not the panel is visible
 */
Autodesk.Viewing.UI.DockingPanel.prototype.isVisible = function () {
    return Boolean(this.container.style.display === "block");
};

/**
 *  Initializes the given HTMLDomElement as the move handle for this DockingPanel.
 *  When this element is clicked and dragged, this DockingPanel is moved.
 *
 *  @param {HTMLElement} mover - the DOM element that will act as the move handle.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.initializeMoveHandlers = function (mover) {
    var x, y;
    var lastX, lastY;
    var startX, startY;
    var deltaX, deltaY;
    var container = this.container;
    var self = this;

    // This gets scoped under window during the handleMove event handler
    function handleMove(e) {
        var minWidth  = container.style.minWidth ? parseInt(container.style.minWidth) : this.kMinWdth;
        var minHeight = container.style.minHeight ? parseInt(container.style.minHeight) : this.kMinHeight;

        var parentRect = self.parentContainer.getBoundingClientRect();

        if (container.style.maxWidth && parseInt(container.style.width) > parseInt(container.style.maxWidth)) {
            container.style.width = container.style.maxWidth;
        }
        if (container.style.maxHeight && parseInt(container.style.height) > parseInt(container.style.maxHeight)) {
            container.style.height = container.style.maxHeight;
        }

        if (parseInt(container.style.width) < minWidth) {
            container.style.width = minWidth + "px";
        }
        if (parseInt(container.style.height) < minHeight) {
            container.style.height = minHeight + "px";
        }
        if (e.type === "touchmove") {
            e.screenX = e.touches[0].screenX;
            e.screenY = e.touches[0].screenY;
        }

        deltaX += e.screenX - lastX;
        deltaY += e.screenY - lastY;

        x = startX + deltaX;
        y = startY + deltaY;

        var wi = parseInt(container.style.width);
        var hi = parseInt(container.style.height);

        if (isNaN(wi)) {
            wi = self.container.getBoundingClientRect().width;
        }
        if (isNaN(hi)) {
            hi = self.container.getBoundingClientRect().height;
        }

        // check left, top
        if (x < 5)
            x = 0;

        if (y < 5)
            y = 0;

        container.dockRight = false;
        container.dockBottom = false;

        // check bottom, right
        if (parentRect.width - 5 < x + wi) {
            x = parentRect.width - wi;
            container.dockRight = true;
        }

        if (parentRect.height - 5 < y + hi) {
            y = parentRect.height - hi;
            container.dockBottom = true;
        }

        container.style.left = x + "px";
        container.style.top = y + "px";
        container.style.maxWidth = (parentRect.width - x) + "px";
        container.style.maxHeight = (parentRect.height - y) + "px";

        //TODO: check for right side
        //TODO: handle docking and bounds check against the canvas element

        lastX = e.screenX;
        lastY = e.screenY;

        self.onMove(e, x, y);
    }

    function handleUp(e) {
        window.removeEventListener('mousemove', handleMove);
        window.removeEventListener('mouseup', handleUp);
        window.removeEventListener('touchmove', handleMove);
        window.removeEventListener('touchend', handleUp);
        self.onEndMove(e, x, y);
    }

    function handleDown(e) {
        if (e.type === "touchstart") {
            e.screenX = e.touches[0].screenX;
            e.screenY = e.touches[0].screenY;
        }
        lastX = e.screenX;
        lastY = e.screenY;

        deltaX = 0;
        deltaY = 0;

        // Save the current panel position relative to its parent container.
        //
        startX = self.container.offsetLeft;
        startY = self.container.offsetTop;

        window.addEventListener('mousemove', handleMove, false);
        window.addEventListener('mouseup', handleUp, false);
        window.addEventListener('touchmove', handleMove, false);
        window.addEventListener('touchend', handleUp, false);

        e.preventDefault();

        self.onStartMove(e, startX, startY);
    }

    // We'll keep track of the mousedown event listener as this one is always active.
    // The mousemove and mouseup listeners above are temporary so we don't need to track them.
    //
    self.addEventListener(mover, 'mousedown', handleDown);
    self.addEventListener(mover, 'touchstart', handleDown);
};

/**
 *  Initializes the given HTMLDomElement as the close handle for this DockingPanel.
 *  When this element is clicked, this DockingPanel is hidden.
 *
 *  @param {HTMLElement} closer - the DOM element that will act as the close handle.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.initializeCloseHandler = function (closer) {
    var self = this;
    self.addEventListener(closer, 'click', function (e) {
        self.setVisible(false);
    }, false);
};

/**
 *  Creates a scroll container element to add to this DockingPanel.  Call this method during
 *  initialize() if a scroll container is needed, and then add it to an existing container.
 *
 *  @param {Object=} [options] - An optional dictionary of options.
 *  @param {boolean} [options.left=false] - When true, the scrollbar appears on the left.
 *  @param {int} [options.heightAdjustment=0] - The scroll container height is 100% of the panel
 *                                              minus the height adjustment.  Provide a value
 *                                              to account for other elements in the panel like a title bar.
 *
 *  @returns {HTMLElement} The created scroll container.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.createScrollContainer = function (options) {
    var scrollContainer = document.createElement("div"),
        classList = scrollContainer.classList;
    classList.add('dockingPanelScroll');
    classList.add((options && options.left) ? 'left' : 'right');

    if (options && options.heightAdjustment) {
        scrollContainer.style.height = "calc(100% - " + options.heightAdjustment + "px)";
    }

    return scrollContainer;
};

/**
 *  Creates a title bar element to add to this DockingPanel.  Call this method during
 *  initialize() if a standard title bar is desired, and then add it to an existing container.
 *
 *  @param {string} title - The text to use in the title bar.
 *
 *  @returns {HTMLElement} The created title bar.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.createTitleBar = function (title) {
    var titleBar = document.createElement("div");
    titleBar.className = "dockingPanelTitle";
    titleBar.textContent = title;

    var that = this;
    that.addEventListener(titleBar, 'click', function (event) {
        if (!that.movedSinceLastClick) {
            that.onTitleClick(event);
        }
        that.movedSinceLastClick = false;
    });

    that.addEventListener(titleBar, 'dblclick', function (event) {
        that.onTitleDoubleClick(event);
    });

    return titleBar;
};

/**
 * Sets the title for this panel.
 *
 * @param {string} text - The title for this panel.
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {boolean} [options.localizeTitle=false] - When true, localization is attempted for the given text.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.setTitle = function (text, options) {
    if (options && options.localizeTitle) {
        this.title.setAttribute('data-i18n', text);
        text = Autodesk.Viewing.i18n.translate(text);
    } else {
        this.title.removeAttribute('data-i18n');
    }
    this.title.textContent = text;
};

/**
 *  Creates a close button to add to this DockingPanel.  When clicked, this DockingPanel
 *  is hidden.  Call this method during initialize() if a standard close button is desired,
 *  and then add it to an existing container.
 *
 *  @returns {HTMLElement} The created close button.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.createCloseButton = function () {
    var closeButton = document.createElement("div");
    closeButton.className = "dockingPanelClose";
    closeButton.innerHTML = "&times;";
    this.initializeCloseHandler(closeButton);
    return closeButton;
};

/**
 * Override this event to be notified when this panel begins a move operation.
 *
 * @param {MouseEvent} event - The mousedown event.
 * @param {int} startX - The starting x position of the panel in pixels.
 * @param {int} startY - The starting y position of the panel in pixels.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.onStartMove = function (event, startX, startY) {
};

/**
 * Override this event to be notified when this panel ends a move operation.
 *
 * @param {MouseEvent} event - The mouseup event.
 * @param {int} endX - The ending x position of the panel in pixels.
 * @param {int} endY - The ending y position of the panel in pixels.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.onEndMove = function (event, endX, endY) {
};

/**
 * Override this to be notified when this panel is moved.  Note, do not forget to call
 * this base class method in the overriding method.
 *
 * @param {MouseEvent} event - The mousemove event
 * @param {int} currentX - The current x position of the panel in pixels
 * @param {int} currentY - The current y position of the panel in pixels
 */
Autodesk.Viewing.UI.DockingPanel.prototype.onMove = function (event, currentX, currentY) {
    this.movedSinceLastClick = true;
};

/**
 * Override this method to be notified when the user clicks on the title.
 * @param {Event} event
 */
Autodesk.Viewing.UI.DockingPanel.prototype.onTitleClick = function (event) {
};

/**
 * Override this method to be notified when the user double-clicks on the title.
 * @param {Event} event
 */
Autodesk.Viewing.UI.DockingPanel.prototype.onTitleDoubleClick = function (event) {
};

/**
 * Adds an event listener to a given target that has an addEventListener(event, callback) API.
 * These event listeners are tracked by the DockingPanel and are automatically removed on uninitialize.
 *
 * @param {Object} target - The target that will fire the event.
 * @param {string} eventId - The event to be listened to.
 * @param {function} callback - The callback to execute when the event is fired.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.addEventListener = function (target, eventId, callback) {
    target.addEventListener(eventId, callback);
    this.listeners.push({target: target, eventId: eventId, callback: callback});
};

/**
 * Removes an existing event listener added using DockingPanel.addEventListener.
 *
 * @param {Object} target - The target with the event listener.
 * @param {string} eventId - The id of the event being listened to.
 * @param {function} callback - The callback executed when the event is fired.
 *
 * @returns {boolean} - true if the listener was removed successfully; false otherwise.
 */
Autodesk.Viewing.UI.DockingPanel.prototype.removeEventListener = function (target, eventId, callback) {
    for (var i = 0; i < this.listeners.length; ++i) {
        var listener = this.listeners[i];
        if (listener.target === target && listener.eventId === eventId && listener.callback === callback) {
            target.removeEventListener(eventId, callback);
            this.listeners.splice(i, 1);
            return true;
        }
    }
    return false;
};

/**
 * Override this method to return the width and height to use when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 * @private
 */
Autodesk.Viewing.UI.DockingPanel.prototype.getContentSize = function () {
    return {height: this.container.clientHeight, width: this.container.clientWidth};
};

/**
 * Resizes the panel to the current content.  Currently this only works on height.
 *
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {int} [options.maxHeight] - The maximum height to resize this panel.
 * @private
 */
Autodesk.Viewing.UI.DockingPanel.prototype.resizeToContent = function (options) {
    var dimensions = this.getContentSize();
    var newHeight = dimensions.height;
    if (options && options.maxHeight) {
        var rect = this.container.getBoundingClientRect();
        var maxHeight = options.maxHeight - rect.top;
        if (newHeight > maxHeight) {
            newHeight = maxHeight;
        }
    }
    this.container.style.height = newHeight.toString() + 'px';
};
;/** @license Copyright (c) 2014 Autodesk Inc. */
/** Version : @buildnum@ */

AutodeskNamespace('Autodesk.Viewing.UI');

/**
 * ModelStructurePanel
 * Sets the model structure panel for displaying the loaded model.
 * @class
 *
 * @param {HTMLElement} parentContainer - The container for this panel.
 * @param {string} id - The id for this panel.
 * @param {string} title - The initial title for this panel.
 * @param {Object} [options] - An optional dictionary of options.
 * @param {boolean} [options.startCollapsed=true] - When true, collapses all of the nodes under the root.
 * @param {boolean} [options.excludeRoot=true] - When true, the root is not displayed in the tree.
 * @constructor
 */
Autodesk.Viewing.UI.ModelStructurePanel = function(parentContainer, id, title, options)
{
    Autodesk.Viewing.UI.DockingPanel.call(this, parentContainer, id, title, options);
    this.container.classList.add('modelStructurePanel');
    this.scrollContainer = this.createScrollContainer({left: false, heightAdjustment:70});
    this.scrollContainer.style.marginTop = "20px";
    this.container.appendChild(this.scrollContainer);
    this.scrollContainer.id = this.container.id + '-scroll-container';

    this.modelRoot = null;
    this.tree = null;
    this.selectedNodes = [];
};

Autodesk.Viewing.UI.ModelStructurePanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.UI.ModelStructurePanel.prototype.constructor = Autodesk.Viewing.UI.ModelStructurePanel;

/**
 * Sets the model for this panel to display.
 *
 * @param {Object} modelRoot - The root returned by Autodesk.Viewing.Model.getObjectTree( function(root) );
 * @param {string=} [modelTitle] - An optional title to display for this model.
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.setModel = function(modelRoot, modelTitle)
{
    var that = this;
    var createDelegate = function()
    {
        var delegate = new Autodesk.Viewing.UI.TreeDelegate();
        delegate.getTreeNodeId = function(node)
        {
            return node.dbId;
        };

        delegate.getTreeNodeLabel = function(node)
        {
            return that.getNodeLabel(node);
        };

        delegate.getTreeNodeClass = function(node)
        {
            return that.getNodeClass(node);
        };

        delegate.isTreeNodeGroup = function(node)
        {
            return that.isGroupNode(node);
        };

        delegate.shouldCreateTreeNode = function(node)
        {
            return that.shouldInclude(node);
        };

        delegate.onTreeNodeHover = function(tree, node, event)
        {
            that.onHover(node, event);
        };

        delegate.onTreeNodeClick = function(tree, node, event)
        {
            that.onClick(node, event);
        };

        delegate.onTreeNodeRightClick = function(tree, node, event)
        {
            that.onRightClick(node, event);
        };

        delegate.onTreeNodeDoubleClick = function(tree, node, event)
        {
            that.onDoubleClick(node, event);
        };

        delegate.onTreeNodeIconClick = function(tree, node, event)
        {
            that.setGroupCollapsed(node, !that.isGroupCollapsed(node));
        };

        return delegate;
    };

    that.selectedNodes = [];

    var title = modelTitle;

    if(!title) {
        if (that.options && that.options.defaultTitle) {
            title = that.options.defaultTitle;
        } else if (modelRoot) {
            title = modelRoot.name;
        }
    }

    var options = {};
    if(!title) {
        title = "Model Structure";
        options.localizeTitle = true;
    }
    that.setTitle(title, options);

    // Remove the previous tree from the scroll container and any listeners on the title bar.
    //
    if(that.tree) {
        while(that.scrollContainer.hasChildNodes()){
            that.scrollContainer.removeChild(that.scrollContainer.lastChild);
        }
        that.title.removeEventListener("click", that.onTitleClick);
        that.title.removeEventListener("dblclick", that.onTitleDoubleClick);
    }

    that.modelRoot = modelRoot;
    if (!modelRoot) {
        return;
    }

    var delegate = createDelegate();
    that.tree = new Autodesk.Viewing.UI.Tree(delegate, modelRoot, that.scrollContainer, {});

    if(!that.options || !that.options.hasOwnProperty('startCollapsed') || that.options.startCollapsed) {
        that.tree.setAllCollapsed(true);
        that.tree.setCollapsed(delegate.getTreeNodeId(modelRoot), false);
    }

    if(!that.options || !that.options.hasOwnProperty('excludeRoot') || that.options.excludeRoot) {
        that.tree.addClass(delegate.getTreeNodeId(modelRoot), 'exclude');
    }
};

/**
 * Override this method to specify the label for a node.
 * By default, this is the node's name, or 'Object ' + object id if the name
 * is blank.
 *
 * @param {Object} node - A node in an Autodesk.Viewing.Model
 * @returns {string} Label of the tree node
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.getNodeLabel = function(node)
{
    return (node.name && node.name !== '') ? node.name : 'Object ' + node.dbId;
};

/**
 * Override this to specify the CSS classes of a node. This way, in CSS, the designer
 * can specify custom styling per type.
 * By default, an empty string is returned.
 *
 * @param {Object} node - A node in an Autodesk.Viewing.Model
 * @returns {string} CSS classes for the node
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.getNodeClass = function(node)
{
    return '';
};

/**
 * Override this method to specify whether or not a node is a group node.
 * By default, a node is considered a group if it has a 'children' property containing
 * an array with at least one element.
 *
 * @param {Object} node - A node in an Autodesk.Viewing.Model
 * @returns {boolean} true if this node is a group node, false otherwise
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.isGroupNode = function(node)
{
    return node.children && Array.isArray(node.children) && node.children.length > 0;
};

/**
 * Override this method to specify if a tree node should be created for this node.
 * By default, every node will be displayed.
 *
 * @param {Object} node - A node in an Autodesk.Viewing.Model
 * @returns {boolean} true if a node should be created, false otherwise
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.shouldInclude = function(node)
{
    return true;
};

Autodesk.Viewing.UI.ModelStructurePanel.prototype.onHover = function(node, event)
{
};

/**
 * Override this method to do something when the user clicks on a tree node
 * @param {Object} node - A node in an Autodesk.Viewing.Model
 * @param {Event} event
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.onClick = function(node, event)
{
    this.setSelection([node]);
};

/**
 * Override this to do something when the user double-clicks on a tree node
 *
 * @param {Object} node - A node in an Autodesk.Viewing.Model
 * @param {Event} event
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.onDoubleClick = function(node, event)
{
};

/**
 * Collapse/expand a group node.
 *
 * @param {Object} node - A node to collapse/expand in the tree.
 * @param {Boolean} collapsed - True to collapse the group, false to expand it.
 * @private
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.setGroupCollapsed = function(node, collapsed)
{
    var delegate = this.tree.delegate();
    if (delegate.isTreeNodeGroup(node)) {
        var id = delegate.getTreeNodeId(node);
        this.tree.setCollapsed(id, collapsed);
    }
};

/**
 * Returns true if the group is collapsed.
 *
 * @param {Object} node - The node in the tree.
 * @returns {Boolean} - True if the group is collapsed, false otherwise.
 * @private
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.isGroupCollapsed = function(node)
{
    var delegate = this.tree.delegate();
    if (delegate.isTreeNodeGroup(node)) {
        var id = delegate.getTreeNodeId(node);
        return this.tree.isCollapsed(id);
    }
    return false
};

/**
 * Override this to do something when the user right-clicks on a tree node
 * 
 * @param {Object} node - A node in an Autodesk.Viewing.Model
 * @param {Event} event
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.onRightClick = function(node, event)
{
};

/**
 * Override this method to be notified when the user clicks on the title.
 * @override
 * @param {Event} event
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.onTitleClick = function(event) {
    this.onClick(this.modelRoot, event);
};

/**
 * Override this method to be notified when the user double-clicks on the title.
 * @override
 * @param {Event} event
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.onTitleDoubleClick = function(event) {
    this.onDoubleClick(this.modelRoot, event);
};

/**
 * Displays the given nodes as selected in this panel.
 *
 * @param {Array} nodes - An array of Autodesk.Viewing.Model nodes to display as selected
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.setSelection = function(nodes)
{
    // Bail if no model structure.
    //
    if (!this.tree) {
        return;
    }

    // Un-mark the ancestors.
    //
    for(var i=0; i<this.selectedNodes.length; ++i) {
        var parent = this.selectedNodes[i].parent;
        while(parent) {
            this.tree.removeClass(this.tree.delegate().getTreeNodeId(parent), 'ancestor-selected');
            parent = parent.parent;
        }
    }

    // Mark the ancestors of the newly selected nodes.
    //
    var selectedIds = [];
    for(var i=0; i<nodes.length; ++i) {
        selectedIds.push(nodes[i].dbId);
        var parent = nodes[i].parent;
        while(parent) {
            this.tree.addClass(this.tree.delegate().getTreeNodeId(parent), 'ancestor-selected');
            parent = parent.parent;
        }
    }

    // Mark the newly selected nodes.
    //
    this.selectedNodes = nodes;
    this.tree.setSelection(selectedIds);
};

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.getContentSize = function () {
    var treeContainer = document.getElementById(this.tree.getRootContainerId());
    return {height: treeContainer.clientHeight + 75, width: treeContainer.clientWidth};
};

/**
 * Given a node's id, adds the given CSS class to this node.
 * 
 * @param {string} id - The id of a node in an Autodesk.Viewing.Model
 * @param {string} className - The CSS class to add
 * @returns {boolean} - true if the class was added, false otherwise
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.addClass = function(id, className)
{
    return (this.tree !== null) && this.tree.addClass(id, className);
};

/**
 * Given a node's id, removes the given CSS class from this node.
 *
 * @param {string} id - The id of a node in an Autodesk.Viewing.Model
 * @param {string} className - The CSS class to remove
 * @returns {boolean} - true if the class was removed, false otherwise
 */
Autodesk.Viewing.UI.ModelStructurePanel.prototype.removeClass = function(id, className)
{
    return (this.tree !== null) && this.tree.removeClass(id, className);
};
;AutodeskNamespace('Autodesk.Viewing.UI');

/**
 * PropertyPanel
 * A panel for displaying a set of properties that are optionally categorized.
 * @class
 *
 * @param {HTMLElement} parentContainer - The container for this panel.
 * @param {string} id - The id for this panel.
 * @param {string} title - The initial title for this panel.
 * @param {Object} [options] - An optional dictionary of options.  Currently unused.
 * @constructor
 */
Autodesk.Viewing.UI.PropertyPanel = function (parentContainer, id, title, options) {
    Autodesk.Viewing.UI.DockingPanel.call(this, parentContainer, id, title, options);

    this.container.classList.add('propertyPanel');
    this.container.dockRight = true;

    this.scrollContainer = this.createScrollContainer({left: false, heightAdjustment: 75});
    this.scrollContainer.style.marginTop = "20px";
    this.container.appendChild(this.scrollContainer);
    this.scrollContainer.id = this.container.id + '-scroll-container';

    this.highlightableElements = {};

    var that = this;

    function createDelegate() {
        var delegate = new Autodesk.Viewing.UI.TreeDelegate();

        function isCategory(object) {
            return object.type === 'category';
        }

        delegate.getTreeNodeId = function (node) {
            return node.name + (node.hasOwnProperty('value') ? node.value : '') + (node.hasOwnProperty('category') ? node.category : '');
        };

        delegate.getTreeNodeClass = function (node) {
            return isCategory(node) ? that.getCategoryClass(node) : that.getPropertyClass(node);
        };

        delegate.isTreeNodeGroup = function (node) {
            return isCategory(node);
        };

        delegate.onTreeNodeHover = function (tree, node, event) {
            if (isCategory(node)) {
                that.onCategoryHover(node, event);
            } else {
                that.onPropertyHover(node, event);
            }
        };

        delegate.onTreeNodeClick = function (tree, node, event) {
            if (isCategory(node)) {
                that.onCategoryClick(node, event);
            } else {
                that.onPropertyClick(node, event);
            }
        };

        delegate.onTreeNodeRightClick = function (tree, node, event) {
            if (isCategory(node)) {
                that.onCategoryRightClick(node, event);
            } else {
                that.onPropertyRightClick(node, event);
            }
        };

        delegate.onTreeNodeDoubleClick = function (tree, node, event) {
            if (isCategory(node)) {
                that.onCategoryDoubleClick(node, event);
            } else {
                that.onPropertyDoubleClick(node, event);
            }
        };

        delegate.onTreeNodeIconClick = function (tree, node, event) {
            if (isCategory(node)) {
                that.onCategoryIconClick(node, event);
            } else {
                that.onPropertyIconClick(node, event);
            }
        };

        delegate.createTreeNode = function (node, parent, options) {
            var highlightableElements = null;
            if (isCategory(node)) {
                highlightableElements = that.displayCategory(node, parent, options);
            } else {
                highlightableElements = that.displayProperty(node, parent, options);
            }

            if (highlightableElements) {
                that.highlightableElements[this.getTreeNodeId(node)] = highlightableElements;
            }
        };

        return delegate;
    }

    var delegate = createDelegate();
    this.tree = new Autodesk.Viewing.UI.Tree(delegate, null, this.scrollContainer, {});
};

Autodesk.Viewing.UI.PropertyPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.UI.PropertyPanel.prototype.constructor = Autodesk.Viewing.UI.PropertyPanel;

/**
 * Adds the given properties to the display panel.
 * @param {Array} properties - An array of properties, each property represented as {displayName: name, displayValue: value}.
 * @param {Object=} [options] - An optional dictionary of options.  Currently unused.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.setProperties = function (properties, options) {
    this.removeAllProperties();

    // Check if any categories need to be displayed.
    //
    var withCategories = [];
    var withoutCategories = [];

    for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        if (!property.hidden) {
            var property = properties[i];
            var category = properties[i].displayCategory;
            if (category && typeof category === 'string' && category !== '') {
                withCategories.push(property);
            } else {
                withoutCategories.push(property);
            }
        }
    }

    if ((withCategories.length + withoutCategories.length) === 0) {
        this.showNoProperties();
        return;
    }

    for (var i = 0; i < withCategories.length; i++) {
        var property = withCategories[i];
        var value = Autodesk.Viewing.Private.formatValueWithUnits(property.displayValue, property.units, property.type);
        this.addProperty(property.displayName, value, property.displayCategory);
    }

    var hasCategories = (withCategories.length > 0);
    for (var i = 0; i < withoutCategories.length; i++) {
        var property = withoutCategories[i];
        var value = Autodesk.Viewing.Private.formatValueWithUnits(property.displayValue, property.units, property.type);
        this.addProperty(property.displayName, value, hasCategories ? 'Other' : '', hasCategories ? {localizeCategory: true} : {});
    }
};

/**
 * Displays only the "No properties" item.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.showNoProperties = function () {
    this.removeAllProperties();
    var rootContainer = document.getElementById(this.tree.myRootContainerId);

    var message = document.createElement('div');
    message.className = 'noProperties';

    var text = 'No properties to display';
    message.setAttribute('data-i18n', text);
    message.textContent = Autodesk.Viewing.i18n.translate(text);

    rootContainer.appendChild(message);
};

/**
 * Override this to display the default properties.  The current default is to display no properties.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.showDefaultProperties = function () {
    this.showNoProperties();

    var dimensions = this.viewer.getDimensions();
    this.resizeToContent({maxHeight: dimensions.height});
};

/**
 * Override this to return true if the default properties are being displayed.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.areDefaultPropertiesShown = function () {
    return !this.hasProperties();
};

/**
 * Adds a property to this panel.  The property is defined by its name, value, and category.  The
 * add will fail if a property with the same name, value, and category already exists.
 *
 * @param {string} name - The name of the property to add.
 * @param {string} value - The value of the property to add.
 * @param {string} category - The category of the property to add.
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {boolean} [options.localizeCategory=false] - When true, localization is attempted for the given category
 * @param {boolean} [options.localizeProperty=false] - When true, localization is attempted for the given property
 * @returns {boolean} - true if the property was added, false otherwise.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.addProperty = function (name, value, category, options) {
    var element = this.tree.getElementByNode({name: name, value: value, category: category});
    if (element) {
        return false;
    }

    var parent = null;
    var property = {name: name, value: value, type: 'property'};

    if (category) {
        parent = this.tree.getElementByNode({name: category});
        if (!parent) {
            parent = this.tree.createElement_({name: category, type: 'category'}, document.getElementById(this.tree.myRootContainerId), options && options.localizeCategory ? {localize: true} : null);
        }
        property.category = category;
    } else {
        parent = document.getElementById(this.tree.myRootContainerId);
    }

    this.tree.createElement_(property, parent, options && options.localizeProperty ? {localize: true} : null);

    return true;
};

/**
 * Returns whether this property panel currently has properties.
 *
 * @returns {boolean} - true if there are properties to display, false otherwise.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.hasProperties = function () {
    for (var property in this.highlightableElements) {
        return true;
    }
    return false;
};

/**
 * Removes a property from this panel.  The property is defined by its name, value, and category.
 *
 * @param {string} name - The name of the property to remove.
 * @param {string} value - The value of the property to remove.
 * @param {string} category - The category of the property to remove.
 * @param {Object=} [options] - An optional dictionary of options.  Currently unused.
 * @returns {boolean} - true if the property was removed, false otherwise.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.removeProperty = function (name, value, category, options) {
    var property = {name: name, value: value, category: category};
    var element = this.tree.getElementByNode(property);
    if (element) {
        delete this.highlightableElements[this.tree.delegate().getTreeNodeId(property)];
        element.parentNode.removeChild(element);
        return true;
    }
    return false;
};

/**
 * Removes all properties from the panel.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.removeAllProperties = function () {
    this.highlightableElements = {};

    var rootContainer = document.getElementById(this.tree.myRootContainerId);
    while (rootContainer.hasChildNodes()) {
        rootContainer.removeChild(rootContainer.lastChild);
    }
};

/**
 * Sets the collapse state of the given category.
 *
 * @param {Object} category - A category object.
 * @param {boolean} collapsed - The new collapse state.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.setCategoryCollapsed = function (category, collapsed) {
    var id = this.tree.delegate().getTreeNodeId(category);
    this.tree.setCollapsed(id, collapsed);
};

/**
 * Returns whether the given category is currently collapsed.
 *
 * @param {Object} category - A category object.
 * @returns {boolean} - true if the category is collapsed, false otherwise.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.isCategoryCollapsed = function (category) {
    var id = this.tree.delegate().getTreeNodeId(category);
    return this.tree.isCollapsed(id);
};

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.getContentSize = function () {
    // For the PropertyPanel, it's the size of the tree + some padding value for the height.
    //
    var treeContainer = document.getElementById(this.tree.myRootContainerId);
    return {height: treeContainer.clientHeight + 75, width: treeContainer.clientWidth};
};

/**
 * Resizes the property panel to the current content.  Currently this only works on height.
 *
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {int} [options.maxHeight] - The maximum height to resize this panel
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.resizeToContent = function (options) {
    // TODO:  Remove this method once DockingPanel's resizeToContent is publicized.
    //
    Autodesk.Viewing.UI.DockingPanel.prototype.resizeToContent.call(this, options);
};

/**
 * Highlights the given text if found in the property name or value.
 *
 * @param {string} text - The text to highlight.
 * @param {Object=} [options] - An optional dictionary of options.  Currently unused.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.highlight = function (text, options) {
    function highlightElement(element) {
        var current = element.innerHTML;
        var unhighlighted = current.replace(/(<highlight>|<\/highlight>)/igm, "");
        if (current !== unhighlighted) {
            element.innerHTML = unhighlighted;
        }

        if (text && text !== "") {
            var query = new RegExp("(\\b" + text + "\\b)", "gim");
            var highlighted = unhighlighted.replace(query, "<highlight>$1</highlight>");
            element.innerHTML = highlighted;
        }
    }

    for (var property in this.highlightableElements) {
        var elements = this.highlightableElements[property];
        for (var i = 0; i < elements.length; ++i) {
            highlightElement(elements[i]);
        }
    }
};

/**
 * Creates and adds the HTML elements to display the given category.
 *
 * @param {Object} category - A category object.
 * @param {HTMLElement} parent - The parent to attach the new HTML elements.
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {boolean} [options.localize=false] - When true, localization is attempted for the given category name.
 *
 * @returns {Array} elementList - the list of HTML elements to include when highlighting.
 *                                Warning:  ensure no event listeners are attached to these elements
 *                                as they will be lost during highlighting.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.displayCategory = function (category, parent, options) {
    var name = document.createElement('div');

    var text = category.name;
    if (options && options.localize) {
        name.setAttribute('data-i18n', text);
        text = Autodesk.Viewing.i18n.translate(text);
    }

    name.textContent = text;
    name.title = text;
    name.className = 'categoryName';
    parent.appendChild(name);

    // Make the category name highlightable.
    //
    return [name];
};

/**
 * Creates and adds the HTML elements to display the given property.
 *
 * @param {Object} property - A property object.
 * @param {HTMLElement} parent - The parent to attach the new HTML elements.
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {boolean} [options.localize=false] - When true, localization is attempted for the given property name.
 *
 * @returns {Array} elementList - the list of HTML elements to include when highlighting.
 *                                Warning:  ensure no event listeners are attached to these elements
 *                                as they will be lost during highlighting.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.displayProperty = function (property, parent, options) {
    var name = document.createElement('div');

    var text = property.name;
    if (options && options.localize) {
        name.setAttribute('data-i18n', text);
        text = Autodesk.Viewing.i18n.translate(text);
    }

    name.textContent = text;
    name.title = text;
    name.className = 'propertyName';

    var separator = document.createElement('div');
    separator.className = 'separator';

    var value = document.createElement('div');
    value.textContent = property.value;
    value.title = property.value;
    value.className = 'propertyValue';

    parent.appendChild(name);
    parent.appendChild(separator);
    parent.appendChild(value);

    // Make the property name and value highlightable.
    //
    return [name, value];
};

/**
 * Override this to specify the CSS classes of a category. This way, in CSS, the designer
 * can specify custom styling for specific category types.
 *
 * @param {Object} category
 * @returns {string} - CSS classes for the category.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.getCategoryClass = function (category) {
    return 'category';
};

/**
 * Override this to specify the CSS classes of a property. This way, in CSS, the designer
 * can specify custom styling for specific property types.
 *
 * @param {Object} property
 * @returns {string} - CSS classes for the property.
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.getPropertyClass = function (property) {
    return 'property';
};

/**
 * Override this method to do something when the user hovers over a category.
 *
 * @param {Object} category
 * @param {Event} event
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.onCategoryHover = function (category, event) {
};

/**
 * Override this method to do something when the user hovers over a property.
 *
 * @param {Object} property
 * @param {Event} event
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.onPropertyHover = function (property, event) {
};

/**
 * Override this method to do something when the user clicks on a category.  The default
 * implementation is to toggle the collapse state of the category.
 *
 * @param {Object} category
 * @param {Event} event
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.onCategoryClick = function (category, event) {
    this.setCategoryCollapsed(category, !this.isCategoryCollapsed(category));
};

/**
 * Override this method to do something when the user clicks on a property.
 *
 * @param {Object} property
 * @param {Event} event
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.onPropertyClick = function (property, event) {
};

/**
 * Override this method to do something when the user clicks on a category's icon.  The default
 * implementation is to toggle the collapse state of the category.
 *
 * @param {Object} category
 * @param {Event} event
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.onCategoryIconClick = function (category, event) {
    this.setCategoryCollapsed(category, !this.isCategoryCollapsed(category));
};

/**
 * Override this method to do something when the user clicks on a property's icon.
 *
 * @param {Object} property
 * @param {Event} event
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.onPropertyIconClick = function (property, event) {
};

/**
 * Override this method to do something when the user double clicks on a category.
 *
 * @param {Object} category
 * @param {Event} event
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.onCategoryDoubleClick = function (category, event) {
};

/**
 * Override this method to do something when the user double clicks on a property.
 *
 * @param {Object} property
 * @param {Event} event
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.onPropertyDoubleClick = function (property, event) {
};

/**
 * Override this method to do something when the user right clicks on a category.
 *
 * @param {Object} category
 * @param {Event} event
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.onCategoryRightClick = function (category, event) {
};

/**
 * Override this method to do something when the user right clicks on a property.
 *
 * @param {Object} property
 * @param {Event} event
 */
Autodesk.Viewing.UI.PropertyPanel.prototype.onPropertyRightClick = function (property, event) {
};
;AutodeskNamespace('Autodesk.Viewing.Private');

/** @constructor */
Autodesk.Viewing.Private.ContextMenu = function(viewer) {

    this.viewer = viewer;
    this.menus = [];
    this.open = false;

    this.itemWidth = 100;
    this.itemHeight = 25;
};

Autodesk.Viewing.Private.ContextMenu.prototype.constructor = Autodesk.Viewing.Private.ContextMenu;

Autodesk.Viewing.Private.ContextMenu.prototype.show = function(event, menu) {
    var viewport = this.viewer.container.getBoundingClientRect();
    var x = event.clientX - viewport.left;
    var y = event.clientY - viewport.top;

    if (!this.open) {

        var self = this;

        this.showMenu(menu, 0, x, y);
        this.open = true;
        this.hideEventListener = function(event) {
            if (event.target.className !== "menuItem") {
                self.hide(event);
            }
        };
        document.body.addEventListener("mousedown", this.hideEventListener, true);
    }
};

Autodesk.Viewing.Private.ContextMenu.prototype.showMenu = function(menu, level, x, y) {

    if (x < 0) {
        x = 0;
    }
    if (y < 0) {
        y = 0;
    }

    var numMenuItems = menu.length,
        canvasWidth = this.viewer.impl.canvas.width,
        canvasHeight = this.viewer.impl.canvas.height;

    // NB: 10 represents the left+right padding on the menu
    if (x + this.itemWidth + 10 > canvasWidth) {
        x = canvasWidth - this.itemWidth - 10;
    }
    if (y + (numMenuItems * this.itemHeight) > canvasHeight) {
        y = canvasHeight - (numMenuItems * this.itemHeight);
    }

    var parentItem = document.createElement("div");
    parentItem.width = this.itemWidth;
    parentItem.className = "menu";
    parentItem.style.top = y + "px";
    parentItem.style.left = x + "px";
    parentItem.style.zIndex = 20;
    this.viewer.container.appendChild(parentItem);

    var top = 0;

    for (var i = 0; i < numMenuItems; ++i) {
        var desc = menu[i];
        var title = desc.title;
        var target = desc.target;

        var menuItem = this.createMenuItem(parentItem, title, top);
        top = top + this.itemHeight;

        if (typeof target === "object") {
            this.addSubMenuClickToMenuItem(menuItem, level, target, x + this.itemWidth + 24 , y + top - this.itemHeight);
        } else if (typeof target === "function") {
            this.addCallbackToMenuItem(menuItem, target);
        } else {
            console.warn("Invalid context menu option:", title, target);
        }
    }

    parentItem.style.height = top + "px";

    if (this.menus[level] != null) {
        this.menus[level].parentNode.removeChild(this.menus[level]);
    }

    this.menus[level] = parentItem;
};

Autodesk.Viewing.Private.ContextMenu.prototype.createMenuItem = function(parentItem, text, top) {
    var menuItem = document.createElement("div");
    menuItem.className = "menuItem";
    menuItem.setAttribute("data-i18n", text);
    menuItem.textContent = Autodesk.Viewing.i18n.translate( text );
    parentItem.appendChild(menuItem);
    return menuItem;
};

Autodesk.Viewing.Private.ContextMenu.prototype.addSubMenuClickToMenuItem = function( menuItem, level, subMenu, x, y) {
    var self = this;

    menuItem.addEventListener("click",
        function() {
            self.showMenu(subMenu, level + 1, x, y);
        });
};

Autodesk.Viewing.Private.ContextMenu.prototype.addCallbackToMenuItem = function( menuItem, callback ) {
    var self = this;

    menuItem.addEventListener("click",
        function(event) {
            self.hide();
            callback();
            event.preventDefault();
            return false;
        });
};

Autodesk.Viewing.Private.ContextMenu.prototype.hide = function() {
    if (this.open) {
        for (var index=0; index<this.menus.length; ++index) {
            if(this.menus[index]) {
                this.menus[index].parentNode.removeChild(this.menus[index]);
            }
        }
        this.menus = [];
        this.open = false;
        document.body.removeEventListener("mousedown", this.hideEventListener );
        return true;
    }
    return false;
};
;AutodeskNamespace('Autodesk.Viewing.UI');

/**
 * Constructs an ObjectContextMenu object.
 * This is the base class for object context menus.
 * @param {Viewer} viewer
 * @constructor
 */
Autodesk.Viewing.UI.ObjectContextMenu = function (viewer) {
    this.viewer = viewer;
    this.contextMenu = new Autodesk.Viewing.Private.ContextMenu(viewer);
};

Autodesk.Viewing.UI.ObjectContextMenu.prototype.constructor = Autodesk.Viewing.UI.ObjectContextMenu;

/**
 * Shows the context menu.
 * @param {Event} event - Browser event that requested the context menu
 */
Autodesk.Viewing.UI.ObjectContextMenu.prototype.show = function (event) {
    var numSelected = this.viewer.getSelectionCount(),
        visibility = this.viewer.getSelectionVisibility(),
        status = {
            numSelected: numSelected,
            hasSelected: (0 < numSelected),
            hasVisible: visibility.hasVisible,
            hasHidden: visibility.hasHidden
        },
        menu = this.buildMenu(event, status);

    if (menu && 0 < menu.length) {
        this.contextMenu.show(event, menu);
    }
};

/**
 * Hides the context menu.
 * @returns {boolean} true if the context menu was open, false otherwise.
 */
Autodesk.Viewing.UI.ObjectContextMenu.prototype.hide = function () {
    return this.contextMenu.hide();
};

/**
 * Builds the context menu to be displayed.
 * Override this method to change the context menu.
 * @param {Event} event - Browser event that requested the context menu
 * @param {Object} status - Information about nodes.
 * @param {Number} status.numSelected - The number of selected objects.
 * @param {Boolean} status.hasSelected - True if there is at least one selected object.
 * @param {Boolean} status.hasVisible - True if at least one selected object is visible.
 * @param {Boolean} status.hasHidden - True if at least one selected object is hidden.
 * @returns {?Array} An array of menu items.
 *
 * Sample menu item:
 * {title: 'This is a menu item', target: function () {alert('Menu item clicked');}}
 * A submenu can be specified by providing an array of submenu items as the target.
 */
Autodesk.Viewing.UI.ObjectContextMenu.prototype.buildMenu = function (event, status) {
    return null;
};
;AutodeskNamespace('Autodesk.Viewing.Private');

/**
 * Application preferences. Optionally uses web storage.
 * @constructor
 * @param {Viewer} viewer - Viewer instance
 * @param {string} prefix - A string to prefix preference names in web storage
 */
Autodesk.Viewing.Private.Preferences = function (viewer, prefix) {
    if (!prefix) {
        prefix = 'Autodesk.Viewing.Preferences.';
    }

    var defaults = {}, // Default values
        callbacks = {}, // Changed and Reset listeners
        tags = {},
        PREF_CHANGED_EVENT = 'PrefChanged',
        PREF_RESET_EVENT = 'PrefReset',
        that = this;

    // TODO: callbacks should be array, not single
    // Would need to deal with issue of registering same callback twice
    //
    viewer.addEventListener(PREF_CHANGED_EVENT, function (event) {
        var callbacksForName = callbacks[event.name];
        if (callbacksForName) {
            var callback = callbacksForName.changed;
            if (callback) {
                callback(event.value);
            }
        }
    });

    viewer.addEventListener(PREF_RESET_EVENT, function (event) {
        for (var name in callbacks) {
            if (callbacks.hasOwnProperty(name)) {
                var callback = callbacks[name].reset;
                if (callback) {
                    callback(that[name]);
                }
            }
        }
    });

    /**
     * Get/set preference value in web storage.
     * @param {string} name - Preference name
     * @param {*=} [value] - Preference value
     * @returns {*} Preference value or undefined if not available
     */
    function webStorage(name, value) {

        if (typeof(localStorage) !== "undefined" && typeof(name) === "string") {

            // Prefix our names, so we don't pollute the localStorage of the embedding application
            name = prefix + name;

            if (typeof(value) !== "undefined") {
                // If value is specified, we set this value at localStorage[name]
                localStorage[name] = value;

            } else {
                // If no value is specified we return the value at localStorage[name]
                value = localStorage[name];
            }
            return value;
        }

        return undefined;
    }

    /**
     * Adds a preference name + default value, tries to load value from web storage.
     * @param {string} name
     * @param defaultValue
     */
    function addPref(name, defaultValue) {
        if (typeof that[name] === 'function') {
            stderr('Preferences: invalid name=' + name);
            return;
        }

        // Use default if nothing in web storage.
        //
        var value = webStorage(name),
            ok = false;

        if (value !== undefined) {
            try {
                value = JSON.parse(value);
                ok = true;
            } catch (e) {
            }
        }
        that[name] = ok ? value : defaultValue;
        tags[name] = {};
    }

    /**
     * Load preference values from web storage/defaults.
     * @param {Object} defaultValues - Preference names and their default values
     */
    this.load = function (defaultValues) {
        defaults = defaultValues;
        for (var name in defaults) {
            if (defaults.hasOwnProperty(name)) {
                addPref(name, defaults[name]);
            }
        }
    };

    /**
     * Adds a tag to the specified preferences.
     * These are used by reset().
     * @param {string} tag
     * @param {Array.<string>|string} [names] - Preference names, default all preferences
     */
    this.tag = function (tag, names) {
        if (tag) {
            if (!names) {
                names = Object.keys(defaults);
            } else if (!Array.isArray(names)) {
                names = [names];
            }
            for (var i = 0; i < names.length; ++i) {
                tags[names[i]][tag] = true;
            }
        }
    };

    /**
     * Removes a tag from the specified preferences.
     * These are used by reset().
     * @param {string} tag
     * @param {Array.<string>|string} [names] - Preference names, default all preferences
     */
    this.untag = function (tag, names) {
        if (tag) {
            if (!names) {
                names = Object.keys(defaults);
            } else if (!Array.isArray(names)) {
                names = [names];
            }
            for (var i = 0; i < names.length; ++i) {
                tags[names[i]][tag] = false;
            }
        }
    };

    /**
     * Adds a new preference name + default value.
     * This preference was not previously loaded via load().
     * @param {string} name - Preference name
     * @param defaultValue - Preference default value
     * @param {Array.<string>|string} [tags] - Optional tags
     * @returns {boolean} true if the preference was added
     */
    this.add = function (name, defaultValue, tags) {
        if (defaults.hasOwnProperty(name)) {
            stderr("Preferences: " + name + " already exists");

        } else {
            defaults[name] = defaultValue;
            addPref(name, defaultValue);

            if (tags) {
                if (!Array.isArray(tags)) {
                    tags = [tags];
                }
                for (var i = 0; i < tags.length; ++i) {
                    this.tag(tags[i], name);
                }
            }
            return true;
        }
        return false;
    };

    /**
     * Removes an existing preference.
     * @param {string} name - Preference name
     * @param {boolean} [removeFromWebStorage=false] - true to clear the web storage entry for this preference
     * @returns {boolean} true if the preference was removed
     */
    this.remove = function (name, removeFromWebStorage) {
        if (defaults.hasOwnProperty(name)) {
            delete defaults[name];
            delete tags[name];
            delete this[name];

            if (removeFromWebStorage) {
                if (typeof(localStorage) !== "undefined" && typeof(name) === "string") {
                    name = prefix + name;
                    delete localStorage[name];
                }
            }

            return true;
        }
        return false;
    };

    /**
     * Reset preferences to default values.
     * If a tag is specified, then only certain preferences are reset.
     * @param {string=} [tag] Optional tag
     * @param {boolean=} [include=true] Include only tagged preferences?
     */
    this.reset = function (tag, include) {
        if (tag && include === undefined) {
            include = true;
        }

        for (var name in defaults) {
            if (defaults.hasOwnProperty(name)) {
                if (tag) {
                    var tagged = !!tags[name][tag];
                    if ((include && !tagged) || (!include && tagged)) {
                        continue;
                    }
                }

                if (this.set(name, defaults[name], false)) {
                    viewer.fireEvent({
                        type: PREF_RESET_EVENT,
                        name: name,
                        value: this[name]
                    });
                }
            }
        }
    };

    /**
     * Get named preference value.
     * Shortcut: prefs[name]
     * @returns {*} Preference value
     */
    this.get = function (name) {
        return this[name];
    };

    /**
     * Set named preference value.
     * Do not use shortcut prefs[name] = value
     * @param {string} name - Preference name
     * @param {*} value - Preference value
     * @param {boolean=} [notify=true] - If true then PREF_CHANGED_EVENT is fired.
     * @returns {boolean} true if the value changed, false otherwise
     */
    this.set = function (name, value, notify) {
        // Updates the cached value as well as the value in the web storage
        if (this[name] !== value) {
            this[name] = value;
            webStorage(name, value);

            if (notify === undefined || notify) {
                viewer.fireEvent({
                    type: PREF_CHANGED_EVENT,
                    name: name,
                    value: value
                });
            }

            return true;
        }
        return false;
    };

    /**
     * Listen for preference changed and reset events.
     * @param {string} name - Preferences name
     * @param {function(*)} onChangedCallback - Function called when preferences are changed
     * @param {function(*)} onResetCallback - Function called when preferences are reset
     */
    this.addListeners = function (name, onChangedCallback, onResetCallback) {
        callbacks[name] = {changed: onChangedCallback, reset: onResetCallback};
    };
};
;AutodeskNamespace('Autodesk.Viewing.Private');

/**
 * Formats a value with units
 * @param {number} value
 * @param {string} units - GNU units format
 * @param {number} type - For example: 1=boolean, 2=integer, 3=double, 20=string
 * @param {number} precision - required precision.
 * see https://git.autodesk.com/A360/platform-translation-propertydb/blob/master/propertydb/PropertyDatabase.h
 * @returns {string} formatted value
 */
Autodesk.Viewing.Private.formatValueWithUnits = function (value, units, type, precision) {

    function modf(x) {
        var intPart = (0 <= x) ? Math.floor(x) : Math.ceil(x);
        var fracPart = x - intPart;
        return {intPart: intPart, fracPart: fracPart};
    }

    function formatNumber(x, precision, needMinusSign) {
        var result = '';

//        // Change -0.0 to 0.0
//        if (x === 0.0) {
//            x = 0.0;
//        }

        if (needMinusSign && x === 0) {
            result += '-';
        }

        if (modf(x).fracPart === 0) {

            // No fractional part.
            //
            result += x;

        } else if (0 < precision) {

            // Truncate any trailing .0's.
            //
            var s = x.toFixed(precision);
            var re = /^\-?([0-9]+)\.0+$/;
            var m = re.exec(s);
            if (m !== null) {
                result += m[1];
            } else {
                result += s;
            }

        } else {
            result += x.toFixed(0);
        }

        return result;
    }

    function formatFeet(value, precision) {
        if (isNaN(value)) {
            return 'NaN';
        }

        // Borrowed from AdCoreUnits PrimeDoublePrimeSymbol2::Format

        var result = '',
            radix = 12.0,
            denominator = 2.0,
            isNegative = (value < 0);

        if (precision) {
            for (var i = 1; i < precision; ++i) {
                denominator *= 2.0;
            }
        }

        // round to the nearest 1/denominator
        if (value > 0) {
            value += 0.5/denominator;
        } else {
            value -= 0.5/denominator;
        }

        var primeValue = modf(value/radix).intPart;
        result += formatNumber(primeValue, 0, isNegative) + '\' ';

        var doublePrimeValue = value - (primeValue * radix);
        if (doublePrimeValue < 0) {
            doublePrimeValue = -doublePrimeValue;
        }

        var intPart = modf(doublePrimeValue).intPart;
        var numerator = modf((doublePrimeValue - intPart) * denominator).intPart;

        if (numerator === 0 || intPart !== 0) {
            result += formatNumber(intPart, 0);
        }

        if (numerator !== 0) {
            if (intPart < 0 && numerator < 0) {
                numerator = -numerator;
            }
            while (numerator % 2 === 0) {
                numerator /= 2;
                denominator /= 2;
            }
            if (intPart !== 0) {
                result += '-';
            }
            result += formatNumber(numerator, 0) + '/' + formatNumber(denominator, 0);
        }

        result += '\"';
        return result;
    }

    var result;

    if (!precision)
        precision = 3;

    if (type === 1) { // Boolean
        result = Autodesk.Viewing.i18n.translate(value ? 'Yes' : 'No');

    } else if (units === 'ft' || units === 'feet' || units === 'foot') {
        result = formatFeet(value * 12.0, precision);

    } else if (units === 'in' || units === 'inch') {
        result = formatFeet(value, precision);

    } else if (type === 3 && units) { // Double, with units
        units = units.replace("^2", String.fromCharCode(0xb2));
        units = units.replace("^3", String.fromCharCode(0xb3));

        result = formatNumber(value, precision) + ' ' + units;

    } else if (units) {
        result = value + ' ' + units;

    } else if (type === 3) { // Double, no units
        result = formatNumber(value, precision);

    } else {
        result = value;
    }

    return result;
};

/**
 * Convert distance from unit to unit.
 * @param {string} fromUnits - GNU units format - units to convert from
 * @param {string} toUnits - GNU units format - units to convert to
 * @param {number} s - distance to convert
 * @returns {number} - distance after conversion.
 */
Autodesk.Viewing.Private.convertUnits = function (fromUnits, toUnits, s) {

    if (fromUnits === toUnits)
        return s;

    var toFactor = 1;
    switch (toUnits) {
        case "mm": toFactor = 1000; break;
        case "cm": toFactor = 100; break;
        case "m" : toFactor = 1; break;
        case "in": toFactor = 39.37; break;
        case "ft": toFactor = 3.28; break;
    }

    var fromFactor = 1;
    switch (fromUnits) {
        case "mm": fromFactor = 0.001; break;
        case "cm": fromFactor = 0.01; break;
        case "m" : fromFactor = 1; break;
        case "in": fromFactor = 0.0254; break;
        case "ft": fromFactor = 0.3048; break;
    }

    return (s * toFactor * fromFactor);
};
;AutodeskNamespace('Autodesk.Viewing.Private');

/** @constructor */
Autodesk.Viewing.Private.OptionSlider = function (caption, min, max, parentTbody) {
    var self = this;
    this.tbody = parentTbody;

    this.sliderRow = this.tbody.insertRow(-1);
    var cell = this.sliderRow.insertCell(0);

    this.caption = document.createElement("div");
    this.caption.setAttribute( "data-i18n", caption );
    this.caption.textContent = Autodesk.Viewing.i18n.translate( caption );


    this.sliderElement = document.createElement("input");
    this.sliderElement.type = "range";
    this.sliderElement.id = caption + "_slider";
    this.sliderElement.min = min;
    this.sliderElement.max = max;
    //this.sliderElement.style.width = "95%";
    cell.appendChild(this.caption);
    cell.appendChild(this.sliderElement);

    cell = this.sliderRow.insertCell(1);
    this.stepperElement = document.createElement("input");
    this.stepperElement.type = "number";
    this.stepperElement.id = caption + "_stepper";
    this.stepperElement.min = min;
    this.stepperElement.max = max;
    this.stepperElement.step = 1;
    //this.stepperElement.style.resize = "none";
    this.stepperElement.style.width = "64px";
    cell.appendChild(this.stepperElement);

    this.blockEvent = false;

    this.stepperElement.addEventListener("change",
        function(e) {
            if (e.target != self.sliderElement)
                self.sliderElement.value = self.stepperElement.value;
            self.fireChangeEvent();
        }, false);

    function changeHandler (e)
    {
        if (e.target != self.stepperElement)
            self.stepperElement.value = self.sliderElement.value;
        self.fireChangeEvent();
    }

    this.sliderElement.addEventListener("change", changeHandler, false);
    this.sliderElement.addEventListener("input", changeHandler, false);
};

Autodesk.Viewing.Private.OptionSlider.prototype = Object.create(THREE.EventDispatcher.prototype);

Autodesk.Viewing.Private.OptionSlider.prototype.fireChangeEvent = function() {
    if (!this.blockEvent) {
        this.value = this.sliderElement.value;
        var e = new CustomEvent("change", {
            detail : {
                target: this,
                value: this.sliderElement.value
            }
        });
        this.dispatchEvent(e);
    }
};

Autodesk.Viewing.Private.OptionSlider.prototype.setValue = function(v) {
    this.blockEvent = true;
    this.value = v;
    this.sliderElement.value = v;
    this.stepperElement.value = v;
    this.blockEvent = false;
};

Autodesk.Viewing.Private.OptionSlider.prototype.setDisabled = function(v) {
    this.sliderElement.disabled = v;
    this.stepperElement.disabled = v;
    this.caption.disabled = v;
};

//==========================================================================================================
//==========================================================================================================
//==========================================================================================================

/** @constructor */
Autodesk.Viewing.Private.OptionCheckbox = function (caption, parentTbody, initialState) {
    THREE.EventDispatcher.call(this.prototype);

    var self = this;
    this.tbody = parentTbody;

    this.sliderRow = this.tbody.insertRow(-1);
    var cell = this.sliderRow.insertCell(0);

    this.caption = document.createElement("div");
    this.caption.setAttribute("data-i18n", caption);
    this.caption.textContent = Autodesk.Viewing.i18n.translate( caption );

    cell.appendChild(this.caption);

    cell = this.sliderRow.insertCell(1);
    this.checkElement = document.createElement("input");
    this.checkElement.type = "checkbox";
    this.checkElement.id = caption + "_check";
    this.checkElement.checked = initialState;
    cell.appendChild(this.checkElement);
    //cell.style.width = "26px";

    this.blockEvent = false;
    this.checked = initialState;

    this.checkElement.addEventListener("change",
        function(e) {
            self.fireChangeEvent();
        }, false);

    this.checkElement.addEventListener("click", function(event) {
        event.stopPropagation();
    }, false);

    // Make the slider row clickable as well so that when
    // clicking on the row, the checkbox is toggled. 
    this.sliderRow.addEventListener("click",
        function(e) {
            self.checkElement.checked = !self.checkElement.checked;
            self.fireChangeEvent();
        }, false);
};

Autodesk.Viewing.Private.OptionCheckbox.prototype = Object.create(THREE.EventDispatcher.prototype);

Autodesk.Viewing.Private.OptionCheckbox.prototype.fireChangeEvent = function() {
    if (!this.blockEvent) {
        this.checked = this.checkElement.checked;
        var e = new CustomEvent("change", {
            detail : {
                target: this,
                value: this.checkElement.checked
            }
        });
        this.dispatchEvent(e);
    }
};

Autodesk.Viewing.Private.OptionCheckbox.prototype.setValue = function(v) {
    this.blockEvent = true;
    this.checked = v;
    this.checkElement.checked = v;
    this.blockEvent = false;
};

Autodesk.Viewing.Private.OptionCheckbox.prototype.setDisabled = function(v) {
    this.checkElement.disabled = v;
    this.caption.disabled = v;
};

Autodesk.Viewing.Private.OptionCheckbox.prototype.setVisibility = function( isVisible ) {
    if (isVisible)
        this.sliderRow.style.display = "table-row";
    else
        this.sliderRow.style.display = "none";
};

//==========================================================================================================
//==========================================================================================================
//==========================================================================================================

Autodesk.Viewing.Private.OptionDropDown = function (caption, parentTbody, items, initialItemIndex) {
    THREE.EventDispatcher.call(this.prototype);

    var self = this;
    this.tbody = parentTbody;

    this.sliderRow = this.tbody.insertRow(-1);
    var cell = this.sliderRow.insertCell(0);

    this.caption = document.createElement("div");
    this.caption.setAttribute( "data-i18n", caption );
    this.caption.textContent = Autodesk.Viewing.i18n.translate( caption );

    cell.appendChild(this.caption);

    cell = this.sliderRow.insertCell(1);
    this.dropdownElement = document.createElement("select");
    this.dropdownElement.id = caption + "_dropdown";
    this.dropdownElement.className = "optionDropDown";

    for (var i = 0; i < items.length; i++) {
        var item = document.createElement("option");
        item.value = i;
        item.setAttribute("data-i18n", items[i]);
        item.textContent = Autodesk.Viewing.i18n.translate( items[i] );
        this.dropdownElement.add(item);
    }

    this.selectedIndex = this.dropdownElement.selectedIndex = initialItemIndex;

    cell.appendChild(this.dropdownElement);

    this.blockEvent = false;

    this.dropdownElement.addEventListener("change",
        function(e) {
            self.fireChangeEvent();
        }, false);

};

Autodesk.Viewing.Private.OptionDropDown.prototype = Object.create(THREE.EventDispatcher.prototype);

Autodesk.Viewing.Private.OptionDropDown.prototype.setSelectedIndex = function(index) {
    this.blockEvent = true;
    this.selectedIndex = this.dropdownElement.selectedIndex = index;
    this.blockEvent = false;
};

Autodesk.Viewing.Private.OptionDropDown.prototype.setSelectedValue = function(value) {
    this.blockEvent = true;
    this.dropdownElement.selectedValue = value;
    this.selectedIndex = this.dropdownElement.selectedIndex;
    this.blockEvent = false;
}

Autodesk.Viewing.Private.OptionDropDown.prototype.fireChangeEvent = function() {
    if (!this.blockEvent) {
        this.selectedIndex = this.dropdownElement.selectedIndex;
        var e = new CustomEvent("change", {
            detail: {
                target: this,
                value: this.selectedIndex
            }
        });
        this.dispatchEvent(e);
    }
};

Autodesk.Viewing.Private.OptionDropDown.prototype.setDisabled = function(v) {
    this.dropdownElement.disabled = v;
    this.caption.disabled = v;
};
;AutodeskNamespace('Autodesk.Viewing.Private');

Autodesk.Viewing.Private.ProgressBar = function (container) {

    this.bg = document.createElement('div');
    this.bg.className = 'progressbg';

    this.fg = document.createElement('div');
    this.fg.className = 'progressfg';
    this.bg.appendChild(this.fg);

    container.appendChild(this.bg);

    this.widthScale = this.fg.clientWidth;
};

Autodesk.Viewing.Private.ProgressBar.prototype.setPercent = function(pct) {
    if (pct >= 99)
        this.bg.style.visibility = "hidden";
    else {
        this.bg.style.visibility = "visible";
        this.fg.style.width = (this.widthScale * pct * 0.01) + "px";
    }
};
;AutodeskNamespace('Autodesk.Viewing.Private');

/** @constructor */
Autodesk.Viewing.Private.RenderOptionsPanel = function (viewer) {
    var self = this;
    var avp = Autodesk.Viewing.Private;
    this.viewer = viewer;
    Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, 'RenderOptionsPanel', 'Rendering Options');

    this.table = document.createElement("table");
    this.table.className = "tftable";

    this.tbody = document.createElement("tbody");
    this.table.appendChild(this.tbody);

    // Create the scroll container.  Adjust the height so the scroll container does not overlap
    // the resize handle.  50px accounts for the titlebar and resize handle.
    //
    this.scrollpanel = this.createScrollContainer({heightAdjustment:70});
    this.scrollpanel.style.marginTop = "20px";
    this.container.appendChild(this.scrollpanel);

    this.scrollpanel.appendChild(this.table);

    this.container.style.width  = "364px";
    this.container.style.top    = "260px";
    this.container.style.left   = "220px"; // just needs an initial value dock overrides value
    this.container.style.height = "460px";
    this.container.dockRight = true;

    var color_list = [];
    for (var p in viewer.impl.BackgroundPresets) {
        color_list.push(p);
    }

    this.bgSelect = new avp.OptionDropDown("Background Color", this.tbody, color_list, -1);
    this.updateBgColorIndex();

    this.addEventListener(this.bgSelect, "change", function(e) {

        var chosen = self.bgSelect.value;

        var c = viewer.BackgroundPresets[chosen];

        viewer.prefs.set("backgroundColorPreset", JSON.stringify(c));
        viewer.impl.setClearColors(c[0],c[1],c[2],c[3],c[4],c[5]);
    });


    this.saoToggle = new avp.OptionCheckbox("AO Enabled", this.tbody, true);
    this.addEventListener(this.saoToggle, "change", function(e) {
        var enable = self.saoToggle.checked;
        viewer.prefs.set("ambientShadows", enable);
        viewer.setQualityLevel(enable, viewer.impl.renderer().settings.antialias);
    });

    this.saoRadius = new avp.OptionSlider("AO Radius", 0, 100, this.tbody);
    this.saoRadius.setValue(10);
    this.saoRadius.sliderElement.step = this.saoRadius.stepperElement.step = 1;
    this.addEventListener(this.saoRadius, "change", function(e) {
        viewer.impl.renderer().setAOOptions(parseInt(self.saoRadius.value), parseFloat(self.saoIntensity.value));
        viewer.impl.renderer().composeFinalFrame(false);
    });

    this.saoIntensity = new avp.OptionSlider("AO Intensity", 0, 3, this.tbody);
    this.saoIntensity.setValue(0.75);
    this.saoIntensity.sliderElement.step = this.saoIntensity.stepperElement.step = 0.1;
    this.addEventListener(this.saoIntensity, "change", function(e) {
        viewer.impl.renderer().setAOOptions(parseInt(self.saoRadius.value), parseFloat(self.saoIntensity.value));
        viewer.impl.renderer().composeFinalFrame(false);
    });

    var env_list = [];
    for (var i=0; i<avp.LightPresets.length; i++) {
        env_list.push(avp.LightPresets[i].name);
    }

    this.envSelect = new avp.OptionDropDown("Environment", this.tbody, env_list, viewer.impl.currentLightPreset());

    this.addEventListener(this.envSelect, "change", function(e) {
        var chosen = self.envSelect.selectedIndex;
        viewer.setLightPreset(chosen);
    });


    var initialTonemapMethod = viewer.impl.renderer().getToneMapMethod();

    this.toneMapMethod = new avp.OptionDropDown("Tonemap Method", this.tbody,
        ["None",
         "Canon-RGB",
         "Canon-Lum"
         ],
        initialTonemapMethod);

    this.addEventListener(this.toneMapMethod, "change", function() {
        var method = self.toneMapMethod.selectedIndex;
        viewer.impl.setTonemapMethod(method);
    });

    this.exposureBias = new avp.OptionSlider("Exposure Bias", -30.0, 30.0, this.tbody);
    this.exposureBias.setValue(viewer.impl.renderer().getExposureBias());
    this.exposureBias.sliderElement.step = this.exposureBias.stepperElement.step = 0.1;
    this.addEventListener(this.exposureBias, "change", function(e) {
        viewer.impl.setExposureBias(self.exposureBias.value, self.whiteScale.value);
    });
    this.exposureBias.setDisabled(initialTonemapMethod == 0);

    this.whiteScale = new avp.OptionSlider("Light Intensity", -5.0, 20.0, this.tbody);
    var intensity = 0.0;
    if (viewer.impl.dir_light1) {
        if (viewer.impl.dir_light1.intensity != 0)
            intensity = Math.log(viewer.impl.dir_light1.intensity)/Math.log(2.0);
        else
            intensity = -1e-20;
    }
    this.whiteScale.setValue(intensity);
    this.whiteScale.sliderElement.step = this.whiteScale.stepperElement.step = 0.1;
    this.addEventListener(this.whiteScale, "change", function(e) {
        viewer.impl.dir_light1.intensity = Math.pow(2.0,self.whiteScale.value);
        viewer.impl.setExposureBias(self.exposureBias.value, self.whiteScale.value);
    });

    // 10-200mm lens range:
    this.fovAngle = new avp.OptionSlider("FOV-degrees", 6.88, 100, this.tbody);
    this.fovAngle.setValue(viewer.getFOV());
    this.addEventListener(this.fovAngle, "change", function(e) {
        viewer.setFOV(parseFloat(self.fovAngle.value));
    });

    this.addEventListener(this.viewer, Autodesk.Viewing.CAMERA_CHANGE_EVENT, function(evt) {
        var myFov = parseFloat(self.fovAngle.value);
        var camFov = viewer.getFOV();

        if (myFov != camFov)
            self.fovAngle.setValue(camFov);
    });


    this.addEventListener(this.viewer, Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT, function(e) {
        self.syncUI();
    });
};

Autodesk.Viewing.Private.RenderOptionsPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Private.RenderOptionsPanel.prototype.constructor = Autodesk.Viewing.Private.RenderOptionsPanel;

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
Autodesk.Viewing.Private.RenderOptionsPanel.prototype.getContentSize = function () {
    return {height: this.table.clientHeight + 75, width: this.table.clientWidth};
};

Autodesk.Viewing.Private.RenderOptionsPanel.prototype.updateBgColorIndex = function() {

    var viewer = this.viewer.impl;
    var ctop = viewer.clearColorTop;
    var cbot = viewer.clearColorBottom;
    var current_color = [(ctop.x * 255)|0, (ctop.y * 255)|0, (ctop.z * 255)|0,
                         (cbot.x * 255)|0, (cbot.y * 255)|0, (cbot.z * 255)|0];

    //Check if the current setting of the viewer matches any of the presets.
    var color_name;
    for (var p in Autodesk.Viewing.Private.BackgroundPresets)
    {
        var c = Autodesk.Viewing.Private.BackgroundPresets[p];
        var j;
        for (j = 0; j<6; j++)
        {
            if (c[j] != current_color[j])
                break;
        }
        if (j == 6)
        {
            color_name = p;
            break;
        }
    }

    //If it does not match, add it as extra entry in the combo box
    if (!color_name)
    {
        color_name = "Custom";
        var custom_color_arr = Autodesk.Viewing.Private.BackgroundPresets[color_name];
        for (var i=0; i<6; i++) {
            custom_color_arr[i] = current_color[i];
        }
    }

    this.bgSelect.setSelectedValue(color_name);
};

Autodesk.Viewing.Private.RenderOptionsPanel.prototype.syncUI = function() {
    var impl = this.viewer.impl;

    var intensity = 0.0;
    if (impl.dir_light1) {
        if (impl.dir_light1.intensity != 0)
            intensity = Math.log(impl.dir_light1.intensity)/Math.log(2.0);
        else
            intensity = -1e-20;
    }
    this.whiteScale.setValue(intensity);

    this.exposureBias.setValue(impl.renderer().getExposureBias());

    this.updateBgColorIndex();

    var method = impl.renderer().getToneMapMethod();
    this.toneMapMethod.setSelectedIndex(method);
    this.envSelect.setSelectedIndex(impl.currentLightPreset());

    this.exposureBias.setDisabled(method == 0);
    this.saoToggle.setValue(impl.renderer().settings.sao);
    this.saoRadius.setDisabled(!impl.renderer().settings.sao);
    this.saoIntensity.setDisabled(!impl.renderer().settings.sao);

    this.saoRadius.setValue(impl.renderer().getAORadius());
    this.saoIntensity.setValue(impl.renderer().getAOIntensity());

    this.fovAngle.setValue(this.viewer.getFOV());
};

Autodesk.Viewing.Private.RenderOptionsPanel.prototype.uninitialize = function () {
    Autodesk.Viewing.UI.DockingPanel.prototype.uninitialize.call(this);
    this.table = null;
    this.tbody = null;
    this.bgSelect = null;
    this.saoToggle = null;
    this.saoRadius = null;
    this.saoIntensity = null;
    this.envSelect = null;
    this.toneMapMethod = null;
    this.exposureBias = null;
    this.whiteScale = null;
    this.fovAngle = null;
    this.viewer = null;
};
;AutodeskNamespace('Autodesk.Viewing.UI');

/**
 * LayersPanel
 * This is a panel for displaying the layers in a file.
 * @class
 *
 * @param {Viewer} viewer - The parent viewer.
 * @param {HTMLElement} parentContainer - The container for this panel.
 * @param {string} id - The id for this panel.
 * @constructor
 * @private
 */
Autodesk.Viewing.UI.LayersPanel = function (viewer, parentContainer, id) {
    this.viewer = viewer;
    this.tree = null;
    this.layersRoot = null;
    this.visibilityImages = {};
    this.isMac = (navigator.userAgent.search("Mac OS") !== -1);

    var title = "Layer Manager",
        viewableName = viewer.config.viewableName;

    if (viewableName) {
        title = Autodesk.Viewing.i18n.translate(title) + ": " + viewableName;
    }

    this.filterImageId = id + "-layerFilterImageId";

    Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, id, title, {localizeTitle: false});
    this.container.classList.add('layersPanel');
    this.filterContainer = document.createElement("div");
    this.filterContainer.className = "filterBox";
    this.filterContainer.id = this.container.id + '-search-container';
    this.container.appendChild( this.filterContainer );

    this.scrollContainer = this.createScrollContainer({heightAdjustment: 105});
    this.scrollContainer.style.marginTop = "5px";
    this.container.appendChild(this.scrollContainer);
    this.scrollContainer.id = this.container.id + '-scroll-container';

    var that = this;
    if (viewer.model) {
        that.build();
    } else {
        that.addEventListener(viewer, Autodesk.Viewing.GEOMETRY_LOADED_EVENT, function () {
            that.build();
        });
    }
};

Autodesk.Viewing.UI.LayersPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.UI.LayersPanel.prototype.constructor = Autodesk.Viewing.UI.LayersPanel;

/**
 * Clean up when the layers panel is about to be removed.
 * @override
 */
Autodesk.Viewing.UI.LayersPanel.prototype.uninitialize = function () {
    Autodesk.Viewing.UI.DockingPanel.prototype.uninitialize.call(this);

    this.viewer = null;
    this.tree = null;
    this.layersRoot = null;
    this.visibilityImages = null;
    this.scrollContainer = null;
    this.filterContainer = null;
};

/**
 * Builds the layers panel.
 */
Autodesk.Viewing.UI.LayersPanel.prototype.build = function () {
    var that = this;

    function createDelegate() {
        var delegate = new Autodesk.Viewing.UI.TreeDelegate();

        delegate.getTreeNodeId = function (node) {
            return node.id;
        };

        delegate.getTreeNodeLabel = function (node) {
            return that.getNodeLabel(node);
        };

        delegate.getTreeNodeClass = function (node) {
            return that.getNodeClass(node);
        };

        delegate.isTreeNodeGroup = function (node) {
            return that.isGroupNode(node);
        };

        delegate.shouldCreateTreeNode = function (node) {
            return that.shouldInclude(node);
        };

        delegate.onTreeNodeClick = function (tree, node, event) {
            that.onClick(node, event);
        };

        delegate.onTreeNodeRightClick = function (tree, node, event) {
            that.onRightClick(node, event);
        };

        delegate.onTreeNodeDoubleClick = function (tree, node, event) {
            that.onDoubleClick(node, event);
        };

        delegate.createTreeNode = function (node, parent) {
            that.createNode(node, parent);
        };

        return delegate;
    }

    // Search field
    var searchDiv = document.createElement("div");
    searchDiv.className = "filterSearch";
    that.filterContainer.appendChild(searchDiv);

    var image = document.createElement('div');
    image.className = "filterImage";
    image.id  = that.filterImageId;
    image.title = Autodesk.Viewing.i18n.translate("Show/hide all layers");
    searchDiv.appendChild( image );
    that.visibilityImages[that.filterImageId] = image;

    that.addEventListener(image, 'click', function (event) {
        that.onImageClick(null, event);
        event.stopPropagation();
    });

    var filterField = this.filterField = document.createElement("input");
    filterField.className = "filterInput";
    filterField.placeholder = Autodesk.Viewing.i18n.translate("Enter filter term");
    filterField.setAttribute("data-i18n", "[placeholder]Enter filter term");
    filterField.type = 'search';
    filterField.incremental = "incremental";

    searchDiv.appendChild(filterField);

    var searchTimer = null,
        viewer = that.viewer;

    function doIncrementalSearch() {
        if (searchTimer) {
            clearTimeout(searchTimer);
        }
        searchTimer = setTimeout(doSearch, 500);
    }

    function doSearch() {
        if (filterField.value) {
            var searchText = filterField.value.toLowerCase();

            function getMatches(node) {
                var matches = [];
                if (node.name.toLowerCase().indexOf(searchText) !== -1) {
                    matches.push(node);
                } else if (!node.isLayer) {
                    var children = node.children;
                    for (var i = 0; i < children.length; ++i) {
                        matches = matches.concat(getMatches(children[i]));
                    }
                }
                return matches;
            }

            var layersRoot = that.layersRoot;
            if (layersRoot) {
                viewer.setLayerVisible(getMatches(layersRoot), true, true);
            }
        } else {
            // Make all the layers visible.
            viewer.setLayerVisible(null, true);
        }
        searchTimer = null;
    }

    filterField.addEventListener('keyup', function (e) {
        doIncrementalSearch();
    });

    // This is to detect when the user clicks on the 'x' to clear.
    filterField.addEventListener('click', function (e) {
        if (filterField.value === '') {
            viewer.setLayerVisible(null, true);
            return;
        }

        // When this event is fired after clicking on the clear button
        // the value is not cleared yet. We have to wait for it.
        setTimeout(function () {
            if (filterField.value === '') {
                viewer.setLayerVisible(null, true);
                e.preventDefault();
            }
        }, 1);
    });

    var delegate = createDelegate(),
        layersRoot = that.layersRoot = that.viewer.model.getLayersRoot();

    if (layersRoot) {
        that.tree = new Autodesk.Viewing.UI.Tree(delegate, layersRoot, that.scrollContainer, {});
        that.tree.addClass(delegate.getTreeNodeId(layersRoot), 'exclude');
        that.update();

        that.addEventListener(that.viewer, Autodesk.Viewing.LAYER_VISIBILITY_CHANGED_EVENT, function () {
            that.update();
        });
    }
};

/**
 * Updates the visibility states for the layers in the panel.
 */
Autodesk.Viewing.UI.LayersPanel.prototype.update = function () {
    if (!this.layersRoot) {
        return;
    }

    var that = this;

    function updateImage(image, state) {
        var cls;
        if (state === 1) {
            cls = 'layerVisible';
        } else if (state === 0) {
            cls = 'layerHidden';
        } else { // -1
            cls = 'layerMixed';
        }
        image.className = cls;
    }

    function updateLook(node, state) {
        if (state === 0) {
            that.tree.addClass(node.id, 'dim');
        } else { // state === 1 || state === -1
            that.tree.removeClass(node.id, "dim");
        }
    }

    function getItemState(items) {
        var state;

        for (var i = 0; i < items.length; ++i) {
            var item = items[i];

            if (state === undefined) {
                state = item;
            } else if (item === 0 && state === 1) {
                state = -1;
            } else if (item === 1 && state === 0) {
                state = -1;
            }

            if (state === -1) {
                break;
            }
        }
        return state;
    }

    function traverse(parent) {
        var id = parent.id,
            image = that.visibilityImages[id];

        if (!parent.isLayer) {
            var children = parent.children,
                visibility = [];

            for (var i = 0; i < children.length; ++i) {
                visibility = visibility.concat(traverse(children[i]));
            }

            var state = getItemState(visibility);
            updateImage(image, state);
            updateLook(parent, state);
            return visibility;
        }

        var visible = that.viewer.isLayerVisible(parent) ? 1 : 0;
        updateImage(image, visible);
        updateLook(parent, visible);

        return [visible];
    }

    var allVisible = traverse(that.layersRoot);

    // Update the filter image.
    var filterImage = that.visibilityImages[that.filterImageId];
    updateImage(filterImage, getItemState(allVisible));
};

/**
 * Toggle the visibility state for a layer node.
 * @param {Object} node
 */
Autodesk.Viewing.UI.LayersPanel.prototype.toggleLayerVisible = function (node) {
    var id = node ? node.id : this.filterImageId,
        cls = this.visibilityImages[id].className,
        visible = (cls !== 'layerVisible');
    this.viewer.setLayerVisible(node, visible);
    this.filterField.value = '';
};

/**
 * Isolate the visibility state for a layer node.
 * @param {Object} node
 * @param {Event} event
 */
Autodesk.Viewing.UI.LayersPanel.prototype.isolateLayerVisible = function (node, event) {
    var isCtrlDown = (this.isMac && event.metaKey) || (!this.isMac && event.ctrlKey),
        cls = this.visibilityImages[node.id].className,
        visible = (cls !== 'layerVisible');

    this.viewer.setLayerVisible(node, visible, /*isolate=*/!isCtrlDown);
    this.filterField.value = '';
};

/**
 * Override this method to specify the label for a node.
 * @param {Object} node
 * @returns {string} Label of the tree node
 */
Autodesk.Viewing.UI.LayersPanel.prototype.getNodeLabel = function (node) {
    return (node.isLayer || 0 === node.childCount) ? node.name : (node.name + " (" + node.childCount + ")");
};

/**
 * Override this to specify the CSS classes of a node. This way, in CSS, the designer
 * can specify custom styling per type.
 * By default, an empty string is returned.
 * @param {Object} node
 * @returns {string} CSS classes for the node
 */
Autodesk.Viewing.UI.LayersPanel.prototype.getNodeClass = function (node) {
    return '';
};

/**
 * Override this method to specify whether or not a node is a group node.
 * @param {Object} node
 * @returns {boolean} true if this node is a group node, false otherwise
 */
Autodesk.Viewing.UI.LayersPanel.prototype.isGroupNode = function (node) {
    return !node.isLayer;
};

/**
 * Override this method to specify if a tree node should be created for this node.
 * By default, every node will be displayed.
 * @param {Object} node
 * @returns {boolean} true if a node should be created, false otherwise
 */
Autodesk.Viewing.UI.LayersPanel.prototype.shouldInclude = function (node) {
    return true;
};

/**
 * Override this method to do something when the user clicks on a tree node
 * @param {Object} node
 * @param {Event} event
 */
Autodesk.Viewing.UI.LayersPanel.prototype.onClick = function (node, event) {
};

/**
 * Override this to do something when the user double-clicks on a tree node
 * @param {Object} node
 * @param {Event} event
 */
Autodesk.Viewing.UI.LayersPanel.prototype.onDoubleClick = function (node, event) {
};

/**
 * Override this to do something when the user right-clicks on a tree node
 * @param {Object} node
 * @param {Event} event
 */
Autodesk.Viewing.UI.LayersPanel.prototype.onRightClick = function (node, event) {
};

/**
 * Override this to do something when the user clicks on an image
 * @param {Object} node
 * @param {Event} event
 */
Autodesk.Viewing.UI.LayersPanel.prototype.onImageClick = function (node, event) {
};

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
Autodesk.Viewing.UI.LayersPanel.prototype.getContentSize = function () {
    var treeContainer = document.getElementById(this.tree.getRootContainerId());
    return {
        height: treeContainer.clientHeight + this.filterContainer.clientHeight + 80,
        width: Math.max(treeContainer.clientWidth, this.filterContainer.clientWidth)
    };
};

/**
 * Override this to create the HTMLContent for this node for appending to the
 * parent.  By default, a label and a visibility image are created.
 * @param {Object} node
 * @param {HTMLElement} parent
 */
Autodesk.Viewing.UI.LayersPanel.prototype.createNode = function (node, parent) {
    var image = document.createElement('div');
    if (parent.children && parent.children.length > 0) {
        parent.insertBefore(image, parent.children[0]);
    } else {
        parent.appendChild(image);
    }
    image.title = Autodesk.Viewing.i18n.translate("Show/hide this layer");
    this.visibilityImages[node.id] = image;

    var label = document.createElement('label');
    label.textContent = this.getNodeLabel(node);
    parent.appendChild(label);

    var that = this;
    this.addEventListener(image, 'click', function (event) {
        that.onImageClick(node, event);
        event.stopPropagation();
    });
};
;AutodeskNamespace('Autodesk.Viewing.Private');

Autodesk.Viewing.Private.NavigationTab  = 1;
Autodesk.Viewing.Private.PerformanceTab = 2;

/** @constructor */
Autodesk.Viewing.Private.Viewer3dSettingsPanel = function (viewer, mode) {
    var self = this;
    this.viewer = viewer;
    this.mode = mode;

    Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, 'Viewer3dSettingsPanel', 'Settings');

    this.container.style.minWidth = "425px";
    this.container.style.maxWidth = "800px";
    this.container.style.top      = "200px";
    this.container.style.left     = "220px"; // just needs an initial value dock overrides value
    this.container.style.position = "absolute";

    this.container.dockRight = true;

    this.main = document.createElement("div");
    this.main.className = "viewer-tabs";
    this.container.appendChild(this.main);

    // Create the two tabs.
    this.tabs = document.createElement( "ul" );
    this.tab1 = document.createElement("li");
    this.tab1.id = "navigationtab";
    this.tab2 = document.createElement("li");
    this.tab2.id = "performancetab";

    var title1 = document.createElement("a");
    var span1  = document.createElement("span");
    span1.setAttribute("data-i18n", "Navigation and seletion");
    span1.textContent = Autodesk.Viewing.i18n.translate( "Navigation and seletion" );
    title1.appendChild(span1);
    var title2 = document.createElement("a");
    var span2  = document.createElement("span");
    span2.setAttribute("data-i18n", "Performance and appearance");
    span2.textContent = Autodesk.Viewing.i18n.translate( "Performance and appearance" );
    title2.appendChild( span2 );

    this.tab1.appendChild( title1 );
    this.tab2.appendChild( title2 );

    this.tabs.appendChild( this.tab1 );
    this.tabs.appendChild( this.tab2 );
    this.main.appendChild( this.tabs );

    this.scrollContainer = this.createScrollContainer({left: false, heightAdjustment:145});
    this.scrollContainer.style.marginTop = "20px";
    this.container.appendChild(this.scrollContainer);
    this.scrollContainer.id = this.container.id + '-scroll-container';

    this.table1 = document.createElement("table");
    this.table1.className = "viewer-table tftable navigation";
    this.tbody1 = document.createElement("tbody");
    this.table1.appendChild(this.tbody1);

    this.table2 = document.createElement("table");
    this.table2.className = "viewer-table tftable performance";
    this.tbody2 = document.createElement("tbody");
    this.table2.appendChild(this.tbody2);

    this.scrollContainer.appendChild( this.table1 );
    this.scrollContainer.appendChild( this.table2 );

    this.restoreDiv = document.createElement('div');
    this.restoreDiv.className = 'viewer-restore-defaults';
    this.restoreDiv.setAttribute("data-i18n", "Restore settings defaults");
    this.restoreDiv.textContent = Autodesk.Viewing.i18n.translate("Restore settings defaults");

    this.addEventListener(this.restoreDiv, 'click', function () {
        var tag = viewer.model.is2d() ? '2d' : '3d';
        viewer.prefs.reset(tag);
    }, false);

    this.container.appendChild(this.restoreDiv);

    this.mouseOver = false;
    this.selectTab( Autodesk.Viewing.Private.NavigationTab );

    var viewerSettings = this;
    this.addEventListener( this.tab1, "click", function(e) {
        viewerSettings.selectTab( Autodesk.Viewing.Private.NavigationTab );
    });

    this.addEventListener( this.tab2, "click", function(e) {
        viewerSettings.selectTab( Autodesk.Viewing.Private.PerformanceTab );
    });

    this.createNavigationPanel( this.tbody1 );
    this.createPerformancePanel( this.tbody2 );

    this.addEventListener( this.container, "mouseover", function(event) {
        //this is the original element the event handler was assigned to
        var e = event.toElement || event.relatedTarget;
        if ( viewerSettings.mouseOver )
            return true;

        //check for all children levels (checking from bottom up)
        while(e && e.parentNode && e.parentNode != window) {
            if (e.parentNode == this ||  e == this) {
                if(e.preventDefault) e.preventDefault();

                viewerSettings.mouseOver = true;

                viewerSettings.tab1.classList.remove("selectedmouseout");
                viewerSettings.tab2.classList.remove("selectedmouseout");

                return true;
            }
            e = e.parentNode;
        }
    });

    this.addEventListener( this.container, "mouseout", function(event) {
        //this is the original element the event handler was assigned to
        var e = event.toElement || event.relatedTarget;

        if (!viewerSettings.mouseOver)
            return;

        //check for all children levels (checking from bottom up)
        while(e && e.parentNode && e.parentNode != window) {
            if (e.parentNode == this ||  e == this) {
                if(e.preventDefault) e.preventDefault();
                return false;
            }
            e = e.parentNode;
        }
        viewerSettings.mouseOver = false;

        var selectedTab = viewerSettings.tab1.classList.contains("tabselected")
            ? viewerSettings.tab1
            : viewerSettings.tab2;

        selectedTab.classList.add("selectedmouseout");
    });
};

Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.constructor = Autodesk.Viewing.Private.Viewer3dSettingsPanel;

Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.uninitialize = function () {
    this.viewer = null;
    Autodesk.Viewing.UI.DockingPanel.prototype.uninitialize.call(this);
};

Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.setVisible = function( show )
{
    if (show) {
        // Since the container does not have width and when display set to none
        // getBoundingClientRect() returns 0, set the display to block before the
        // parent calculates the position and the panel.
        // NOTE: Setting the width for the container does not work here.
        this.container.style.display = "block";
    }
    Autodesk.Viewing.UI.DockingPanel.prototype.setVisible.call( this, show );
};

Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.selectTab = function( tab )
{
    var is3d = this.mode === "3d";
    var that = this;

    if ( tab===Autodesk.Viewing.Private.NavigationTab ) {

        // Adjust the height.
        this.container.style.height    = is3d ? "310px" : "235px";
        this.container.style.maxHeight = "800px";
        this.container.style.resize    = "vertical";

        this.table1.style.display = 'table';
        this.table2.style.display = 'none';
        
        this.tab1.classList.add("tabselected");
        this.tab2.classList.remove("tabselected");

        // If mouse is out the styling is a little bit different
        if (!this.mouseOver) {
            this.tab1.classList.add("selectedmouseout");
            this.tab2.classList.remove("selectedmouseout");
        }
    }
    else if (tab===Autodesk.Viewing.Private.PerformanceTab) {

        // Adjust the height.
        this.container.style.height    = is3d ? "305px" : "180px";
        this.container.style.maxHeight = is3d ? "305px" : "180px";
        this.container.style.resize    = "none";

        this.table1.style.display = 'none';
        this.table2.style.display = 'table';

        this.tab2.classList.add("tabselected");
        this.tab1.classList.remove("tabselected");

        // If mouse is out the styling is a little bit different.
        if (!this.mouseOver) {
            this.tab2.classList.add("selectedmouseout");
            this.tab1.classList.remove("selectedmouseout");
        }
    }
};

Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.isTabSelected = function (tab) {
    var elem;
    if (tab === Autodesk.Viewing.Private.NavigationTab) {
        elem = this.tab1;
    } else if (tab === Autodesk.Viewing.Private.PerformanceTab) {
        elem = this.tab2;
    }
    return elem && elem.classList.contains('tabselected');
};

Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.addOptionCheckbox = function(tooltip, parent, initialState, onchange, saveKey)
{
    var viewer = this.viewer;

    // Use the stored settings or defaults
    var storedState = viewer.prefs[saveKey];
    initialState = (typeof storedState === 'boolean') ? storedState : initialState;

    var checkBoxElem = new Autodesk.Viewing.Private.OptionCheckbox(tooltip, parent, initialState );
    this.addEventListener(checkBoxElem, "change", function(e) {
        var checked = e.detail.target.checked;
        viewer.prefs.set(saveKey, checked);
        onchange(checked);
    });

    viewer.prefs.addListeners(saveKey, function (value) {
        checkBoxElem.setValue(value);
    }, function (value) {
        checkBoxElem.setValue(value);
        onchange(value);
    });

    return checkBoxElem;
};

Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.createNavigationPanel = function( tbody )
{
    var viewer = this.viewer;
    var is3d   = this.mode === "3d";

    if (is3d) {
        this.viewcube = this.addOptionCheckbox("Show ViewCube", tbody, true, function(checked) {
            viewer.displayViewCube(checked);
        }, "viewCube");

        this.viewcubeonpivot = this.addOptionCheckbox("ViewCube acts on pivot", tbody, false, function(checked) {
            viewer.setUsePivotAlways(checked);
        }, "alwaysUsePivot");

        this.zoom = this.addOptionCheckbox("Zoom towards pivot", tbody, false, function(checked) {
            viewer.setZoomTowardsPivot(checked);
        }, "zoomTowardsPivot");

        this.setpivot = this.addOptionCheckbox("Set pivot with left mouse button", tbody, false, function(checked) {
            viewer.setClickToSetCOI(checked);
        }, "clickToSetCOI");
    }

    this.reverse = this.addOptionCheckbox("Reverse mouse zoom direction", tbody, false, function(checked) {
        viewer.setReverseZoomDirection(checked);
    }, "reverseMouseZoomDir");

    if (is3d) {
        this.lookHor = this.addOptionCheckbox("Reverse horizontal look direction", tbody, false, function(checked) {
            viewer.setReverseHorizontalLookDirection(checked);
        }, "reverseHorizontalLookDirection");

        this.lookVert = this.addOptionCheckbox("Reverse vertical look direction", tbody, false, function(checked) {
            viewer.setReverseVerticalLookDirection(checked);
        }, "reverseVerticalLookDirection");

        this.orbit = this.addOptionCheckbox("Orbit past world poles", tbody, true, function(checked) {
            viewer.setOrbitPastWorldPoles(checked);
        }, "orbitPastWorldPoles");
    }

    this.propertiesOnSelect = this.addOptionCheckbox("Open properties on select", tbody, true, function(checked) {
        viewer.setPropertiesOnSelect(checked);
    }, "openPropertiesOnSelect");

    this.leftHanded = this.addOptionCheckbox("Left handed mouse setup", tbody, false, function(checked) {
        viewer.setUseLeftHandedInput(checked);
    }, "leftHandedMouseSetup");
};

Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.createPerformancePanel = function( tbody )
{
    var viewer = this.viewer;
    var is3d   = this.mode === "3d";

    if (is3d) {
        this.ghosthidden = this.addOptionCheckbox("Ghost hidden objects", tbody, true, function(checked) {
            viewer.setGhosting(checked);
        }, "ghosting");

        this.optimizeNavigation = this.addOptionCheckbox("Smooth navigation", tbody, false, function(checked) {
            viewer.setOptimizeNavigation(checked);
        }, "optimizeNavigation");


        this.ambientshadows = this.addOptionCheckbox("Ambient shadows", tbody, true, function(checked) {
            viewer.setQualityLevel(checked, viewer.prefs.antialiasing);
        }, "ambientShadows");

        this.antialiasing = this.addOptionCheckbox("Anti-aliasing", tbody, true, function(checked) {
            viewer.setQualityLevel(viewer.prefs.ambientShadows, checked);
        }, "antialiasing");
    }

    this.progressiveRender = this.addOptionCheckbox("Progressive model display", tbody, true, function(checked) {
        viewer.setProgressiveRendering(checked);
    }, "progressiveRendering");
};

/**
 * KLUDGE Solution. We allow it because production-minified viewer will bundle 'Autodesk.Markers' extension code.
 * TODO: Figure out a better approach.
 *
 * Creates a new checkbox that toggles the visibility of the 'Autodesk.Markers' extension.
 *
 * @param {Autodesk.Viewing.Extensions.Markers.ViewerMarkers} extension
 */
Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.addMarkersOption = function( extension ) {

    var tbody = this.tbody1;
    var markersExtension = extension || this.getMarkersExtension();

    if (markersExtension) {

        //@note: added this if section because 'showCommentMarkers' is not created and thus no value is assigned to it.
        if (this.viewer.prefs.showCommentMarkers === undefined) {
            this.viewer.prefs.showCommentMarkers = true;
        }
        this.showCommentMarkers = this.addOptionCheckbox("Show Comment Markers", tbody, true, function(checked) {
            markersExtension.setEnabled(checked);
        }, "showCommentMarkers");

        // Probably an overkill to call this here.
        this.selectTab( Autodesk.Viewing.Private.NavigationTab );
    }
};

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.getContentSize = function () {
    return {
        height: this.main.clientHeight + this.table1.clientHeight +
                this.table2.clientHeight + this.restoreDiv.clientHeight + 95,
        width: this.main.clientWidth
    };
};

Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.syncUI = function() {

    var viewer = this.viewer;
    if (this.antialiasing) {
        this.antialiasing.setValue(viewer.prefs.antialiasing);
    }
    if (this.ambientshadows) {
        this.ambientshadows.setValue(viewer.prefs.ambientShadows);
    }
    if (this.progressiveRender) {
        this.progressiveRender.setValue(viewer.prefs.progressiveRendering);
    }
    if (this.ghosthidden) {
        this.ghosthidden.setValue(viewer.prefs.ghosting);
    }
    if (this.showCommentMarkers) {
        var markersExtension = this.getMarkersExtension();
        if (markersExtension) {
            this.showCommentMarkers.setValue(markersExtension.markersEnabled);
        }
    }
};

Autodesk.Viewing.Private.Viewer3dSettingsPanel.prototype.getMarkersExtension = function() {
    // return null; // TESTING CODE //
    return this.viewer.loadedExtensions['Autodesk.Markers'];
};
;AutodeskNamespace('Autodesk.Viewing.Private');

/** @constructor */
Autodesk.Viewing.Private.AlertBox = function () {
};

Autodesk.Viewing.Private.AlertBox.instances = [];

// static
Autodesk.Viewing.Private.AlertBox.displayError = function(container, msg, title, imgClass, hints ) {

    var alertBox = document.createElement("div");
    alertBox.className = "alertBox error";
    container.appendChild( alertBox );

    // Create the image element.
    var errorImageClass = imgClass;
    if (!errorImageClass)
        errorImageClass = "img-item-not-found";

    var alertBoxImg = document.createElement("div");
    alertBoxImg.className = "alertBoxImage " + errorImageClass;
    alertBox.appendChild( alertBoxImg );

    // Create the title & message element.
    var alertBoxMsg = document.createElement("div");
    alertBoxMsg.className = "alertBoxMsg";
    alertBox.appendChild( alertBoxMsg );

    var errorTitle = title;
    if (!errorTitle)
        errorTitle =  Autodesk.Viewing.i18n.translate( "Error Occurred", { "defaultValue" : "Error Occurred" } );

    var alertBoxTitle = document.createElement("div");
    alertBoxTitle.className = "alertBoxTitle";
    alertBoxTitle.textContent = errorTitle;
    alertBoxMsg.appendChild( alertBoxTitle );

    var alertBoxText = document.createElement("div");
    alertBoxText.className = "alertBoxText";
    alertBoxText.textContent = msg;
    alertBoxMsg.appendChild( alertBoxText );

    // Add additional content
    if (hints) {
        var content = document.createElement("div");
        content.className = "alertBoxContent";
        alertBoxMsg.appendChild( content );

        var hintsElement = document.createElement("ul");
        hintsElement.className = "alertBoxContent";
        for (var h=0; h<hints.length; h++) {
            var hint = hints[h];
            if (!hint)
                continue;

            var hintElem = document.createElement("li");
            hintsElement.appendChild( hintElem );

            var result = this.extractList(hint);
            if (result.list.length) {
                var unorderedlist = this.generateListElement(list);
                hintsElement.appendChild( unorderedlist );
            }
            hintElem.innerHTML = result.msg;
        }
        content.appendChild( hintsElement );
    }

    var alertBoxOK = document.createElement("div");
    alertBoxOK.className = "alertBoxOK";
    alertBoxOK.textContent = Autodesk.Viewing.i18n.translate( "OK", { "defaultValue" : "OK" } );

    var instance = { alertBox: alertBox, container: container };
    alertBoxOK.addEventListener("click", function(event) {
        alertBox.style.visibility = "hidden";
        container.removeChild( alertBox );
        Autodesk.Viewing.Private.AlertBox.instances.splice(Autodesk.Viewing.Private.AlertBox.instances.indexOf(instance), 1);
    });
    alertBox.appendChild( alertBoxOK );

    alertBox.style.visibility = "visible";

    Autodesk.Viewing.Private.AlertBox.instances.push(instance);
};

// static
Autodesk.Viewing.Private.AlertBox.displayErrors = function(container, imgClass, errors) {

    var alertBox = document.createElement("div");
    alertBox.className = "alertBox errors";
    container.appendChild( alertBox );

    // Create the image element.
    var errorImageClass = imgClass;
    if (!errorImageClass)
        errorImageClass = "img-item-not-found";

    var alertBoxImg = document.createElement("div");
    alertBoxImg.className = "alertBoxImage " + errorImageClass;
    alertBox.appendChild( alertBoxImg );

    // Create the title & message element.
    var alertBoxMsg = document.createElement("div");
    alertBoxMsg.className = "alertBoxMsg errors";
    alertBox.appendChild( alertBoxMsg );

    for (var i=0; i<errors.length; i++) {

        var errorTitle = errors[i].header;
        if (!errorTitle)
            errorTitle =  Autodesk.Viewing.i18n.translate( "Error", { "defaultValue" : "Error" } );

        var alertBoxTitle = document.createElement("div");
        alertBoxTitle.className = "alertBoxTitle errors";
        alertBoxTitle.textContent = errorTitle;
        alertBoxMsg.appendChild( alertBoxTitle );

        // Add message, there maybe a list of files at the end.
        var alertBoxText = document.createElement("div");
        alertBoxText.className = "alertBoxText errors";

        var msg = errors[i].msg;
        var result = this.extractList(msg);
        if (result.list.length) {
            var listElem = document.createElement("div");
            var unorderedlist = this.generateListElement(result.list);
            listElem.appendChild( unorderedlist );

            alertBoxText.textContent = result.msg;
            alertBoxText.appendChild( listElem );
        } else {
            alertBoxText.textContent = msg;
        }
        alertBoxMsg.appendChild( alertBoxText );

        // Add additional content
        if (errors[i].hints) {
            var hintsElement = document.createElement("ul");
            hintsElement.className = "alertBoxContent";
            var hints = errors[i].hints;
            for (var h=0; h<hints.length; h++) {
                var hint = hints[h];
                if (!hint)
                    continue;

                var hintElem = document.createElement("li");
                hintsElement.appendChild( hintElem );

                var result = this.extractList(hint);
                if (result.list.length) {
                    var unorderedlist = this.generateListElement(result.list);
                    hintsElement.appendChild( unorderedlist );
                }
                hintElem.innerHTML = result.msg;
            }
            alertBoxMsg.appendChild( hintsElement );
        }
    }

    var alertBoxOK = document.createElement("div");
    alertBoxOK.className = "alertBoxOK";
    alertBoxOK.textContent = Autodesk.Viewing.i18n.translate( "OK", { "defaultValue" : "OK" } );

    var instance = { alertBox: alertBox, container: container };
    alertBoxOK.addEventListener("click", function(event) {
        alertBox.style.visibility = "hidden";
        container.removeChild( alertBox );
        Autodesk.Viewing.Private.AlertBox.instances.splice(Autodesk.Viewing.Private.AlertBox.instances.indexOf(instance), 1);
    });
    alertBox.appendChild( alertBoxOK );

    alertBox.style.visibility = "visible";

    Autodesk.Viewing.Private.AlertBox.instances.push(instance);
};

Autodesk.Viewing.Private.AlertBox.extractList = function(msg) {
    var result = {
        "msg" : msg,
        "list" : []
    };

    if (msg && msg.indexOf("<ul>") != -1) {
        var parts = msg.split("<ul>");
        result.msg = parts[0];

        parts = parts[1].split("</ul>");
        result.list = parts[0].split(", ");
        if (result.list.length === 1) {
            // There maybe no spaces. Try just comma.
            result.list = parts[0].split(",");
        }
    }
    return result;
};


Autodesk.Viewing.Private.AlertBox.generateListElement = function(list) {
    var unorderedlist = document.createElement("ul");
    for (var l=0; l<list.length; l++) {
        var listElement = document.createElement("li");
        listElement.textContent = list[l];
        unorderedlist.appendChild( listElement );
    }

    return unorderedlist;
};


// static
Autodesk.Viewing.Private.AlertBox.dismiss = function() {
    // dismiss the topmost alert box
    if (Autodesk.Viewing.Private.AlertBox.instances.length > 0) {
        var instance = Autodesk.Viewing.Private.AlertBox.instances.pop();
        instance.alertBox.style.visibility = "hidden";
        instance.container.removeChild(instance.alertBox);
        return true;
    }
    return false;
};
;AutodeskNamespace('Autodesk.Viewing.Private');

/** @constructor */
Autodesk.Viewing.Private.HudMessage = function () {
};

Autodesk.Viewing.Private.HudMessage.instances = [];

// static
Autodesk.Viewing.Private.HudMessage.displayMessage = function(container, messageSpecs, closeCB, buttonCB, checkboxCB ) {

    // If hud message is already up, return.
    if (Autodesk.Viewing.Private.HudMessage.instances.length > 0)
        return ;

    var msgTitle = messageSpecs.msgTitleKey;
    var msgTitleDefault = messageSpecs.msgTitleDefaultValue ? messageSpecs.msgTitleDefaultValue : msgTitle;
    var message    = messageSpecs.messageKey;
    var messageDefault = messageSpecs.messageDefaultValue ? messageSpecs.messageDefaultValue : message ;
    var buttonText = messageSpecs.buttonText;

    var hudMessage = document.createElement("div");
    hudMessage.className = "hud";
    container.appendChild( hudMessage );

    var title = document.createElement("div");
    title.className = "hudTitle";
    title.textContent = Autodesk.Viewing.i18n.translate( msgTitle, { "defaultValue" : msgTitleDefault } );
    title.setAttribute( "data-i18n", msgTitle );
    hudMessage.appendChild( title );

    if (closeCB) {
        var closeButton = document.createElement("div");
        closeButton.className = "hudClose";
        closeButton.innerHTML = "&times;";
        closeButton.addEventListener('click', function(e) {
            container.removeChild( hudMessage );
            if (closeCB)
                closeCB(e);
        });
        hudMessage.appendChild(closeButton);
    }

    var text = document.createElement("div");
    text.className = "hudMessage";
    text.textContent = Autodesk.Viewing.i18n.translate( message, { "defaultValue" : messageDefault } );
    text.setAttribute( "data-i18n", message );
    hudMessage.appendChild( text );

    if (buttonCB) {
        var button = document.createElement("div");
        button.className = "hudButton";
        button.textContent = Autodesk.Viewing.i18n.translate( buttonText, { "defaultValue" : buttonText } );
        button.setAttribute( "data-i18n", buttonText );
        button.addEventListener( "click", buttonCB );
        hudMessage.appendChild( button );
    }

    if (checkboxCB) {
        var checkbox = document.createElement("div");
        var cb = document.createElement("input");
        cb.className = "hudCheckbox";
        cb.type = "checkbox";
        checkbox.appendChild(cb);

        var checkboxText = "Do not show this message again";

        var lbl = document.createElement("label");
        lbl.setAttribute('for', checkboxText);
        lbl.setAttribute("data-i18n", checkboxText);
        lbl.textContent = Autodesk.Viewing.i18n.translate( checkboxText, { "defaultValue" : checkboxText } );
        checkbox.appendChild(lbl);
        cb.addEventListener( "change", checkboxCB );

        hudMessage.appendChild(checkbox);
    }

    var instance = { hudMessage: hudMessage, container: container };
    Autodesk.Viewing.Private.HudMessage.instances.push(instance);
};

Autodesk.Viewing.Private.HudMessage.dismiss = function() {
    // dismiss the topmost alert box
    if (Autodesk.Viewing.Private.HudMessage.instances.length > 0) {
        var instance = Autodesk.Viewing.Private.HudMessage.instances.pop();
        instance.hudMessage.style.visibility = "hidden";
        instance.container.removeChild(instance.hudMessage);
        return true;
    }
    return false;
};;'use strict';

AutodeskNamespace('Autodesk.Viewing.UI');

/**
 * Tree view control delegate
 * This class allows you to customize the behavior of a Tree view control.
 * Override the methods you want and pass an instance of this class to
 * the Tree constructor.
 * @constructor
 */
Autodesk.Viewing.UI.TreeDelegate = function () {
};

Autodesk.Viewing.UI.TreeDelegate.prototype.constructor = Autodesk.Viewing.UI.TreeDelegate;

/**
 * Override this method to specify whether or not a node is a group node
 * @param {Object} node - Node in the model Document
 * @returns {boolean} true if this node is a group node, false otherwise
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.isTreeNodeGroup = function (node) {
    throw 'isTreeNodeGroup is not implemented.';
};

/**
 * Override this method to specify the id for a node
 * @param {Object} node - Node in the model Document
 * @returns {string} Id of the tree node
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.getTreeNodeId = function (node) {
    throw 'getTreeNodeId is not implemented.';
};

/**
 * Override this method to specify the label for a node
 * @param {Object} node - Node in the model Document
 * @returns {string} Label of the tree node
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.getTreeNodeLabel = function (node) {
    return node.name;
};

/**
 * Override this method to specify if a tree node should be created for this node
 * @param {Object} node - Node in the model Document
 * @returns {boolean} true if a node should be created, false otherwise
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.shouldCreateTreeNode = function (node) {
    return true;
};

/**
 * Override this to create the HTMLContent for this node for appending to the
 * parent.  By default, a label is created.
 *
 * @param {Object} node - Node in the model Document
 * @param {HTMLElement} parent - the parent for this conent.
 * @param {Object=} [options] - An optional dictionary of options.  Current parameters:
 *                              {boolean} [localize] - when true, localization is attempted for the given node; false by default.
 *
 * @private
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.createTreeNode = function (node, parent, options) {
    var label = document.createElement('label');
    parent.appendChild(label);

    var text = this.getTreeNodeLabel(node);
    if (options && options.localize) {
        label.setAttribute('data-i18n', text);
        text = Autodesk.Viewing.i18n.translate(text);
    }
    label.textContent = text;
};

/**
 * Override this method to do something when the user clicks on a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeClick = function (tree, node, event) {};

/**
 * Override this to do something when the user clicks on this tree node's icon.
 * The default behavior is for the icons for group nodes to toggle the collapse/expand
 * state of that group.
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeIconClick = function (tree, node, event) {
    if (tree.delegate().isTreeNodeGroup(node)) {
        var id = tree.delegate().getTreeNodeId(node);
        tree.setCollapsed(id, !tree.isCollapsed(id));
    }
};

/**
 * Override this to do something when the user double-clicks on a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeDoubleClick = function (tree, node, event) {};

/**
 * Override this to do something when the user right-clicks on a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeRightClick = function (tree, node, event) {};

/**
 * Override this to do something when the user enters a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeEnter = function (tree, node, event) {};

/**
 * Override this to do something when the user leaves a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeLeave = function (tree, node, event) {};

/**
 * Override this to do something when the user hovers over a tree node
 * @param {Tree} tree
 * @param {Object} node - Node in the model Document
 * @param {Event} event
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.onTreeNodeHover = function (tree, node, event) {};

/**
 * Override this to specify the type of a node. This way, in css, the designer
 * can specify custom styling per type.
 * @param {Object} node - Node in the model Document
 * @returns {string} Class for the node
 */
Autodesk.Viewing.UI.TreeDelegate.prototype.getTreeNodeClass = function (node) {
    return '';
};

/**
 * Tree view control
 * @constructor
 * @param {TreeDelegate} delegate
 * @param {Object} root - A node in the model Document
 * @param {HTMLElement|string} parentContainer - Or parentContainerId
 * @param {Object} options
 */
Autodesk.Viewing.UI.Tree = function (delegate, root, parentContainer, options) {
    this.myDelegate = delegate;
    this.mySelectedIds = [];
    this.myOptions = options;

    // parentContainer can be HTMLElement or string id of an HTMLElement.
    // Figure out which one we've been passed.
    //
    var parentContainerId;
    if (typeof parentContainer === 'string') {
        parentContainerId = parentContainer;
        parentContainer = document.getElementById(parentContainerId);
    } else {
        parentContainerId = parentContainer.id;
    }

    var className = 'treeview';
    this.myRootContainerId = parentContainerId + '-' + className;

    this.myInternalIds = {};
    this.myInternalIdCounter = 0;
    this.myGroupNodes = []; // <group> HTML elements in the tree

    var rootContainer = this.createHtmlElement_(parentContainer, 'div', this.myRootContainerId, className);
    this.createElement_(root, rootContainer);
};

Autodesk.Viewing.UI.Tree.prototype.constructor = Autodesk.Viewing.UI.Tree;

/**
 * Show/hide the tree control
 * @param {boolean} show - true to show the tree control, false to hide it
 */
Autodesk.Viewing.UI.Tree.prototype.show = function (show) {
    var rootContainer = document.getElementById(this.myRootContainerId);
    if (show) {
        rootContainer.style.display = 'block'; // TODO: want fade in
    } else {
        rootContainer.style.display = 'none';
    }
};

/**
 * Get the root container id
 * @nosideeffects
 * @returns {string}
 */
Autodesk.Viewing.UI.Tree.prototype.getRootContainerId = function () {
    return this.myRootContainerId;
};

/**
 * Get the tree delegate
 * @nosideeffects
 * @returns {TreeDelegate}
 */
Autodesk.Viewing.UI.Tree.prototype.delegate = function () {
    return this.myDelegate;
};

/**
 * Is the given group node in the tree collapsed?
 * @nosideeffects
 * @param {string} groupId - Id of the group node
 * @returns {boolean} true if group node is collapsed, false if expanded
 */
Autodesk.Viewing.UI.Tree.prototype.isCollapsed = function (groupId) {
    return this.hasClass(groupId, 'collapsed');
};

/**
 * Collapse/expand the given group node in the tree
 * @param {string} groupId - Id of the group node
 * @param {boolean} collapsed - true to collapse the group node, false to expand it
 */
Autodesk.Viewing.UI.Tree.prototype.setCollapsed = function (groupId, collapsed) {
    var isCollapsed = this.isCollapsed(groupId);

    if (collapsed) {
        if (!isCollapsed) {
            this.addClass(groupId, 'collapsed');
            this.removeClass(groupId, 'expanded');
            return true;
        }
    } else {
        if (isCollapsed) {
            this.addClass(groupId, 'expanded');
            this.removeClass(groupId, 'collapsed');
            return true;
        }
    }
    return false;
};

/**
 * Collapse/expand all group nodes in the tree
 * @param {boolean} collapsed - true to collapse tree, false to expand it
 */
Autodesk.Viewing.UI.Tree.prototype.setAllCollapsed = function (collapsed) {
    var wantNode, changeNode;

    if (collapsed) {
        wantNode = function (node) {
            return node.classList.contains('expanded');
        };
        changeNode = function (node) {
            node.classList.add('collapsed');
            node.classList.remove('expanded');
        };

    } else {
        wantNode = function (node) {
            return node.classList.contains('collapsed');
        };
        changeNode = function (node) {
            node.classList.add('expanded');
            node.classList.remove('collapsed');
        };
    }

    for (var i = 0; i < this.myGroupNodes.length; ++i) {
        var node = this.myGroupNodes[i];
        if (wantNode(node)) {
            changeNode(node);
        }
    }
};

/**
 * Add the given nodes to the current selection
 * @param {Array.<string>} ids - Ids of the nodes to add to the current selection
 */
Autodesk.Viewing.UI.Tree.prototype.addToSelection = function (ids) {
    var tree = this;

    function addSingle(id) {
        var index = tree.mySelectedIds.indexOf(id);
        if (index === -1) {
            tree.mySelectedIds.push(id);
            return true;
        }
        return false;
    }

    var numIds = ids.length;
    for (var i = 0; i < numIds; ++i) {
        var id = ids[i];
        if (addSingle(id)) {
            this.addClass(id, 'selected');
        }
    }
};

/**
 * Remove the given nodes from the current selection
 * @param {Array.<string>} ids - Ids of the nodes to remove from the current selection
 */
Autodesk.Viewing.UI.Tree.prototype.removeFromSelection = function (ids) {
    var tree = this;

    function removeSingle(id) {
        var index = tree.mySelectedIds.indexOf(id);
        if (index !== -1) {
            tree.mySelectedIds.splice(index, 1);
            return true;
        }
        return false;
    }

    for (var i = ids.length - 1; i >= 0; --i) {
        var id = ids[i];
        if (removeSingle(id)) {
            this.removeClass(id, 'selected');
        }
    }
};

/**
 * Set the current selection
 * @param {Array.<string>} ids - Ids of nodes to make currently selected
 */
Autodesk.Viewing.UI.Tree.prototype.setSelection = function (ids) {
    this.removeFromSelection(this.mySelectedIds);
    this.addToSelection(ids);
    return this.mySelectedIds;
};

/**
 * Clear the current selection
 */
Autodesk.Viewing.UI.Tree.prototype.clearSelection = function () {
    this.removeFromSelection(this.mySelectedIds);
};

/**
 * Is the given node selected?
 * @nosideeffects
 * @param {string} id - Id of node
 * @returns {boolean} - true if node is selected, false otherwise
 */
Autodesk.Viewing.UI.Tree.prototype.isSelected = function (id) {
    return this.hasClass(id, 'selected');
};

/**
 * Add a class to a node
 * @param {string} id - Id of the node
 * @param {string} className
 * @returns {boolean} - true if the class was added, false otherwise
 */
Autodesk.Viewing.UI.Tree.prototype.addClass = function (id, className) {
    var internalId = this.getInternalId_(id, false);
    if (internalId) {
        var elem = document.getElementById(internalId);
        if (elem) {
            var contains = elem.classList.contains(className);
            if (!contains) {
                elem.classList.add(className);
                return true;
            }
        }
    }
    return false;
};

/**
 * Remove a class from a node
 * @param {string} id - Id of the node
 * @param {string} className
 * @returns {boolean} - true if the class was removed, false otherwise
 */
Autodesk.Viewing.UI.Tree.prototype.removeClass = function (id, className) {
    var internalId = this.getInternalId_(id, false);
    if (internalId) {
        var elem = document.getElementById(internalId);
        if (elem) {
            var contains = elem.classList.contains(className);
            if (contains) {
                elem.classList.remove(className);
                return true;
            }
        }
    }
    return false;
};

/**
 * Does the node have the given class?
 * @nosideeffects
 * @param {string} id - Id of the node
 * @param {string} className
 * @returns {boolean} true if the node has the given class, false otherwise
 */
Autodesk.Viewing.UI.Tree.prototype.hasClass = function (id, className) {
    var internalId = this.getInternalId_(id, false);
    if (internalId) {
        var elem = document.getElementById(internalId);
        return elem.classList.contains(className);
    }
    return false;
};

/**
 * Get internal id of a node
 * @private
 * @param {string} id - Id of node
 * @param {boolean} create - true to create a new internal id if none exists
 * @returns {string|undefined} Internal id of the node, undefined if the node does not exist and 'create' is false
 */
Autodesk.Viewing.UI.Tree.prototype.getInternalId_ = function (id, create) {
    if ((this.myInternalIds[id] === undefined) && create) {
        this.myInternalIds[id] = this.myRootContainerId + '-node-' + this.myInternalIdCounter;
        this.myInternalIdCounter++;
    }
    return this.myInternalIds[id];
};

/**
 * Given a node, create the corresponding HTML elements for the node and all of its descendants
 * @private
 * @param {Object} node - Node in the model Document
 * @param {HTMLElement} parentElement
 * @param {Object=} [options] - An optional dictionary of options.  Current parameters:
 *                              {boolean} [localize] - when true, localization is attempted for the given node; false by default.
 */
Autodesk.Viewing.UI.Tree.prototype.createElement_ = function (node, parentElement, options) {
    if (!node) {
        return null;
    }

    if (!this.myDelegate.shouldCreateTreeNode(node)) {
        return null;
    }

    var tree = this;
    var id = tree.myDelegate.getTreeNodeId(node);
    var internalId = this.getInternalId_(id, true);
    var elem;

    function createElementForNode(parentElement, elemId, type, classes) {
        var root = tree.createHtmlElement_(parentElement, type, elemId, classes);

        var header = tree.createHtmlElement_(root, 'header', 'header' + elemId);
        var icon = tree.createHtmlElement_(header, 'icon');

        icon.addEventListener('click', function (e) {
            tree.myDelegate.onTreeNodeIconClick(tree, node, e);
            e.stopPropagation();
            e.preventDefault();
        }, false);

        tree.myDelegate.createTreeNode(node, header, options);

        return root;
    }

    if (tree.myDelegate.isTreeNodeGroup(node)) {
        elem = createElementForNode(parentElement, internalId, 'group', 'expanded');

        // Remember this group node for use by setAllCollapsed().
        //
        tree.myGroupNodes.push(elem);

        var childCount = node.children ? node.children.length : 0;
        for (var childIndex = 0; childIndex < childCount; ++childIndex) {
            var child = node.children[childIndex];
            tree.createElement_(child, elem, options);
        }

    } else {
        elem = createElementForNode(parentElement, internalId, 'leaf', 'expanded');
    }


    elem.addEventListener('click', function (e) {
        tree.myDelegate.onTreeNodeClick(tree, node, e);
        e.stopPropagation();
        e.preventDefault();
    }, false);

    elem.addEventListener('dblclick', function (e) {
        tree.myDelegate.onTreeNodeDoubleClick(tree, node, e);
        e.stopPropagation();
        e.preventDefault();
    }, false);

    elem.addEventListener('contextmenu', function (e) {
        tree.myDelegate.onTreeNodeRightClick(tree, node, e);
        e.stopPropagation();
        e.preventDefault();
    }, false);

    function mouseenter(e) {
        tree.myDelegate.onTreeNodeEnter(tree, node, e);
        tree.myDelegate.onTreeNodeHover(tree, node, e);
        e.stopPropagation();
        e.preventDefault();
    }

    function mouseleave(e) {
        tree.myDelegate.onTreeNodeLeave(tree, node, e);
        tree.myDelegate.onTreeNodeHover(tree, node, e);
        e.stopPropagation();
        e.preventDefault();
    }

    elem.addEventListener('mouseenter', function (e) {
        mouseenter(e);
    }, false);

    elem.addEventListener('mouseleave', function (e) {
        mouseleave(e);
    }, false);

    elem.addEventListener('mouseover', function (e) {
        mouseenter(e);
    }, false);

    elem.addEventListener('mouseout', function (e) {
        mouseleave(e);
    }, false);

    var c = tree.myDelegate.getTreeNodeClass(node);
    if (c) {
        elem.classList.add(c);
    }

    return elem;
};

/**
 * Create an HTML element
 * @private
 * @param {HTMLElement} parent - Parent element of the new HTML element
 * @param {string} tagName - New HTML element tag name
 * @param {string=} [id] - New HTML element id
 * @param {string=} [className] - New HTML element class
 * @returns {HTMLElement} The newly-created HTML element
 */
Autodesk.Viewing.UI.Tree.prototype.createHtmlElement_ = function (parent, tagName, id, className) {
    var elem = document.createElement(tagName);
    parent.appendChild(elem);

    if (id) {
        elem.id = id;
    }
    if (className) {
        elem.className = className;
    }

    return elem;
};

/**
 * Returns the HTML element representing the given node.
 * @param {Object} node
 * @returns {HTMLElement}
 */
Autodesk.Viewing.UI.Tree.prototype.getElementByNode = function(node) {
    return document.getElementById(this.getInternalId_(this.delegate().getTreeNodeId(node), false));
}

// Alias Tree/TreeDelegate from Private namespace into UI namespace.
// This is temporary and should be removed eventually.
//
AutodeskNamespace('Autodesk.Viewing.Private');
Autodesk.Viewing.Private.TreeDelegate = Autodesk.Viewing.UI.TreeDelegate;
Autodesk.Viewing.Private.TreeDelegate.prototype = Autodesk.Viewing.UI.TreeDelegate.prototype;
Autodesk.Viewing.Private.Tree = Autodesk.Viewing.UI.Tree;
Autodesk.Viewing.Private.Tree.prototype = Autodesk.Viewing.UI.Tree.prototype;
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Private');

Autodesk.Viewing.Private.BrowserDelegate = function ()
{
};

Autodesk.Viewing.Private.BrowserDelegate.prototype.constructor = Autodesk.Viewing.Private.BrowserDelegate;

Autodesk.Viewing.Private.BrowserDelegate.prototype.getNodeId = function(node)
{
    throw 'getId is not implemented.'
};

Autodesk.Viewing.Private.BrowserDelegate.prototype.getNodeLabel = function(node)
{
    return node.name;
};

Autodesk.Viewing.Private.BrowserDelegate.prototype.getNodeClass = function(node)
{
    return '';
};

Autodesk.Viewing.Private.BrowserDelegate.prototype.hasThumbnail = function(node)
{
    return false;
};

Autodesk.Viewing.Private.BrowserDelegate.prototype.getThumbnail = function(node)
{
    return null;
};

Autodesk.Viewing.Private.BrowserDelegate.prototype.onNodeClick = function(browser, node, event)
{
};

Autodesk.Viewing.Private.BrowserDelegate.prototype.onNodeHover = function(browser, node, event)
{
};

Autodesk.Viewing.Private.BrowserDelegate.prototype.hasContent = function(node)
{
    return false;
};

Autodesk.Viewing.Private.BrowserDelegate.prototype.addContent = function(node, parentId)
{
};

Autodesk.Viewing.Private.Browser = function ( delegate, items, parentContainerId, options )
{
    this.myDelegate = delegate;
    this.mySelectedIds = [];
    this.myParentContainderId = parentContainerId;

    var prefix = 'browserview';
    this.myRootContainerId = parentContainerId + '-' + prefix;

    this.myInternalIds = [];
    this.myInternalIdCounter = 0;

    this.myOptions = options;
    this.jQuery = (options && options.jQuery) ? options.jQuery : $;

    this.jQuery('<div id="' + this.myRootContainerId +'" class="' + prefix +'"></div>').appendTo( "#"+this.myParentContainderId );

    this.createElements(items, this.myRootContainerId);
};

Autodesk.Viewing.Private.Browser.prototype.constructor = Autodesk.Viewing.Private.Browser;

Autodesk.Viewing.Private.Browser.prototype.show = function(show)
{
    if (show)
		this.jQuery('#'+this.myRootContainerId).fadeIn();
    else
		this.jQuery('#'+this.myRootContainerId).hide();
};

Autodesk.Viewing.Private.Browser.prototype.getRootContainerId = function()
{
    return this.myRootContainerId;
};

Autodesk.Viewing.Private.Browser.prototype.delegate = function()
{
    return this.myDelegate;
};

Autodesk.Viewing.Private.Browser.prototype.addToSelection = function(ids)
{
    var browser = this;
    function addSingle(id)
    {
        var index = browser.mySelectedIds.indexOf(id);
        if(index==-1)
        {
            browser.mySelectedIds.push(id);
            return true;
        }
        return false;
    }

    for(var index in ids)
    {
        var id = ids[index];
        if(addSingle(id))
        {
            var internalId = this.getInternalId(id, false);
            this.jQuery('#' + internalId).addClass('selected');
        }
    }
};

Autodesk.Viewing.Private.Browser.prototype.removeFromSelection = function(ids)
{
    var browser = this;
    function removeSingle(id)
    {
        var index = browser.mySelectedIds.indexOf(id);
        if(index!=-1)
        {
            browser.mySelectedIds.splice(index, 1);
            return true;
        }
        return false;
    }

    for(var index in ids)
    {
        var id = ids[index];
        if(removeSingle(id))
        {
            var internalId = this.getInternalId(id, false);
            this.jQuery('#' + internalId).removeClass('selected');
        }
    }
};

Autodesk.Viewing.Private.Browser.prototype.setSelection = function(ids)
{
    this.removeFromSelection(this.mySelectedIds);
    this.addToSelection(ids);
    return this.mySelectedIds;
};

Autodesk.Viewing.Private.Browser.prototype.clearSelection = function()
{
    this.removeFromSelection(this.mySelectedIds);
};

Autodesk.Viewing.Private.Browser.prototype.getInternalId = function(id, create)
{
    if((this.myInternalIds[id] === undefined) && create)
    {
        this.myInternalIds[id] = this.myRootContainerId + '-node-' + this.myInternalIdCounter;
        this.myInternalIdCounter++;
    }
    return this.myInternalIds[id];
};

Autodesk.Viewing.Private.Browser.prototype.createElements = function(items, containerId)
{
    if (!items)
        return;

    var browser = this;
    for(var nodeIndex = 0; nodeIndex<items.length; nodeIndex++)
    {
        var node = items[nodeIndex];
        browser.createElement( node, containerId );
    }
};

Autodesk.Viewing.Private.Browser.prototype.createElement = function( browserNode, containerId )
{
    var browser = this;

    var id = browser.myDelegate.getNodeId(browserNode);
    var internalId = browser.getInternalId(id, true);
    var elementId = '#' + internalId;

    this.jQuery('<item id="' + internalId + '"></item>').appendTo(this.jQuery('#' + containerId)).hover( function()
    {
        browser.myDelegate.onNodeHover(browser, browserNode);
    });
    this.jQuery('#' + internalId).click( function (e) {
			browser.jQuery(".flipped").removeClass("flipped");
            browser.myDelegate.onNodeClick(browser, browserNode, e);
    });
	
	var card = this.jQuery('<div id="card'+ internalId +'" class="card"></div>');
    card.appendTo(this.jQuery(elementId));
	
    var elemWrapper = this.jQuery('<div class="browserElement"></div>');
    elemWrapper.appendTo(card);

    var label = browser.myDelegate.getNodeLabel(browserNode);
    this.jQuery('<label>' + label + '</label>').appendTo(elemWrapper).click( function(e)
    {
        browser.myDelegate.onNodeClick(browser, browserNode, e);
    });
	
    var thumbnailUrl = browser.myDelegate.getThumbnail(browserNode);
    if (thumbnailUrl)
    {
        this.jQuery('<img class="thumb" src="' + thumbnailUrl + '" ></img>').appendTo(elemWrapper).click( function(e)
        {
            browser.myDelegate.onNodeClick(browser, browserNode, e);
        });
    }

    if (browser.myDelegate.hasContent( browserNode )) {
        browser.myDelegate.addContent( browserNode, internalId );
    }
    this.jQuery(elementId).addClass(browser.myDelegate.getNodeClass(browserNode));
};
;AutodeskNamespace('Autodesk.Viewing.Private');

Autodesk.Viewing.Private.WEBGL_HELP_LINK = null;

Autodesk.Viewing.Private.ErrorInfoData = {
    // UNKNOWN FAILURE
    1:   { 'img'             : "img-reload",                  // "icons/error_reload_in_viewer.png",
           'globalized-msg'  : "Viewer-UnknownFailure",
           'default-msg'     : "<title> Sorry </title>" +
                               "<message>We seem to have some technical difficulties and couldn't complete your request.</message> " +
                                    "<hint>Try loading the item again. </hint>" +
                                    "<hint>Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
    },

    // BAD DATA
    2:   { 'img'             : "img-unsupported",             // "icons/error_unsupported_file_type.png",
           'globalized-msg'  : "Viewer-BadData",
           'default-msg'     : "<title> Sorry </title>" +
                               "<message>The item you are trying to view was not processed completely. </message>" +
                                     "<hint>Try loading the item again.</hint>" +
                                     "<hint>Please upload the file again to see if that fixes the issue.</hint>"
    },

    // NETWORK ERROR
    3:  { 'img'             : "img-reload",                   // "icons/error_reload_in_viewer.png",
          'globalized-msg'  : "Viewer-NetworkError",
          'default-msg'     : "<title> Sorry </title>" +
                              "<message>We seem to have some technical difficulties and couldn't complete your request.</message>" +
                                    "<hint> Try loading the item again.</hint>" +
                                    "<hint> Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
    },

    // NETWORK_ACCESS_DENIED
    4: { 'img'             : "img-unloack",                   // "icons/error_unlock_upload.png",
         'globalized-msg'  : "Viewer-AccessDenied",
         'default-msg'     : "<title> No access </title>" +
                             "<message>Sorry. You dont have the required privileges to access this item.</message>" +
                                    "<hint> Please contact the author</hint>"
    },

    // NETWORK_FILE_NOT_FOUND
    5: { 'img'             : "img-item-not-found",            //"icons/error_item_not_found.png",
         'globalized-msg'  : "Viewer-FileNotFound",
         'default-msg'     : "<title> Sorry </title>" +
                             "<message>We cant display the item you are looking for. It may not have been processed yet. It may have been moved, deleted, or you may be using a corrupt file or unsupported file format.</message>" +
                                "<hint> Try loading the item again.</hint>" +
                                "<hint> Please upload the file again to see if that fixes the issue.</hint>" +
                                '<hint> <a href="http://help.autodesk.com/view/ADSK360/ENU/?guid=GUID-488804D0-B0B0-4413-8741-4F5EE0FACC4A" target="_blank">See a list of supported formats.</a></hint>'
    },

    // NETWORK_SERVER_ERROR
    6: { 'img'             : "img-reload",                    // "icons/error_reload_in_viewer.png",
         'globalized-msg'  : "Viewer-ServerError",
         'default-msg'     : "<title> Sorry </title>" +
                             "<message>We seem to have some technical difficulties and couldn't complete your request.</message>" +
                                    "<hint> Try loading the item again.</hint>" +
                                    "<hint> Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
    },


    // NETWORK_UNHANDLED_RESPONSE_CODE
    7: { 'img'             : "img-reload",                    // "icons/error_reload_in_viewer.png",
         'globalized-msg'  : "Viewer-UnhandledResponseCode",
         'default-msg'     : "<title> Network problem </title>" +
                             "<message>Sorry. We seem to have some technical difficulties and couldn't complete your request.</message>" +
                                "<hint> Try loading the item again.</hint>" +
                                "<hint> Please verify your Internet connection, and refresh the browser to see if that fixes the problem.</hint>"
    },

    // BROWSER_WEBGL_NOT_SUPPORTED
    8: { 'img'             : "img-unsupported",               // "icons/error_unsupported_file_type.png",
         'globalized-msg'  : "Viewer-WebGlNotSupported",
         'default-msg'     : "<title> Sorry </title>" +
                             "<message>We couldnt show the item because your browser doesnt support 3D viewing.</message>" +
                                    "<hint> Please use Google Chrome, Firefox or another browser that supports WebGL 3D graphics.</hint>" +
                                    '<hint> <a href="WEBGL_HELP" target="_blank">See a list of browsers supporting WebGL 3D graphics.</a></hint>'
    },

    // BAD_DATA_NO_VIEWABLE_CONTENT
    9: { 'img'             : "img-item-not-found",            // "icons/error_item_not_found.png",
         'globalized-msg'  : "Viewer-NoViewable",
         'default-msg'     : "<title> No viewable content </title>" +
                             "<message>Theres nothing to display for this item. It may not have been processed or it may not have content we can display.</message>" +
                                    "<hint> Please contact the author.</hint>" +
                                    "<hint> Please upload the file again to see if that fixes the issue.</hint>"
    },

    // BROWSER_WEBGL_DISABLED
    10: { 'img'             : "img-unsupported",              // "icons/error_unsupported_file_type.png",
          'globalized-msg'  : "Viewer-WebGlDisabled",
          'default-msg'     : "<title> Sorry </title>" +
                              "<message>We couldnt show the item because you haven't enabled 3D viewing in your browser.</message>" +
                                    "<hint> Please use Google Chrome, Firefox or enable WebGL 3D graphics in your browser.</hint>" +
                                    '<hint> <a href="WEBGL_HELP" target="_blank">See a list of browsers supporting WebGL 3D graphics.</a></hint>'
    }
};

Autodesk.Viewing.Private.ErrorHandler = function()
{
};

Autodesk.Viewing.Private.ErrorHandler.prototype.constructor = Autodesk.Viewing.Private.ErrorHandler;

Autodesk.Viewing.Private.ErrorHandler.getErrorCode = function( networkStatus )
{
    if ( (networkStatus === 403) || ( networkStatus === 401) )
    {
        return Autodesk.Viewing.ErrorCodes.NETWORK_ACCESS_DENIED;
    }
    else if (networkStatus === 404 )
    {
        return Autodesk.Viewing.ErrorCodes.NETWORK_FILE_NOT_FOUND;
    }
    else if (networkStatus >= 500 )
    {
        return Autodesk.Viewing.ErrorCodes.NETWORK_SERVER_ERROR;
    }
    return Autodesk.Viewing.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE;
};

Autodesk.Viewing.Private.ErrorHandler.reportError = function( container, errorCode, errorMsg, errorType )
{
    // If there is no errorCode, just return (otherwise an empty alert box is being shown)
    if (!errorCode)
        return;

    var errorInfo = Autodesk.Viewing.Private.ErrorInfoData[errorCode];
    if (errorInfo)
    {
        var options = {
            "defaultValue" : ""
        };

        options.defaultValue = errorInfo['default-msg'];
        var imgClass = errorInfo["img"];
        var errorGlobalizedMsg = errorInfo['globalized-msg'];

        var error = this.parseErrorString( errorGlobalizedMsg, options );

        if (errorCode === Autodesk.Viewing.ErrorCodes.BROWSER_WEBGL_DISABLED ||
            errorCode === Autodesk.Viewing.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED)
        {
            var WEBGL_HELP_LINK = Autodesk.Viewing.Private.WEBGL_HELP_LINK || RESOURCE_ROOT + "webGLHelp.html";

            for (var i = 0; i < error.hints.length; i++) {
                var index = error.hints[i].indexOf('href="WEBGL_HELP"');
                if (index !== -1) {
                    error.hints[i] = error.hints[i].replace('href="WEBGL_HELP"', 'href="' + WEBGL_HELP_LINK + '"');
                }
            }
        }

        Autodesk.Viewing.Private.AlertBox.displayError( container, error.msg, error.header, imgClass, error.hints );
    }
    else
    {
        var imgClass = "img-unsupported"; // RESOURCE_ROOT + "icons/error_unsupported_file_type.png";

        var options = {
            "defaultValue"          : "",
            "interpolationPrefix"   : "{",
            "interpolationSuffix"   : "}"
        };

        this.parseArguments( errorMsg, options );
        var error = this.parseErrorString( errorCode, options );

        if (!error.header)
            error.header = (errorType === "warning") ? Autodesk.Viewing.i18n.translate( "header-warning" ) : "";
        Autodesk.Viewing.Private.AlertBox.displayError( container, error.msg, error.header, imgClass, error.hints );
    }
};

Autodesk.Viewing.Private.ErrorHandler.reportErrors = function( container, errors )
{
    if (!errors)
        return;

    var options = {
        "defaultValue"          : "",
        "interpolationPrefix"   : "{",
        "interpolationSuffix"   : "}"
    };

    var formattedErrors = [];
    for (var i=0; i<errors.length; i++) {
        if (!errors[i].code)
            continue;

        this.parseArguments( errors[i].message, options );

        var error = this.parseErrorString( errors[i].code, options );
        if (!error.header)
            error.header = (errors[0].type === "warning") ? Autodesk.Viewing.i18n.translate( "header-warning", {"defaultValue" : "Warning"} ) : "";

        formattedErrors.push( error );
    }

    if (!formattedErrors.length)
        return;

    // Default image.
    var imgClass = "img-unsupported"; // RESOURCE_ROOT + "icons/error_unsupported_file_type.png";

    Autodesk.Viewing.Private.AlertBox.displayErrors( container, imgClass, formattedErrors );
};


Autodesk.Viewing.Private.ErrorHandler.parseArguments = function( errorMsg, options )
{
    if (!errorMsg)
        return;

    // Add arguments
    if (typeof(errorMsg) === "string" ) {
        options.defaultValue = errorMsg;
    }
    else {
        // If there is an array, then there are arguments in the string.
        // Add them to the options (arguments are named: 0, 1, 2, ...
        options.defaultValue = errorMsg[0];
        for (var i=1; i<errorMsg.length; i++) {
            var arg = i-1;
            var argName = arg.toString();
            options[argName] = errorMsg[i];
        }
    }
};

Autodesk.Viewing.Private.ErrorHandler.parseErrorString = function( errorCode, options )
{
    var error = {
        "msg"     : null,
        "msgList" : null,
        "header"  : null,
        "hints"   : null
    };

    if (!errorCode)
        return error;

    // Translate the message.
    var msg = Autodesk.Viewing.i18n.translate( errorCode, options );
    if (!msg)
        return error;

    // Split into header, message and hints. The messages may have the following format
    //   <title>header</title>text of the error message. <hint> hint-1 <hint> hint-2 ... <hint> hint-n
    //
    
    // Get the header
    if (msg.indexOf("<title>") != -1) {
        var parts = msg.split("<title>")[1].split("</title>");
        error.header = parts[0];
        msg = parts[1];
    }

    // Extract the message last.
    if (msg && msg.indexOf("<message>") != -1) {
        var parts = msg.split("<message>")[1].split("</message>");
        error.msg = parts[0];
        msg = parts[1];
    }
    else  {
        error.msg = msg;
    }

    // Extract the hints next.
    if (msg && msg.indexOf("<hint>") != -1) {
        // There are hints.
        error.hints = [];
        var hints = msg.split("<hint>");
        for (var h=0; h<hints.length; h++) {
            var hint = hints[h].split("</hint")[0];
            error.hints.push(hint);
        }
    }

    return error;
};;'use strict';

/**
 * An Extension is a way to configure add functionality to the viewer.  Derive from this
 * class and implement the load and optionally the unload methods.
 *
 * Register this extension by calling:
 * Autodesk.Viewing.theExtensionManager.registerExtension('your_extension_id', Autodesk.Viewing.Extensions.<your_extension_class>);
 *
 * @param {Viewer} viewer - the viewer to be extended.
 * @param {Object} options - An optional dictionary of options for this extension.
 * @constructor
 * @private
 */
Autodesk.Viewing.Extension = function (viewer, options) {
    this.viewer = viewer;
    this.options = options;
};

/**
 * Override the load method to add functionality to the viewer.  Use the Viewer's APIs
 * to add/modify/replace/delete UI, register event listeners, etc.
 *
 * @returns {boolean} - True if the load was successful.
 */
Autodesk.Viewing.Extension.prototype.load = function () {
    return true;
};

/**
 * Override the unload method to perform some cleanup of operations that were done
 * in load.
 *
 * @returns {boolean} - True if the unload was successful.
 */
Autodesk.Viewing.Extension.prototype.unload = function () {
    return true;
};

/**
 * Gets the extension state as a plain object. Intended to be called when viewer state is requested.
 *
 * @param {Object} viewerState - Object to inject extension values.
 *
 * @virtual
 */
Autodesk.Viewing.Extension.prototype.getState = function( viewerState ) {
};

/**
 * Restores the extension state from a given object.
 *
 * @param {Object} viewerState
 * @param {boolean} [immediate] - Whether the new view is applied with (true) or without transition (false)
 *
 * @returns {boolean} true if restore operation was successful.
 *
 * @virtual
 */
Autodesk.Viewing.Extension.prototype.restoreState = function (viewerState, immediate) {
    return true;
};;'use strict';

AutodeskNamespace('Autodesk.Viewing.Private');

/**
 * The ExtensionManager manages a set of extensions available to the viewer.
 * Register, retrieve, and unregister your extension using the singleton theExtensionManager.
 *
 * You can load/unload your registered extension into a Viewer by calling
 * {@link Autodesk.Viewing.Viewer#loadExtension|viewer.loadExtension(id, options)} and
 * {@link Autodesk.Viewing.Viewer#unloadExtension|viewer.unloadExtension(id)}, respectively.
 * @constructor
 */
Autodesk.Viewing.ExtensionManager = function () {
    var extensions = {};

    /**
     * Registers a new extension with the given id.
     *
     * @param {string} extensionId - The string id of the extension.
     * @param {Extension} extension - The Extension-derived class representing the extension.
     * @returns {boolean} - True if the extension was successfully registered.
     */
    function registerExtension(extensionId, extension) {
        if (!extensions.hasOwnProperty(extensionId)) {
            extensions[extensionId] = extension;
            return true;
        }
        return false;
    }

    /**
     * Returns the class representing the extension with the given id.
     *
     * @param {string} extensionId - The string id of the extension.
     * @returns {!Extension} - The Extension-derived class if one was registered; null otherwise.
     */
    function getExtension(extensionId) {
        if (extensions.hasOwnProperty(extensionId)) {
            return extensions[extensionId];
        }
        return null;
    }

    /**
     * Unregisters an existing extension with the given id.
     *
     * @param {string} extensionId - The string id of the extension.
     * @returns {boolean} - True if the extension was successfully unregistered.
     */
    function unregisterExtension(extensionId) {
        if (extensions.hasOwnProperty(extensionId)) {
            delete extensions[extensionId];
            return true;
        }
        return false;
    }

    return {
        registerExtension: registerExtension,
        getExtension: getExtension,
        unregisterExtension: unregisterExtension
    };
};

Autodesk.Viewing.theExtensionManager = new Autodesk.Viewing.ExtensionManager();;AutodeskNamespace('Autodesk.Viewing');

Autodesk.Viewing.UnifiedCamera = function ( clientWidth, clientHeight)
{
    THREE.Camera.call( this );

    this.fov = 45;
    this.near = 0.1;
    this.far = 100000;
    this.aspect = clientWidth / clientHeight;
    
    this.left = -clientWidth / 2;
    this.right = clientWidth / 2;
    this.top = clientHeight / 2;
    this.bottom = -clientHeight / 2;

    this.target  = new THREE.Vector3(0, 0, -1);
    this.worldup = new THREE.Vector3(0, 1, 0);
    
    this.orthographicCamera = new THREE.OrthographicCamera( this.left, this.right, this.top, this.bottom,  this.near, this.far );
    this.perspectiveCamera = new THREE.PerspectiveCamera( this.fov, this.aspect, this.near, this.far);

    this.zoom = 1;
    
    this.toPerspective();
};

//Constant FOV used to make math right for Ortho cameras.
Autodesk.Viewing.UnifiedCamera.ORTHO_FOV = THREE.Math.radToDeg(2 * Math.atan(0.5));

Autodesk.Viewing.UnifiedCamera.prototype = Object.create( THREE.Camera.prototype );

Autodesk.Viewing.UnifiedCamera.prototype.clone = function ()
{
	var camera = new Autodesk.Viewing.UnifiedCamera(this.right * 2.0, this.top * 2.0);

	THREE.Camera.prototype.clone.call( this, camera );

    camera.position.copy(this.position);
    camera.up.copy(this.up);
    if( this.target )
        camera.target = this.target.clone();
    if( this.worldup )
        camera.worldup = this.worldup.clone();

	camera.left = this.left;
	camera.right = this.right;
	camera.top = this.top;
	camera.bottom = this.bottom;
	
	camera.near = this.near;
	camera.far = this.far;
    camera.fov = this.fov;
    camera.aspect = this.aspect;
    camera.zoom = this.zoom;

    camera.isPerspective = this.isPerspective;

    this.updateProjectionMatrix();

	return camera;
};

Autodesk.Viewing.UnifiedCamera.prototype.__computeFovPosition = function(fov)
{
    if( Math.abs(this.fov - fov)  <= 0.0001 )
        return this.position.clone();

    var eye = this.target.clone().sub( this.position );

    var oldFOV = THREE.Math.degToRad(this.fov);
    var newFOV = THREE.Math.degToRad(fov);

    var distance = eye.length() * Math.tan(oldFOV * 0.5) / Math.tan(newFOV * 0.5);
    var offset = eye.normalize().multiplyScalar( -distance );

    return this.target.clone().add(offset);
};

Autodesk.Viewing.UnifiedCamera.prototype.toPerspective = function()
{
    // Switches to the Perspective Camera

    if( !this.isPerspective && this.saveFov ) {
        this.position.copy(this.__computeFovPosition(this.saveFov));
        this.fov = this.saveFov;
    }

    this.perspectiveCamera.aspect = this.aspect;
    this.perspectiveCamera.near = this.near;
    this.perspectiveCamera.far = this.far;

    this.perspectiveCamera.fov = this.fov / this.zoom ;
    this.perspectiveCamera.updateProjectionMatrix();

    this.projectionMatrix = this.perspectiveCamera.projectionMatrix;

    this.isPerspective = true;
};

Autodesk.Viewing.UnifiedCamera.prototype.toOrthographic = function()
{
    if( this.isPerspective ) {
        this.saveFov = this.fov;
        var newFov = Autodesk.Viewing.UnifiedCamera.ORTHO_FOV;
        this.position.copy(this.__computeFovPosition(newFov));
        this.fov = newFov;
    }

    this.orthoScale = this.target.clone().sub(this.position).length();

    var halfHeight = this.orthoScale * 0.5;
    var halfWidth = halfHeight * this.aspect;

    this.left   = this.orthographicCamera.left   = -halfWidth;
    this.right  = this.orthographicCamera.right  =  halfWidth;
    this.top    = this.orthographicCamera.top    =  halfHeight;
    this.bottom = this.orthographicCamera.bottom = -halfHeight;

    this.orthographicCamera.near = this.near;
    this.orthographicCamera.far = this.far;
    this.orthographicCamera.updateProjectionMatrix();

    this.projectionMatrix = this.orthographicCamera.projectionMatrix;

    this.isPerspective = false;
};

Autodesk.Viewing.UnifiedCamera.prototype.updateProjectionMatrix = function()
{
    if ( this.isPerspective ) {
        this.toPerspective();
    } else {
        this.toOrthographic();
    }
};

Autodesk.Viewing.UnifiedCamera.prototype.setSize = function( width, height )
{
    this.aspect = width / height;
    this.left = -width / 2;
    this.right = width / 2;
    this.top = height / 2;
    this.bottom = -height / 2;

};


Autodesk.Viewing.UnifiedCamera.prototype.setFov = function( fov )
{
    this.fov = fov;
    this.updateProjectionMatrix();
};

/*
* Uses Focal Length (in mm) to estimate and set FOV
* 35mm (fullframe) camera is used if frame size is not specified;
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
*/
Autodesk.Viewing.UnifiedCamera.prototype.setLens = function ( focalLength, frameHeight )
{
    if ( frameHeight === undefined ) frameHeight = 24;

    var fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );

    this.setFov( fov );

    return fov;
};


Autodesk.Viewing.UnifiedCamera.prototype.getCameraChangedEvent = function() {
    return {type: Autodesk.Viewing.CAMERA_CHANGE_EVENT, camera: this};
};
;/** @license Copyright (c) 2014 Autodesk Inc. */
/** Version : @buildnum@ */

/**
 * This is the Tessera document API for design content.
 * @ignore
 */
AutodeskNamespace('Autodesk.Viewing.UI');

/**
 * @class
 * This is the core class that represents the horizontal toolbar. It consists of horizontal subtoolbars that
 * group the tools with similar functionality. Usage:
 *
 *  @example
 *  // Create a Toolbar
 *  var toolbar = new Autodesk.Viewing.UI.Toolbar( parentContainer );
 *
 *  // Create a subtoolbar
 *  var subToolbar = toolbar.addSubToolbar( "Sub1" );
 *
 *  // Add some buttons to it.
 *  var button1 = Autodesk.Viewing.UI.Toolbar.createMenuButton( "B1", "ToolTip for B1", function(e) {
 *                          console.log( "Clicked on B1" ):
 *                          });
 *
 *  // Add button1 to the subtoolbar
 *  toolbar.addToSubToolbar( "Sub1", button1 );
 *
 *  @param {HTMLElement} parentContainer - The container for this toolbar.
 *  @constructor
 */
Autodesk.Viewing.UI.Toolbar = function( parentContainer )
{
    this.parentContainer = parentContainer;

    // Create menu container
    this.container = document.createElement("div");
    this.container.className = 'toolbar-menuplacer';

    this.menu = document.createElement("ul");
    this.menu.className = 'toolbar-menu';
    this.menu.classList.add(('ontouchstart' in window) ? "touch" : "notouch");

    this.container.appendChild(this.menu);
    this.parentContainer.appendChild(this.container);

    this.subToolbars = {};
};

Autodesk.Viewing.UI.Toolbar.prototype.constructor = Autodesk.Viewing.UI.Toolbar;

Autodesk.Viewing.UI.Toolbar.toolButtons = {};

/**
 * Static method to create a menu button.
 *
 * @param {string} id  - the id of the new button.
 * @param {string} tooltip - a tooltip string (key) for the button.
 * @param {function} onclick - an on click handler.
 * @param {Object} [options] - additional options.
 * @param {string} [options.defaultTooltipValue] - default string value for tooltip if different from the key.
 * @param {function} [options.onToolStateChangedCB] - method which is called when the tool changes state.
 *
 * @returns {HTMLElement} - the created button.
 * 
 * @example <caption>From viewer3D.js</caption>
 * this.cameraMenu.fittoviewbutton = Autodesk.Viewing.UI.Toolbar.createMenuButton("toolbar-fitToViewTool", "Fit to view (F)", function(e) {
    viewer.impl.controls.fitToView();
  });
 */
Autodesk.Viewing.UI.Toolbar.createMenuButton = function(id, tooltip, onclick, options)
{
    var buttonGroup = document.createElement("li");
    buttonGroup.className = "toolbar-generic-button";
    buttonGroup.id = id;

    var tooltipElem = null;
    if (tooltip) {
        var defaultTooltipText = tooltip;
        if (options && options.defaultTooltipValue)
            defaultTooltipText = options.defaultTooltipValue;

        tooltipElem = document.createElement("div");
        tooltipElem.className = "toolbar-tooltip";
        tooltipElem.setAttribute("data-i18n", tooltip);
        tooltipElem.setAttribute("tooltipText", tooltip);
        tooltipElem.textContent = Autodesk.Viewing.i18n.translate(tooltip, { defaultValue: defaultTooltipText });

        buttonGroup.appendChild( tooltipElem );
    }

    var button = document.createElement("div");
    button.className = "toolbar-button";
    button.id = Autodesk.Viewing.UI.SubToolbar.getInternalButtonId( id );
    buttonGroup.appendChild( button );

    var isTouch = ('ontouchstart' in window);
    var onClickEvent = isTouch ? "touchstart" : "click";

    function onClickCB(e) {
        if (Autodesk.Viewing.UI.SubToolbar.isDisabled( button ))
            return;

        if (onclick) {
            onclick(e);
        }

        if (isTouch) {
            // If any submenu is visible, hide it.
            for (var key in Autodesk.Viewing.UI.Toolbar.toolButtons) {
                var bGrp = Autodesk.Viewing.UI.Toolbar.toolButtons[key];
                if (bGrp.id === buttonGroup.id || !bGrp.hasSubmenu)
                    continue;

                var isVisible = bGrp.classList.contains("toolbar-submenu-visible");
                if (isVisible)
                    bGrp.classList.remove("toolbar-submenu-visible");
            }

            // If this is a touch device, and there is a submenu,
            // on click toggle showing of the submenu.
            if (buttonGroup.hasSubmenu) {
                var isVisible = buttonGroup.classList.contains("toolbar-submenu-visible");
                if (isVisible)
                    buttonGroup.classList.remove("toolbar-submenu-visible");
                else
                    buttonGroup.classList.add("toolbar-submenu-visible");
            }

            // Instead of using stopPropagation, mark the event appriopriately
            // so other elements higher up can still get.
            // See: http://css-tricks.com/dangers-stopping-event-propagation/
            //
            if (!e.hanled)
                e.handled = []
            e.handled.push("toolbar-menu");
        }
    };
    button.addEventListener(onClickEvent, onClickCB);

    button.onToolStateChangedCB = null;
    if (options && options.onToolStateChangedCB)
        button.onToolStateChangedCB = options.onToolStateChangedCB;

    // Add rollover only if this is not a touch device.
    if ( !isTouch && tooltipElem ) {
        // Make the tooltip appear/disappear when we hover over the button.
        buttonGroup.addEventListener("mouseover", function(e) {
           if (e.target === buttonGroup || e.target === button)
                tooltipElem.style.visibility = "visible";
        });

        buttonGroup.addEventListener("mouseout", function(e) {
           if (e.target === buttonGroup || e.target === button )
                tooltipElem.style.visibility = "hidden";
        });
    }

    // Keep track of all the created tool buttons.
    Autodesk.Viewing.UI.Toolbar.toolButtons[id] = buttonGroup;
    return buttonGroup;
};

/**
 * Static method that returns the tool button with a given id.
 *
 * @param {string} id - id of the tool button to return.
 * @returns {HTMLElement} - the tool button or undefined if it does not exists.
 */
Autodesk.Viewing.UI.Toolbar.getToolButton = function(id)
{
    return Autodesk.Viewing.UI.Toolbar.toolButtons[id];
};

/**
 * Clean up the toolbar.
 */
Autodesk.Viewing.UI.Toolbar.destroy = function()
{
    Autodesk.Viewing.UI.Toolbar.toolButtons = {};
};

/**
* Creates a new subtoolbar, adds to the end of the tool bar, and returns it.
*
* @param {string} id - the id of the subtoolbar.
* @param {boolean} isRadio - specify as true if the tools in this subtoolbar are radio buttons.
* @returns {SubToolbar} - the subtoolbar with a given id.
*/
Autodesk.Viewing.UI.Toolbar.prototype.addSubToolbar = function( id, isRadio )
{
    var subToolbar = new Autodesk.Viewing.UI.SubToolbar( this.menu, id, isRadio );

    this.subToolbars[id] = subToolbar;

    return subToolbar;
};

/**
 * Returns the list of all subtoolbars in this menu bar.
 *
 * @returns {Object.<SubToolbar>} - returns a dictionary: id->subtoolbar.
 */
Autodesk.Viewing.UI.Toolbar.prototype.getSubToolbars = function()
{
    return this.subToolbars;
};

/**
 * Returns a subtoolbar with a given id.
 *
 * @param {string} id - the subtoolbar id to return.
 * @returns {SubToolbar} - the subtoolbar with a given id.
 */
Autodesk.Viewing.UI.Toolbar.prototype.getSubToolbarById = function(id)
{
    return this.subToolbars[id];
};


/**
 * Removes a given subtoolbar from this menu bar.
 *
 * @param {string|Object} subtoolbar - the id or object instance of the subtoolbar to remove.
 */
Autodesk.Viewing.UI.Toolbar.prototype.removeSubToolbar = function( subtoolbar )
{
    if (typeof subtoolbar === "string") {
        var child = this.subToolbars[subtoolbar];
        if (child) {
            this.menu.removeChild(child.subtoolbar);
            delete this.subToolbars[subtoolbar];
        }
    } else if (subtoolbar) {
        this.menu.removeChild(subtoolbar.subtoolbar);
        if (subtoolbar.id)
            delete this.subToolbars[subtoolbar.id];
    }
};

/**
 * Removes all subtoolbars from this menu bar.
 */
Autodesk.Viewing.UI.Toolbar.prototype.removeAllSubToolbars = function( )
{
    while (this.menu.firstChild) {
        this.menu.removeChild(this.menu.firstChild);
    }
    this.subToolbars = {};
};


/**
 * Adds an item to a given subtoolbar.
 *
 * @param {string} id - the subtoolbar id
 * @param {HTMLElement} item - the item to add to a subtoolbar.
 */
Autodesk.Viewing.UI.Toolbar.prototype.addToSubToolbar = function( id, item )
{
    if (this.subToolbars[id])
        this.subToolbars[id].addTool(item);
};

/**
 * Remove an item from a given subtoolbar.
 *
 * @param {string} id - the id of the subtoolbar to remove the item from.
 * @param {HTMLElement} item - the item to remove from the given subtoolbar.
 */
Autodesk.Viewing.UI.Toolbar.prototype.removeFromSubToolbar = function( id, item )
{
    if (this.subToolbars[id])
        this.subToolbars[id].removeTool(item);
};


/**
 * Attach a submenu to a given button or item.
 *
 * @param {HTMLElement} parent - the parent (button) to which to attach the submenu.
 * @param {HTMLElement} submenu - the submenu to attach to the parent.
 */
Autodesk.Viewing.UI.Toolbar.prototype.attachSubMenu = function( parent, submenu )
{
    parent.appendChild(submenu);
    parent.hasSubmenu = true;

    // If this is a touch device, add on click behaviour to the submenu,
    // so that we can hide the submenu once the choice has been made.
    var isTouch = ('ontouchstart' in window);
    if (isTouch) {
        document.addEventListener("touchstart", function(e) {
            // If the event was already handled by some other
            // toolbar button, then do nothing.
            if (e.handled && e.handled.indexOf("toolbar-menu") !== -1)
                return;

            var isVisible = parent.classList.contains("toolbar-submenu-visible");
            if (isVisible)
                parent.classList.remove("toolbar-submenu-visible");
        });
    }
};


/**
 * Collapse or uncollapse the toolbar.
 *
 * @param {boolean} collapse - if true, the menu is collapsed, otherwise, it is uncollapsed.
 */
Autodesk.Viewing.UI.Toolbar.prototype.collapse = function( collapse )
{
    this.container.classList.toggle("toolbar-menu-collapsed", collapse);
};

/**
 *
 * @returns {boolean} - true if the container is collapsed, false otherwise.
 * @nosideeffects
 *
 */
Autodesk.Viewing.UI.Toolbar.prototype.isCollapsed = function()
{
    return this.container.classList.contains("toolbar-menu-collapsed");
};


/**
 * Adds an event listener to the main DOM element for the toolbar.
 *
 * @param {string} eventName - the name of the event that fires the action.
 * @param {function} action - the function that is executed when the event happens.
 */
Autodesk.Viewing.UI.Toolbar.prototype.addEventListener = function( eventName, action )
{
    this.menu.addEventListener( eventName, action );
};


/**
 * Removes an event listener for a passed event and method.
 *
 * @param {string} eventName - the event name for which to remove the listener.
 * @param {function} action - the listener (function) to remove.
 */
Autodesk.Viewing.UI.Toolbar.prototype.removeEventListener = function( eventName, action )
{
    this.menu.removeEventListener( eventName, action );
};


// =====================================================================================
// =====================================================================================

/**
 *  SubToolbar class
 *  @constructor
 *
 *  @param {HTMLElement} parentContainer - the container to attach this subtoolbar to.
 *  @param {string} id - the id of the new subtoolbar.
 *  @param {boolean} isRadio - true if the tools in this subtoolbar are radio buttons.
 **/
Autodesk.Viewing.UI.SubToolbar = function( parentContainer, id, isRadio )
{
    this.parentContainer = parentContainer;

    this.subtoolbar = document.createElement("div");
    this.subtoolbar.className = 'toolbar-subtoolbar';
    this.id = this.subtoolbar.id = id;

    this.parentContainer.appendChild(this.subtoolbar);

    this.buttons  = {};
    this.isRadio  = isRadio;
};

Autodesk.Viewing.UI.SubToolbar.prototype.constructor = Autodesk.Viewing.SubToolbar;

/**
 * Inactive state
 * @type {number}
 */
Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE   = 0;
/**
 * Active state
 * @type {number}
 */
Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE      = 1;
/**
 * Disabled state
 * @type {number}
 */
Autodesk.Viewing.UI.SubToolbar.STATE_DISABLED    = -1;

/**
 *
 * @param id  - id of the button group (the group always has a tooltip and the button and optionally, attached submenu)
 * @returns {string} - id of the button element inside the group.
 */
Autodesk.Viewing.UI.SubToolbar.getInternalButtonId = function(id)
{
    return id + "Button";
};


/**
 * Adds a tool to this subtoolbar.
 *
 * @param {HTMLElement} button - a tool button to be added.
 */
Autodesk.Viewing.UI.SubToolbar.prototype.addTool = function( button )
{
    this.buttons[button.id] = button;
    this.subtoolbar.appendChild( button );

    Autodesk.Viewing.UI.SubToolbar.setToolState( button.id, Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE );
};


/**
 * Inserts a tool to this subtoolbar before the given tool.
 *
 * @param {HTMLElement} newButton - a tool button to be added.
 * @param {HTMLElement} existingButton - existing button before which to insert the new button.
 */
Autodesk.Viewing.UI.SubToolbar.prototype.insertToolBefore = function( newButton, existingButton )
{
    this.buttons[newButton.id] = newButton;
    this.subtoolbar.insertBefore( newButton, existingButton );

    Autodesk.Viewing.UI.SubToolbar.setToolState( newButton.id, Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE );
};

/**
 * Sets the state of the tool.
 *
 * @param {string|Object} button - the id or object of the tool to change the state of.
 * @param {int} state - The state of the tool. One of
 * - {@link Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE}
 * - {@link Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE}
 * - {@link Autodesk.Viewing.UI.SubToolbar.STATE_DISABLED}
 */
Autodesk.Viewing.UI.SubToolbar.setToolState = function( button, state )
{
    if (typeof button === "string") {
        var buttonId = Autodesk.Viewing.UI.SubToolbar.getInternalButtonId( button );
        button = document.getElementById( buttonId );
    }

    if (!button)
        return;

    switch (state) {
        case Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE:
            button.classList.remove("active-button");
            button.classList.remove("disabled-button");
            break;
        case Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE:
            button.classList.remove("disabled-button");
            button.classList.add("active-button");
            break;
        case Autodesk.Viewing.UI.SubToolbar.STATE_DISABLED:
            button.classList.remove("active-button");
            button.classList.add("disabled-button");
            break;
    }

    if (button.onToolStateChangedCB)
        button.onToolStateChangedCB();
};

/**
 * Returns the state of the given tool.
 * One of
 * - {@link Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE}
 * - {@link Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE}
 * - {@link Autodesk.Viewing.UI.SubToolbar.STATE_DISABLED}
 *
 * @param {string|Object} button - id or object of the tool to get the state of.
 * @returns {int} - the state of the given tool.
 */
Autodesk.Viewing.UI.SubToolbar.getToolState = function( button )
{
    if (typeof button === "string") {
        var buttonId = Autodesk.Viewing.UI.SubToolbar.getInternalButtonId( button );
        button = document.getElementById( buttonId );
    }

    if (!button)
        return Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE;

    if (button.classList.contains("active-button")) {
        return Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE;
    }
    else if (button.classList.contains("disabled-button")) {
        return Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE;
    }

    return Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE;
};

/**
 * Inserts a tool at index.
 *
 * @param {HTMLElement} newButton - button to insert.
 * @param {HTMLElement} index - index where to insert.
 */
Autodesk.Viewing.UI.SubToolbar.prototype.insertToolAtIndex = function( newButton, index )
{
    this.buttons[newButton.id] = newButton;

    if (index<this.getToolCount()) {
        var existingButton = this.subtoolbar.children[index];
        this.subtoolbar.insertBefore( newButton, existingButton );
    }
    else {
        this.subtoolbar.appendChild( newButton );
    }
    Autodesk.Viewing.UI.SubToolbar.setToolState( newButton.id, Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE );
};


/**
 * Adds an image to the tool button.
 *
 * @param {string} id - the id of the tool.
 * @param {string} imgUrl - tool icon image: 24x24 to set be on the tool.
 */
Autodesk.Viewing.UI.SubToolbar.prototype.setToolImage = function( id, imgUrl )
{
    var buttonElementId = id + "Button";
    var buttonElement   = document.getElementById( buttonElementId );
    if (buttonElement)
        buttonElement.style.backgroundImage = "url('" + imgUrl + "')";
};


/**
 * Adds an image to the tool button.
 *
 * @param {string} id - the id of the tool.
 * @param {string} color - background color as hex string i.e. "#8B008B" for magenta
 */
Autodesk.Viewing.UI.SubToolbar.prototype.setToolBackgroundColor = function( id, color )
{
    var button   = this.buttons[id]
    if (button)
        button.style.backgroundColor = color;
};


/**
 * Adds text to the tool button.
 *
 * @param {string} id - the id of the tool.
 * @param {string} text - text to be displayed on the tool button.
*/
Autodesk.Viewing.UI.SubToolbar.prototype.setToolText = function( id, text )
{
    var buttonElementId = id + "Button";
    var buttonElement   = document.getElementById( buttonElementId );
    if (buttonElement) {
        var btnText = document.createElement('span');
        btnText.textContent = Autodesk.Viewing.i18n.translate(text);
        btnText.style.fontSize = "12px";
        btnText.style.color = "black";
        btnText.style.zIndex = "10";
        btnText.setAttribute("data-i18n", text);
        buttonElement.appendChild(btnText);
    }
};

/**
 * Removes the tool button from the subtoolbar.
 *
 * @param {string|Object} button - the id or object instance of the button to be removed.
 */
Autodesk.Viewing.UI.SubToolbar.prototype.removeTool = function( button )
{
    if (typeof button === "string") {
        var obj = this.buttons[button];
        if (obj) {
            this.subtoolbar.removeChild( obj );
            delete this.buttons[button];
        }
    }
    else if (button) {
        this.subtoolbar.removeChild( button );
        if (button.id) {
            delete this.buttons[button.id];
        }
    }
};


/**
 * Returns a tool button with a given id.
 *
 * @param {string} id - the id of the button to be returned.
 * @returns {HTMLElement} - a tool with a given id.
 */
Autodesk.Viewing.UI.SubToolbar.prototype.getTool = function( id )
{
    return this.buttons[id];
};


/**
 * Returns list of ids of all tools in order that they are positioned.
 *
 * @returns {list} - id list of all tools.
 */
Autodesk.Viewing.UI.SubToolbar.prototype.getAllToolIds = function()
{
    var ids = [];
    var childCount = this.subtoolbar.children ? this.subtoolbar.children.length : 0;
    for (var i=0; i<childCount; i++) {
        var child = this.subtoolbar.children[i];
        ids.push(child.id);
    }
    return ids;
};


/**
 * Returns the number of items/tools in this subtoolbar.
 *
 * @returns {number} - the tool count.
 * @nosideeffects
 */
Autodesk.Viewing.UI.SubToolbar.prototype.getToolCount = function()
{
    if (this.subtoolbar.children)
        return this.subtoolbar.children.length;
    return 0;
};

/**
 * Activate a given tool.
 *
 * @param {string} id - the id of the tool to be selected.
 */
Autodesk.Viewing.UI.SubToolbar.prototype.select = function( id )
{
    // If button is disabled, do not allow selection.
    if (Autodesk.Viewing.UI.SubToolbar.getToolState(id) === Autodesk.Viewing.UI.SubToolbar.STATE_DISABLED)
        return;

    // If this is radio, deselect all, and then select the one.
    if (this.isRadio)
        this.deselectAll();

    // Select this one.
    Autodesk.Viewing.UI.SubToolbar.setToolState(id, Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE);
};

/**
 * Deselects the button (greys it out) with a given id.
 *
 * @param {string} id - the id of the tool to be deselected.
 */
Autodesk.Viewing.UI.SubToolbar.prototype.deselect = function( id )
{
    if ( id in this.buttons ) {
        Autodesk.Viewing.UI.SubToolbar.setToolState( id, Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE);
    }
};

/**
 * Deselects all buttons in this subtoolbar (greys them out).
 */
Autodesk.Viewing.UI.SubToolbar.prototype.deselectAll = function()
{
    for (var id in this.buttons) {
        if (this.buttons.hasOwnProperty( id ))
            this.deselect( id );
    }
};

/**
 * Returns true if the tool is active
 *
 * @param {DOM} - DOM element that the state is being queried.
 * @returns {bool} - true is active, false otherwise
 */
Autodesk.Viewing.UI.SubToolbar.isActive = function( button ) {
    return button.classList.contains("active-button");
};


/**
 * Returns true if the tool is disabled.
 *
 * @param {DOM} - DOM element that the state is being queried.
 * @returns {bool} - true is disabled, false otherwise
 */
Autodesk.Viewing.UI.SubToolbar.isDisabled = function( button ) {
    return button.classList.contains("disabled-button");
};


/**
 * Changes the visibility of the given tool.
 *
 * @param {string} id - the id of the tool to change the visibility of.
 * @param {boolean} visible - if true, the tool is visible, otherwise, it is hidden.
 */
Autodesk.Viewing.UI.SubToolbar.prototype.setToolVisibility = function( id, visible )
{
    if (id in this.buttons)
        if (visible)
            this.buttons[id].style.display = "list-item";
        else
            this.buttons[id].style.display = "none";
};

/**
 * Returns the visibility state of a given tool.
 *
 * @param {string} id - the id of the tool.
 * @returns {boolean} - true if the button is visible.
 * @nosideeffects
 */
Autodesk.Viewing.UI.SubToolbar.prototype.isToolVisible = function( id )
{
    if (id in this.buttons)
        return !(this.buttons[id].style.display && this.buttons[id].style.display === "none");
    return false;
};

/**
 * Changes visibility of the whole subtoolbar.
 *
 * @param {boolean} visible - if false, the subtoolbar is not visible.
 */
Autodesk.Viewing.UI.SubToolbar.prototype.setVisibility = function( visible )
{
    if (visible)
        this.subtoolbar.style.display = "";
    else
        this.subtoolbar.style.display = "none";
};

/**
 * Returns the visibility state of this subtoolbar.
 *
 * @returns {boolean} - returns true if this subtoolbar is visible, false otherwise.
 * @nosideeffects
 */
Autodesk.Viewing.UI.SubToolbar.prototype.isVisible = function()
{
    return  !(this.subtoolbar.style.display && this.subtoolbar.style.display === "none");
};

// Alias for case change requested by users for consistency: ToolBar -> Toolbar.
//
Autodesk.Viewing.UI.ToolBar = Autodesk.Viewing.UI.Toolbar;
Autodesk.Viewing.UI.ToolBar.prototype = Autodesk.Viewing.UI.Toolbar.prototype;
;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

/**
 * This is the Tessera canvas API for 3D design content.
 * @ignore
 */
AutodeskNamespace('Autodesk.Viewing');

/**
 * Autodesk.Viewing
 * @namespace "Autodesk.Viewing"
 */

// Event types supported by this class.
Autodesk.Viewing.GEOMETRY_LOADED_EVENT       = 'geometry_loaded';
Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT    = 'frag->node array created';

Autodesk.Viewing.SELECTION_CHANGED_EVENT     = 'selection';
Autodesk.Viewing.ISOLATE_EVENT               = 'isolate';
Autodesk.Viewing.HIDE_EVENT                  = 'hide';
Autodesk.Viewing.SHOW_EVENT                  = 'show';
Autodesk.Viewing.HIGHLIGHT_EVENT             = 'highlight';

Autodesk.Viewing.CAMERA_CHANGE_EVENT         = 'cameraChanged';
Autodesk.Viewing.EXPLODE_CHANGE_EVENT        = 'explodeChanged';
Autodesk.Viewing.TOOL_CHANGE_EVENT           = 'toolChanged';
Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT = 'renderOptionChanged';
Autodesk.Viewing.LAYER_VISIBILITY_CHANGED_EVENT  = 'layerVisibility';


/**
 * Navigation Mode constants.
 *
 * These constants are used to define the Navigation MODE.
 *
 * @enum {number}
 * @readonly
 * @deprecated
 */
Autodesk.Viewing.NAVIGATION_MODE = {
        ORBIT:  0,
        PAN:    1,
        DOLLY:  2,
        ROLL:   3,
        FOV:    4,
        TOUCH_PAN_DOLLY: 5,
        TOUCH_ROLL:      6,
        OTHER:           7
};


/**
 * Viewer tools sets
 *
 * These constants are used to define the standard set of tools
 *
 * @enum {string}
 * @readonly
 * @memberof "Autodesk.Viewing"
 */
Autodesk.Viewing.TOOLBAR = {
    NAVTOOLSID:     "navTools",
    MODELTOOLSID:   "modelTools"
};

/**
 *  This is the core viewing class for all 3D models. It contains everything that is needed
 *  to connect to the Autodesk viewing service and display 3D models.
 *
 *  @constructor
 *  @param {HTMLElement} container - The viewer container.
 *  @param {object} config - The initial settings object.
 *  @param {boolean} [config.startOnInitialize=true] - Set this to false if you want to defer the run to a later time
 *                                                     by calling run() explicitly.
 *
 *  @property {Autodesk.Viewing.Navigation} navigation - The Navigation api object.
 *  @property {Autodesk.Viewing.ToolController} toolController - The ToolController object.
 *  @property {Autodesk.Viewing.ViewingUtilities} utilities - The ViewingUtilities object.
 */
Autodesk.Viewing.Viewer3D = function(container, config)
{
    Autodesk.Viewing.Viewer.call(this, container, config);

    // Create the canvas if it doesn't already exist
    if ( this.container.nodeName === "CANVAS") {
        throw 'Viewer must be initialized on a div [temporary]';
    }
    else
    {
        this.canvas = document.createElement("canvas");
        this.canvas.tabIndex = 0;
        var dimensions = this.getDimensions();
        this.canvas.width = dimensions.width;
        this.canvas.height = dimensions.height;
        this.container.appendChild(this.canvas);
    }

    this.canvas.viewer = this; //store a pointer to the viewer in the canvas
    this.modelstructure = null;
    this.layersPanel = null;
    this.toolbar = null;
    this.running = false;
    this._pushedTool = '';
    this._defaultNavigationTool = '';

    // Preferences. Prefix is a bit odd, but a legacy result after refactoring.
    //
    this.prefs = new Autodesk.Viewing.Private.Preferences(this, 'Autodesk.Viewing.Private.GuiViewer3D.SavedSettings.');
};

Autodesk.Viewing.Viewer3D.prototype = Object.create(Autodesk.Viewing.Viewer.prototype);
Autodesk.Viewing.Viewer3D.prototype.constructor = Autodesk.Viewing.Viewer3D;

Autodesk.Viewing.Viewer3D.kDefaultCanvasConfig = {
    "click": {
        "onObject": ["selectOnly"],
        "offObject": ["deselectAll"]
    },
    "clickAlt": {
        "onObject": ["setCOI"],
        "offObject": ["setCOI"]
    },
    "clickCtrl": {
        "onObject": ["selectToggle"],
        "offObject": ["deselectAll"]
    },
    "clickShift": {
        "onObject": ["selectToggle"],
        "offObject": ["deselectAll"]
    }
};

/**
 * Create any DOM and canvas elements, and 
 * setup WebGL.
 *
 * @return {Number} - 0 if initialization was successful, Autodesk.Viewing.ErrorCode otherwise.
 */
Autodesk.Viewing.Viewer3D.prototype.initialize = function()
{
    var self = this;

    var webGL = this.detectWebGL();
    if (webGL <= 0) {  // WebGL error.
        return webGL === -1 ? Autodesk.Viewing.ErrorCodes.BROWSER_WEBGL_NOT_SUPPORTED : Autodesk.Viewing.ErrorCodes.BROWSER_WEBGL_DISABLED;
    }

    Autodesk.Viewing.Viewer.prototype.initialize.call(this);

    function registerUniversalHotkeys()
    {
        var onPress;
        var onRelease;
        var keys = Autodesk.Viewing.theHotkeyManager.KEYCODES;

        // Add Fit to view hotkey
        onPress = function() {
            self.navigation.setRequestFitToView(true);
            return true;
        };
        Autodesk.Viewing.theHotkeyManager.pushHotkeys("Autodesk.FitToView", [
            {
                keycodes: [keys.f],
                onPress: onPress
            }
        ]);

        // Add home hotkey
        onPress = function() {
            self.navigation.setRequestHomeView(true);
            return true;
        };
        Autodesk.Viewing.theHotkeyManager.pushHotkeys("Autodesk.Home", [
            {
                keycodes: [keys.h],
                onPress: onPress
            },
            {
                keycodes: [keys.HOME],
                onPress: onPress
            }
        ]);

        // Escape
        onRelease = function() {
            // handle internal GUI components before firing the event to the client
            if (self.objectContextMenu && self.objectContextMenu.hide()) {
                return true;
            }

            // TODO: Could this all be unified somehow? If event listeners had priorities,
            //       we could intersperse listeners from the client and the viewer, which
            //       I think will eventually be required.

            self.fireEvent({ type: Autodesk.Viewing.ESCAPE_EVENT });
            return true;
        };

        Autodesk.Viewing.theHotkeyManager.pushHotkeys("Autodesk.Escape", [
            {
                keycodes: [keys.ESCAPE],
                onRelease: onRelease
            }
        ]);

        // Pan
        onPress = function() {
            previousTool = self.getActiveNavigationTool();
            return self.setActiveNavigationTool("pan");
        };
        onRelease = function() {
            return self.setActiveNavigationTool(previousTool);
        };
        hotkeys = [
            {
                keycodes: [keys.SHIFT],
                onPress: onPress,
                onRelease: onRelease
            },
            {
                keycodes: [keys.SPACE],
                onPress: onPress,
                onRelease: onRelease
            }];
        Autodesk.Viewing.theHotkeyManager.pushHotkeys("Autodesk.Pan", hotkeys, {tryUntilSuccess: true});
    }

    function createControls( impl )
    {
        self.navigation = new Autodesk.Viewing.Navigation(impl.camera);
        self.__initAutoCam(impl);

        self.utilities = new Autodesk.Viewing.ViewingUtilities(impl, self.autocam, self.navigation);
        self.clickHandler = new Autodesk.Viewing.DefaultHandler(impl, self.navigation, self.utilities);
        self.toolController = new Autodesk.Viewing.ToolController(impl, self, self.autocam, self.utilities, self.clickHandler);
        self.toolController.registerTool( new Autodesk.Viewing.GestureHandler(self) );

        self.toolController.registerTool( Autodesk.Viewing.theHotkeyManager );
        self.toolController.activateTool( Autodesk.Viewing.theHotkeyManager.getName() );

        registerUniversalHotkeys();

        self.toolController.registerTool( new Autodesk.Viewing.OrbitDollyPanTool(impl, self) );
        self.toolController.activateTool( "gestures" );

        return self.toolController;
    }
    // the implementation of the canvas
    this.impl  = new Autodesk.Viewing.Private.Viewer3DImpl(this.canvas, this, createControls);
    this.setDefaultNavigationTool( "orbit" );
    this.model = null;

    if( this.impl.controls )
        this.impl.controls.setAutocam(self.autocam);

    
    var canvasConfig = (this.config && this.config.canvasConfig) ? this.config.canvasConfig : Autodesk.Viewing.Viewer3D.kDefaultCanvasConfig;
    this.setCanvasClickBehavior(canvasConfig);

    // Create a div containing an image: this will be a
    // spinner (aka activity indicator) that tells the user
    // that the file is loading.
    //
    this.loader = document.createElement("div");
    this.loader.id = "loader";
    this.loader.className = "spinner";
    this.container.appendChild(this.loader);

    // Generate circles for spinner
    for (var i=1; i<=3; i++) {
        var spinnerContainer = document.createElement("div");
        spinnerContainer.className = "bounce" + i;
        this.loader.appendChild(spinnerContainer);
    }

    // Setup of AO, Ghosting, Env Lighting etc.
    this.initSettings();

    // Auxiliary class to get / restore the viewer state.
    this.viewerState = new Autodesk.Viewing.Private.ViewerState( this );

    // The default behavior is to run the main loop immediately, unless startOnInitialize
    // is provided and is false.
    //
    if (!this.config || !this.config.hasOwnProperty("startOnInitialize") || this.config.startOnInitialize)
    {
        this.run();
    }
    
    return 0;   // No Error initializing.
};

Autodesk.Viewing.Viewer3D.prototype.run = function()
{
    if( !this.running ) {
        this.resize();
        this.running = true;
        this.impl.run();
    }
};

Autodesk.Viewing.Viewer3D.prototype.__initAutoCam = function(impl)
{
    var self = this;

    var ourCamera = impl.camera;

    if( !ourCamera.pivot )
        ourCamera.pivot = new THREE.Vector3(0, 0, 0);

    if( !ourCamera.target )
        ourCamera.target = new THREE.Vector3(0, 0, 0);

    if( !ourCamera.worldup )
        ourCamera.worldup = ourCamera.up.clone();

    function autocamChange(upChanged)
    {
        if( self.autocamCamera.isPerspective !== ourCamera.isPerspective )
        {
            if( self.autocamCamera.isPerspective )
                self.navigation.toPerspective();
            else
                self.navigation.toOrthographic();
        }
        self.navigation.setVerticalFov(self.autocamCamera.fov, false);
        self.navigation.setView(self.autocamCamera.position, self.autocamCamera.target);
        self.navigation.setPivotPoint(self.autocamCamera.pivot);
        self.navigation.setCameraUpVector(self.autocamCamera.up);
        if( upChanged )
            self.navigation.setWorldUpVector(self.autocamCamera.worldup);

        self.impl.syncCamera(upChanged);
    }

    function pivotDisplay(state)
    {
        if( self.utilities )
            self.utilities.pivotActive(state, false);
        else
            self.impl.controls.pivotActive(state, false);
    }

    self.autocamCamera = ourCamera.clone();
    self.autocamCamera.target = ourCamera.target.clone();
    self.autocamCamera.pivot  = ourCamera.pivot.clone();
    self.autocamCamera.worldup = ourCamera.worldup.clone();

    self.autocam  = new Autocam(self.autocamCamera, self.navigation, self.canvas, autocamChange, pivotDisplay);
        
    self.addEventListener("cameraChanged", function(evt)
    {
        var ourCamera = evt.camera;
        self.autocam.sync(ourCamera);
    });

    self.autocam.sync(ourCamera);
};

/**
 * Load the file from the cloud or locally.
 * Asynchronously loads the document given its svfURN.
 *
 * On success: Calls onDocumentLoadedCallback.
 * On error: Displays an error AlertBox.
 * @param {string} svfURN The URN or filepath to load
 * @param {string} [sharedPropertyDbPath] Optional path to shared property database
 * @param {function} [onSuccessCallback] method gets called when initial loading is done and streaming starts
 * @param {function(int, string)} [onErrorCallback] method gets called when initial loading is done and streaming starts
 */
Autodesk.Viewing.Viewer3D.prototype.load = function(svfURN, sharedPropertyDbPath, onSuccessCallback, onErrorCallback)
{
    var self = this;

    return this.loadModel(svfURN, null, sharedPropertyDbPath, function() {
        var callback;
        if (self.modelstructure) {
            callback = function (root) {
                self.modelstructure.setModel(root, self.config.defaultModelStructureTitle ? self.config.defaultModelStructureTitle : '');
            };
        }
        self.model.getObjectTree(callback);

        if(onSuccessCallback)
        {
            onSuccessCallback();
        }
    }, onErrorCallback);
};

/**
 * Removes all created DOM elements
 * and performs any GL un-initialization that is needed.
 */
Autodesk.Viewing.Viewer3D.prototype.uninitialize = function(file)
{
    this.canvas.parentNode.removeChild(this.canvas);
    this.canvas.viewer = null;
    this.canvas = null;

    this.viewerState = null;

    if( this.toolController ) {
        this.toolController.uninitialize();
        this.toolController = null;
        this.clickHandler = null;
        this.utilities = null;
    }

    if (this.navigation) {
        this.navigation.uninitialize();
        this.navigation = null;
    }

    if (this.impl){
        this.impl.uninitialize();
        this.impl = null;
    }

    this.loader = null;
    this.model = null;
    this.prefs = null;

    // Toolbar
    Autodesk.Viewing.UI.Toolbar.destroy();
    this.toolbar = null;

    Autodesk.Viewing.theHotkeyManager.popHotkeys("Autodesk.FitToView");
    Autodesk.Viewing.theHotkeyManager.popHotkeys("Autodesk.Home");
    Autodesk.Viewing.theHotkeyManager.popHotkeys("Autodesk.Escape");
    Autodesk.Viewing.theHotkeyManager.popHotkeys("Autodesk.Pan");
    Autodesk.Viewing.theHotkeyManager.popHotkeys("Autodesk.Orbit");

    Autodesk.Viewing.Viewer.prototype.uninitialize.call(this);
};

/**
 * Detects if WebGL is enabled.
 *
 * @return { number } -1 for not Supported,
 *                    0 for disabled
 *                    1 for enabled
 */
Autodesk.Viewing.Viewer3D.prototype.detectWebGL = function()
{
    // Check for the webgl rendering context
    if ( !! window.WebGLRenderingContext) {
        var canvas = document.createElement("canvas"),
            names = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"],
            context = false;

        for (var i = 0; i < 4; i++) {
            try {
                context = canvas.getContext(names[i]);
                if (context && typeof context.getParameter === "function") {
                    // WebGL is enabled.
                    //
                    return 1;
                }
            } catch (e) {}
        }

        // WebGL is supported, but disabled.
        //
        return 0;
    }

    // WebGL not supported.
    //
    return -1;
};

/**
 * Loads a model into the viewer
 * @param {string} url the url to the model.
 * @param {string} [ids] A list of object id to load.
 * @param {string} [sharedPropertyDbPath] Optional path to shared property database.
 * @param {function} [onSuccessCallback] A method that gets called when initial loading is done and streaming starts.
 * @param {function(int, string)} [onErrorCallback] A method that gets called when loading fails.
 */
Autodesk.Viewing.Viewer3D.prototype.loadModel = function(url, ids, sharedPropertyDbPath, onSuccessCallback, onErrorCallback)
{
    var self = this;

    function registerDimensionSpecificHotkeys() {
        if (self.model.is2d()) {
            // Remove 3D specific hotkeys
            Autodesk.Viewing.theHotkeyManager.popHotkeys("Autodesk.Orbit");
        } else {
            // Add 3D specific hotkeys
            // Orbit
            var previousTool;
            var onPress = function() {
                previousTool = self.getActiveNavigationTool();
                return self.setActiveNavigationTool("orbit");
            };
            var onRelease = function() {
                return self.setActiveNavigationTool(previousTool);
            };
            var hotkeys = [
                {
                    keycodes: [Autodesk.Viewing.theHotkeyManager.KEYCODES.ALT],
                    onPress: onPress,
                    onRelease: onRelease
                }];
            Autodesk.Viewing.theHotkeyManager.pushHotkeys("Autodesk.Orbit", hotkeys, {tryUntilSuccess: true});
        }
    }

    function onSuccess( modelData ) {
        self.model = new Autodesk.Viewing.Model( modelData );
        self.impl.setModel(self.model);

        self.loader.style.display = "None";

        registerDimensionSpecificHotkeys();

        if (onSuccessCallback) {
            onSuccessCallback();
        }
    }

    function onError( errorCode, errorMessage ) {
        self.loader.style.display = "None";
        if (onErrorCallback)
            onErrorCallback( errorCode, errorMessage );
    }

    this.addEventListener( Autodesk.Viewing.GEOMETRY_LOADED_EVENT, function(e) {
        // Force a repaint when a file is fully done loading
        this.impl.needsRender = true;
        self.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT);
    });

    return this.impl.loadSvf(url, ids, sharedPropertyDbPath, onSuccess, onError );
};

/**
 * Returns a toolbar.
 *
 * @param {bool} create - if true and the toolbar does not exist, it will be created
 * @returns {Object} - retunrs a toolbar
 */
Autodesk.Viewing.Viewer3D.prototype.getToolbar = function( create )
{
    if (!this.toolbar) {
        if (create) {
            this.toolbar = new Autodesk.Viewing.UI.Toolbar( this.container );

            // Add two default subtoolbars: Navigation, Model
            this.navTools   = this.toolbar.addSubToolbar( Autodesk.Viewing.TOOLBAR.NAVTOOLSID, true );
            this.modelTools = this.toolbar.addSubToolbar( Autodesk.Viewing.TOOLBAR.MODELTOOLSID, false );
        }
    }
    return this.toolbar;
};

/**
 * Resizes the viewer.
 */
Autodesk.Viewing.Viewer3D.prototype.resize = function()
{
    Autodesk.Viewing.Viewer.prototype.resize.call(this);
    return this.impl.resize(this.container.clientWidth, this.container.clientHeight);
};

/**
 *
 * Gets the camera so it can be modified by the client.
 * @returns {THREE.camera} The active camera.
 */
Autodesk.Viewing.Viewer3D.prototype.getCamera = function()
{
    return this.impl.camera;
};

/**
 * Gets the view state as a plain object.
 *
 * @param {Object} [filter] - Specifies which viewer values to get.
 * @returns {Object} viewers state.
 */
Autodesk.Viewing.Viewer3D.prototype.getState = function( filter ) {
    return this.viewerState.getState(filter);
};

/**
 * Restores the viewer state from a given object.
 * @param {Object} viewerState
 * @param {Object} [filter] - Similar in structure to viewerState used to filter out values
 *                            that should not be restored.
 * @param {boolean} [immediate] - Whether the new view is applied with (true) or without transition (false)
 *
 * @returns {boolean} true if restore operation was successful.
 */
Autodesk.Viewing.Viewer3D.prototype.restoreState = function (viewerState, filter, immediate)  {
    var success = this.viewerState.restoreState(viewerState, filter, immediate);
    if (success) {
        this.fireEvent({ type: Autodesk.Viewing.VIEWER_STATE_RESTORED_EVENT, value: success });
    }
    return success;
};

/**
 * Checks whether a viewerState object is valid for the current loaded URN.
 * @param {Object} viewerState - Viewer State Object to check for validity.
 * @returns {boolean} true if the viewerState is valid for the loaded URN.
 */
Autodesk.Viewing.Viewer3D.prototype.isValidState = function (viewerState)  {
    return this.viewerState.isValidState(viewerState);
};

/**
 * Sets the view from an array of parameters
 * @param {Array} params - View parameters:
 *  [position-x, position-y, position-z,
 *    target-x, target-y, target-z,
 *    up-x, up-y, up-z,
 *    aspect, fov (radians), orthoScale,
 *    isPerspective (0=perspective, 1=ortho)]
 */
Autodesk.Viewing.Viewer3D.prototype.setViewFromArray = function(params)
{
    this.setActiveNavigationTool("orbit");

    //TODO: It might be best to get rid of the setViewFromArray API as it's not
    //very descriptive, and move the params->camera conversion to the bubble-reading
    //logic in ViewingApplication.
    var camera = {
        position: new THREE.Vector3(params[0], params[1], params[2]),
        target: new THREE.Vector3(params[3], params[4], params[5]),
        up: new THREE.Vector3(params[6], params[7], params[8]),
        aspect: params[9],
        fov: THREE.Math.radToDeg(params[10]),
        orthoScale: params[11],
        isPerspective: !params[12]
    };

    this.impl.setViewFromCamera(camera);
};

/**
 * Sets the view from an array representing a view box
 * @param {Array} viewbox - View parameters:
 *  [min-x, min-y, max-x, max-y]
 */
Autodesk.Viewing.Viewer3D.prototype.setViewFromViewBox = function (viewbox)
{
    this.impl.setViewFromViewBox(viewbox, false);
};

/**
 * Sets the view using the default view in the source file.
 */
Autodesk.Viewing.Viewer3D.prototype.setViewFromFile = function()
{
    this.setActiveNavigationTool(this.model.is2d() ? "pan" : "orbit");
    this.impl.setViewFromFile(this.model);
};

/**
 * Gets the properties for an id. Once the properties are returned, the method raises a onPropertiesReady event.
 * @param {number} dbid
 * @param {function} [onSuccessCallback] call this callback once the properties are found.
 * @param {function(int, string)} [onErrorCallback] call this callback if the properties are not found, or another error occurs.
 */
Autodesk.Viewing.Viewer3D.prototype.getProperties = function(dbid, onSuccessCallback, onErrorCallback)
{
    if (this.model) {
        this.model.getProperties(dbid, onSuccessCallback, onErrorCallback);
    }
    else {
        if (onErrorCallback)
            onErrorCallback(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Properties failed to load since model does not exist.");
    }
};

/**
 * Gets the viewer model object tree. Once the tree is received it will invoke the specified callback function.  
 * 
 * You can use the model object tree to get information about items in the model.  The tree is made up
 * of nodes, which correspond to model components such as assemblies or parts.  
 * 
 * @param {function} [onSuccessCallback] call this callback once the object tree is loaded.
 * @param {function(int, string)} [onErrorCallback] call this callback if the object tree is not found.
 */
Autodesk.Viewing.Viewer3D.prototype.getObjectTree = function(onSuccessCallback, onErrorCallback)
{
    if (this.model) {
        this.model.getObjectTree(onSuccessCallback, onErrorCallback);
    }
    else {
        if (onErrorCallback)
            onErrorCallback(Autodesk.Viewing.ErrorCodes.BAD_DATA, "ObjectTree failed to load since model does not exist.");
    }
};

/**
 * Sets the click behavior on the canvas to follow config.
 * This is used to change the behavior of events such as selection or COI changed.
 *
 *  @example
 *  {
 *       "click": {
 *           "onObject": [ACTIONS],
 *           "offObject": [ACTIONS]
 *       },
 *       "clickCtrl": {
 *           "onObject": [ACTIONS],
 *           "offObject": [ACTIONS]
 *       },
 *       "clickShift": {
 *           ...
 *       },
 *       "clickCtrlShift": {
 *           ...
 *       }
 *  }
 *  Actions can be any of the following:
 *  "selectOnly"
 *  "selectToggle"
 *  "deselectAll"
 *  "isolate"
 *  "showAll"
 *  "setCOI"
 *  "focus"
 *  "hide"
 *
 * @param {object} config paramater that meets the above layout
 */
 Autodesk.Viewing.Viewer3D.prototype.setCanvasClickBehavior = function(config)
 {
    if (this.impl.controls.hasOwnProperty("setClickBehavior"))
        this.impl.controls.setClickBehavior(config);

    if( this.clickHandler )
        this.clickHandler.setClickBehavior(config);
 };

/**
 * Searches the elements for the given text.  When the search is complete,
 * the callback onResultsReturned(idArray) is invoked.
 * @param {string} text - the search term.
 * @param {function(idArray)} onSuccessCallback - the callback to invoke when search is complete.
 * @param {function(errorCode, errorMsg)} onErrorCallback - the callback to invoke when search is complete.
 */
Autodesk.Viewing.Viewer3D.prototype.search = function(text, onSuccessCallback, onErrorCallback)
{
    this.searchText = text;

    if (this.model) {
        this.model.search(text, onSuccessCallback, onErrorCallback);
    }
    else {
        if (onErrorCallback)
            onErrorCallback(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Search failed since model does not exist.");
    }
};

/**
 * Returns the currently isolated nodes.
 *
 * @returns {Array} of nodes that are currently isolated.
 */
Autodesk.Viewing.Viewer3D.prototype.getIsolatedNodes = function () {
    return this.impl.visibilityManager.getIsolatedNodes();
};

/**
 * Isolates one of many sub-elements. You can pass in a node or an array of nodes to isolate.
 * Pass in null to reset isolation.
 * @param node an object from the tree returned by {@link BaseViewer#getObjectTree}
 */
Autodesk.Viewing.Viewer3D.prototype.isolate = function(node)
{
    if (Array.isArray(node))
        this.impl.visibilityManager.isolateMultiple(node);
    else
        this.impl.visibilityManager.isolate(node);
};


/**
 * Isolates one of many sub-elements. You can pass in a dbid or an array of dbid to isolate.
 * @param {array| int} dbids either an array or a single integer.
 */
Autodesk.Viewing.Viewer3D.prototype.isolateById = function(dbids) {
    var nodes = [];
    var self = this;

    // TODO: this code needs to be optimized
    // currently getObjectTree is the only thing that will guarentee
    // that the tree is available to load, but it is called twice
    // once here, and once in the documentStructurePanel

    // Calls isolate on the nodes specified
    // this is only called after the svf is done loading
    // and the object tree was created
    function isolateNodes(result) {
        nodes = self.model.getNodesByIds(Array.isArray(dbids) ? dbids : [dbids]);

        if (nodes) {
            self.isolate(nodes);
        }
    }
    
    // This is called once the geometry is done loading
    function handleGeomLoadedEvent(event) {
        self.getObjectTree(isolateNodes);
        self.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, handleGeomLoadedEvent);
    }

    // Checks to see if the svf is already loaded
    // if it's already loaded calls isolateNodes once the objectTree is loaded
    // if the geometry is not yet loaded, then adds an event listener with a callback
    if (this.model && this.model.isLoadDone()) {
        this.getObjectTree(isolateNodes);
    } else {
        this.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, handleGeomLoadedEvent);
    }

};

/**
 * Sets the background Color
 * @param {Number} red
 * @param {Number} green
 * @param {Number} blue
 * @param {Number} red2
 * @param {Number} green2
 * @param {Number} blue2
 */
Autodesk.Viewing.Viewer3D.prototype.setBackgroundColor = function(red, green, blue, red2, green2, blue2)
{
    this.impl.setClearColors(red, green, blue, red2, green2, blue2);
};

/**
 * Toggles the selection for a given dbid. If it was unselected, it is selected.  If it was selected, it is unselected.
 * @param {( number)} dbid
 */
Autodesk.Viewing.Viewer3D.prototype.toggleSelect = function(dbid)
{
    this.impl.selector.toggleSelectionId(dbid);
};

/**
 * Selects the array of ids. You can also just pass in a single id instead of an array.
 * @param {( number[] | number)} dbids
 */
Autodesk.Viewing.Viewer3D.prototype.select = function(dbids)
{
    if (typeof dbids === "number") {
        dbids = [dbids];
    }
    this.impl.selector.setSelectionIds(dbids);
};

/**
 * Deselects the given id array. You can also pass in a single id
 * @param {( number[] | number)} dbids
 */
Autodesk.Viewing.Viewer3D.prototype.deselect = function(/*array? unsigned int*/ dbids)
{
    throw Error("not implemented yet");
};


/**
 * Clears the selection.
 */
Autodesk.Viewing.Viewer3D.prototype.clearSelection = function()
{
    this.impl.selector.clearSelection();
};

/**
 * Returns information about the visibility of the current selection.
 * @returns {Object} hasVisible, hasHidden
 */
Autodesk.Viewing.Viewer3D.prototype.getSelectionVisibility = function () {
    return this.impl.selector.getSelectionVisibility();
};

/**
 * Returns the number of nodes in the current selection.
 * @returns {number}
 */
Autodesk.Viewing.Viewer3D.prototype.getSelectionCount = function () {
    return this.impl.selector.getSelectionLength();
};

/**
 * Returns the current selection.
 * @returns {Array} An array of the currently selected nodes.
 */
Autodesk.Viewing.Viewer3D.prototype.getSelection = function () {
    return this.impl.selector.getSelection();
};

/**
 * Ensures the passed in dbid / ids are hidden.
 * @param {( number[] | number)} node
 */
Autodesk.Viewing.Viewer3D.prototype.hide = function(node)
{
    if (Array.isArray(node)) {
        this.impl.visibilityManager.hideMultiple(node);
    }
    else {
        this.impl.visibilityManager.hide(node);
    }
};

/**
 * Ensures the passed in dbid / ids are shown.
 * @param {( number[] | number)} node
 */
Autodesk.Viewing.Viewer3D.prototype.show = function(node)
{
    if (Array.isArray(node)) {
        this.impl.visibilityManager.showMultiple(node);
    }
    else {
        this.impl.visibilityManager.show(node);
    }
};

/**
 * Ensures everything is visible.
 */
Autodesk.Viewing.Viewer3D.prototype.showAll = function()
{
    this.impl.visibilityManager.isolateNone();
    if (this.model.is2d()) {
        this.setLayerVisible(null, true);
    }
};

/**
 * Ensures everything is invisible.
 */
Autodesk.Viewing.Viewer3D.prototype.hideAll = function()
{
    throw Error("not implemented yet");
};


/**
 * Toggles the visibility of the given node.
 * @param {( number)} node
 */
Autodesk.Viewing.Viewer3D.prototype.toggleVisibility = function(node)
{
    this.impl.visibilityManager.toggleVisibility(node);
};

/**
 * Returns true if every node is visible.
 * @returns {boolean}
 */
Autodesk.Viewing.Viewer3D.prototype.areAllVisible = function() {
    return this.impl.visibilityManager.areAllVisible();
};

/**
 * Explodes the model from the center of gravity.
 * @param {number} scale - a value from 0.0-1.0 to indicate how much to explode.
 */
Autodesk.Viewing.Viewer3D.prototype.explode = function( scale)
{
    this.impl.explode(scale);
};

/**
 * Returns the explode scale
 */
Autodesk.Viewing.Viewer3D.prototype.getExplodeScale = function()
{
    return this.impl.getExplodeScale();
};


/**
 * Enables or disables the high quality rendering settings.
 * @param {boolean} useSAO - true or false to enable screen space ambient occlusion.
 * @param {boolean} useFXAA - true or false to enable fast approximate anti-aliasing.
 */
Autodesk.Viewing.Viewer3D.prototype.setQualityLevel = function(useSAO, useFXAA)
{
    this.prefs.set('ambientShadows', useSAO);
    this.prefs.set('antialiasing', useFXAA);
    this.impl.togglePostProcess(useSAO, useFXAA);
};


/**
 * This method allows setting the environment map for the viewer.
 * @param {string} url to the environment cube map null for cleaning out.
 */
Autodesk.Viewing.Viewer3D.prototype.setEnvironmentMap = function(url)
{
    this.impl.setCubeMap(url);
};

/**
 * Toggles ghosting during search and isolate.
 * @param {boolean} value is indicating whehter ghosting is on or off
 */
Autodesk.Viewing.Viewer3D.prototype.setGhosting = function(value)
{
    this.prefs.set('ghosting', value);
    this.impl.toggleGhosting(value);
};

/**
 * Toggles whether progressive rendering is used. Warning: turning progressive rendering off
 * will have serious performance implications.
 * @param {boolean} value whether it is on or off
 */
Autodesk.Viewing.Viewer3D.prototype.setProgressiveRendering = function(value)
{
    this.prefs.set('progressiveRendering', value);
    this.impl.toggleProgressive(value);
};

/**
 * Toggles whether the navigation should be optimized for performance. If set
 * to true, anti-aliasing and ambient shadows will be off while navigating.
 * @param {boolean} value whether it is on or off
 */
Autodesk.Viewing.Viewer3D.prototype.setOptimizeNavigation = function(value)
{
    this.prefs.set('optimizeNavigation', value);
    this.impl.setOptimizeNavigation(value);
};

/**
 * Gets the current default navigation mode for the left mouse button / single finger drag.
 * @returns { NAVIGATION_MODE } value from NAVIGATION_MODE or undefined.
 * @deprecated Please use {@link Autodesk.Viewing.Viewer3D#getActiveNavigationTool|getActiveNavigationTool()} instead.
 */
Autodesk.Viewing.Viewer3D.prototype.getNavigationMode = function()
{
    return this._navigationMode;
};

/**
 * Sets the default navigation mode for the left mouse button / single finger drag.
 * Should trigger NAVIGATION_MODE_CHANGED event if the mode actually changes.
 * @param { NAVIGATION_MODE } mode - use values from NAVIGATION_MODE.
 * @deprecated Please use {@link Autodesk.Viewing.Viewer3D#setActiveNavigationTool|setActiveNavigationTool()} instead.
 */
Autodesk.Viewing.Viewer3D.prototype.setNavigationMode = function(mode)
{
    var toolName = null;

    switch( mode ) {
        case Autodesk.Viewing.NAVIGATION_MODE.ORBIT:
            toolName = "orbit";
            break;

        case Autodesk.Viewing.NAVIGATION_MODE.PAN:
            toolName = "pan";
            break;

        case Autodesk.Viewing.NAVIGATION_MODE.DOLLY:
            toolName = "dolly";
            break;
    }
    this.setActiveNavigationTool(toolName, mode);
};

/**
 * Swaps the current navigation tool for the tool with the provided name.
 * Will trigger NAVIGATION_MODE_CHANGED event if the mode actually changes.
 *
 * @param {string} [toolName] - The name of the tool to activate. By default it will switch to the default tool.
 *
 * @returns {boolean} - True if the tool was set successfully. False otherwise.
 *
 * @see {@link Autodesk.Viewing.Viewer3D#getActiveNavigationTool|getActiveNavigationTool()}
 */
Autodesk.Viewing.Viewer3D.prototype.setActiveNavigationTool = function(toolName)
{
    if(toolName === this._pushedTool || (!toolName && !this._pushedTool))
        return true;

    if( this._pushedTool ) {
        if( this.impl.controls.deactivateTool(this._pushedTool) ) {
            this._pushedTool = null;
        } else {
            return false;
        }
    }

    var isDefault = !toolName || toolName === this.getDefaultNavigationToolName();

    if (isDefault && this._pushedTool === null) {
        this.fireEvent({ type: Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, id: this.getDefaultNavigationToolName() });
        return true;
    }

    if( this.impl.controls.activateTool(toolName) ) {
        this._pushedTool = toolName;
        this.fireEvent({ type: Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, id: this._pushedTool });
        return true;
    }

    return false;
};

/**
 * Returns the name of the active navigation tool.
 * @returns {string} - The tool's name.
 *
 * @see {@link Autodesk.Viewing.Viewer3D#setActiveNavigationTool|setActiveNavigationTool()}
 */
Autodesk.Viewing.Viewer3D.prototype.getActiveNavigationTool = function()
{
    return this._pushedTool ? this._pushedTool : this._defaultNavigationTool;
};

/**
 * Sets the default navigation tool. This tool will always sit beneath the navigation tool on the tool stack.
 *
 * @param {string} toolName - The name of the new default navigation tool.
 */
Autodesk.Viewing.Viewer3D.prototype.setDefaultNavigationTool = function(toolName)
{
    if (this._defaultNavigationTool) {
        this.impl.controls.deactivateTool(this._defaultNavigationTool);
    }

    if (this._pushedTool) {
        this.impl.controls.deactivateTool(this._pushedTool);
    }

    this.impl.controls.activateTool(toolName);
    this._defaultNavigationTool = toolName;

    if (this._pushedTool) {
        this.impl.controls.activateTool(this._pushedTool);
    }
};

/**
 * Returns the default navigation tool
 *
 * @returns {Object} - The default navigation tool.
 */
Autodesk.Viewing.Viewer3D.prototype.getDefaultNavigationToolName = function()
{
    return this._defaultNavigationTool;
};

/**
 * Gets the current camera vertical field of view.
 * @returns { number } - the field of view in degrees.
 */
Autodesk.Viewing.Viewer3D.prototype.getFOV = function()
{
    return this.navigation.getVerticalFov();
};

/**
 * Sets the current cameras vertical field of view.
 * @param { number } degrees - Field of view in degrees.
 */
Autodesk.Viewing.Viewer3D.prototype.setFOV = function(degrees)
{
    this.navigation.setVerticalFov(degrees, true);
};

/**
 * Gets the current camera focal length.
 * @returns { number } - the focal length in millimetres.
 */
Autodesk.Viewing.Viewer3D.prototype.getFocalLength = function()
{
    return this.navigation.getFocalLength();
};

/**
 * Sets the current cameras focal length.
 * @param { number } mm - Focal length in millimetres
 */
Autodesk.Viewing.Viewer3D.prototype.setFocalLength = function(mm)
{
    this.navigation.setFocalLength(mm, true);
};

/**
 * Hides all lines in the scene.
 * @param {boolean} hide
 */
Autodesk.Viewing.Viewer3D.prototype.hideLines = function(hide){
    this.prefs.set('lineRendering', !hide);
    if (!this.impl.hideLines(hide)) {
        var that = this;
        function onGeometryLoaded() {
            that.impl.hideLines(hide);
            that.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
        }

        this.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
    }
};

/**
 * Applies the camera to the current viewer's camera.
 * @param {THREE.Camera} camera - the camera to apply.
 * @param {boolean} [fit=false] - Do a fit to view after transition.
 */
Autodesk.Viewing.Viewer3D.prototype.applyCamera = function(camera, fit) {
    this.impl.applyCamera(camera, fit);
};

/**
 * Fits camera to objects by ID - Fits entire model if none provided.
 * @param {array| int} objectIds array of Ids
 */
Autodesk.Viewing.Viewer3D.prototype.fitToView = function(objectIds){

    var that = this;
    var instant = true;

    var fit = function(){
        var fitTo = null;
        if( Array.isArray(objectIds) && (objectIds.length > 0) )
        {
            var bounds = new THREE.Box3();
            var box = new THREE.Box3();

            var fragIds = [];
            for (var i=0; i<objectIds.length; i++)
                that.model.getNodeFragments(objectIds[i], fragIds);

            for (var i = 0; i < fragIds.length; i++) {
                if (fragIds[i] !== undefined){
                    var m = that.impl.getRenderProxy(that.model, fragIds[i]);
                    box.copy(m.geometry.boundingBox).applyMatrix4(m.matrixWorld);
                    bounds.union(box);
                }
            }
            if( !bounds.empty() )
                fitTo = bounds;
        }
        if( !fitTo || fitTo.empty() )
            fitTo = that.impl.getFitBounds();

        that.navigation.fitBounds(false, fitTo);

        that.removeEventListener(Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT, checkGeomAndFit);
        that.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, fit);

        return instant;
    };

    var checkGeomAndFit = function () {
        if(that.model && that.model.isLoadDone()){
            fit();
        } else {
            instant = false;
            that.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, fit);
        }
    };

    var propertyDB = this.model.getData().propertydb,
        propertyDBFileExists = propertyDB && propertyDB.attrs.length > 0;

    // This doesn't guarantee that an object tree will be created but it will be pretty likely
    if (!this.model.is2d() && propertyDBFileExists && objectIds !== null && objectIds !== undefined) {

        if (this.model && this.model.isObjectTreeCreated()) {
            checkGeomAndFit();
        } else {
            instant = false;
            this.addEventListener(Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT, checkGeomAndFit);
        }
    } else {
        // Fallback, fit to the model bounds
        this.navigation.fitBounds(false, this.impl.getFitBounds(true));
    }
};

/**
 * Modifies a click action configuration entry.
 * @param {string} what - which click config to modify (one of "click", "clickAlt", "clickCtrl", "clickShift", "clickCtrlShift").
 * @param {string} where - hit location selector (one of "onObject", "offObject").
 * @param {Array|string} newAction - action list (containing any of "setCOI", "selectOnly", "selectToggle", "deselectAll", "deselectAll", "isolate", "showAll", "hide", "focus").
 * @returns {boolean} False if specified entry is not found, otherwise true.
 */
Autodesk.Viewing.Viewer3D.prototype.setClickConfig = function(what, where, newAction)
{
    var config = this.clickHandler ? this.clickHandler.getClickBehavior()
                                   : this.impl.controls.getClickBehavior();

    if( what in config )
    {
        var actions = config[what];
        if( where in actions )
        {
            actions[where] = newAction;
            return true;
        }
    }
    return false;
};

/**
 * Fetch a click action configuration entry.
 * @param {string} what - which click config to fetch (one of "click", "clickAlt", "clickCtrl", "clickShift", "clickCtrlShift").
 * @param {string} where - hit location selector (one of "onObject", "offObject").
 * @returns {Array} action list for the given entry or null if not found.
 */
Autodesk.Viewing.Viewer3D.prototype.getClickConfig = function(what, where)
{
    var config = this.clickHandler ? this.clickHandler.getClickBehavior()
                                   : this.impl.controls.getClickBehavior();

    if( what in config )
    {
        var actions = config[what];
        if( where in actions )
            return actions[where];
    }
    return null;
};

/**
 * Modify the default click behaviour for the viewer.
 * @param {boolean} state - If true the default is to set the center of interest. If false the default is single select.
 */
Autodesk.Viewing.Viewer3D.prototype.setClickToSetCOI = function(state)
{
    this.prefs.set('clickToSetCOI', state);
    var currentOn = this.getClickConfig("click", "onObject");
    if( state )
    {
        if( currentOn.indexOf("setCOI") === -1 ) // Not already set?
        {
            this.setClickConfig("click", "onObject",  [ "setCOI" ]);
        }
    }
    else if( currentOn.indexOf("setCOI") >= 0 ) // Is currently set?
    {
        this.setClickConfig("click", "onObject",  [ "selectOnly" ]);
    }
};

/**
 * Sets the model structure panel for displaying the loaded model.
 * @param {ModelStructurePanel} modelStructurePanel - the model structure panel to use, or null.
 *
 * @returns {boolean} true if the panel, or null, was set successfully; false otherwise.
 */
Autodesk.Viewing.Viewer3D.prototype.setModelStructurePanel = function (modelStructurePanel) {
    var self = this;
    if (modelStructurePanel instanceof Autodesk.Viewing.UI.ModelStructurePanel || modelStructurePanel === null) {
        if (this.modelstructure) {
            this.modelstructure.setVisible(false);  // This ensures the button is in the correct state.
            this.removePanel(this.modelstructure);
            this.modelstructure.uninitialize();
        }
        this.modelstructure = modelStructurePanel;

        if (modelStructurePanel) {
            this.addPanel(this.modelstructure);

            // If the model already exists, then set it now.  Otherwise, it will be
            // set later when the model is created in load().
            //
            if (self.model) {
                self.model.getObjectTree(function (root) {
                    self.modelstructure.setModel(root);
                });
            }
        }
        return true;
    }
    return false;
};

/**
 * Sets the layers panel for display 2d layers.
 * @param {!LayersPanel} layersPanel - the layers panel to use, or null
 * @returns {boolean} true if the panel or null was set successfully, and false otherwise
 */
Autodesk.Viewing.Viewer3D.prototype.setLayersPanel = function (layersPanel) {
    if (layersPanel instanceof Autodesk.Viewing.UI.LayersPanel || !layersPanel) {
        if (this.layersPanel) {
            this.layersPanel.setVisible(false);
            this.removePanel(this.layersPanel);
            this.layersPanel.uninitialize();
        }

        this.layersPanel = layersPanel;
        if (layersPanel) {
            this.addPanel(layersPanel);
        }
        return true;
    }
    return false;
};

/**
 * Sets the property panel.
 * @param {!PropertyPanel} propertyPanel - the property panel to use, or null
 * @returns {boolean} true if the panel or null was set successfully, and false otherwise
 */
Autodesk.Viewing.Viewer3D.prototype.setPropertyPanel = function (propertyPanel) {
    if (propertyPanel instanceof Autodesk.Viewing.UI.PropertyPanel || !propertyPanel) {
        if (this.propertygrid) {
            this.propertygrid.setVisible(false);
            this.removePanel(this.propertygrid);
            this.propertygrid.uninitialize();
        }

        this.propertygrid = propertyPanel;
        if (propertyPanel) {
            this.addPanel(propertyPanel);
        }
        return true;
    }
    return false;
};

/**
 * Initializes all gui settings to their defaults or to the session stored setting
 * This gives session stored settings priority
 */
Autodesk.Viewing.Viewer3D.prototype.initSettings = function() {
    var nav = window.navigator;
    var isAndroid = (nav.platform.indexOf("armv") != -1) || (nav.appVersion && nav.appVersion.indexOf("Android") != -1);
    var isIPad = (nav.appVersion && nav.appVersion.indexOf("iPad") !== -1);

    //Android device is assumed too weak to manage SSAO, so we turn it off
    //by default but we don't disallow turning it back on.
    var defaultSettings = {
        "ambientShadows": !(isAndroid || isIPad),
        "antialiasing": !(isAndroid || isIPad),
        "progressiveRendering": true,
        "environmentMap": false,
        "openPropertiesOnSelect": !(isAndroid || isIPad),
        "ghosting": true,
        "viewCube": !(isAndroid || isIPad),
        "lineRendering": true,
        "lightPreset": (isAndroid || isIPad || _isIE11) ? 0 : Autodesk.Viewing.Private.DefaultLightPreset,
        "backgroundColorPreset": null,
        "reverseMouseZoomDir": false,
        "reverseHorizontalLookDirection": false,
        "reverseVerticalLookDirection": false,
        "alwaysUsePivot": false,
        "zoomTowardsPivot": false,
        "orbitPastWorldPoles": true,
        "leftHandedMouseSetup": false,
        "clickToSetCOI": (isAndroid || isIPad),
        "optimizeNavigation": false
    };

    this.prefs.load(defaultSettings);

    this.prefs.tag('3d');
    this.prefs.tag('2d');
    this.prefs.untag('2d', [ // 3d only
        'viewCube',
        'alwaysUsePivot',
        'zoomTowardsPivot',
        'reverseHorizontalLookDirection',
        'reverseVerticalLookDirection',
        'orbitPastWorldPoles',
        'clickToSetCOI',
        'ghosting',
        'optimizeNavigation',
        'ambientShadows',
        'antialiasing',
        'lineRendering',
        'lightPreset'
    ]);

    // Apply settings
    this.setQualityLevel(this.prefs.ambientShadows, this.prefs.antialiasing);
    this.setGhosting(this.prefs.ghosting);
    this.setProgressiveRendering(this.prefs.progressiveRendering);
    this.setClickToSetCOI(this.prefs.clickToSetCOI);
    this.setOptimizeNavigation(this.prefs.optimizeNavigation);
    this.hideLines(!this.prefs.lineRendering);

    this.navigation.setUsePivotAlways(this.prefs.alwaysUsePivot);
    this.navigation.setReverseZoomDirection(this.prefs.reverseMouseZoomDir);
    this.navigation.setReverseHorizontalLookDirection(this.prefs.reverseHorizontalLookDirection);
    this.navigation.setReverseVerticalLookDirection(this.prefs.reverseVerticalLookDirection);
    this.navigation.setZoomTowardsPivot(this.prefs.zoomTowardsPivot);
    this.navigation.setOrbitPastWorldPoles(this.prefs.orbitPastWorldPoles);
    this.navigation.setUseLeftHandedInput(this.prefs.leftHandedMouseSetup);

    var bacStr = this.prefs.backgroundColorPreset;
    if (bacStr) {
        try {
            var bac = JSON.parse(bacStr);
            this.impl.setClearColors(bac[0],bac[1],bac[2],bac[3],bac[4],bac[5]);
        } catch(e) {
            this.prefs.set("backgroundColorPreset", null);
        }
    }

    var lightPreset = /*viewer.model.is2d() ? Autodesk.Viewing.Private.DefaultLightPreset2d :*/ this.prefs.lightPreset;
    this.impl.setLightPreset(lightPreset, true);
};

/**
 * Sets the Light Presets (Environments) for the Viewer.
 *
 * Sets the preference in the UI
 * @param {Number} index - where
 * - 0 Simple Grey
 * - 1 Sharp Highlights
 * - 2 Dark Sky
 * - 3 Grey Room
 * - 4 Photo Booth
 * - 5 Tranquility
 * - 6 Infinity Pool
 * - 7 Simple White
 * - 8 Riverbank
 * - 9 Contrast
 * - 10 Rim Highlights
 * - 11 Cool Light
 * - 12 Warm Light
 * - 13 Soft Light
 * - 14 Grid Light
 * - 15 Plaza
 * - 16 Snow Field
 * @note this list is copied from the ones in Environments.js
 */

Autodesk.Viewing.Viewer3D.prototype.setLightPreset = function (index) {
    this.prefs.set('lightPreset', index);

    this.impl.setLightPreset(index);
};

/**
 *  Set or unset a view navigation option which requests that orbit controls always orbit around the currently set pivot point.
 *  
 *  Sets the preference in the UI
 *  @param {boolean} value - value of the option, true to request use of the pivot point. When false some controls may pivot around the center of the view. (Currently applies only to the view-cube orbit controls.)
 */
Autodesk.Viewing.Viewer3D.prototype.setUsePivotAlways = function (value) {
    this.prefs.set('alwaysUsePivot', value);
    this.navigation.setUsePivotAlways(value);
};

/**
 * Set or unset a view navigation option to reverse the default direction for camera dolly (zoom) operations.
 *
 *  Sets the preference in the UI
 *  @param {boolean} value - value of the option, true for reverse, false for default
 */
Autodesk.Viewing.Viewer3D.prototype.setReverseZoomDirection = function (value) {
    this.prefs.set('reverseMouseZoomDir', value);
    this.navigation.setReverseZoomDirection(value);
};

/**
 * Set or unset a view navigation option to reverse the default direction for horizontal look operations.
 *
 *  Sets the preference in the UI
 *  @param {boolean} value - value of the option, true for reverse, false for default
 */
Autodesk.Viewing.Viewer3D.prototype.setReverseHorizontalLookDirection = function (value) {
    this.prefs.set('reverseHorizontalLookDirection', value);
    this.navigation.setReverseHorizontalLookDirection(value);
};

/**
 * Set or unset a view navigation option to reverse the default direction for vertical look operations.
 *
 *  Sets the preference in the UI
 *  @param {boolean} value - value of the option, true for reverse, false for default
 */
Autodesk.Viewing.Viewer3D.prototype.setReverseVerticalLookDirection = function (value) {
    this.prefs.set('reverseVerticalLookDirection', value);
    this.navigation.setReverseVerticalLookDirection(value);
};

/**
 * Get the state of the view navigation option that requests the default direction for camera dolly (zoom) operations to be towards the camera pivot point.
 *
 *  Sets the preference in the UI
 *  @param {boolean} - value of the option, true for towards the pivot, false for default
 */
Autodesk.Viewing.Viewer3D.prototype.setZoomTowardsPivot = function (value) {
    this.prefs.set('zoomTowardsPivot', value);
    this.navigation.setZoomTowardsPivot(value);
};

/**
 * Set or unset a view navigation option to allow the orbit controls to move the camera beyond the north and south poles (world up/down direction). In other words, when set the orbit control will allow the camera to rotate into an upside down orientation. When unset orbit navigation should stop when the camera view direction reaches the up/down direction.
 *
 *  Sets the preference in the UI
 *  @param {boolean} value - value of the option, true to allow orbiting past the poles.
 */
Autodesk.Viewing.Viewer3D.prototype.setOrbitPastWorldPoles = function (value) {
    this.prefs.set('orbitPastWorldPoles', value);
    this.navigation.setOrbitPastWorldPoles(value);
};

/**
 * Set or unset a view navigation option which requests that mouse buttons be reversed from their default assignment. i.e. Left mouse operation becomes right mouse and vice versa.
 *
 *  Sets the preference in the UI
 *  @param {boolean} value - value of the option, true to request reversal of mouse button assignments.
 */
Autodesk.Viewing.Viewer3D.prototype.setUseLeftHandedInput = function (value) {
    this.prefs.set('leftHandedMouseSetup', value);
    this.navigation.setUseLeftHandedInput(value);
};

/**
 * Called before showing the context menu.
 * @param {Event} event - Mouse event that triggered this context menu
 * @returns {boolean} true if the context menu should be shown
 * @override
 */
Autodesk.Viewing.Viewer3D.prototype.preContextMenuShow = function (event) {

    function isMultiSelect(event) {
        var isMac = (navigator.userAgent.search("Mac OS") !== -1);
        return (isMac && event.metaKey) || (!isMac && event.ctrlKey);
    }

    // Select the object under the mouse if it's not selected
    var result = this.impl.castRay(event.clientX, event.clientY);
    if (result.node) {
        if (!this.impl.selector.isSelectedOrParentIsSelected(result.node) ) {
            if (!isMultiSelect(event)) {
                this.impl.selector.setSelection([result.node]);
            }
        }
    }
    return true;
};

/**
 * Set visibility for a single layer, or for all layers.
 * @param {?Array} nodes - An array of layer nodes, or a single layer node, or null for all layers
 * @param {boolean} visible - true to show the layer, false to hide it
 * @param {boolean=} [isolate] - true to isolate the layer
 */
Autodesk.Viewing.Viewer3D.prototype.setLayerVisible = function (nodes, visible, isolate) {
    var that = this;

    function getLayerIndexes(node, visible) {
        var layerIndexes = [];

        if (node.isLayer) {
            layerIndexes.push(node.index);
        } else {
            var children = node.children;
            for (var i = 0; i < children.length; ++i) {
                layerIndexes = layerIndexes.concat(getLayerIndexes(children[i]));
            }
        }

        return layerIndexes;
    }

    var layersRoot = that.model.getLayersRoot();
    if (!layersRoot) {
        return;
    }

    if (nodes === null) {
        nodes = [layersRoot];
    }
    if (!Array.isArray(nodes)) {
        nodes = [nodes];
    }

    if (isolate) {
        that.impl.setLayerVisible(getLayerIndexes(layersRoot), false);
        visible = true; // force this because isolate + not visible doesn't make sense
    }

    var layerIndexes = [];
    for (var i = 0; i < nodes.length; ++i) {
        layerIndexes = layerIndexes.concat(getLayerIndexes(nodes[i]));
    }
    that.impl.setLayerVisible(layerIndexes, visible);
    that.fireEvent({type: Autodesk.Viewing.LAYER_VISIBILITY_CHANGED_EVENT});
};

/**
 * Returns true if the layer is visible.
 * @param {Object} node - Layer node
 * @returns {boolean} true if the layer is visible
 */
Autodesk.Viewing.Viewer3D.prototype.isLayerVisible = function (node) {
    return node && node.isLayer && this.impl.isLayerVisible(node.index);
};

/**
 * Returns true if any layer is hidden.
 * @returns {boolean} true if any layer is hidden
 */
Autodesk.Viewing.Viewer3D.prototype.anyLayerHidden = function () {
    var that = this;

    function anyLayerHidden(node) {
        if (node.isLayer) {
            return !that.impl.isLayerVisible(node.index);
        } else {
            var children = node.children;
            for (var i = 0; i < children.length; ++i) {
                if (anyLayerHidden(children[i])) {
                    return true;
                }
            }
        }
        return false;
    }

    var layersRoot = that.model.getLayersRoot();
    return layersRoot && anyLayerHidden(layersRoot);
};

// Viewer3D was formerly BaseViewer3D.  It is now deprecated, but we'll continue to support it
// for backwards compatibility.
//
Autodesk.Viewing.BaseViewer3D = Autodesk.Viewing.Viewer3D;
;/**
 * This is the Tessera document API for design content.
 * @ignore
 */
AutodeskNamespace('Autodesk.Viewing');

/**
 * Error code constants
 *
 * These constants will be used in onErrorCallbacks.
 *
 * @enum {number}
 * @readonly
 */
Autodesk.Viewing.ErrorCodes = {
    /** An unknown failure has occurred. */
    UNKNOWN_FAILURE: 1,

    /** Bad data (corrupted or malformed) was encountered. */
    BAD_DATA: 2,

    /** A network failure was encountered. */
    NETWORK_FAILURE: 3,

    /** Access was denied to a network resource (HTTP 403) */
    NETWORK_ACCESS_DENIED: 4,

    /** A network resource could not be found (HTTP 404) */
    NETWORK_FILE_NOT_FOUND: 5,

    /** A server error was returned when accessing a network resource (HTTP 5xx) */
    NETWORK_SERVER_ERROR: 6,

    /** An unhandled response code was returned when accessing a network resource (HTTP 'everything else') */
    NETWORK_UNHANDLED_RESPONSE_CODE: 7,

    /** Browser error: webGL is not supported by the current browser */
    BROWSER_WEBGL_NOT_SUPPORTED: 8,

    /** There is nothing viewable in the fetched document */
    BAD_DATA_NO_VIEWABLE_CONTENT: 9,

    /** Browser error: webGL is supported, but not enabled */
    BROWSER_WEBGL_DISABLED: 10

};;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

/**
 * This is the Tessera canvas API for 2D design content.
 * @ignore
 */
AutodeskNamespace('Autodesk.Viewing');

/**
 *  
 *  @class 
 *  This is the core viewing class for all 2D drawings.  
 *  To create a viewer:
 * 
 *  1. Create a new viewer object with `new Autodesk.Viewing.Viewer2D()`
 *  2. Initialize the viewer with `Viewer2D.initialize()`
 *  3. Initialize the viewer runtime with `Autodesk.Viewing.Initializer()`
 * 
 *  
 *  @see Autodesk.Initializer
 *  
 *
 *  @constructor
 *  @param {HTMLDomElement} container - The id of the HTML container for the
 *   viewer.
 *  @param {object} config - Initial settings.  The settings are:
 
  + `config.tileSize`: the size of the tiles in pixels.  The default is **1024**.
  + `config.maxZoom`: the maximum zoom level.  The default is **6**.
		
 */
Autodesk.Viewing.Viewer2D = function(container, config)
{
    Autodesk.Viewing.Viewer.call(this, container, config);
    // the implementation of the canvas
    if(!config) {
        config = {};
    }
    config.domElement = this.container;
    this.impl = new Autodesk.Viewing.Private.Viewer2DImpl(this, config);
};

Autodesk.Viewing.Viewer2D.prototype = Object.create(Autodesk.Viewing.Viewer.prototype);
Autodesk.Viewing.Viewer2D.prototype.constructor = Autodesk.Viewing.Viewer2D;

/**
 *
 * Create any DOM and canvas elements.
 *
 * @return 0 if initialization was successful, Autodesk.Viewing.ErrorCode otherwise.
 */
Autodesk.Viewing.Viewer2D.prototype.initialize = function()
{
    Autodesk.Viewing.Viewer.prototype.initialize.call(this);
    return this.impl.initialize();
};

/**
 * Load the file from the cloud or locally
 * Asynchronously loads the document given its svfURN
 * On success: Calls onDocumentLoadedCallback, if it is provided.
 * On error: Displays an error AlertBox.
 * @param {string} sheetURN The URN to load.  This must be the URN of a 2d geometry object
 * @param {string} [sharedPropertyDbPath] Optional path to a shared property database.
 * @param {function} [onSuccessCallback] A function that gets called when initial loading is done.
 * @param {function} [onErrorCallback] A function that gets called when initial loading fails.
 */
Autodesk.Viewing.Viewer2D.prototype.load = function(sheetURN, sharedPropertyDbPath, onSuccessCallback, onErrorCallback)
{
  if(this.impl.load(sheetURN))
  {
    if(onSuccessCallback)
    {
        onSuccessCallback();
    }
    return true;
  }

  if (onErrorCallback)
    onErrorCallback();

  return false;
};

/**
 *
 * Remove all created DOM elements
 */
Autodesk.Viewing.Viewer2D.prototype.uninitialize = function()
{
    this.impl.uninitialize();
    Autodesk.Viewing.Viewer.prototype.uninitialize.call(this);
};

Autodesk.Viewing.Viewer2D.prototype.resize = function () {
    Autodesk.Viewing.Viewer.prototype.resize.call(this);
    this.impl.resize();
};

Autodesk.Viewing.Viewer2D.prototype.setViewFromFile = function () {
    this.impl.goHome();
};;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

/**
 * This is the Tessera document API for design content.
 * @ignore
 */
AutodeskNamespace('Autodesk.Viewing');

/**
 * @class
 *  This is the core model data class for all items and collections.
 *  It allows the client to load the model data from the cloud, it
 *  gives access to the root and provides a method for finding elements
 *  by id.  
 *
 *  Typically, you load the document from the Viewing Service, parse it for 
 *  the required content (for example, 3d geometries), then pass this on to 
 *  the viewer to display.  You can also get some information about the document,
 *  such as the number of views it contains and its thumbnail image.
 * 
 * You can view the json structure of a Document object by requesting it from
 * the viewing service, once you have been authenticated (eg a valid accessToken
 * is stored as a cookie):
 * https://viewing-dev.api.autodesk.com/viewingservice/v1/bubbles/[urn]
 * 
 *  
 *  @param {Object} dataJSON - json data representing the document
 *  @param {string} path - path to the document
 */
Autodesk.Viewing.Document = function( dataJSON, path )
{
    this.myPath = path;
    this.myData = dataJSON;
    this.myViewGeometry = {};
    this.myNumViews = {};
    this.myPropertyDb = null;

    // Search bubble for type="view" role="3d" children of type="geometry" role="3d" items.
    // Add count of view-3d items to parent geometry-3d items.
    // Collect geometry items of camera view items referenced by guid.
    //
    var self = this;

    function annotateViews(item) {
        if (!item) {
            return;
        }

        var childCount = item.children ? item.children.length : 0;
        // To enable 2D views, remove the check for 3D here and in the child if statement.
        if (item.type === "geometry" && item.role === "3d" && childCount) {
            var viewCount = 0;
            for (var i = 0; i < childCount; i++) {
                var child = item.children[i];
                if (child && child.type === "view" && child.role === "3d") {
                    self.myViewGeometry[child.guid] = item;
                    viewCount++;
                }
            }

            self.myNumViews[item.guid] = viewCount;

        } else if (item.mime == "application/autodesk-db" && item.urn) {
            //If there is a shared property database, remember its location
            self.myPropertyDb = item.urn.substr(0, item.urn.lastIndexOf("/")+1);
        } else if (0 < childCount) {
            for (var i = 0; i < childCount; i++) {
                annotateViews(item.children[i]);
            }
        }
    }
    annotateViews(dataJSON);

    // Traverse the document and populate the parents table (for each node, store its parent id).
    //
    this.parents = {};
    function setParent( itemId, parentId ) {
        self.parents[itemId] = parentId;
    }

    function traverse( data, parentId, func ) {
        if (!data)
            return;

        var itemId = data.guid;
        if (itemId) {
            func.apply(this,[ itemId, parentId ]);

            var len = data.children ? data.children.length : 0;
            for(var i=0; i < len; i++)
            {
                traverse( data.children[i], itemId, func );
            }
        }
    }
    traverse( this.myData, null, setParent );

    if (ENABLE_DEBUG)
    {
        function printItemDBG( key, value, space ) {
            console.log(space + key + " : " + value);
        }

        function traverseDBG( data, printFunc, tabSpace, root ) {
            if (!data)
                return;

            for (var key in data) {
                printFunc.apply(this,[ key, data[key], tabSpace ]);

                if (data[key] !== null && typeof(data[key]) === "object" ) {
                    //going on step down in the object tree!!
                    var space = tabSpace + "    ";
                    traverseDBG( data[key], printFunc, space );
                }
            }
        }
        //traverseDBG( this.myData, printItemDBG, "    " );
    }
};

Autodesk.Viewing.Document.prototype.constructor = Autodesk.Viewing.Document;

/**
 * Static method to load the model data from the cloud.
 *
 *  @example
 *      &lt;script&gt;
 *         // Load the model from the cloud
 *         var urn = 'dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOnRyYW5zbGF0aW9uXzI1X3Rlc3RpbmcvRFdGL0Nhci5kd2Y=';
 *         var seedFile  = "https://viewing-dev.api.autodesk.com/viewingservice/v1/" + urn;
 *         var jsonData = "";
 *         Autodesk.Document.load( seedFile, function( doc ) { jsonData=doc }, function( ) { } );
 *         var model = new Autodesk.Document(jsonData, 'path');
 *         var root  = model.getRootItem(); // top item of the hierarchy of the model data
 *         var item  = model.getItemById( "XXX02UUEs");
 *         var path = model.getFullPath(); // should be 'path'
 *     &lt;/script&gt;
 *
 *  @param {string} seedFile - The cloud urn of the file.
 *  @param {function(object)} onSuccessCallback - A function that is called when load succeeds.
 *  @param {function(int, string)} onErrorCallback - A function that is called when load fails.
 */
Autodesk.Viewing.Document.load = function( documentId, onSuccessCallback, onErrorCallback )
{
    // The function signature was changed and we removed the need for the Auth parameter
    // Check what the second parameter is if its a non function assign the others correctly
    // this will also work in the case of missing arguments
    if (typeof(arguments[1]) !== 'function') {
        console.log("Autodesk.Viewing.Document.load called with deprecated (auth) parameter");
        if (typeof(arguments[2]) === 'function') {
            onSuccessCallback = arguments[2];
        }
        if (typeof(arguments[3]) === 'function') {
            onErrorCallback = arguments[3];
        }
     }

    function getDocumentPath(documentId)
    {
        // Handle local paths explicitly.
        //
        if(documentId.indexOf('urn:') === -1) {
            var relativePath = documentId;
            if(relativePath.indexOf('/') !== 0) {
                relativePath = '/' + relativePath;
            }
            return window.location.protocol + "//" + window.location.host + relativePath;
        }
        return documentId;
    }

    function getViewableCount( modelDocument ) {
        var viewableItems = Autodesk.Viewing.Document.getSubItemsWithProperties(modelDocument.getRootItem(), {'type':'folder','role':'viewable'}, true);
        var root = viewableItems[0];
        var geometryItems = Autodesk.Viewing.Document.getSubItemsWithProperties(root, {'type':'geometry'}, true);
        return geometryItems.length;
    }

    function getGlobalMessages( data ) {
        var result = [];

        var messages = null;
        if (!data || !data.children)
            return result;

        var child = data.children.length === 1 ? data.children[0] : null;
        if (child) {
            messages = child.messages;
        }

        var messageCount = (messages) ? messages.length : 0;
        for (var i=0; i<messageCount; i++){
            result.push(messages[i]);
        }
        return result;
    }

    var documentPath = getDocumentPath(documentId);
    try {
        var vsXhr = new Autodesk.Viewing.Private.ViewingServiceXhr(VIEWING_URL, 'bubbles', {encodeUrn:false});

        function onSuccess(data) {
            var regex = /<[^>]*script/;
            if (regex.test(data)) {
                if (onErrorCallback)
                    onErrorCallback(Autodesk.Viewing.ErrorCodes.BAD_DATA, "Malicious document content detected. Abort loading.");
                return;
            }

            var items = typeof(data) === 'string' ? JSON.parse(data) : data;
            var document = new Autodesk.Viewing.Document(items, documentPath);

            // Check if there are any viewables.
            if (getViewableCount(document) > 0) {
                var messages  = getGlobalMessages( document.getRootItem() );
                if (onSuccessCallback) {
                    onSuccessCallback(document, messages);
                }
            }
            else {
                // If there are no viewables, report an error.
                //
                if (onErrorCallback) {
                    var messages  = getGlobalMessages( document.getRootItem() );
                    var errorCode =  Autodesk.Viewing.ErrorCodes.BAD_DATA_NO_VIEWABLE_CONTENT;
                    var errorMsg  = "No viewable content.";
                    onErrorCallback(errorCode, errorMsg, messages);
                }
            }
        }

        function onFailure(statusCode, statusText, data) {
            var items = typeof(data) === 'string' ? JSON.parse(data) : data;
            var messages  = getGlobalMessages( data );
            if (onErrorCallback) {
                var errorMsg = "Error: " + statusCode + " (" + statusText + ")";
                var errorCode = Autodesk.Viewing.Private.ErrorHandler.getErrorCode(statusCode);
                onErrorCallback(errorCode, errorMsg, messages);
            }
        }

        vsXhr.get(documentPath, onSuccess, onFailure);
    } catch (e) {
        if (onErrorCallback) {
            var errorMsg = "An exception occurred while loading the document: " + e.toString();
            var errorCode = Autodesk.Viewing.ErrorCodes.UNKNOWN_FAILURE;
            onErrorCallback(errorCode, errorMsg, null);
        }
    }
};

/**
 *  Returns the full path to the given urn.
 *  @param {string} urn - the urn of the document
 *  @returns {string}
 */
Autodesk.Viewing.Document.prototype.getFullPath = function(urn)
{

    if (!urn)
        return urn;

	var fullPath = urn;

    // Use the viewing service.
    //
    if(urn.indexOf('urn') === 0)
    {
        fullPath = VIEWING_URL +  "/items/" + urn;
    }
    // Handle local files.
    //
    else if(urn.indexOf('$file$') === 0 && this.myPath.indexOf('/output/bubble.json') !== -1)
    {
        fullPath = this.myPath.replace('/output/bubble.json', '') + urn.replace('$file$', '');
    }
    return fullPath;
};

/**
 *  Returns the path to the thumbnail of the item with the given id.
 *  @param {string} id - the id of the item.
 *  @param {int} width - the requested thumbnail width.
 *  @param {int} height - the requested thumbnail height.
 *  @returns {string}
 */
Autodesk.Viewing.Document.prototype.getThumbnailPath = function(item, width, height)
{
    var requestedWidth = width ? width : 200;
    var requestedHeight = height ? height : 200;
    return VIEWING_URL + "/thumbnails/" + this.myData.urn + "?guid=" + encodeURIComponent(item.guid) + "&width=" + requestedWidth + "&height=" + requestedHeight;
};

/**
 *  Returns the path to the viewable of the given item.
 *  @param {Object} item - the item whose viewable is requested.
 *  @returns {string}
 */
Autodesk.Viewing.Document.prototype.getViewablePath = function(item)
{
    if(item.type === 'geometry') {
        var items = [];
        if(item.role === '3d') {
            items = Autodesk.Viewing.Document.getSubItemsWithProperties(item, {
                'mime': 'application/autodesk-svf'
            }, false);
        }
        else if(item.role === '2d') {
            // first check for vector and if does not exist for tiles.
            items = Autodesk.Viewing.Document.getSubItemsWithProperties(item, {
                'mime': 'application/autodesk-f2d'
            }, false);

            // old file does not have f2d yet - so load tile viewer
            if (items.length == 0) {
                items = Autodesk.Viewing.Document.getSubItemsWithProperties(item, {
                    'role': 'tileRoot'
                }, true);
            }
        }
        if(items.length > 0)
        {
            return this.getFullPath(items[0].urn);
        }
    }
    else if(item.type === 'view') {
        var geometryItem = this.getViewGeometry(item);
        if (geometryItem) {
            return this.getViewablePath(geometryItem);
        }
    }

    return '';
};

/**
 * Returns the root path to a shared (across all sheets/views) property database's json files.
 * @returns {string}
 */
Autodesk.Viewing.Document.prototype.getPropertyDbPath = function()
{
    return this.myPropertyDb;
};

/**
 *  Returns the root of the model data hierarchy.
 *  @returns {Object}
 */
Autodesk.Viewing.Document.prototype.getRootItem = function()
{
    return this.myData;
};

/**
 *  Returns the id of this document.
 *  @returns {string}
 */
Autodesk.Viewing.Document.prototype.getPath = function()
{
    return this.myPath;
};

/**
 * Returns an item from the model data hierarchy with the given id.
 * If the item is not found, null object is returned.
 *
 *  @param {string} id  - an id of the item to be found.
 *  @returns {Object} - item with a given id.
 */
Autodesk.Viewing.Document.prototype.getItemById = function(id)
{
    function traverse( data ) {
        if (!data)
            return null;

        for (var key in data) {
            var val = data[key];
            if ( key === 'guid' && val === id )
                return data;

            if (val !== null && typeof(val) === "object") {
                //going on step down in the object tree!!
                var item = traverse( val );
                if (item)
                    return item;
            }
        }
        return null;
    }
    return traverse( this.myData );
};

/**
 * Static method that returns an array of all items with given properties.
 *
 *  @param {string} item - the document node to begin searching from.
 *  @param {string} properties - the properties to search for. 
 *  @param {bool} recursive - if true, searches recursively
 *  @returns {Object} - list of items that have given properties.
 *  
 *  @example
 *  // search the document starting from the root element for all 2d geometry items
  geometryItems = Autodesk.Document.getSubItemsWithProperties(adocument.getRootItem(), {
                        'type' : 'geometry',
                        'role' : '2d'
                    }, true);
 */
Autodesk.Viewing.Document.getSubItemsWithProperties = function(item, properties, recursive)
{
  var subItems = [];
  if(!item) return [];

  function hasProperties(item, properties)
  {
    for(var p in properties)
    {
      if (!(p in item) || (properties[p] !== item[p]))
        return false;
    }
    return true;
  }

  var len = item.children ? item.children.length : 0;
  for(var i=0; i < len; i++)
  {
    // Check if this child has this key and value.
    //
    var child = item.children[i];
    if(hasProperties(child, properties))
    {
      subItems.push(child);
    }

    // Search the descendants if requested.
    //
    if(recursive)
    {
      subItems.push.apply(subItems, Autodesk.Viewing.Document.getSubItemsWithProperties(child, properties, recursive));
    }
  }
  return subItems;
};

/**
 * Return the parent geometry item for a given view item
 * @param {Object} item - view item
 * @returns {Object} The parent geometry item
 */
Autodesk.Viewing.Document.prototype.getViewGeometry = function (item) {
    return this.myViewGeometry[item.guid];
};

/**
 * Return the number of view items underneath a geometry item.
 * @param {Object} item - geometry item
 * @returns {number} The number of view items underneath the geometry item.
 */
Autodesk.Viewing.Document.prototype.getNumViews = function (item) {
    return this.myNumViews[item.guid] || 0;
};

/**
 * Return parent id of the given item.
 * @param {string} itemId - guid of the item.
 * @returns {string}
 */
Autodesk.Viewing.Document.prototype.getParentId = function (itemId) {
    return this.parents[itemId];
};


/**
 * Return messages (error and warning messages) associated with a given item. It includes
 * item's messages as well as messages of all its parents.
 *
 * @param {string} itemId - guid of the item.
 * @param {bool} - if true the top messages that apply to the whole file are excluded.
 * @returns {Object} - returns an array of messages.
 */
Autodesk.Viewing.Document.prototype.getMessages = function( itemId, excludeGlobal ) {

    var messages = [];
    if (!itemId)
        return messages;

    var rootId = null;
    if (excludeGlobal)
        rootId = this.getRootItem().guid;

    var currentId = itemId;
    var parentId  = this.parents[currentId];
    while (currentId) {
        if (excludeGlobal && parentId===rootId)
            break;

        var currentItem = this.getItemById( currentId );
        if (currentItem && currentItem.messages) {
            for (var i=0; i<currentItem.messages.length; i++){
                messages.push( currentItem.messages[i] );
            }
        }
        currentId = parentId;
        parentId = this.parents[currentId];
    }
    return messages;
};;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

/**
 * This is the Tessera document API for design content.
 * @ignore
 */
AutodeskNamespace('Autodesk.Viewing');

Autodesk.Viewing.ModelUnits = {
    METER       : 'm',
    CENTIMETER  : 'cm',
    MILLIMETER  : 'mm',
    FOOT        : 'ft',
    INCH        : 'in'
};

/**
 * This is the core class to represent the geometry.
 * @class
 * 
 */
Autodesk.Viewing.Model = function( modelData )
{
    this.myData = modelData;

    this.sharedPath = null;
    this.propWorker = null;

    // TODO: remove it once we move some of the worker stuff here.
    this.myLoader = null;
};

Autodesk.Viewing.Model.prototype = Object.create(THREE.EventDispatcher.prototype);
Autodesk.Viewing.Model.prototype.constructor = Autodesk.Viewing.Model;

/**
 * Set the geometry data.
 *  @param {Object} data - data that represents the geometry.
 */
Autodesk.Viewing.Model.prototype.setData = function( data )
{
    this.myData = data;
};

/**
 * Returns the geometry data.
 */
Autodesk.Viewing.Model.prototype.getData = function()
{
    return this.myData;
};

/**
 * Returns the geometry data.
 */
Autodesk.Viewing.Model.prototype.setLoader = function( loader )
{
    this.myLoader = loader;
};

/**
 * Returns the root of the geometry node graph.
 */
Autodesk.Viewing.Model.prototype.getRoot = function()
{
    if (this.myData)
        return this.myData.instanceTree;
    return null;
};

/**
 * Returns the root of the geometry node graph.
 */
Autodesk.Viewing.Model.prototype.getRootId = function()
{
    if (this.myData && this.myData.instanceTree)
        return this.myData.instanceTree.dbId;
    return null;
};


/**
* Returns the bounding box of the model.
*/
Autodesk.Viewing.Model.prototype.getBoundingBox = function()
{
    if (this.myData)
        return this.myData.bbox;
    return null;
};


/**
 * Returns the scale factor of model's distance unit to meters.
 * Returns unity in case the units are not known.
 */
Autodesk.Viewing.Model.prototype.getUnitScale = function()
{
    var unit = this.getMetadata('distance unit', 'value', null);

    //Why are translators not using standard strings for those?!?!?!?
    switch (unit) {
        case 'meter'      :
        case 'm'          : return 1.0;
        case 'foot'       :
        case 'ft'         : return 0.3048;
        case 'inch'       :
        case 'in'         : return 0.0254;
        case 'centimeter' :
        case 'cm'         : return 0.01;
        case 'millimeter' :
        case 'mm'         : return 0.001;
        default: return 1.0;
    }
};

/**
 * Returns a standard string representation of the model's distance unit.
 * Returns null if the unit is not known.
 */
Autodesk.Viewing.Model.prototype.getUnitString = function() {
    var unit = this.getMetadata('distance unit', 'value', null);

    //Why are translators not using standard strings for those?!?!?!?
    switch (unit) {
        case 'meter'      :
        case 'm'          : return Autodesk.Viewing.ModelUnits.METER;
        case 'foot'       :
        case 'ft'         : return Autodesk.Viewing.ModelUnits.FOOT;
        case 'inch'       :
        case 'in'         : return Autodesk.Viewing.ModelUnits.INCH;
        case 'centimeter' :
        case 'cm'         : return Autodesk.Viewing.ModelUnits.CENTIMETER;
        case 'millimeter' :
        case 'mm'         : return Autodesk.Viewing.ModelUnits.MILLIMETER;
        default: return null;
    }
};


/**
 * Returns the node with the given id.
 */
Autodesk.Viewing.Model.prototype.getNodeById = function( id )
{
    function traverse( node ) {
        if (!node)
            return null;

        //console.log("\t\t ## traversing: ", node.dbId, "   searching for:", id );
        if (node.dbId && node.dbId === id )
            return node;

        if (node.children && node.children.length > 0) {
            for (var index=0; index<node.children.length; index++) {
                var foundNode = traverse( node.children[index] );
                if (foundNode)
                    return foundNode;
            }
        }
        return null;
    }
    return traverse( this.getRoot() );
};

Autodesk.Viewing.Model.prototype.getNodesByIds = function(nodeIDArray) {
    // newNodeArray will eventually be destroyed by the recursive function
    // so we must copy it to not ruin the callers data.
    var newNodeArray = nodeIDArray.slice(0);

    function recursiveGetNodeByID(array, node, list) {
        if (array.length === 0) {
            return list;
        }

        var nodeIDIndex = array.indexOf(node.dbId);
        if (nodeIDIndex !== -1) {
            list.push(node);
            array.splice(nodeIDIndex, 1);
        }

        if (node.children) {
            for (var i=0; i < node.children.length; i++) {
                recursiveGetNodeByID(array, node.children[i], list);
            }
        }
        return list;
    }

    return recursiveGetNodeByID(newNodeArray, this.getRoot(), []);
};

Autodesk.Viewing.Model.prototype.getNodeFragments = function(nodeId, resultArray) {

    var node = this.getNodeById(nodeId);

    function pushToFragIds(dbNode, res) {
        var ids = dbNode.fragIds;
        if (ids !== undefined) {
            if (!Array.isArray(ids))
                ids = [ids]; //could be just single fragment index in the node, in which case it's not an array

            for (var j = 0; j < ids.length; ++j) {
                res.push(ids[j]);
            }
        }

        if (dbNode.children) {
            for (var k = 0; k < dbNode.children.length; k++) {
                pushToFragIds(dbNode.children[k], res);
            }
        }
    }

    pushToFragIds(node, resultArray);
};

/**
 * Return metadata value.
 * @param {string} itemName - metadata item name
 * @param {string=} [subitemName] - metadata subitem name
 * @param {*} [defaultValue] - default value
 * @returns {*} metadata value, or defaultValue if no metadata or metadata item/subitem does not exist
 */
Autodesk.Viewing.Model.prototype.getMetadata = function (itemName, subitemName, defaultValue) {
    if (this.myData) {
        var metadata = this.myData.metadata;
        if (metadata) {
            var item = metadata[itemName];
            if (item !== undefined) {
                if (subitemName) {
                    var subitem = item[subitemName];
                    if (subitem !== undefined) {
                        return subitem;
                    }
                } else {
                    return item;
                }
            }
        }
    }
    return defaultValue;
};

/*
Autodesk.Viewing.Model.prototype.displayMetadata = function () {
    console.log('metadata:');
    if (this.myData) {
        var metadata = this.myData.metadata;
        if (metadata) {
            for (itemName in metadata) {
                if (metadata.hasOwnProperty(itemName)) {
                    console.log('  ' + itemName);
                    var item = metadata[itemName];
                    if (item) {
                        for (subItemName in item) {
                            if (item.hasOwnProperty(subItemName)) {
                                console.log('    ' + subItemName + '=' + JSON.stringify(item[subItemName]));
                            }
                        }
                    }
                }
            }
        }
    }
};
*/

/**
 * Returns the default camera.
 */
Autodesk.Viewing.Model.prototype.getDefaultCamera = function() {

    var myData = this.myData;

    if (!myData)
        return null;

    var defaultCamera = null;
    var numCameras = myData.cameras ? myData.cameras.length : 0;
    if (0 < numCameras) {
        // Choose a camera.
        // Use the default camera if specified by metadata.
        //
        var defaultCameraIndex = this.getMetadata('default camera', 'index', null);
        if (defaultCameraIndex !== null && myData.cameras[defaultCameraIndex]) {
            defaultCamera = myData.cameras[defaultCameraIndex];

        } else {

            // No default camera. Choose a perspective camera, if any.
            //
            for (var i = 0; i < numCameras; i++) {
                var camera = myData.cameras[i];
                if (camera.isPerspective) {
                    defaultCamera = camera;
                    break;
                }
            }

            // No perspective cameras, either. Choose the first camera.
            //
            if (!defaultCamera) {
                defaultCamera = myData.cameras[0];
            }
        }
    }

    return defaultCamera;
};

/**
 * Returns up vector as an array of 3
 */
Autodesk.Viewing.Model.prototype.getUpVector = function() {
    return this.getMetadata('world up vector', 'XYZ', null);
};

/**
 * Returns the polygon count.
 * @returns {?number}
 */
Autodesk.Viewing.Model.prototype.geomPolyCount = function() {

    if (!this.myData)
        return null;

    return this.myData.geomPolyCount;
};

/**
 * Returns the instanced polygon count.
 * @returns {?number}
 */
Autodesk.Viewing.Model.prototype.instancePolyCount = function() {

    if (!this.myData)
        return null;

    return this.myData.instancePolyCount;
};


/**
 * Returns the root of the layers tree.
 * @returns {?Object}
 */
Autodesk.Viewing.Model.prototype.getLayersRoot = function () {
    return this.myData ? this.myData.layersRoot : null;
};

/**
 * Returns true if the model represents a 2D drawings, false otherwise.
 * @returns {boolean}
 */
Autodesk.Viewing.Model.prototype.is2d = function() {

    return this.myData && this.myData.is2d;
};

/**
 * Returns true if the model with all its geometries has loaded.
 * @returns {boolean}
 */
Autodesk.Viewing.Model.prototype.isLoadDone = function() {

    return this.myData && this.myData.loadDone;
};

/**
 * Returns true if the frag to node id mapping is done.
 * @returns {boolean}
 */
Autodesk.Viewing.Model.prototype.isObjectTreeCreated = function() {

    return this.myData && this.myData.fragToNodeDone;
};


/**
 * Returns object properties.
 *
 *  @param {int} dbId - id of the node to return the properties for.
 *  @param {function} onSuccessCallback - this method that is called when request for property db succeeds.
 *  @param {function} onErrorCallback - this method that is called when request for property db fails.
 */
Autodesk.Viewing.Model.prototype.getProperties = function( dbId, onSuccessCallback, onErrorCallback )
{
    if (!this.myData || !this.myLoader)
        return;

    this.myLoader.getProperties( dbId, onSuccessCallback, onErrorCallback );
};

/**
 * Returns object tree.
 *
 *  @param {function} onSuccessCallback - this method that is called when request for object tree succeeds.
 *  @param {function} onErrorCallback - this method that is called when request for object tree fails.
 */
Autodesk.Viewing.Model.prototype.getObjectTree = function( onSuccessCallback, onErrorCallback )
{
    if (!this.myData || !this.myLoader)
        return;

    this.myLoader.getObjectTree( onSuccessCallback, onErrorCallback );
};

/**
 * Returns search results.
 *
 *  @param {string} text - the search term.
 *  @param {function} onSuccessCallback - this method that is called when request for search succeeds.
 *  @param {function} onErrorCallback - this method that is called when request for search fails.
 */
Autodesk.Viewing.Model.prototype.search = function(text, onSuccessCallback, onErrorCallback)
{
    var self = this;
    if (this.isLoadDone()) {
        this.myLoader.searchProperties(text, onSuccessCallback, onErrorCallback);
    } else {
        this.getObjectTree( function(tree) {
            self.myLoader.searchProperties(text, onSuccessCallback, onErrorCallback);
        });
    }

};
;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */

/**
 * This is the Tessera navigation API for design content.
 * @ignore
 */
AutodeskNamespace('Autodesk.Viewing');

/**
 * This is the core interface to camera controls and navigation. The active navigation object can normally be obtained from the "navigation" property of the Viewer3D instance. Client implementations should not normally instantiate this class directly.
 *  @class
 *  @param {THREE.Camera} camera - The main camera object used to render the scene.
 *  @constructor
 */
Autodesk.Viewing.Navigation = function(camera)
{
    var kMinFOV  = 6.88; // 200 mm
    var kMaxFOV  = 100;  // 10 mm
    var kEpsilon = 0.000001;

    this.__options = {
        dollyToPivot: false,
        orbitPastPoles: true,
        reverseDolly: false,
        reverseHorizontalLook: false,
        reverseVerticalLook: false,
        useLeftHandedInput: false,
        usePivotAlways: false,
        lockNavigation: false
    };

    this.__pivotIsSetFlag = false;
    this.__fitToViewRequested = false;
    this.__homeViewRequested = false;
    this.__transitionActive = false;
    this.__destinationView = null;
    this.__is2D = false;
    this.__isTouchDevice = false;
    this.__kEpsilon = kEpsilon;

    var _camera = null;
    var _projector = new THREE.Projector();

    var _viewport = { left: 0, top: 0, width: 1, height: 1 };

    this.uninitialize = function()
    {
        this.setCamera(null);
    };

    /**
     * Set or unset the current camera used for navigation. Normally set via the constructor.
     * The camera should be of type Autodesk.Viewing.UnifiedCamera.
     *  @param {THREE.Camera} camera - the current camera object.
     */
    this.setCamera = function(camera)
    {
        if( camera !== _camera )
        {
            _camera = camera;
            if( camera )
            {
                if( !camera.hasOwnProperty("target") )
                    camera.target = new THREE.Vector3(0, 0, 0);

                if( !camera.hasOwnProperty("pivot") )
                    camera.pivot = new THREE.Vector3(0, 0, 0);

                camera.worldup = camera.up.clone();  // Initial assumption!!
                camera.dirty = true;
            }
        }
    };

    /**
     *  @returns {THREE.Camera} - the current camera object.
     */
    this.getCamera = function()
    {
        return _camera;
    };

    /**
     * Set the current canvas viewport in screen coordinates.
     * Invoked internally on canvas resize.
     *  @param {Object} viewport - Rectangle with properties left, top, width, height.
     */
    this.setScreenViewport = function( viewport )
    {
        _viewport = viewport;
    };

    /**
     * Get the current canvas viewport in screen coordinates.
     *  @returns {Object} with properties left, top, width, height.
     */
    this.getScreenViewport = function()
    {
        return _viewport;
    };

    this.__setUp = function(up)
    {
        if( up && _camera )
        {
            var upCheck = up.clone().normalize();
            var diff = upCheck.sub( _camera.worldup );
            if( diff.lengthSq() !== 0.0 )
            {
                _camera.worldup.copy(up).normalize();
                _camera.dirty = true;
                return true;
            }
        }
        return false;
    };

    this.__getUp = function()
    {
        return _camera ? _camera.worldup : new THREE.Vector3(0, 1, 0);
    };

    this.__getProjector = function()
    {
        return _projector;
    };

    /**
     * Sets the cameras position and view direction.
     *  @param {THREE.Vector3} position - the new position for the camera in world space.
     *  @param {THREE.Vector3} target - the point in world space that the camera should look towards.
     */
    this.setView = function( position, target )
    {
        if( _camera && position && target && !this.__options.lockNavigation )
        {
            _camera.position.copy(position);
            _camera.target.copy(target);
            _camera.dirty = true;
        }
    };

    /**
     * Orient the camera's up direction with the current world up direction
     */
    this.orientCameraUp = function()
    {
        if( _camera && !this.__options.lockNavigation )
        {
            _camera.up.copy(this.getAlignedUpVector()); // New up aligned with world up
            _camera.dirty = true;
        }
    };

    /**
     *  @returns {THREE.Vector3} the world space position of the pivot point for orbit navigation.
     */
    this.getPivotPoint = function()
    {
        return _camera ? _camera.pivot.clone() : new THREE.Vector3(0, 0, 0);
    };

    /**
     * Sets the Vector3 world space position of the pivot point for orbit navigation.
     *  @param {THREE.Vector3} pivot - the new pivot position.
     */
    this.setPivotPoint = function( pivot )
    {
        if( _camera && pivot && !this.__options.lockNavigation )
        {
            _camera.pivot.copy(pivot);
            _camera.dirty = true;
        }
    };

    /**
     *  @returns {THREE.Vector3} the world space position of the camera.
     */
    this.getPosition = function()
    {
        return _camera ? _camera.position.clone() : new THREE.Vector3(0, 0, 1);
    };

    /**
     * Sets the Vector3 world space position of camera.
     *  @param {THREE.Vector3} pos - the new camera position.
     */
    this.setPosition = function( pos )
    {
        if( _camera && pos && !this.__options.lockNavigation )
        {
            _camera.position.copy(pos);
            _camera.dirty = true;
        }
    };

    /**
     * Sets the Vector3 world space position towards which the camera should be pointing.
     *  @param {THREE.Vector3} target - the new camera look at point.
     */
    this.setTarget = function(target)
    {
        if( _camera && target && !this.__options.lockNavigation )
        {
            _camera.target.copy(target);
            _camera.dirty = true;
        }
    };

    /**
     *  @returns {THREE.Vector3} the world space position towards which the camera is pointing.
     */
    this.getTarget = function()
    {
        return _camera ? _camera.target.clone() : new THREE.Vector3(0, 0, 0);
    };

    /**
     * Get the current camera view vector. This vector is not normalized and its
     * length is the distance between the camera position and the camera look at point.
     *  @returns {THREE.Vector3} the current camera view vector in world space.
     */
    this.getEyeVector = function ()
    {
        return _camera ? _camera.target.clone().sub( _camera.position ) : new THREE.Vector3(0, 0, -1);
    };

    /**
     *  @returns {number} the minimum allowed vertical field of view in degrees.
     */
    this.getFovMin = function()
    {
        return kMinFOV;
    };

    /**
     *  @returns {number} the maximum allowed vertical field of view in degrees.
     */
    this.getFovMax = function()
    {
        return kMaxFOV;
    };

    /**
     * Set the current vertical field of view.
     *  @param {number} fov - the new field of view in degrees (value is clamped to the minimum and maximum field of view values).
     *  @param {boolean} adjustPosition - If true the camera position will be modified to keep the world space area of view at the camera look at point unchanged.
     */
    this.setVerticalFov = function(fov, adjustPosition)
    {
        // If camera is not perspective don't allow fov change
        if( _camera && !_camera.isPerspective)
            return;

        if( fov < kMinFOV ) fov = kMinFOV;
        else if( fov > kMaxFOV ) fov = kMaxFOV;

        if( _camera && !this.__options.lockNavigation )
        {
            if( Math.abs(_camera.fov - fov)  <= kEpsilon )
                return;

            if( adjustPosition )
            {
                var eye = this.getEyeVector();

                var oldFOV = THREE.Math.degToRad(_camera.fov);
                var newFOV = THREE.Math.degToRad(fov);

                var distance = eye.length() * Math.tan(oldFOV * 0.5) / Math.tan(newFOV * 0.5);
                var moveDirection = eye.multiplyScalar(-1).normalize();

                this.setPosition( this.getTarget().add(moveDirection.multiplyScalar(distance)) );
            }
            // stderr("FOV " + _camera.fov.toFixed(3) + " => " + fov.toFixed(3));
            _camera.setFov(fov);
            _camera.dirty = true;
        }
    };

    /**
     * Compute camera position and look at point which will fit the given bounding box in the view frustum at the given field of view angle.
     *  @param {THREE.Vector3} oldpos - existing camera position
     *  @param {THREE.Vector3} oldcoi - existing camera look at point
     *  @param {number} fov - field of view to use for fit calculation in degrees
     *  @param {THREE.Box3} bounds - bounding box to fit
     *  @returns {Object} Object with properties "position" and "target".
     */
    this.computeFit = function(oldpos, oldcoi, fov, bounds)
    {
        if( !bounds || bounds.empty() )
            return {position: oldpos, target: oldcoi};

        var coi  = bounds.center();
        var size = bounds.size();
        var radius = 0.5 * Math.sqrt(size.x*size.x + size.y*size.y + size.z*size.z);
        if( radius === 0.0 )
            radius = 1.0;

        if( !this.getIs2D() )
        {
            // For wide angle views the fit is often too tight because of perspective
            // distortion, so fudge the radius based on the FOV...
            var fovFudge = Math.max(1.0, 0.9 + fov / kMaxFOV * 0.5);
            radius *= fovFudge;
        }
        var eye = oldpos.clone().sub(oldcoi).normalize();
        var fitToViewDistance = radius / Math.tan(THREE.Math.degToRad(fov * 0.5));
        eye.multiplyScalar( fitToViewDistance );

        var pos = coi.clone().add( eye );
        return {position: pos, target: coi};
    };

    /**
     * Compute a vector which is orthogonal to the given view and aligned with the world up direction.
     *  @param {THREE.Vector3} pos - view position
     *  @param {THREE.Vector3} coi - center of interest (view look at point)
     *  @returns {THREE.Vector3} up direction orthogonal to the given view
     */
    this.computeOrthogonalUp = function(pos, coi)
    {
        var worldUp = this.__getUp();
        var eye = coi.clone().sub(pos);
        if( eye.lengthSq() === 0.0 )    // Invalid view?
            return eye.copy(worldUp);

        var right = eye.clone().cross(worldUp);
        if( right.lengthSq() === 0 )
        {
            // If eye and up are colinear, perturb eye
            // to get a valid result:
            if( worldUp.z > worldUp.y )
                eye.y -= 0.0001;
            else
                eye.z -= 0.0001;

            right.crossVectors( eye, worldUp );
        }
        return right.cross(eye).normalize();
    };

    /**
     * Causes the current camera position to be changed in order to fit the given bounds into the current view frustum.
     *  @param {boolean} immediate - if false the camera position will animate to the new location.
     *  @param {THREE.Box3} bounds - bounding box to fit
     *  @param {boolean} reorient - if true the camera up direction will be reoriented with the world up.
     *  @returns {Object} Object with properties "position" and "target".
     */
    this.fitBounds = function(immediate, bounds, reorient)
    {
        var oldcoi = this.getTarget();
        var pos    = this.getPosition();

        if( this.__options.lockNavigation || !bounds || bounds.empty() )
            return {position: pos, target: oldcoi};

        var fov = this.getVerticalFov();
        var fit = this.computeFit(pos, oldcoi, fov, bounds);
        var up  = reorient ? this.computeOrthogonalUp(pos, oldcoi) : _camera.up;

        if( immediate )
        {
            _camera.up.copy(up);
            this.setView(fit.position, fit.target);
        }
        else
        {
            this.setRequestTransitionWithUp( true, fit.position, fit.target, fov, up );
        }
        this.setPivotPoint(fit.target);
        this.setPivotSetFlag(true);

        return fit;
    };


    /**
     * Update the current camera projection matrix and orient the camera to the current look at point.
     * Invoked internally prior to rendering a new frame with the current camera.
     */
    this.updateCamera = function()
    {
        if( _camera )
        {
            _camera.updateProjectionMatrix();
            this.orient( _camera, _camera.target, _camera.position, _camera.up );
            _camera.dirty = false;
        }
    };

    this.setCamera(camera);
};

Autodesk.Viewing.Navigation.prototype.constructor = Autodesk.Viewing.Navigation;


Autodesk.Viewing.Navigation.prototype.setIs2D = function( state )
{
    this.__is2D = !!state;
};

Autodesk.Viewing.Navigation.prototype.getIs2D = function()
{
    return this.__is2D;
};

Autodesk.Viewing.Navigation.prototype.setIsTouchDevice = function( state )
{
    this.__isTouchDevice = !!state;
};

Autodesk.Viewing.Navigation.prototype.getIsTouchDevice = function()
{
    return this.__isTouchDevice;
};

/**
 * Rotate the given object so that its negative Z axis is directed towards the given point in world space. Used internally to orient the camera towards the target look at point. This is a modified version of the Object3D.lookAt method that uses different solution for the singular case when (view X up) == 0.
 *  @method
 *  @param {THREE.Object3D} object - the object to be oriented
 *  @param {THREE.Vector3} target - the world space point to orient towards
 *  @param {THREE.Vector3} from - the world space position of the object being rotated
 *  @param {THREE.Vector3} up - the direction to align the objects Y axis with
 */
Autodesk.Viewing.Navigation.prototype.orient = function()
{
    var m1 = new THREE.Matrix4();
    var x = new THREE.Vector3();
    var y = new THREE.Vector3();
    var z = new THREE.Vector3();

    return function ( object, target, from, up )
    {
        var te = m1.elements;

        z.subVectors( from, target ).normalize();
        if ( z.lengthSq() === 0 ) {
            z.z = 1;
        }
        x.crossVectors( up, z ).normalize();
        if ( x.lengthSq() === 0 ) {
            // If Z is up then cross with Y to get X
            // otherwize cross with Z to get X.
            if( up.z > up.y )
                z.y -= 0.0001;
            else
                z.z += 0.0001;

            x.crossVectors( up, z ).normalize();
        }
        y.crossVectors( z, x );

        te[0] = x.x; te[4] = y.x; te[8] = z.x;
        te[1] = x.y; te[5] = y.y; te[9] = z.y;
        te[2] = x.z; te[6] = y.z; te[10] = z.z;

        object.setRotationFromMatrix( m1 );
    };
}();

/**
 * Convert a vertical field of view angle in degrees to a 35mm camera focal length value.
 *  @param {number} fov - vertical field of view in degrees
 *  @returns {number} focal length in millimeters
 */
Autodesk.Viewing.Navigation.prototype.fov2fl = function ( fov )
{
    // Note: the size of the 35mm camera back is 36x24mm.  Since we are setting and
    // getting the vertical FOV, we need to use the vertical measurement of 24mm, or
    // rather half of that (12.0) in our calculations.
    var k35mmVerticalCameraBackSize = 12.0;

    // Given a vertical field-of-view, return the focal length in millimeters
    // that it corresponds to in a 35mm film camera.
    var rads = THREE.Math.degToRad(fov);
    if (rads <= 0.0)
        rads = 0.0001;
    return Math.round( k35mmVerticalCameraBackSize / Math.tan(rads * 0.5) );
};

/**
 * Convert a 35mm camera focal length value to a vertical field of view angle in degrees.
 *  @param {number} fl - focal length in millimeters
 *  @returns {number} vertical field of view in degrees
 */
Autodesk.Viewing.Navigation.prototype.fl2fov = function ( fl )
{
    // Note: the size of the 35mm camera back is 36x24mm.  Since we are setting and
    // getting the vertical FOV, we need to use the vertical measurement of 24mm, or
    // rather half of that (12.0) in our calculations.
    var k35mmVerticalCameraBackSize = 12.0;

    // Given a focal length, return the vertical field of view that
    // this would correspond to in a 35mm camera.
    if (fl <= 0)
        fl = 0.0001;

    var rads = 2.0 * Math.atan(k35mmVerticalCameraBackSize / fl);
    return THREE.Math.radToDeg(rads);
};

/**
 * Set the up direction for the camera. The given vector should be orthogonal to the current view direction.
 *  @method
 *  @param {THREE.Vector3} up - the new up direction vector
 */
Autodesk.Viewing.Navigation.prototype.setCameraUpVector = function(up)
{
    if( !this.__options.lockNavigation )
    {
        var camera = this.getCamera();
        camera.up.copy(up);
        camera.dirty = true;
    }
};

/**
 * Get the world space vector which is the current cameras up direction.
 *  @method
 *  @returns {THREE.Vector3} the current camera up direction (normalized)
 */
Autodesk.Viewing.Navigation.prototype.getCameraUpVector = function()
{
    var right = this.getCameraRightVector(false);
    var eye   = this.getEyeVector();
    return right.cross(eye).normalize();
};

/**
 * Get the world space vector which is the orthogonal to the view direction and aligned with the world up direction.
 *  @method
 *  @returns {THREE.Vector3} the current camera up direction (normalized)
 */
Autodesk.Viewing.Navigation.prototype.getAlignedUpVector = function()
{
    var right = this.getCameraRightVector(true);
    var eye   = this.getEyeVector();
    return right.cross(eye).normalize();
};

/**
 * Get the world space vector which is the right side direction of the current camera.
 *  @method
 *  @param {boolean} worldAligned - if true get the right vector aligned with the world up, otherwise use the current camera's up direction.
 *  @returns {THREE.Vector3} the current camera right direction, orthogonal to view and up (normalized)
 */
Autodesk.Viewing.Navigation.prototype.getCameraRightVector = function(worldAligned)
{
    var right = new THREE.Vector3();
    var up  = worldAligned ? this.getWorldUpVector() : this.getCamera().up;
    var eye = this.getEyeVector();
    right.crossVectors(eye, up);
    if( right.lengthSq() === 0 )
    {
        // If eye and up are colinear, perturb eye
        // to get a valid result:
        if( up.z > up.y )
            eye.y -= 0.0001;
        else
            eye.z += 0.0001;

        right.crossVectors(eye, up);
    }
    return right.normalize();
};

/**
 * Change the current world up direction.
 *  @param {THREE.Vector3} up - the new world up direction
 *  @param {boolean} reorient - if true, make sure the camera up is oriented towards the world up direction.
 */
Autodesk.Viewing.Navigation.prototype.setWorldUpVector = function(up, reorient)
{
    if( !this.__options.lockNavigation )
    {
        this.__setUp(up);

        if( reorient )
            this.orientCameraUp();
    }
};

/**
 * Get the current world up direction.
 *  @returns {THREE.Vector3} the current world up direction (normalized)
 */
Autodesk.Viewing.Navigation.prototype.getWorldUpVector = function()
{
    return this.__getUp().clone();
};

/**
 * Compute a world right direction based on the current world up direction. This will return the normalized cross product of the current up direction with one of the major axes to provide a usable world right direction.
 *  @method
 *  @returns {THREE.Vector3} the computed world right direction
 */
Autodesk.Viewing.Navigation.prototype.getWorldRightVector = function()
{
    var right = new THREE.Vector3();
    right.copy(this.__getUp());

    if (Math.abs(right.z) <= Math.abs(right.y))
    {
        // Cross(Vertical, ZAxis)
        right.set(right.y, -right.x, 0);
    }
    else if (right.z >= 0)
    {
        // Cross(YAxis, Vertical)
        right.set(right.z, 0, -right.x);
    }
    else
    {
        // Cross(Vertical, YAxis)
        right.set(-right.z, 0, right.x);
    }
    return right.normalize();
};

/**
 *  @returns {number} the current camera vertical field of view in degrees
 */
Autodesk.Viewing.Navigation.prototype.getVerticalFov = function()
{
    return this.getCamera().fov;
};

/**
 *  @returns {number} the current camera horizontal field of view in degrees
 */
Autodesk.Viewing.Navigation.prototype.getHorizontalFov = function()
{
    var viewport = this.getScreenViewport();
    return this.getCamera().fov * (viewport.width / viewport.height);
};

/**
 *  @returns {number} the current camera focal length based on a 35mm camera lens model
 */
Autodesk.Viewing.Navigation.prototype.getFocalLength = function()
{
    return this.fov2fl(this.getVerticalFov());
};

/**
 * Set the current cameras field of view using a 35mm camera focal length value
 *  @param {number} millimeters - focal length in millimeters
 *  @param {boolean} adjustPosition - If true the camera position will be modified to keep the world space area of view at the camera look at point unchanged.
 */
Autodesk.Viewing.Navigation.prototype.setFocalLength = function(millimeters, adjustPosition)
{
    this.setVerticalFov(this.fl2fov(millimeters), adjustPosition);
};

/**
 * Set or unset a view navigation option to reverse the default direction for camera dolly (zoom) operations.
 *  @param {boolean} state - value of the option, true for reverse, false for default
 */
Autodesk.Viewing.Navigation.prototype.setReverseZoomDirection = function( state )
{
    this.__options.reverseDolly = !!state;
};

/**
 * Set or unset a view navigation option to reverse the default direction for horizontal look operations.
 *  @param {boolean} state - value of the option, true for reverse, false for default
 */
Autodesk.Viewing.Navigation.prototype.setReverseHorizontalLookDirection = function( state )
{
    this.__options.reverseHorizontalLookDirection = !!state;
};

/**
 * Set or unset a view navigation option to reverse the default direction for vertical look operations.
 *  @param {boolean} state - value of the option, true for reverse, false for default
 */
Autodesk.Viewing.Navigation.prototype.setReverseVerticalLookDirection = function( state )
{
    this.__options.reverseVerticalLookDirection = !!state;
};

/**
 * Get the state of the view navigation option which requests the reversal of the default direction for camera dolly (zoom) operations.
 *  @returns {boolean} - value of the option, true for reverse, false for default
 */
Autodesk.Viewing.Navigation.prototype.getReverseZoomDirection = function()
{
    return this.__options.reverseDolly;
};

/**
 * Get the state of the view navigation option which requests the reversal of the default horizontal look direction
 *  @returns {boolean} value of the option, true for reverse, false for default
 */
Autodesk.Viewing.Navigation.prototype.getReverseHorizontalLookDirection = function()
{
    return this.__options.reverseHorizontalLookDirection;
};

/**
 * Get the state of the view navigation option which requests the reversal of the default vertical look direction
 *  @returns {boolean} value of the option, true for reverse, false for default
 */
Autodesk.Viewing.Navigation.prototype.getReverseVerticalLookDirection = function()
{
    return this.__options.reverseVerticalLookDirection;
};

/**
 * Set or unset a view navigation option to request the default direction for camera dolly (zoom) operations to be towards the camera pivot point. If unset the default direction would normally be towards the cursor position.
 *  @param {boolean} state - value of the option, true for towards the pivot, false for default
 */
Autodesk.Viewing.Navigation.prototype.setZoomTowardsPivot = function( state )
{
    this.__options.dollyToPivot = !!state;
};

/**
 * Get the state of the view navigation option that requests the default direction for camera dolly (zoom) operations to be towards the camera pivot point.
 *  @returns {boolean} - value of the option, true for towards the pivot, false for default
 */
Autodesk.Viewing.Navigation.prototype.getZoomTowardsPivot = function()
{
    return this.__options.dollyToPivot;
};

/**
 * Set or unset a view navigation option to allow the orbit controls to move the camera beyond the north and south poles (world up/down direction). In other words, when set the orbit control will allow the camera to rotate into an upside down orientation. When unset orbit navigation should stop when the camera view direction reaches the up/down direction.
 *  @param {boolean} state - value of the option, true to allow orbiting past the poles.
 */
Autodesk.Viewing.Navigation.prototype.setOrbitPastWorldPoles = function( state )
{
    this.__options.orbitPastPoles = !!state;
};

/**
 * Get the state of the view navigation option that allows orbit controls to continue past the world up/down direction.
 *  @returns {boolean} - value of the option, true if orbiting past the poles is allowed.
 */
Autodesk.Viewing.Navigation.prototype.getOrbitPastWorldPoles = function()
{
    return this.__options.orbitPastPoles;
};

/**
 * Set or unset a view navigation option which requests that orbit controls always orbit around the currently set pivot point.
 *  @param {boolean} state - value of the option, true to request use of the pivot point. When false some controls may pivot around the center of the view. (Currently applies only to the view-cube orbit controls.)
 */
Autodesk.Viewing.Navigation.prototype.setUsePivotAlways = function( state )
{
    this.__options.usePivotAlways = !!state;
};

/**
 * Get the state of the view navigation option that requests full use of the pivot point.
 *  @returns {boolean} - value of the option, if the pivot should be used as the orbit origin.
 */
Autodesk.Viewing.Navigation.prototype.getUsePivotAlways = function()
{
    return this.__options.usePivotAlways;
};

/**
 * Set or unset a view navigation option which requests that mouse buttons be reversed from their default assignment. i.e. Left mouse operation becomes right mouse and vice versa.
 *  @param {boolean} state - value of the option, true to request reversal of mouse button assignments.
 */
Autodesk.Viewing.Navigation.prototype.setUseLeftHandedInput = function( state )
{
    this.__options.useLeftHandedInput = !!state;
};

/**
 * Get the state of the view navigation option that requests mouse button reversal.
 *  @returns {boolean} - value of the option, true if reversal is requested.
 */
Autodesk.Viewing.Navigation.prototype.getUseLeftHandedInput = function()
{
    return this.__options.useLeftHandedInput;
};

/**
 * Lock or unlock view modification operations.
 *  @param {boolean} state - when true changes to the current camera parameters are not allowed.
 */
Autodesk.Viewing.Navigation.prototype.setIsLocked = function( state )
{
    this.__options.lockNavigation = !!state;
};

/**
 * Get the state of the current view modification lock.
 *  @returns {boolean} - true if view modifications are not currently allowed.
 */
Autodesk.Viewing.Navigation.prototype.getIsLocked = function()
{
    return this.__options.lockNavigation;
};

/**
 * Set or unset a view navigation option which indicates that the pivot camera parameter is set and can be used for orbit and zoom controls.
 *  @param {boolean} state - value of the option. When not set orbit and zoom operations should occur at the look at position in the center of the current view.
 */
Autodesk.Viewing.Navigation.prototype.setPivotSetFlag = function( state )
{
    if( !this.__options.lockNavigation )
        this.__pivotIsSetFlag = !!state;
};

/**
 * Get the state of the view navigation option that indicates the pivot is set.
 *  @returns {boolean} - value of the option, true if pivot may be used.
 */
Autodesk.Viewing.Navigation.prototype.getPivotSetFlag = function()
{
    return this.__pivotIsSetFlag;
};

/**
 * Issue a request to change the current cameras view position to fit the active model data into the current view frustum.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view. 
 */
Autodesk.Viewing.Navigation.prototype.setRequestFitToView = function( state )
{
    if( !this.__options.lockNavigation )
        this.__fitToViewRequested = !!state;
};

/**
 * Get the state of the view navigation option requesting a camera repositioning to fit the active model data. Value will be false if a request has not been made or if having been made has been received and acted upon.
 *  @returns {boolean} - current state of the request.
 */
Autodesk.Viewing.Navigation.prototype.getRequestFitToView = function()
{
    return this.__fitToViewRequested;
};

/**
 * Issue a request to change the current cameras view to the current "home" view. The home view includes position, view direction, world up direction and field of view.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view. 
 */
Autodesk.Viewing.Navigation.prototype.setRequestHomeView = function( state )
{
    if( !this.__options.lockNavigation )
        this.__homeViewRequested = !!state;
};

/**
 * Get the state of the view navigation option requesting a camera change to the current "home" view. Value will be false if a request has not been made or if having been made has been received and acted upon.
 *  @returns {boolean} - current state of the request.
 */
Autodesk.Viewing.Navigation.prototype.getRequestHomeView = function()
{
    return this.__homeViewRequested;
};

/**
 * Issue a request to transition the current cameras view to that specified by the parameters.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view. 
 *  @param {THREE.Vector3} pos - the new camera position in world space
 *  @param {THREE.Vector3} coi - the point in world space that the camera should look towards.
 *  @param {number} fov - vertical field of view in degrees
 *  @param {boolean} reorient - set to true to recalculate up vector
 */
Autodesk.Viewing.Navigation.prototype.setRequestTransition = function( state, pos, coi, fov, reorient )
{
    if( state )
    {
        this.__destinationView = {
            position: pos.clone(),
                 coi: coi.clone(),
                 fov: fov,
                  up: this.getCamera().up.clone(),
             worldUp: this.getWorldUpVector(),
            reorient: reorient
        };
    }
    else
        this.__destinationView = null;
};

/**
 * Issue a request to transition the current cameras view to that specified by the parameters which inlude both the camera up direction and optionally the world up direction.
 *  @param {boolean} state - value of the requst. Set to true in order to request the change of view. 
 *  @param {THREE.Vector3} pos - the new camera position in world space
 *  @param {THREE.Vector3} coi - the point in world space that the camera should look towards.
 *  @param {number} fov - vertical field of view in degrees
 *  @param {THREE.Vector3} up -  use this as the target camera up direction
 *  @param {THREE.Vector3} worldUp - (optional) use this as the target world up direction
 */
Autodesk.Viewing.Navigation.prototype.setRequestTransitionWithUp = function( state, pos, coi, fov, up, worldUp )
{
    if( state )
    {
        this.__destinationView = {
            position: pos.clone(),
                 coi: coi.clone(),
                 fov: fov,
                  up: up.clone(),
             worldUp: worldUp ? worldUp : this.getWorldUpVector(),
            reorient: false
        };
    }
    else
        this.__destinationView = null;
};

/**
 * Get the state of the view navigation option requesting a camera transition to a new view.
 *  @returns {Object} - If a transition request is active, an object with properties "position" (Vector3), "coi" (Vector3), "fov" (Number), "up" (Vector3), "worldUp" (Vector3), "reorient" (boolean). Returns null when no transition is active.
 *  @see setRequestTransitionWithUp
 */
Autodesk.Viewing.Navigation.prototype.getRequestTransition = function()
{
    return this.__destinationView;
};

/**
 * Set a status indicating that the current camera view is in a transitioning state.
 * Used internally to indicate that a transition is active.
 *  @param {boolean} state - value of the transtion status
 */
Autodesk.Viewing.Navigation.prototype.setTransitionActive = function( state )
{
    this.__transitionActive = !!state;
};

/**
 *  Check the status of a view transition request.
 *  @returns {boolean} - value of the transtion status
 */
Autodesk.Viewing.Navigation.prototype.getTransitionActive = function()
{
    return this.__transitionActive;
};

/**
 *  @param {number} atDistance - Distance from the camera at which to compute the view frustum size.
 *  @returns {THREE.Vector2} The size of the view frustum at this distance from the camera.
 */
Autodesk.Viewing.Navigation.prototype.getWorldSize = function(atDistance)
{
    var viewport = this.getScreenViewport();
    var aspect = viewport.width / viewport.height;
    var worldHeight = 2.0 * atDistance * Math.tan(THREE.Math.degToRad(this.getCamera().fov * 0.5));
    var worldWidth  = worldHeight * aspect;

    return new THREE.Vector2(worldWidth, worldHeight);
};

/**
 *  Get a world point from normalized screen coordinates by projecting to the plane at the pivot point.
 *  @param {number} x - Normalized screen X coordinate in [0, 1] range (left == 0)
 *  @param {number} y - Normalized screen Y coordinate in [0, 1] range (top == 0)
 *  @returns {THREE.Vector3} - Point in world space 
 */
Autodesk.Viewing.Navigation.prototype.getWorldPoint = function(x, y)
{
    /*
    var x = (mouseX - this.viewport.left) / this.viewport.width;
    var y = (mouseY - this.viewport.top) / this.viewport.height;
    */
    y = 1.0 - y;    // Invert Y so 0 == bottom and map to [-1, 1]
    x = x * 2.0 - 1.0;
    y = y * 2.0 - 1.0;
    var clickPoint = new THREE.Vector3(x, y, 1.0);
    this.__getProjector().unprojectVector(clickPoint, this.getCamera());

    var position = this.getPosition();
    var direction = clickPoint.sub(position).normalize();

    var pivot = this.getPivotPoint();
    var view  = this.getEyeVector();

    var denominator = direction.dot(view);
    var distance = (denominator !== 0.0)
                 ?  pivot.sub(position).dot(view) / denominator
                 :  pivot.sub(position).length();
    
    // console.log("GWP: (" + pivot.x.toFixed(3) + ", "+ pivot.y.toFixed(3) + ", "+ pivot.z.toFixed(3) + ") " + denominator);

    return direction.multiplyScalar(distance).add(position);
};

/**
 * @returns {number} - The perpendicular distance from the camera to the plane containing the pivot point.
 */
Autodesk.Viewing.Navigation.prototype.getPivotPlaneDistance = function()
{
    var pivot = this.getPivotPoint();
    var view  = this.getEyeVector();
    var position = this.getPosition();

    return pivot.sub(position).dot(view.normalize());
};

/**
 * Pan the camera a relative distance up/down or left/right.
 *  @param {number} deltaX - Normalized X distance to pan left/right (negative/positive).
 *  @param {number} deltaY - Normalized Y distance to pan down/up (negative/positive).
 *  @param {number} atDistance - Pan distance is scaled by the size of the view frustum at this distance from the camera.
 */
Autodesk.Viewing.Navigation.prototype.panRelative = function( deltaX, deltaY, atDistance )
{
    var trackSpeed = this.getWorldSize(atDistance);
    var offsetX = deltaX * trackSpeed.x;
    var offsetY = deltaY * trackSpeed.y;

    var trackX = this.getCameraRightVector(false).multiplyScalar( offsetX );
    var trackY = this.getCameraUpVector().multiplyScalar( offsetY );

    var offsetVector = trackX.add(trackY);

    this.setView( this.getPosition().add(offsetVector), this.getTarget().add(offsetVector) );

    if( !this.getPivotSetFlag() )
        this.setPivotPoint(this.getTarget());
};

/**
 * Dolly the camera a distance along the vector from a given point to its current position. The dolly distance is clamped to not go past the point.
 *  @param {number} distance - World space distance to move the camera by.
 *  @param {THREE.Vector3} point - World space position used to define the dolly direction.
 */
Autodesk.Viewing.Navigation.prototype.dollyFromPoint = function( distance, point )
{
    if( Math.abs(distance) <= this.__kEpsilon )
        return;

    var position = this.getPosition();
    var dollyVec = point.clone().sub(position);
    var oldLength = dollyVec.length();
    var newLength = oldLength + distance;
    var kMinDistance = this.__kEpsilon * 10;    // ???
    if( newLength < kMinDistance )
        newLength = kMinDistance;

    var scaleFactor = newLength / oldLength;
    if( Math.abs(scaleFactor - 1.0) > this.__kEpsilon )
    {
        dollyVec.multiplyScalar( scaleFactor );
        dollyVec.set(-dollyVec.x, -dollyVec.y, -dollyVec.z);
        var newPosition = dollyVec.add(point);

        // Compute a new look at point from the new position:
        var viewVec = this.getEyeVector();
        viewVec.multiplyScalar( scaleFactor );

        this.setView( newPosition, viewVec.add(newPosition) );
    }
};

/**
 *  Change current camera to perspective camera
 */
Autodesk.Viewing.Navigation.prototype.toPerspective = function()
{
    var camera = this.getCamera();

    if( !this.__options.lockNavigation && !camera.isPerspective )
    {
        // stderr("Nav: toPerspective");
        camera.toPerspective();
        camera.dirty = true;
    }
};

/**
 *  Change current camera to orthographic camera
 */
Autodesk.Viewing.Navigation.prototype.toOrthographic = function()
{
    var camera = this.getCamera();

    if( !this.__options.lockNavigation && camera.isPerspective )
    {
        // stderr("Nav: toOrtho");
        camera.toOrthographic();
        camera.dirty = true;
    }
};

;/** @license Copyright (c) 2013 Autodesk Inc. */
/** Version : @buildnum@ */
'use strict';

AutodeskNamespace('Autodesk.Viewing');

//==============================================================================
// Tessera API
//==============================================================================

/**
 * Attach ViewingApplication to a div by id
 * and initializes common properties of the viewing application
 *
 * @class
 *
 * @param {string} containerId - The id of the main container
 * @param {Object=} [options] - An optional dictionary of options.
 * @param {bool} [options.disableBrowserContextMenu=true] - Disables the browser's default context menu.
 * @constructor
 */
Autodesk.Viewing.ViewingApplication = function(containerId, options) {
    this.appContainerId = containerId;
    this.container = document.getElementById(containerId);
    this.options = options;
    this.myRegisteredViewers = {};
    this.myDocument = null;
    this.myCurrentViewer = null;
    this.urn = null;
};

/**
 * Defines the 3D viewer type
 */
Autodesk.Viewing.ViewingApplication.prototype.k3D = '3D';
/**
 * Defines the 2D viewer type
 */
Autodesk.Viewing.ViewingApplication.prototype.k2D = '2D';


/**
 * Register a Viewer to be used with this ViewingApplication
 *
 * @param {} viewableType
 * @param {} viewerClass
 * @param {} config
 */
Autodesk.Viewing.ViewingApplication.prototype.registerViewer = function(viewableType, viewerClass, config) {
    // Pass the disableBrowserContextMenu option down to the viewer config.
    //
    config = config || {};
    if (this.options && this.options.hasOwnProperty("disableBrowserContextMenu")) {
        // Don't override if the option was already explicitly specified.
        //
        if (!config.hasOwnProperty("disableBrowserContextMenu")) {
            config.disableBrowserContextMenu = this.options.disableBrowserContextMenu;
        }
    }

    this.myRegisteredViewers[viewableType] = {};
    this.myRegisteredViewers[viewableType].class = viewerClass;
    this.myRegisteredViewers[viewableType].config = config;
};

Autodesk.Viewing.ViewingApplication.prototype.getViewerClass = function(viewableType) {
    return this.myRegisteredViewers.hasOwnProperty(viewableType) ? this.myRegisteredViewers[viewableType].class : null;
};

/**
 * Returns the container that will be used by the viewer
 * By default uses the same container as the appContainer
 * This method can be overridden to specify a different
 * sub container for the viewer
 *
 * @return MemberExpression
 */
Autodesk.Viewing.ViewingApplication.prototype.getViewerContainer = function() {
    return document.getElementById(this.appContainerId);
};

/**
 * Returns a new instance of a Viewer of requested type
 *
 * @param {string} viewableType
 * @param {Object} config - Viewer configuration override.
 * @param {function(int,string)} onErrorCallback - this method is called when the viewer failed to initialize.
 * @return Viewer or null
 */
Autodesk.Viewing.ViewingApplication.prototype.getViewer = function(viewableType, config, onErrorCallback) {
    if (viewableType in this.myRegisteredViewers) {
        this.setCurrentViewer(null);
        var viewerClass = this.myRegisteredViewers[viewableType].class;

        // Merge the config object provided here with the config object provided
        // when the viewer type was registered. The former takes precedence.
        //
        var mergedConfig = {};
        var registeredViewerConfig = this.myRegisteredViewers[viewableType].config;
        var name;

        for (name in registeredViewerConfig) {
            if (registeredViewerConfig.hasOwnProperty(name)) {
                mergedConfig[name] = registeredViewerConfig[name];
            }
        }
        for (name in config) {
            if (config.hasOwnProperty(name)) {
                mergedConfig[name] = config[name];
            }
        }

        // If previous viewer.initialize() failed, then clean it up now.
        // This might happen if, for instance, we had a 3d viewer but
        // WebGL is not supported.
        // TODO: need a better solution
        //
        var container = this.getViewerContainer();
        while (container.hasChildNodes()) {
            container.removeChild(container.lastChild);
        }

        var viewer = new viewerClass(container, mergedConfig);
        var viewerInitCode = viewer.start();
        if (viewerInitCode === 0) {        // There were no errors initializing.
            this.setCurrentViewer(viewer);
            return viewer;
        }
        else {  // Initialization returned an error code.
            if (onErrorCallback)
                onErrorCallback( viewerInitCode, "Viewer failed to initialize." );
        }
    }
    return null;
};

/**
 * Sets this ViewingApplication's viewer to the provided viewer
 *
 *  @param {} viewer
 */
Autodesk.Viewing.ViewingApplication.prototype.setCurrentViewer = function(viewer) {
    if (this.myCurrentViewer) {
        this.myCurrentViewer.finish();
    }
    this.myCurrentViewer = viewer;
};

/**
 * Returns the currently set Viewer
 *
 *  @return Viewer
 */
Autodesk.Viewing.ViewingApplication.prototype.getCurrentViewer = function() {
    return this.myCurrentViewer;
};

/**
 * Asynchronously loads the document given its documentId
 * On success: Calls onDocumentLoadedCallback
 * On error: Calls onDocumentFailedToLaod callback
 *
 * @param {} documentId
 * @param {function} [onDocumentLoadCallback]
 * @param {function} [onLoadFailedCallback]
 */
Autodesk.Viewing.ViewingApplication.prototype.loadDocument = function(documentId, onDocumentLoadCallback, onLoadFailedCallback) {
    var application = this;
    Autodesk.Viewing.Document.load(documentId,
        function(document, errorsandwarnings) { // onLoadCallback
            application.myDocument = document;
            application.onDocumentLoaded(document, errorsandwarnings);
            if (onDocumentLoadCallback) {
                onDocumentLoadCallback(document, errorsandwarnings);
            }
        },
        function(errorCode, errorMsg, errors) { // onErrorCallback
            application.onDocumentFailedToLoad(errorMsg, errorCode, errors);
            if (onLoadFailedCallback)
                onLoadFailedCallback(errorCode, errorMsg, errors);
        }
    );
};

/**
 * Default success callback for loadDocument
 * Logs the document that was loaded on console
 *
 * @param {} document
 */
Autodesk.Viewing.ViewingApplication.prototype.onDocumentLoaded = function(document, errorsandwarnings) {
    console.log(document, errorsandwarnings);
};

/**
 * Default success callback for documentFailedToLoad
 * Logs the document that was loaded on console
 *
 * @param {string} errorCode - globalized error code.
 * @param {string} errorMsg  - error message to display
 * @parma {Array}  errors    - list of errors that come from other clients (translators)
 */
Autodesk.Viewing.ViewingApplication.prototype.onDocumentFailedToLoad = function( errorCode, errorMsg, errors ) {
    console.log(errorCode, errorMsg, errors);
};

/**
 * Asynchronously loads an individual item from a document into the correct viewer
 *
 * @param {} item
 * @param {} onSuccessCallback - This call back is called when the item is selected
 * @param {} onErrorCallback - This call back is called when the item fails to select.
 * @return Boolean
 */
Autodesk.Viewing.ViewingApplication.prototype.selectItem = function(item, onSuccessCallback, onErrorCallback) {
    var urnToLoad = this.myDocument.getViewablePath(item);

    if (urnToLoad) {
        var viewerType, viewItem, title;
        if (item.type === 'geometry' && item.role === '3d') {
            viewerType = this.k3D;
            title = item.name;
        } else if (item.type === "view" && item.role === "3d") {
            viewItem = item;
            viewerType = this.k3D;
            var geometry = this.myDocument.getViewGeometry(item);
            if (geometry) {
                title = geometry.name;
            }
        } else if (item.type === 'geometry' && item.role === '2d') {
            var subitems = Autodesk.Viewing.Document.getSubItemsWithProperties(item, {
                'mime': 'application/autodesk-f2d'
            }, false);

            if (subitems.length >0)
                viewerType= this.k3D;
            else
                viewerType = this.k2D;
            title = item.name;
        } else if (item.type === 'view' && item.role === '2d') {
            viewItem = item;
            viewerType = this.k3D;
            var geometry = this.myDocument.getViewGeometry(item);
            if (geometry) {
                title = geometry.name;
            }
        }

        Autodesk.Viewing.Private.logger.log({
            viewer_current_time : Date.now(),
            viewer_event_type : "switch sheet",
            viewer_sheet_title : title
        });

        // Check if there are any warnign or errors from translators.
        // Exclude the global ones (ones from the root node).
        var messages = this.myDocument.getMessages( item.guid, true );

        if(viewerType) {
            var self = this;
            var urnAlreadyLoaded = (this.myCurrentViewer && this.urn === urnToLoad);
            var onLoadCallback = null;

            if (viewItem && viewItem.camera) {
                onLoadCallback = function() {
                    self.myCurrentViewer.setViewFromArray(viewItem.camera);
                    if(onSuccessCallback) {
                        onSuccessCallback(self.myCurrentViewer, item, messages );
                    }
                };
            } else if (viewItem && viewItem.viewbox) {
                onLoadCallback = function() {
                    self.myCurrentViewer.setViewFromViewBox(viewItem.viewbox);
                    if(onSuccessCallback) {
                        onSuccessCallback(self.myCurrentViewer, item, messages );
                    }
                };
            } else if (urnAlreadyLoaded) {
                onLoadCallback = function() {
                    self.myCurrentViewer.setViewFromFile();
                    if(onSuccessCallback) {
                        onSuccessCallback(self.myCurrentViewer, item, messages );
                    }
                };
            } else {
                onLoadCallback = function() {
                    if(onSuccessCallback) {
                        onSuccessCallback(self.myCurrentViewer, item, messages );
                    }
                };
            }

            var onFailedToLoadCallback = function( errorCode, errorMsg ) {
                if (onErrorCallback)
                    onErrorCallback( errorCode, errorMsg, messages );
            };

            var loaded = false;

            if (urnAlreadyLoaded) {
                if (onLoadCallback) {
                    onLoadCallback();
                }
                loaded = true;

            } else {
                this.urn = null;
                var config = {defaultModelStructureTitle: title, viewableName: title};

                // Add any extensions to the config.
                //
                if(item.hasOwnProperty('extensions')) {
                    config.extensions = Array.isArray(item.extensions) ? item.extensions : [item.extensions];
                }

                var viewer = this.getViewer(viewerType, config, onErrorCallback);
                if (viewer && viewer.load(this.myDocument.getFullPath(urnToLoad), this.myDocument.getPropertyDbPath(), onLoadCallback, onFailedToLoadCallback)) {
                    this.urn = urnToLoad;
                    loaded = true;
                }
            }

            if (loaded) {
                this.onItemSelected(item);
                return true;
            }
        }
    }

    return false;
};

/**
 * Called when selectItem successfully loads an item
 *
 * @param {int} item
 */
Autodesk.Viewing.ViewingApplication.prototype.onItemSelected = function(item) {
    console.log('Selected URL: http://' + location.host + location.pathname + '?document=urn:' + this.myDocument.getRootItem().guid + '&item=' + encodeURIComponent(item.guid));
};

/**
 * Finds the item within the current document and calls selectItem
 * @param {int} itemId
 * @param {function} [onItemSelectedCallback] - This call back is called when the item is selected
 * @param {function} [onItemFailedToSelectCallback] - This call back is called when the item fails to select
 * @return Boolean
 */
Autodesk.Viewing.ViewingApplication.prototype.selectItemById = function(itemId, onItemSelectedCallback, onItemFailedToSelectCallback) {
    var item = this.myDocument.getItemById(itemId);
    if (item) {
        return this.selectItem(item, onItemSelectedCallback, onItemFailedToSelectCallback);
    }
    return false;
};
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Private');

//==============================================================================
// Builds on the basic Viewer3D by adding various common GUI elements.
// Future potential customizations:
// - hotkeys/navigation
// - other UI
//==============================================================================
Autodesk.Viewing.Private.GuiViewer3D = function(container, config)
{
    // Explicitly set startOnInitialize = false, as we want to finish some initialization
    // before starting the main loop.
    //
    if(!config) {
        config = {};
    }
    config.startOnInitialize = false;

    // Set the default click configuration for the model structure panel, as this may be used
    // in an extension.
    //
    if(!config.hasOwnProperty('docStructureConfig')) {
        config.docStructureConfig = Autodesk.Viewing.Private.GuiViewer3D.kDefaultDocStructureConfig;
    }

    Autodesk.Viewing.Viewer3D.call(this, container, config);
};

Autodesk.Viewing.Private.GuiViewer3D.prototype = Object.create(Autodesk.Viewing.Viewer3D.prototype);
Autodesk.Viewing.Private.GuiViewer3D.prototype.constructor = Autodesk.Viewing.Private.GuiViewer3D;


Autodesk.Viewing.Private.GuiViewer3D.prototype.resize = function() {
    Autodesk.Viewing.Viewer3D.prototype.resize.call(this);
    if (this.container.clientWidth < 600) {
        this.toolbar.collapse( true );
    } else {
        this.toolbar.collapse( false );
    }
};

Autodesk.Viewing.Private.GuiViewer3D.kDefaultDocStructureConfig = {
    "click": {
        "onObject": ["isolate"]
    },
    "clickCtrl": {
        "onObject": ["toggleVisibility"]
    }
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initialize = function()
{
    var viewerErrorCode = Autodesk.Viewing.Viewer3D.prototype.initialize.call(this);
    if (viewerErrorCode > 0)    // ErrorCode was returned.
    {
        return viewerErrorCode;
    }

    var viewer = this;

    if( this.toolController ) {
        var hottouch = new Autodesk.Viewing.HotGestureTool(this);
        var fovtool  = new Autodesk.Viewing.FovTool(this);
        var rolltool = new Autodesk.Viewing.WorldUpTool(this.impl, this);

        this.toolController.registerTool( hottouch );
        this.toolController.registerTool( fovtool );
        this.toolController.registerTool( rolltool );

        this.toolController.activateTool( hottouch.getName() );
    }

    var container = viewer.container;

    // Default Navigation
    this.setDefaultNavigationTool("orbit");

    // Create toolbar that is attached to the bottom of the panel.
    this.initializeToolbar(container);

    this.initFocalLengthOverlay();

    this.addEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, function (e) {
        viewer.resizePanels({viewer: viewer});
        viewer.updateScreenModeButton(e.mode);
    });

    // Context menu
    if (!this.contextMenu) {
        this.setContextMenu(new Autodesk.Viewing.Extensions.ViewerObjectContextMenu(this));
    }

    // Create a progress bar. Shows streaming.
    //
    this.progressbar = new Autodesk.Viewing.Private.ProgressBar(this.container);
    this.addEventListener(Autodesk.Viewing.PROGRESS_UPDATE_EVENT, function (e) {
        if (e.percent !== undefined) {
            viewer.progressbar.setPercent(e.percent);
        }
    }, false);

    // There is no way on the API to get the current selection (yet?)
    //
    // We need to know if there is anything selected in order to process the
    // Escape key workflow, so track it manually.
    this.selectionActive = false;
    this.addEventListener(Autodesk.Viewing.SELECTION_CHANGED_EVENT, function(event) {
        viewer.selectionActive = (event.dbIdArray.length > 0);

        if (viewer.prefs.openPropertiesOnSelect) {
            var propertyPanel = viewer.getPropertyPanel(true);
            propertyPanel.setVisible(viewer.selectionActive);
        }
    });

    this.addEventListener(Autodesk.Viewing.ISOLATE_EVENT, function (event) {
        if (viewer.prefs.openPropertiesOnSelect || event.nodeIdArray[0] === viewer.model.getRoot()) {
            if (viewer.propertygrid) {
                viewer.propertygrid.setVisible(event.nodeIdArray.length > 0);
            }
        }
    });

    this.addEventListener(Autodesk.Viewing.VIEWER_STATE_RESTORED_EVENT, function(event) {
        if (viewer.renderoptions) {
            viewer.renderoptions.syncUI();
        }
        viewer.vieweroptions.syncUI();

        // We don't really need to update these 2 values, because the panel is usually closed.
        // Leaving code here just in case it becomes necessary.
        //this.envSelect.setSelectedIndex(viewer.impl.currentLightPreset());
        //this.viewerOptionButton.displayLines.setValue(viewer.prefs.lineRendering);
    });

    this.initEscapeHandlers();
    this.updateScreenModeButton(this.getScreenMode());

    // Now that all the ui is created, localize it.
    this.localize();

    // Now that all of our initialization is done, start the main loop.
    //
    this.run();

    return 0;   // No errors initializing.
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.uninitialize = function () {
    if (this.vieweroptions) {
        this.vieweroptions.uninitialize();
        this.vieweroptions = null;
    }

    if (this.modelstructure) {
        this.modelstructure.uninitialize();
        this.modelstructure = null;
    }

    if (this.layersPanel) {
        this.layersPanel.uninitialize();
        this.layersPanel = null;
    }

    if (this.propertygrid) {
        this.propertygrid.uninitialize();
        this.propertygrid = null;
    }

    if (this.renderoptions) {
        this.renderoptions.uninitialize();
        this.renderoptions = null;
    }

    Autodesk.Viewing.theHotkeyManager.popHotkeys("Autodesk.ROLL");
    Autodesk.Viewing.theHotkeyManager.popHotkeys("Autodesk.FOV");

    this.progressbar = null;

    this.minTools = null;
    this.modelTools = null;
    this.navTools = null;
    this.debugMenu = null;
    this.searchMenu = null;

    Autodesk.Viewing.Viewer3D.prototype.uninitialize.call(this);
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initializeToolbar = function( container )
{
    var toolbar = this.getToolbar( true );

    if (this.canChangeScreenMode()) {
        this.minToolsId = "minTools";
        this.minTools = toolbar.addSubToolbar( this.minToolsId, false );

        var viewer = this;
        this.minTools.minfullscreenbutton = this.addMenuButton( this.minToolsId, "toolbar-minfullscreenTool", "Full screen", function(e) {
            viewer.nextScreenMode();
        });
    }

    this.navTools   = toolbar.getSubToolbarById( Autodesk.Viewing.TOOLBAR.NAVTOOLSID );
    this.modelTools = toolbar.getSubToolbarById( Autodesk.Viewing.TOOLBAR.MODELTOOLSID );
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.loadModel = function(url, ids, sharedPropertyDbPath, onSuccessCallback, onErrorCallback) {

    if (url.indexOf(".f2d") != -1) {
        this.createUI("2d");
//        this.unloadExtension('Autodesk.Beeline');

        // Make pan a default navigation tool.
        this.setDefaultNavigationTool("pan");
    }
    else { // 3d model
        this.createUI("3d");
//        this.loadExtension('Autodesk.Beeline', null);

        // Make orbit a default navigation tool.
        this.setDefaultNavigationTool("orbit");
    }

    return Autodesk.Viewing.Viewer3D.prototype.loadModel.call(this, url, ids, sharedPropertyDbPath, onSuccessCallback, onErrorCallback);
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.setModelStructurePanel = function (modelStructurePanel) {
    var self = this;
    if (Autodesk.Viewing.Viewer3D.prototype.setModelStructurePanel.call(self, modelStructurePanel)) {
        if (modelStructurePanel) {
            modelStructurePanel.addVisibilityListener(function (visible) {
                if (visible) {
                    self.onPanelVisible(modelStructurePanel, self);
                }
                self.setStructureButtonEnabled(visible);
            });
        }
        return true;
    }
    return false;
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.setPropertyPanel = function (propertyPanel) {
    var self = this;
    if (Autodesk.Viewing.Viewer3D.prototype.setPropertyPanel.call(self, propertyPanel)) {
        if (propertyPanel) {
            propertyPanel.addVisibilityListener(function (visible) {
                if (visible) {
                    self.onPanelVisible(propertyPanel, self);
                }
                self.setPropertiesButtonEnabled(visible);
            });
        }
        return true;
    }
    return false;
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.setLayersPanel = function (layersPanel) {
    var self = this;
    Autodesk.Viewing.Viewer3D.prototype.setLayersPanel.call(self, layersPanel);
    if (layersPanel) {
        layersPanel.addVisibilityListener(function (visible) {
            if (visible) {
                self.onPanelVisible(layersPanel, self);
                self.modelTools.select(self.modelTools.layerButton.id );
            }
            else {
                self.modelTools.deselect(self.modelTools.layerButton.id );
            }
        });
    }
    return true;
};


Autodesk.Viewing.Private.GuiViewer3D.prototype.createUI = function( mode ) {

    var is3d = mode === "3d";

    this.initHotkeys(mode);

    this.initNavTools(mode);
    this.initCameraStateMachine(mode);
    this.initModelTools(mode);

    //Optional rendering options panel + button
    if (ENABLE_DEBUG) {
        this.initDebugTools();
    }

    // Dispatch a toolbar created event
    this.fireEvent({type:Autodesk.Viewing.TOOLBAR_CREATED_EVENT});

    // Add search box last, at the very right of the menu
    this.initSearchBox();


    // Add info button, home button, and view cube.
    this.initInfoButton();

    this.initHomeButton(mode);

    // Show view cube only in 3d/
    if (is3d)
        this.initViewCube();

};

Autodesk.Viewing.Private.GuiViewer3D.prototype.addOptionToggle = function(parent, tooltip, initialState, onchange, saveKey) {

    // Use the stored settings or defaults
    var storedState = saveKey ? this.prefs[saveKey] : null;
    initialState = (typeof storedState === 'boolean') ? storedState : initialState;

    var li = document.createElement("li");
    li.className = "toolbar-submenu-listitem";

    var cb = document.createElement("input");
    cb.className = "toolbar-submenu-checkbox";
    cb.type = "checkbox";
    cb.id = tooltip;
    li.appendChild(cb);

    var lbl = document.createElement("label");
    lbl.setAttribute ('for', tooltip);
    lbl.setAttribute("data-i18n", tooltip);
    lbl.textContent = Autodesk.Viewing.i18n.translate( tooltip );
    li.appendChild(lbl);

    parent.appendChild(li);

    cb.checked = initialState;

    var onClickEvent = this.navigation.getIsTouchDevice() ? "touchstart" : "click";

    // Add a handler also to the whole element so that we can click anywhere and
    // the checkbox will toggle.
    cb.addEventListener(onClickEvent, function(e) {
        onchange(cb.checked);
        e.stopPropagation();
    });

    lbl.addEventListener(onClickEvent, function(e) {
        e.stopPropagation();
    });

    li.addEventListener(onClickEvent, function(e) {
        onchange(!cb.checked);
        e.stopPropagation();
    });

    if (saveKey) {
        this.prefs.addListeners(saveKey, function (value) {
            cb.checked = value;
        }, function (value) {
            cb.checked = value;
            onchange(value);
        });
    }
    return cb;
};


Autodesk.Viewing.Private.GuiViewer3D.prototype.addOptionList = function(parent, label, optionList, initialIndex, onchange, saveKey) {

    // Use the stored settings or defaults
    var storedState = this.prefs[saveKey];
    initialIndex = (typeof storedState === 'number') ? storedState : initialIndex;

    // Wrap the onchange with the update to that setting
    var handler = function(e) {
        var selectedIndex = e.target.selectedIndex;
        onchange(selectedIndex);
        e.stopPropagation();
    };

    var selectElem = document.createElement("select");
    selectElem.className = 'optionDropDown';
    for (var i = 0; i < optionList.length; i++) {
        var item = document.createElement("option");
        item.value = i;
        item.setAttribute("data-i18n",  optionList[i]);
        item.textContent = Autodesk.Viewing.i18n.translate( optionList[i] );
        selectElem.add(item);
    }

    var li = document.createElement("li");
    li.className = "toolbar-submenu-select";

    var lbl = document.createElement("div");
    lbl.className = "toolbar-submenu-selectlabel";
    lbl.setAttribute ('for', label);
    lbl.setAttribute("data-i18n", label);
    lbl.textContent = Autodesk.Viewing.i18n.translate( label );
    li.appendChild(lbl);
    li.appendChild(selectElem);

    parent.appendChild(li);

    selectElem.selectedIndex = initialIndex;
    selectElem.onchange = handler;
    selectElem.addEventListener( this.navigation.getIsTouchDevice() ? "touchstart" : "click", function(e) {e.stopPropagation()});

    if (saveKey) {
        this.prefs.addListeners(saveKey, function (value) {
            selectElem.selectedIndex = value;
        }, function (value) {
            selectElem.selectedIndex = value;
            onchange(value);
        });
    }

    return selectElem;
};


Autodesk.Viewing.Private.GuiViewer3D.prototype.addMenuButton = function(subToolbarId, id, tooltip, onclick) {
    var button = Autodesk.Viewing.UI.Toolbar.createMenuButton( id, tooltip, onclick );
    this.toolbar.addToSubToolbar( subToolbarId, button );
    return button;
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.removeMenuButton = function(subToolbarId, item) {
    this.toolbar.removeFromSubToolbar( subToolbarId, item );
};


Autodesk.Viewing.Private.GuiViewer3D.prototype.initExplodeSlider = function( modelToolsId ) {

    var self = this;

    var container = this.container;

    // Create the base keyframe rules
    // Add keyframes programatically so we have don't violate same origin policy when we modify them (hopefully)
    var animationinbaserule  = "explode-in {0% {bottom: calc(100% + 50px); width: 0; left: 50%;} 60% {bottom: calc(100% - 50px);} 75% {bottom: calc(100% - 15px); width: 200px; left: calc(50% - 100px);}  90% {bottom: calc(100% - 35px);} 100% {bottom: calc(100% - 30px);}}";
    var animationoutbaserule = "explode-out {0% {bottom: calc(100% - 30px); width: 200px; left: calc(50% - 100px); opacity: 1;} 20% {bottom: calc(100% - 15px);} 35% {width: 200px; left: calc(50% - 100px);} 50% {bottom: calc(100% - 50px);} 100% {bottom: calc(100% + 50px); width: 0; left: 50%; opacity: 1;}}";
    var style = document.createElement("style");
    style.appendChild(document.createTextNode(""));
    document.head.appendChild(style);
    var sheet = style.sheet;
    var isFirefox = (navigator.userAgent.search("Firefox") != -1);
    var prefix = isFirefox ? "-moz-" : "-webkit-";
    try {
        sheet.insertRule("@" + prefix + "keyframes " + animationinbaserule, 0);
        sheet.insertRule("@" + prefix + "keyframes " + animationoutbaserule, 0);
    } catch (e) {
        try {
            // fall back to no prefix (IE)
            sheet.insertRule("@keyframes " + animationinbaserule, 0);
            sheet.insertRule("@keyframes " + animationoutbaserule, 0);
        } catch (e) {
            //console.log("Failed to generate CSS animation for slider: " + e);
        }
    }

    var explodeslider = this.explodeslider = document.createElement("input");
    explodeslider.className = "explode-slider";
    explodeslider.id = "explode-slider";
    explodeslider.type = "range";
    explodeslider.min = "0";
    explodeslider.max = "100";
    explodeslider.value = "0";
    explodeslider.width = "200";
    container.appendChild(explodeslider);

    // hook up toolbar
    // TODO: find a better solution to responding to slider changes
    // IE doesn't respond to input event on sliders
    explodeslider.addEventListener("input", function(e) {
        self.explode(explodeslider.value /100);
    });
    // Firefox doesn't respond to change event until after the user lets go
    explodeslider.addEventListener("change", function(e) {
        self.explode(explodeslider.value /100);
        //console.log(JSON.stringify(self.impl.fragTransformConfig));
    });

    this.explodebutton = this.addMenuButton( modelToolsId, "toolbar-explodeTool", "Explode model", function (e) {
        var isHidden = !explodeslider.classList.contains("slider-anim-in");
        self.showExplodeSlider(isHidden);

        // If Measure tool is active, deactivate it.
        //
        // TODO:    Once the tool API exists that sends an event about the tool deactivation,
        // TODO:    we should use it instead of doing it manually.
        //
        var measureTool = Autodesk.Viewing.UI.Toolbar.getToolButton("toolbar-measureTool");
        if (measureTool) {
            self.toolController.deactivateTool("measure");
            Autodesk.Viewing.UI.SubToolbar.setToolState( measureTool.id, Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE);
        }
    });

    explodeslider.addEventListener("keyup", function(e) {
        if (e.keyCode === 27) {
            // Shift focus back to the canvas so that the key can be handled there.
            //
            // Actually, I'm surprised this works; apparently switching focus in the
            // middle of a DOM event handler also allows the events to propagate to
            // the newly focused element. Who knew?
            self.canvas.focus();
        }
    });
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.showExplodeSlider = function(show) {
    // Modify the CSS keyframes so the slider animates from the button's location
    var keyframesinrule = "explode-in";
    var keyframesoutrule = "explode-out";

    var buttonrect = this.explodebutton.getBoundingClientRect();
    var sliderparentrect = this.container.getBoundingClientRect();

    var newlocation = {
        x: buttonrect.left - sliderparentrect.left + buttonrect.width / 4,
        y: buttonrect.top - sliderparentrect.top
    };

    try {
        for (var i in document.styleSheets) {
            var sheet = document.styleSheets[i];
            for (var j in sheet.cssRules) {
                var rule = sheet.cssRules[j];
                if (rule.name === keyframesinrule) {
                    // Modify the in animation
                    rule.deleteRule("0%");
                    rule.deleteRule("60%");
                    var newRule = "0% {bottom: calc(100% - " + newlocation.y + "px); width: 0; left: " +
                        newlocation.x + "px;}";
                    if (rule.insertRule !== undefined) {
                        rule.insertRule(newRule); // Chrome/Safari
                    } else if (rule.appendRule !== undefined) {
                        rule.appendRule(newRule); // Firefox
                    }
                } else if (rule.name === keyframesoutrule) {
                    // modify the out animation
                    rule.deleteRule("100%");
                    rule.deleteRule("50%");
                    var newRule = "100% {bottom: calc(100% - " + newlocation.y + "px); width: 0; left: " +
                        newlocation.x + "px; opacity: 1;}";
                    if (rule.insertRule !== undefined) {
                        rule.insertRule(newRule); // Chrome/Safari
                    } else if (rule.appendRule !== undefined) {
                        rule.appendRule(newRule); // Firefox
                    }
                }
            }
        }
    } catch(e) {
        // If exception is thrown then the default animation is used.
    }

    if (show) {
        Autodesk.Viewing.UI.SubToolbar.setToolState( this.explodebutton.id, Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE);
        this.explodeslider.classList.add("slider-anim-in");
        this.explodeslider.classList.remove("slider-anim-out");
    } else {
        Autodesk.Viewing.UI.SubToolbar.setToolState( this.explodebutton.id, Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE);
        this.explodeslider.classList.add("slider-anim-out");
        this.explodeslider.classList.remove("slider-anim-in");
    }
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.showViewer3dOptions = function(show) {
    if (show && this.vieweroptions.isVisible()) {
        this.vieweroptions.setVisible(false);
    }
    this.vieweroptions.setVisible(show);
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.showRenderingOptions = function(show) {
    this.renderoptions.setVisible(show);
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.showLayerManager = function(show) {
    this.layersPanel.setVisible(show);
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initHotkeys = function( mode ) {
    var viewer = this;
    var keys = Autodesk.Viewing.theHotkeyManager.KEYCODES;
    var onPress;
    var onRelease;

    if (mode === "3d") {
        // Add FOV hotkey
        var previousToolForFOV;
        onPress = function () {
            if (viewer.toolController.getIsLocked()) {
                return false;
            }

            previousToolForFOV = viewer.getActiveNavigationTool();
            viewer.setActiveNavigationTool("fov");
            return true;
        };
        onRelease = function () {
            if (viewer.toolController.getIsLocked()) {
                return false;
            }

            viewer.setActiveNavigationTool(previousToolForFOV);
            return true;
        };
        Autodesk.Viewing.theHotkeyManager.pushHotkeys("Autodesk.FOV", [
            {
                keycodes: [keys.CONTROL, keys.SHIFT],
                onPress: onPress,
                onRelease: onRelease
            }
        ], {tryUntilSuccess: true});
    }

    // Add Roll hotkey
    var previousToolForRoll;
    onPress = function() {
        if (viewer.toolController.getIsLocked()) {
            return false;
        }

        previousToolForRoll = viewer.getActiveNavigationTool();
        viewer.setActiveNavigationTool("worldup");
        return true;
    };
    onRelease = function() {
        if (viewer.toolController.getIsLocked()) {
            return false;
        }

        viewer.setActiveNavigationTool(previousToolForRoll);
        return true;
    };
    Autodesk.Viewing.theHotkeyManager.pushHotkeys("Autodesk.ROLL", [{
        keycodes: [keys.ALT, keys.SHIFT],
        onPress: onPress,
        onRelease: onRelease
    }], {tryUntilSuccess: true});
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initNavTools = function( mode ) {

    var viewer = this;

    var navToolsId = Autodesk.Viewing.TOOLBAR.NAVTOOLSID;
    if (mode === "3d") {
        this.navTools.orbitbutton = this.addMenuButton( navToolsId, "toolbar-orbitTool", "Orbit", function(e) {
            var state = Autodesk.Viewing.UI.SubToolbar.getToolState(viewer.navTools.orbitbutton.id);
            if (state === Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE) {
                viewer.setActiveNavigationTool("orbit");
            } else if (state === Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE) {
                viewer.setActiveNavigationTool();
            }
        });
    }
    this.navTools.panbutton = this.addMenuButton( navToolsId, "toolbar-panTool", "Pan", function(e) {
        var state = Autodesk.Viewing.UI.SubToolbar.getToolState(viewer.navTools.panbutton.id);
        if (state === Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE) {
            viewer.setActiveNavigationTool("pan");
        } else if (state === Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE) {
            viewer.setActiveNavigationTool();
        }
    });

    this.navTools.dollybutton = this.addMenuButton( navToolsId, "toolbar-zoomTool", "Zoom", function(e) {
        var state = Autodesk.Viewing.UI.SubToolbar.getToolState(viewer.navTools.dollybutton.id);
        if (state === Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE) {
            viewer.setActiveNavigationTool("dolly");
        } else if (state === Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE) {
            viewer.setActiveNavigationTool();
        }
    });

    // Add the camera button.
    var cameraButtonId = "toolbar-cameraSubmenuTool";
    var options = {
        onToolStateChangedCB: function() {
            if (Autodesk.Viewing.UI.SubToolbar.getToolState(cameraButtonId) === Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE) {
                Autodesk.Viewing.UI.SubToolbar.setToolState("toolbar-fitToViewTool", Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE);
                Autodesk.Viewing.UI.SubToolbar.setToolState("toolbar-rollTool", Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE);
            }
        }
    };
    var cameraButton = Autodesk.Viewing.UI.Toolbar.createMenuButton( cameraButtonId, "Camera interactions", null, options );
    cameraButton.style.position = "relative";
    this.toolbar.addToSubToolbar( navToolsId, cameraButton );

    // Create camera submenu and attach it to camera button.
    var cameraSubmenu = this.createCameraSubmenu(mode);
    this.toolbar.attachSubMenu( cameraButton, cameraSubmenu );
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.createCameraSubmenu = function(mode)
{
    var submenu = document.createElement("ul");
    submenu.style.width    = "48px";
    submenu.style.position = "absolute";
    submenu.style.left     = "2px";
    submenu.style.paddingBottom = "2px";

    var createButton = Autodesk.Viewing.UI.Toolbar.createMenuButton;
    var viewer = this;

    var options = { defaultTooltipValue : "Fit to view (F)" };
    this.navTools.fittoviewbutton = createButton( "toolbar-fitToViewTool", "Fit to view", function(e) {
        viewer.fitToView();
    }, options);
    this.navTools.fittoviewbutton.style.marginLeft = "2px";
    this.navTools.fittoviewbutton.style.marginTop  = "2px";
    submenu.appendChild( this.navTools.fittoviewbutton );

    if (mode === "3d") {
        options.defaultTooltipValue = "Focal length (Ctrl+Shift drag)";
        this.navTools.fovbutton = createButton( "toolbar-focalLengthTool", "Focal length", function(e) {
            var state = Autodesk.Viewing.UI.SubToolbar.getToolState(viewer.navTools.fovbutton.id);
            if (state === Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE) {
                viewer.setActiveNavigationTool("fov");
            } else if (state === Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE) {
                viewer.setActiveNavigationTool();
            }
        }, options);
        this.navTools.fovbutton.style.marginLeft = "2px";
        this.navTools.fovbutton.style.marginTop  = "2px";

        submenu.appendChild( this.navTools.fovbutton );
    }

    options.defaultTooltipValue = "Roll (Alt+Shift drag)";
    this.navTools.rollbutton = createButton( "toolbar-rollTool", "Roll", function(e) {
        var state = Autodesk.Viewing.UI.SubToolbar.getToolState(viewer.navTools.rollbutton.id);
        if (state === Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE) {
            viewer.setActiveNavigationTool("worldup");
        } else if (state === Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE) {
            viewer.setActiveNavigationTool();
        }
    }, options);
    this.navTools.rollbutton.style.marginLeft = "2px";
    this.navTools.rollbutton.style.marginTop  = "2px";

    submenu.appendChild(  this.navTools.rollbutton );

    return submenu;
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initCameraStateMachine = function(mode) {
    var viewer = this;

    viewer.addEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, function (e) {
        var activeNavTool = viewer.getActiveNavigationTool();
        var toolToButtonMap = {
            "orbit": viewer.navTools.orbitbutton,
            "dolly": viewer.navTools.dollybutton,
            "pan": viewer.navTools.panbutton,
            "fov": viewer.navTools.fovbutton,
            "worldup": viewer.navTools.rollbutton
        };

        for (var tool in toolToButtonMap) {
            if (!toolToButtonMap[tool])
                continue;

            Autodesk.Viewing.UI.SubToolbar.setToolState(toolToButtonMap[tool].id, Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE);
        }

        if (toolToButtonMap[activeNavTool])
            Autodesk.Viewing.UI.SubToolbar.setToolState(toolToButtonMap[activeNavTool].id, Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE);
    });

    viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, function (e) {
        if (e.toolName === "fov") {
            viewer.showFocalLengthOverlay(e.active);
        }
    });
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.getPropertyPanel = function (createDefault) {
    if (!this.propertygrid && createDefault) {
        this.setPropertyPanel(new Autodesk.Viewing.Extensions.ViewerPropertyPanel(this));
    }
    return this.propertygrid;
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initModelTools = function(mode) {
    var viewer = this;

    var modelToolsId = Autodesk.Viewing.TOOLBAR.MODELTOOLSID;
    var resetTooltip = null;
    if (mode === "3d") {
        this.modelTools.structurebutton = this.addMenuButton(modelToolsId, "toolbar-modelStructureTool", "Model structure", function (e) {
            if (!viewer.modelstructure) {
                var options = {docStructureConfig: viewer.config.docStructureConfig};
                viewer.setModelStructurePanel(new Autodesk.Viewing.Extensions.ViewerModelStructurePanel(viewer, 'Model Structure Loading', options));
            }
            viewer.showModelStructurePanel(!viewer.modelstructure.isVisible());
        });

        this.initExplodeSlider( modelToolsId );

        resetTooltip = "Reset model";
    }
    else {
        var layersPanel = new Autodesk.Viewing.Extensions.ViewerLayersPanel(this);
        this.setLayersPanel(layersPanel);

        this.modelTools.layerButton =  this.addMenuButton(modelToolsId, "toolbar-layersTool", "Layer Manager", function (e) {
            viewer.showLayerManager(!viewer.layersPanel.isVisible());
        });

        resetTooltip = "Reset drawing";
    }

    this.modelTools.resetModelButton = this.addMenuButton( modelToolsId, "toolbar-resetTool", resetTooltip, function(e) {
        if (mode === "3d") {
            viewer.explode(0);
            viewer.explodeslider.value = 0;
        }
        viewer.showAll();
    });

    this.modelTools.propertiesbutton = this.addMenuButton( modelToolsId, "toolbar-propertiesTool", "Properties", function(e) {
        var propertyPanel = viewer.getPropertyPanel(true);
        propertyPanel.setVisible(!propertyPanel.isVisible());
    });
    this.modelTools.setToolVisibility( this.modelTools.propertiesbutton.id, !viewer.prefs.openPropertiesOnSelect );

    // New viewer options' panel
    this.vieweroptions = new Autodesk.Viewing.Private.Viewer3dSettingsPanel(this, mode);
    this.addPanel( this.vieweroptions );
    this.viewerOptionButton = this.addMenuButton( modelToolsId, "toolbar-settingsTool", "", null );
    this.createViewerOptionsMenu(mode);

    if (ENABLE_DEBUG && mode === "3d") {
        this.renderoptions = new Autodesk.Viewing.Private.RenderOptionsPanel(this);
        this.addPanel(this.renderoptions);
        this.renderoptionsbutton = this.addMenuButton( modelToolsId, "toolbar-renderOptionsTool", "Rendering options", function(e) {
            viewer.showRenderingOptions(!viewer.renderoptions.isVisible());
        });
    }

    if (this.canChangeScreenMode()) {
        this.modelTools.fullscreenbutton = this.addMenuButton( modelToolsId, "toolbar-fullscreenTool", "Full screen", function(e) {
            viewer.nextScreenMode();
        });
    }
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.setPropertiesOnSelect = function(onSelect) {
    if (onSelect) {
        this.modelTools.setToolVisibility( this.modelTools.propertiesbutton.id, false );
    } else {
        this.modelTools.setToolVisibility( this.modelTools.propertiesbutton.id, true );
    }
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.addDivider = function(parent) {
    var item = document.createElement("li");
    item.className = "toolbar-submenu-horizontal-divider";
    parent.appendChild(item);
    return item;
};


Autodesk.Viewing.Private.GuiViewer3D.prototype.createViewerOptionsMenu = function(mode) {
    var viewer = this;

    this.viewerOptionButton.subMenu = document.createElement("ul");
    this.viewerOptionButton.subMenu.className = "toolbar-submenu";
    this.viewerOptionButton.subMenu.style.minWidth = "310px";
    this.viewerOptionButton.subMenu.mode = mode;

    // Temporarily attach it to the main container so that it can be
    // properly sized. Once it has a correct width (important for localization)
    // we will remove it from the container and attach it to the button.
    //
    this.container.appendChild( this.viewerOptionButton.subMenu );

    if (mode === "3d") {
        // Environment map preset list
        var env_list = [];
        for (var i=0; i<Autodesk.Viewing.Private.LightPresets.length; i++) {
            env_list.push(Autodesk.Viewing.Private.LightPresets[i].name);
        }

        this.viewerOptionButton.envList = this.addOptionList(this.viewerOptionButton.subMenu, "Background and lighting", env_list, 4, function(selectedIndex)
        {
            if (viewer.blockEvent)
                return;
            viewer.setLightPreset(selectedIndex);

        }, "lightPreset");

        this.selectLightPreset = function( e ) {
            viewer.blockEvent = true;
            if (viewer.viewerOptionButton.envList)
                viewer.viewerOptionButton.envList.selectedIndex = viewer.impl.currentLightPreset();
            viewer.blockEvent = false;
        };
        viewer.addEventListener(Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT, this.selectLightPreset );

        this.viewerOptionButton.displayLines = this.addOptionToggle(this.viewerOptionButton.subMenu, "Display Lines", true, function(checked) {
            viewer.hideLines(!checked);
        }, "lineRendering");

        this.addDivider(this.viewerOptionButton.subMenu);
    }

    var performanceOption = document.createElement("li");
    performanceOption.className = "toolbar-submenu-listitem";
    var perfLabel = document.createElement("label");
    perfLabel.setAttribute("data-i18n", "Performance and appearance settings");
    perfLabel.textContent = Autodesk.Viewing.i18n.translate( "Performance and appearance settings" );
    performanceOption.appendChild(perfLabel);

    function show3dOptions(tab) {
        var panel = viewer.vieweroptions;
        if (!panel.isVisible() || !panel.isTabSelected(tab)) {
            viewer.showViewer3dOptions(true);
            panel.selectTab(tab);
        } else {
            viewer.showViewer3dOptions(false);
        }
    }

    var onClickEvent = this.navigation.getIsTouchDevice() ? "touchstart" : "click";

    this.show3dOptionsPerformanceTab = function () {
        show3dOptions(Autodesk.Viewing.Private.PerformanceTab);
    };
    this.viewerOptionButton.performanceOption = performanceOption;
    this.viewerOptionButton.performanceOption.addEventListener(onClickEvent, this.show3dOptionsPerformanceTab );
    this.viewerOptionButton.subMenu.appendChild(this.viewerOptionButton.performanceOption);

    this.addDivider(this.viewerOptionButton.subMenu);

    var navigationOption = document.createElement("li");
    navigationOption.className = "toolbar-submenu-listitem";
    var navigLabel = document.createElement("label");
    navigLabel.setAttribute("data-i18n", "Navigation and selection settings");
    navigLabel.textContent = Autodesk.Viewing.i18n.translate( "Navigation and selection settings" );
    navigationOption.appendChild(navigLabel);

    this.show3dOptionsNavigationTab = function () {
        show3dOptions(Autodesk.Viewing.Private.NavigationTab);
    };

    this.viewerOptionButton.navigationOption = navigationOption;
    this.viewerOptionButton.navigationOption.addEventListener(onClickEvent, this.show3dOptionsNavigationTab );
    this.viewerOptionButton.subMenu.appendChild(navigationOption);

    // Calculate width, disconnect from the main container and attach
    // as a submenu to the parent button.
    this.viewerOptionButton.subMenu.style.width = this.viewerOptionButton.subMenu.getBoundingClientRect().width + "px";
    this.container.removeChild( this.viewerOptionButton.subMenu );
    this.toolbar.attachSubMenu( this.viewerOptionButton, this.viewerOptionButton.subMenu );
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.removeViewerOptionsMenu = function( mode ) {
    this.viewerOptionButton.removeChild( this.viewerOptionButton.subMenu );
    if (mode === "3d") {
        this.removeEventListener(Autodesk.Viewing.RENDER_OPTION_CHANGED_EVENT, this.selectLightPreset );
        this.viewerOptionButton.envList = null;
    }

    var onClickEvent = this.navigation.getIsTouchDevice() ? "touchstart" : "click";
    this.viewerOptionButton.navigationOption.removeEventListener(onClickEvent, this.show3dOptionsNavigationTab );
    this.viewerOptionButton.navigationOption = null;
    this.viewerOptionButton.performanceOption.removeEventListener(onClickEvent, this.show3dOptionsPerformanceTab );
    this.viewerOptionButton.performanceOption = null;
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initDebugTools = function() {

    var debugMenuId = "debugTools";
    this.debugMenu = this.toolbar.addSubToolbar( debugMenuId, false );

    // Create the debug submenu button and attach submenu to it.
    this.debugMenu.debugSubMenuButton = this.addMenuButton( debugMenuId, "toolbar-debugTool", "", null);
    this.createDebugSubmenu( this.debugMenu.debugSubMenuButton );
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.createDebugSubmenu = function( parent ) {

    var viewer = this;
    this.debugMenu.subMenu = document.createElement("ul");
    this.debugMenu.subMenu.className = "toolbar-submenu";
    this.debugMenu.subMenu.style.minWidth = "180px";

    // Temp connect to the main container to calculate the correct width
    this.container.appendChild( this.debugMenu.subMenu );

    this.initModelStats();
    this.addDivider( this.debugMenu.subMenu );

    this.addOptionToggle(this.debugMenu.subMenu, "Show search bar", false, function(checked) {
        viewer.searchMenu.setVisibility(checked);
    });

    // Add the language setting
    this.addDivider( this.debugMenu.subMenu );
    var langNames   = [ "English", "Russian", "Japanese", "Korean", "Chinese", "Spanish(unsupported)" ];
    var langSymbols = [ "en", "ru", "ja", "ko", "zh-Hant", "sp" ];

    function setLanguage() {
        viewer.localize();
    }
    var initialSelection = viewer.selectedLanguage ? viewer.selectedLanguage : 0;
    var langList = this.addOptionList( this.debugMenu.subMenu, "Language", langNames, initialSelection, function(selectedIndex)
    {
        var langSymb = langSymbols[selectedIndex];
        viewer.selectedLanguage = selectedIndex;
        Autodesk.Viewing.Private.setLanguage( langSymb, setLanguage );
    }, null);
    langList.parentNode.style.paddingBottom = "15px";

    // Add display of errors
    this.addDivider( this.debugMenu.subMenu );
    var errorNames  = [ "UNKNOWN FAILURE", " BAD DATA", "NETWORK ERROR", "NETWORK ACCESS DENIED",
                        "NETWORK FILE NOT FOUND", " NETWORK SERVER ERROR", "NETWORK UNHANDLED RESPONSE CODE",
                        "BROWSER WEBGL NOT SUPPORTED", "BAD DATA NO VIEWABLE CONTENT" ];

     var errorList = this.addOptionList( this.debugMenu.subMenu, "Error", errorNames, 0, function(errorIndex)
     {
        var errorCode = errorIndex + 1;
        Autodesk.Viewing.Private.ErrorHandler.reportError(viewer.container, errorCode, "");
     }, null);
     errorList.parentNode.style.paddingBottom = "15px";

    this.debugMenu.subMenu.style.width = this.debugMenu.subMenu.getBoundingClientRect().width + "px";
    this.container.removeChild( this.debugMenu.subMenu );
    this.toolbar.attachSubMenu( parent, this.debugMenu.subMenu );

    // Check if the menu fits on the right site and if not, adjust the right edge.
    var right = this.debugMenu.subMenu.getBoundingClientRect().right;
    var rightBoundary = this.container.getBoundingClientRect().right;
    if (right > rightBoundary) {
        var leftAdjustment = -(right - rightBoundary + 10) + "px";
        this.debugMenu.subMenu.style.left = leftAdjustment;
    }
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initModelStats = function() {

    var self = this;

    function updateModelStatContent(message) {
        var viewer = self.impl;
        var text = "";
        var model = self.model;
        if (model) {
            text += "Geom&nbsp;polys:&nbsp;" + model.geomPolyCount() + "<br>";
            text += "Instance&nbsp;polys:&nbsp;" + model.instancePolyCount() + "<br>";
            text += "Scenes:&nbsp;" + viewer.modelQueue().getSceneCount() + "<br>";
        }
        text += "# " + (message || "");

        self.modelStats.innerHTML = text;
    }

    // On progress update debug text.
    //
    function createModelStats() {
        self.modelStats = document.createElement("div");
        self.modelStats.className = "statspanel";
        self.container.appendChild(self.modelStats);

        self.addEventListener(Autodesk.Viewing.PROGRESS_UPDATE_EVENT, function (e) {
            if (e.message) {
                updateModelStatContent(e.message);
            }
        });
    }

    this.addOptionToggle(this.debugMenu.subMenu, "Model statistics", false, function(checked) {

        if (checked && !self.modelStats) {
            createModelStats();
            updateModelStatContent("");
        }

        self.modelStats.style.visibility = (checked ? "visible" : "hidden");
    });

};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initEscapeHandlers = function() {
    var viewer = this;

    this.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, function(event) {
        if (viewer.contextMenu && viewer.contextMenu.hide()) {
            return;
        }

        // Render options isn't enabled in release, so don't try to manipulate it
        if (viewer.renderoptions) {
            // Close render settings panel
            if (viewer.renderoptions.isVisible() )  {
                viewer.renderoptions.setVisible(false);
                return;
            }
        }

        // Dismiss explode slider (an explode in progress stays in progress)
        if (viewer.explodeslider && viewer.explodeslider.classList.contains("slider-anim-in"))  {
            viewer.showExplodeSlider(false);
            return;
        }

        // TODO: stop any active animation

        // Reset default navigation mode:
        if (viewer.getActiveNavigationTool() !== viewer.getDefaultNavigationToolName()) {
            // Force unlock active tool:
            if( viewer.toolController )
                viewer.toolController.setIsLocked(false);

            viewer.setActiveNavigationTool();
            Autodesk.Viewing.Private.HudMessage.dismiss();
            return;
        }

        // Deselect
        if (viewer.selectionActive) {
            viewer.clearSelection();
            return;
        }

        // Show all if anything is hidden
        if (!viewer.areAllVisible()) {
            viewer.showAll();
            return;
        }

        // Close open alert windows
        if (Autodesk.Viewing.Private.AlertBox.dismiss()) {
            return;
        }

        // Close open windows
        for (var i = 0; i < viewer.dockingPanels.length; ++i) {
            var panel = viewer.dockingPanels[i];
            if (panel.container.style.display !== "none" && panel.container.style.display !== "") {
                // NB: Since the document structure panel state is reflected
                //     in the toolbar, we need to update that as well.
                if (panel.container === viewer.modelstructure) {
                    viewer.showModelStructurePanel(false);
                } else {
                    panel.setVisible(false);
                }
                return;
            }
        }

        if (viewer.escapeScreenMode()) {
            return;
        }
    });
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initHomeButton = function(mode)
{
    var homeViewContainer = document.createElement('div');
    homeViewContainer.className = "homeViewWrapper";
    homeViewContainer.style.cursor = "pointer";

    this.container.appendChild(homeViewContainer);

    this.homeViewContainer = homeViewContainer;

    var self = this;
    homeViewContainer.addEventListener("click", function(e) {
        self.navigation.setRequestHomeView(true);
    });

    this.initHomeMenu( homeViewContainer, mode );
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initHomeMenu = function(parent, mode) {
    var autocam = this.autocam;
    var self    = this;

    function hideHomeViewMenu(e) {
        homeViewMenu.style.display = "none";
        document.removeEventListener("click", hideHomeViewMenu );
    }

    // Add the handle for the menu.
    var handle = document.createElement("div");
    handle.className = "homeViewMenuHandle";
    var image = document.createElement('img');
    image.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAKQWlDQ1BJQ0MgUHJvZmlsZQAASA2dlndUU9kWh8+9N73QEiIgJfQaegkg0jtIFQRRiUmAUAKGhCZ2RAVGFBEpVmRUwAFHhyJjRRQLg4Ji1wnyEFDGwVFEReXdjGsJ7601896a/cdZ39nnt9fZZ+9917oAUPyCBMJ0WAGANKFYFO7rwVwSE8vE9wIYEAEOWAHA4WZmBEf4RALU/L09mZmoSMaz9u4ugGS72yy/UCZz1v9/kSI3QyQGAApF1TY8fiYX5QKUU7PFGTL/BMr0lSkyhjEyFqEJoqwi48SvbPan5iu7yZiXJuShGlnOGbw0noy7UN6aJeGjjAShXJgl4GejfAdlvVRJmgDl9yjT0/icTAAwFJlfzOcmoWyJMkUUGe6J8gIACJTEObxyDov5OWieAHimZ+SKBIlJYqYR15hp5ejIZvrxs1P5YjErlMNN4Yh4TM/0tAyOMBeAr2+WRQElWW2ZaJHtrRzt7VnW5mj5v9nfHn5T/T3IevtV8Sbsz55BjJ5Z32zsrC+9FgD2JFqbHbO+lVUAtG0GQOXhrE/vIADyBQC03pzzHoZsXpLE4gwnC4vs7GxzAZ9rLivoN/ufgm/Kv4Y595nL7vtWO6YXP4EjSRUzZUXlpqemS0TMzAwOl89k/fcQ/+PAOWnNycMsnJ/AF/GF6FVR6JQJhIlou4U8gViQLmQKhH/V4X8YNicHGX6daxRodV8AfYU5ULhJB8hvPQBDIwMkbj96An3rWxAxCsi+vGitka9zjzJ6/uf6Hwtcim7hTEEiU+b2DI9kciWiLBmj34RswQISkAd0oAo0gS4wAixgDRyAM3AD3iAAhIBIEAOWAy5IAmlABLJBPtgACkEx2AF2g2pwANSBetAEToI2cAZcBFfADXALDIBHQAqGwUswAd6BaQiC8BAVokGqkBakD5lC1hAbWgh5Q0FQOBQDxUOJkBCSQPnQJqgYKoOqoUNQPfQjdBq6CF2D+qAH0CA0Bv0BfYQRmALTYQ3YALaA2bA7HAhHwsvgRHgVnAcXwNvhSrgWPg63whfhG/AALIVfwpMIQMgIA9FGWAgb8URCkFgkAREha5EipAKpRZqQDqQbuY1IkXHkAwaHoWGYGBbGGeOHWYzhYlZh1mJKMNWYY5hWTBfmNmYQM4H5gqVi1bGmWCesP3YJNhGbjS3EVmCPYFuwl7ED2GHsOxwOx8AZ4hxwfrgYXDJuNa4Etw/XjLuA68MN4SbxeLwq3hTvgg/Bc/BifCG+Cn8cfx7fjx/GvyeQCVoEa4IPIZYgJGwkVBAaCOcI/YQRwjRRgahPdCKGEHnEXGIpsY7YQbxJHCZOkxRJhiQXUiQpmbSBVElqIl0mPSa9IZPJOmRHchhZQF5PriSfIF8lD5I/UJQoJhRPShxFQtlOOUq5QHlAeUOlUg2obtRYqpi6nVpPvUR9Sn0vR5Mzl/OX48mtk6uRa5Xrl3slT5TXl3eXXy6fJ18hf0r+pvy4AlHBQMFTgaOwVqFG4bTCPYVJRZqilWKIYppiiWKD4jXFUSW8koGStxJPqUDpsNIlpSEaQtOledK4tE20Otpl2jAdRzek+9OT6cX0H+i99AllJWVb5SjlHOUa5bPKUgbCMGD4M1IZpYyTjLuMj/M05rnP48/bNq9pXv+8KZX5Km4qfJUilWaVAZWPqkxVb9UU1Z2qbapP1DBqJmphatlq+9Uuq43Pp893ns+dXzT/5PyH6rC6iXq4+mr1w+o96pMamhq+GhkaVRqXNMY1GZpumsma5ZrnNMe0aFoLtQRa5VrntV4wlZnuzFRmJbOLOaGtru2nLdE+pN2rPa1jqLNYZ6NOs84TXZIuWzdBt1y3U3dCT0svWC9fr1HvoT5Rn62fpL9Hv1t/ysDQINpgi0GbwaihiqG/YZ5ho+FjI6qRq9Eqo1qjO8Y4Y7ZxivE+41smsImdSZJJjclNU9jU3lRgus+0zwxr5mgmNKs1u8eisNxZWaxG1qA5wzzIfKN5m/krCz2LWIudFt0WXyztLFMt6ywfWSlZBVhttOqw+sPaxJprXWN9x4Zq42Ozzqbd5rWtqS3fdr/tfTuaXbDdFrtOu8/2DvYi+yb7MQc9h3iHvQ732HR2KLuEfdUR6+jhuM7xjOMHJ3snsdNJp9+dWc4pzg3OowsMF/AX1C0YctFx4bgccpEuZC6MX3hwodRV25XjWuv6zE3Xjed2xG3E3dg92f24+ysPSw+RR4vHlKeT5xrPC16Il69XkVevt5L3Yu9q76c+Oj6JPo0+E752vqt9L/hh/QL9dvrd89fw5/rX+08EOASsCegKpARGBFYHPgsyCRIFdQTDwQHBu4IfL9JfJFzUFgJC/EN2hTwJNQxdFfpzGC4sNKwm7Hm4VXh+eHcELWJFREPEu0iPyNLIR4uNFksWd0bJR8VF1UdNRXtFl0VLl1gsWbPkRoxajCCmPRYfGxV7JHZyqffS3UuH4+ziCuPuLjNclrPs2nK15anLz66QX8FZcSoeGx8d3xD/iRPCqeVMrvRfuXflBNeTu4f7kufGK+eN8V34ZfyRBJeEsoTRRJfEXYljSa5JFUnjAk9BteB1sl/ygeSplJCUoykzqdGpzWmEtPi000IlYYqwK10zPSe9L8M0ozBDuspp1e5VE6JA0ZFMKHNZZruYjv5M9UiMJJslg1kLs2qy3mdHZZ/KUcwR5vTkmuRuyx3J88n7fjVmNXd1Z752/ob8wTXuaw6thdauXNu5Tnddwbrh9b7rj20gbUjZ8MtGy41lG99uit7UUaBRsL5gaLPv5sZCuUJR4b0tzlsObMVsFWzt3WazrWrblyJe0fViy+KK4k8l3JLr31l9V/ndzPaE7b2l9qX7d+B2CHfc3em681iZYlle2dCu4F2t5czyovK3u1fsvlZhW3FgD2mPZI+0MqiyvUqvakfVp+qk6oEaj5rmvep7t+2d2sfb17/fbX/TAY0DxQc+HhQcvH/I91BrrUFtxWHc4azDz+ui6rq/Z39ff0TtSPGRz0eFR6XHwo911TvU1zeoN5Q2wo2SxrHjccdv/eD1Q3sTq+lQM6O5+AQ4ITnx4sf4H++eDDzZeYp9qukn/Z/2ttBailqh1tzWibakNml7THvf6YDTnR3OHS0/m/989Iz2mZqzymdLz5HOFZybOZ93fvJCxoXxi4kXhzpXdD66tOTSna6wrt7LgZevXvG5cqnbvfv8VZerZ645XTt9nX297Yb9jdYeu56WX+x+aem172296XCz/ZbjrY6+BX3n+l37L972un3ljv+dGwOLBvruLr57/17cPel93v3RB6kPXj/Mejj9aP1j7OOiJwpPKp6qP6391fjXZqm99Oyg12DPs4hnj4a4Qy//lfmvT8MFz6nPK0a0RupHrUfPjPmM3Xqx9MXwy4yX0+OFvyn+tveV0auffnf7vWdiycTwa9HrmT9K3qi+OfrW9m3nZOjk03dp76anit6rvj/2gf2h+2P0x5Hp7E/4T5WfjT93fAn88ngmbWbm3/eE8/syOll+AAAACXBIWXMAAAsTAAALEwEAmpwYAAACw2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzI8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNC0wOS0yMlQyMDoyMDo1MDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+QWRvYmUgRmlyZXdvcmtzIENTNS4xIDExLjEuMC4yMDUgTWFjaW50b3NoPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDE0LTA5LTI0VDE1OjIzOjQzPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+Cj190pwAAADZSURBVDgR7ZKxDcIwEEWP4IppUiBcpGCQ1LCBp/AGiNaDUEaiyATpsgJVBNyPZOscBVknRIcL5/vu+8X5MdF/lBLYRIO19h615tl13R5+IzeFEOSyqNu2TZ4qqS9FdiL5Bi03ZYSNxpjjNE07ls8CqGLvg7236MtA2sBj0IBln4ZCXdfknIP8OLz31Pd91t/K1TiOVz7yaRgGappGtpKOED7NgYuv2MhAaDDswrDzGkxAcHcSBLAlCDVagy0gs09OWdiyAY3wkRkGMpHhzkXNBJj2b2r4v/O+AQ/0UQF3+ePEAAAAAElFTkSuQmCC";
    handle.appendChild( image );
    handle.addEventListener( "mouseover", function(e) {
        image.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAALEgAACxIB0t1+/AAAAB50RVh0U29mdHdhcmUAQWRvYmUgRmlyZXdvcmtzIENTNS4xqx9I6wAAABV0RVh0Q3JlYXRpb24gVGltZQA5LzIyLzE0QkgJKgAABpZwclZXeJztWttx6zYQhWiIMGkZosgGUkIybiQt5CPK721HzaSAjHpJB3F29ywetMb3ChQlz53BMSUApIR9YR+A/M9/f/9rvplv74wz/b2fz2fpneV1PtHf+4na0/nI1+l4PB+Pp7fT+e10ejue344nU1FRUVFRUVFRUVFRUVFR8RNi9OO4H0c/rfgqoe/HyQ/EAb92K7VF8u8H4niY/DhMK7X7Evq7UZTGalitLZNfNDC+juu1JfSnwbMChO+12iL5/URst33X9Z283dTSUvaHMvpit65zXd/i6nmwcIwlUEKfnW8YmX/IQNO5XKyScduN5INl9ofdIANLgLna4jHf6rsl9j/QqsVkEAdrAQQKxvL9cvtL7PVRgSKS6DSKdeW447dy+7PBdpNtbGtbw29W3qTfaN9q38TH6M8+L+/l9p+EZZ4G1Ey45uPwnBnNxzowYMMssL9ELQM5IGWQysq8rQmDoIUoc/h8+ixJX+r/FIA96z9dKlAThLUmXLgVe2EcNNZapl7o//SFgxeaTZITUn3QhH7gUhOqffoMclkJfbH/mAgnqRrlI0hnlG6wd5OWQ2y5ACjM/6yACX7rYyV00Nc0aPvZ/WFe+fC98VBCfy/lF/yWkyd1Bp0u5PTAwi6OP5LUlrkvXv87IUsxAFMMoMReMe10TClaxsgVYYx2TGNWfXH+V66hBlBHLt9Hc3hwko9RtEbqkkMGOP8S/+f56fuYUG0sWnlNCp6N8+eqfOWh1P8h6ST6n6DCJBqWBPeHMA4qyMbDHtrhdVMc/wH34lzvXvqXZ7mc/PXSkw7dfNYxvesnQksN93mOcsrAi5NpmYZMG7tgIHAVu+hjqC2Rf+6X0heBe6bH00Ggl0hJWZJ+H+4l2jLg77vn5fJDA5/Kn/qZKQJ5pwzcJP+zU9Fl6hkPUEeu/+c4FsrMg/C/XP7eJYEurJzpOjIVl6YL+qdrKX0/SuUS/Fz8W7xwiL4uzzhYvMbgGwORjEeuIxbioFHAD5l/72ZhLjzz4GIv7i4pge9Lpyzz5UAVxDFoPKAdENZ0R/vxWbo36P295Ial9D3Yz0LbZbTP7w3T7NjC67eXy//6w52txPhdFus1W44HL5ooznwX8n9vZztqjBcqmmqFetBIeeZTtHzBjtjISI2n1dhFO+tTjUiFGPaO5TsfoDGWLtgRG6pU0md17sea2MTdicUeeGnmY/lNcxA7YjcV6v20rQhV6YeaX/vYiJXvfCJ5mg1Gxi60jRXwnA3bpso41wL2fovtb2b2p5myuj7bAiQ2PmoE+9Cl9reigZ3an0VpoqQXW4B5X/cLOP1YbH9BY42TszCcRZBAKjdh27bWUets6kMjWC8oXUmMTbtZSt+aJ9ts4efQAvTtmA2+2tBBX5+Kw8jS2bWbVpbyd/Grvi7heBVMUk3ruQ6UrRJblp4lj/1GHA+a54hIKnz6MQOfwVEU2DaSWkccaYT9/eyKPVmKBscvCH5m25jF6Z+FJxaQxbCe1QW20eZBchlDO3nka+ymXc4AfzWcXkD/YWv/ySXa0cgnKWBreAXcCGJiY7EZ6zIvcG2mBfE68KgxR4x3K2logWXArHKuqV6QLX4NDbA8MiSRJ+dZg74YwSHHd2EZElPJ77fhPCyt/FFcdz3yBhWmRiFNA1F6jX7Zyh+IvL3d9MqAMw0qWZxqqhe6Nq6By5XP3yHfXwENG9LKIYKX42WnRztRer4k8mQr362x8jNYw16AWtOlikjzIFb+XmpAThv88ZVB1BuDglDPeGPWM20vtifuyEo3xrzPwFK1qHpBXk87ueoR1XcdTmSIzdas43k5RCpUvdB/qj5I/k7lp+fNhvPm2uQbKUlwHohz/nQCyvbnuCCnppTzNyut/BxbcmfxAs9RWGrCUPKQK+CgX2O+FM/3AcnFGTFWRPh9oQsrz5nlyf4qSCyIFVEffmfBCfNOQs76npcDFZHnylh/G0Kdj98LJFLek/wTV6RPOAsOvzRx6yXybMwNxcZV4GpuY+WIwXf68xxfHJsPsP/iavcaNFKMwM+D7dPKf4D9BaIFI8cM4glS59/P6S7BucAi20hGkDr/vpaf0ydFN8Me0fBADBiUKQ+CpRDfbNIhx5X7nNXQbFER8z8p6G97vOwfZgALLwg/j9yh2rkKHO1s7D+cAUkF6nOtMPNYIBfpwN099F7gq+WXkGOz/qPtT9JH+R8b/yoqKioqKioqKioqfmr8bv4wf5k/zS/mt69mpeIL8D9UVPgCtOlelgAAAEhta0JG+t7K/gAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKaQzoQAAOMhta1RTeJztfdtz20aWPjYTx5blazKVfdgXVe3+6vc0HtxJPoqkKCmhJA5J2XJeXCRI2NootleSlXhZ+N/3nNONW6MBAuDVNkYTN4nGpfs7p79z6W7w5Nfm3exlf3A5G3kv+yeXM83r9FuRov+v08tZzXZq7sioexfdljtTvdeseHXcdmda3Ts6HlLZPxi4s5ru9Qfnl1DdPIQ7uPQ/r9ft3s2aPfintT+8mSk7ylhxlDdKT5kq7+HTpXLlHZ+eQM1DqHkPNZryD6i9VP6CM668fvtsjLfcP6U770ODjWnda7aPsZHNE2i5CwX1ozk4oJMGHaobHFHR7NLB5q9UtE75DQ469L0/pJM6TfrW6VNxyg4Oepezhu01h6xyyO4+HLCHnLD7seJ4H1t5iq1SvfaZdjmrQ6HjbdpnBhUdOKhDobPCwMLLhcy/y5BR9pR9OHoL3/8Bn66gHCk3UDNZJ2bagphpq8Jsl2N2qFwDLh+Vd1B3q0wzsTEZNtMMbFQpNo4Tw0bNwMapM2wMvTA6msngGTF4RgyeOoOnzuCpe4Peb/CUsTcY8LJ3BqhZIzjAP+QD8DkHsKV8AOX6ADCCaoHSRc+Mggk3JjR1KwvNUQ40BU3LQlPQtNFyRydBaNsSCAe9JqsZsDIK6QMOaZPG46XicEAfcUAHAKYLurindKH2fRmd1FyzOI5ZI9ZwSo7YUdERm4bO0wQ6ffj0CY5N5nJaLowWZrXNY+Rr0BEcv6bBWFqD8rBaAStZABt1tfoTYrOg/izZj1gfQj6ltwmhd9T7OEaRmhiSWRjpWzrGtKWj9EyKUpu0aQymMHu0bStO+ppwGsLouwR/60vFyVg6Tk+kOHGeKo7Rxpk7a8RZDCGLIWQtxEtHUI6UO+XzF2n7tbjPbjGYLAbTiME0YjDJPfIkTDsBTB/AQbpdo1uU6YI7Zkm/SGXQqAwalUGjMmhUBo0ag+YRh2YfGOYaLHwT/v2EIHGAHnCA8lk0lGkEH9tkAFH9XIDqZgZAFNtFIJosaPt1hpDOEDIZQiZDyGQBH4o1FvFhNyhcgQNFMPTj5iGo11+gZJ9Y4JeNpJSosoHUGhxKfZwVPItQFgqfS4OpN/KB+YSD2QKFu6IUzNsg3fBZGLV9qB3D3wflfQzM2oShWXd4gqaxJNbPGrSlYxm9ngfFohj9wDF6Bap2K0Wn5qev5KSWFQ7jpTF89I3jQ+kDytE0S+lUNtGJGjVdrkLJ3Qh9qxTKB+hfwF+XeFYMINNiAGljQav8rKjKMHKyCMwd5Rl2ZCgiONncWOLVq9Gs3/ChPHdlaJOQwMoSFyrZH0RcH7IzyxxEzcgdR2uqWZy7LJVBSJ4MYuhmpf2WA2IUu90Au3fkwzuAzChIm/qotchuInLZ/qtAaJruSClNwK3mFMfN5LnSER+jxsTMbTvLK1/Tz5xyieVHsownIjcPlJJOB9PRi4MZ+CGWztAkweVEU5vmNhLM80AQ3QLQ3Y8nU4tARpw3N06g3hJm6IflxMye8oFLUB3w7P1SFbAPeqdPp/ChmSS9fAO3Rzb1dv7kozBwXTMH37lmCdh8k8HHLane8octjtaB7/yizWBesP8hpoz0oS8Z0TsBxGhNPpOzG1fJPhz/fU5uqM6QbTBkyYRGkFUXDVxNhitTQxxadW6MKSZBaHEuC7HVM7C1ePgK/jrLgDQYujaH1+b42hxgxoL4YewKM0roCfaPyJDlA7NYoBuPcyneKpngzqOmSTRzKKqhyxTV5khyINNwDBTVx1Hgyvk4Dml62FF+LzLicwGZz0uUI0kDHQ31eOk8SSOeRrMPZD869BkZpCPqM2mHFiLgZN0Qk75COq9LbuU7qj8hxoWBr1xnxneONJOgZwQroSkq4QstKVyxE3Pw0eEdOkIINDlC9WkBPP0E8hHH8yrAVUTTn4Mnl4ZUVo1RKXOEElQqjf7IVuV1yUcrhTM/VPdjA/r9cmf9cqas1OWshcmraVG9Eld35NOrNh+b6aM0xUAXIULNmuZJna55mDb9zGkyD/MDx+5MskStSZNc6CXOm+YalZ1aRs6fh5IhODK+wfA9ROLNhBuj5YhF8ChNdXGs9DqzEGQP9smsEcfhEhi0DyaW5AXnxnAA6KE9xgn6mzza5ucV/ES9NpoumqjnOFoCjnF1wxE8oAWS6WbX5tM8NN1jsBJxNByGI5UGlYQj4dYnvHz7Svjp8/HbDfDDSdYRnwnKHq8jaYiXRw0n06zkljOSBsVBgJeZmUlxp3MiSN5Lcl1W/4yP6F4/RBm1tT9IBoQyeH+SZx34TEm+QV8rOehz2RUevbgjIQvGtdUcx8a8KRvzvrYSSxp8lHMZ0PQtn32DMj4fwhzEPtPXQZ/zAf+Oeqy5uXngeYRLMQ5HiNei05gfyKHTOicFRxeUesITPSzin6PWQB5SqB2+bNPhBOvUxeiGtNn/IFd09sGPx1EuJCAUCIvQJTr/mIviFcE85WkQWuBZwodyOTW7cWp2R0uycIv6l3LrpsvCIeZERQEPoiAxAzwfwweBy55nDYMwfxp46fnm6jEDWdAZDXSZ+H2hrKV0+XGQTApjdPKy/A/9s4gJVBl1CKto82OcL3jX6zJSZq7rEhH2Y3fDTwtb+QGWO62GTFlp6XHa4mRZ7qPPPa0Pyh/CnGsHTZwMurEZI1p/jBfxHjLXxZOay/JxcveLGzRDhpxTl7Nsg3v8DZ5CatjMfSWz5ac3mqEZ89MdQiiQDqLPla8pcMrmyrgC5soX58Ix7heMpatxBK9AypVpPmxaQjM+0cNhI5tTGD62oik7CjBk41eYoVWl6Kn50SOdTMI3NufngwP4hHwwqjXhxz4Y7APzq+pT7lfhB7LftsocK3JZ+z5dsggrH6Z+fID7Nt4rLq6owE1CMmw1iw9xOz7ERwWsuC3lRlXGjSwhXGYdlM+M8Z0vOqdGKg0qGWY2Nymi3U4HLQxK/wfocEQ+f7Y6WmUXVRQwJsy3jwT2BSbMYMRL1RGPd/jxDjseUCIZ6hq30zWmkT41kkIeMQ9Ttp7sHPB7T7b6E4X1vpt/jyNrKO0SM7e1PGvx8uR9jbh5jmsg9FUSM+WLT/W6JFNyxDyfIjg9DHGCQOiQPJ0/sxGTMmK+5Ys+ZNp8SnSkjKhNZVZZWytkjwMH8APZj3cQPfK522zglrf2PEvX6tIlUeiHRoDTi2ST0oBjBniQJLy8SncGx29pXmHeZqJlKJ2VP7shKF1jvhfjzyQKpmJJKvcoMK7vaG0PptWniSWdImh22SSwlj9VHoR2hl18+tUP7ebtLD3yI42jZKQxD7rnQbxxRYvyiuZ75DODi7MdLYOKJHxGctWb5k8Ci1GIVPl8r68fZG2STl5eSHHJyiXtBV85pIn5bEOKaaMeT6K5Ursrn58QVgY4ci6UhXbizucwfcYdmWjKkqEPHaxZjDztYuD/zMF/SUlhh7aH3dCmfORR3CO9FwqmuBjYQsC8mi2VQtwcCXacEhRJGRTyfQyeSDP4jigoSQZ8XUFUzXs82o6lgMjnjGST6/FkcsrOhTSBPIm4A39RRmiPskeFHQJanFVgB0MgBXN+DFT6dRIY5OSgaEq6OTXJwhia66QD/gcf6x4P3bGLLG8cieUpf+x1uu27WSe6C9clWQwoJ3cZ2aLkkgxO6YUBf5B0zlNruEw6DJAOs3Qdpo2dAwKt02/TKf0+qztixQUWXica2rEG8Q3RGMIJTYrWnKfWlGuSzpoExWHQoufQHid4AcWEc8Jt5H0KN4Ef6/CZECRuR/kd1NZ/XUXn8CUAf9piNz+Gz4c9fANLh71iRaX/eZEqza/i71/ButdYpy5+H63kLfwq+E7QeTHR7XLRtWhHkgOj+koivj4HMalR0Zpy4jOY+IxKfCXE94SLrw8AOdBpTK28FYT4JBCV7JzzHOeUE+yICXZUCbaEYB8G4xITiWhPo4GjG0ky+nXnGXXlBGgyAZqVABcYmUwQt+ShXvuwCSNTfs55jnMWolxNqyRbQrKh+zWiF4CF65ldnsb2j5+nHC8nNYtJzaqEtoDQeuRuOpFd6y6P4v3j5ynHywmtxoRWq4S2gNA6BMwkgMUXTnj8POV4OaHVmdDqldBKCO0xF9oB39v6kUgv6r885mKSnXE+94xyIm0wkTYqkZYQ6X0u0iZNzt4E6wfcYB/UdTAGxaPlxOUwcTmVuEqIaycICnHksLdBifF8WCPG82FNOdFNmOgmlegWsHivaOHiNGHxwuPnKcfLCW3KhDathLZArN4LZ36CoOBh4EdG684z6soJ0GUCdGMNexRo01QZK22SyDuamPInVH3tEevP59SXa6TGs8dYtrUIsJ22HvtmxL6ZsW9DJoBDSopX2ppLW0vh9JTjhHNsH2iq/VY547uG3s7HSm+oI6uR0seawxs4H6t899kwVg85VpH3F0BdiJAta5br2jbOe0aqXuh1v7au1lVUhGitafm1ts3UJFprh5cCMkJlzfIiGhZ/bBRQ+H9SMF9e87dEH/q0falJqy7mjhj2dHmzGqo61nOOmHz32TBCPgsH3Bvy8XycROWRNS4PTnnus2GcdjhOA3qV1h1Z3zm80jAaIOe0gWnq+Jc2MMfW2BhrKQPTtpMjPhyYkyn+SbFAMqhLxPLlNX9LbDLjlUNaKo3nJhnGyMcM6gsrbCL+l9p6mXOzqodsGOVnEQ8RUOVovyarzpYGz8HZp1kpBBn0DP+TOkaresiGcd4NuO0jn3fG16H+MY/fZAqmRysTfkfYbn2U6nYkVVN9UY+Alqa3fnNykdv2tn3DuvBcGHOR0TaP3V6EbRkDSKO0ITFxoTpe2RCvzBx5S37QlngWWPORRmDUszClprlm2prQbSPo9nhSdyxBB4Na29Gnmtxtn7qTsTNJYr+ZJmxYKk8iUhnjhActLE6OACm7qKpRFzkidJ2AQRqjWprrBMbEzuCX5KW1jEs1sUW5yHGrm78lPskBbXygpbe0ij/wAefphq4aTsLyBOBq40ZNG6eBq01N17RSwLVHU0fV0sBN3lgTW5RLN7a6+UvMKx902nezg05kOnVKGnJMC69R8k34947ekOnPw02DvR0j5dY76A3uZu3WAf7zK8UMB4pLe1HRwzpWbviq+Uv+gyrt1ks463vufUEEFLl2N3btCb0r5Fhp82v+nzJTalRrKxr8qYqu/AM+O3AEP+GxCf1wXh2O1aBGpT+LzqzBvxrU4Dcv9tSdsI/KUPmMtok/8d8UNXbmw8iZr2hfy63yjp/7HbYodvbjyNn+eqprlrELrqkplnDNAdz1LVyDrzqgralQ0vqClDY9pp8GfEsZU/8Htd7TdTfBFUbsikf07q8b5ffU88UnhG/3a/PX4oxomYqP099IGiJW4VVBCyPnG0LPd6A1V+QbTOdI4WnkzBNaNXrLf4bmkrwK/ypNuIrtfIvpdMh8/Kr7yn8C/i7XnPhzn9De9T95/IujYJK4fgeuVyN/huIKWB5R/in7Dm7kT7zDLt3himexZO2PXC1cOaCtbBPqhezKSMsF7A74a8FBS2Dkj2jMzet7UiMGpMt/giTGyn+zUc6vvQetRRtzk2CEJkntlsbPgDTvNlUznvubafmZ16kaK165E1wpjmvxzP8PSPwO7e+QFKaUU7zm0jiDZ1yB7rJXSv0BOvmBRvw1HIsy2zmcf8o2FfKn7EYYdy/CuUTRBdj5IWfn32js/QbPeKvoFUdXHL1yjjYrjq44uuLoHBy9wzm6D6jh83DMVQxdMfSqGdquGLpi6IqhC+Q4+rQd423FzhU7r5ydrYqdK3au2LmA/zyAe/O3gVUMXTH0yhla5NqKoSuGrhhaxtA/Jhman08rShX2e+YVZ1ecvWrO1ivOrji74uwCXnVk5rBi6IqhV87QRsXQFUNXDB0wtESTv8mVd1rFzlvAztXKu4qdv3Z2DrVzEXb+FlfeVRy9DRxdrbyrOLri6Dwc/e2tvKsYehsYulp5VzF0xdBFchzfxsq7ip23gZ2rlXcVO1fsXMR//nZW3lUMvQ0MXa28qxi6Yug8DF2tvKs4ezs4u1p5V3F2xdlFvOpvZ+VdxdDbwNDVyruKoSuGDhm6DWeh/kfkGbwHmzF0+Bseb2JnrZetR8BvDcWEvwncr74Uts7WYlEHR4J39zB29bx11tFz2ZtGQ3YxBW6Inpumc7WMniQ50gAErLXonq9PezFdKap7/owItyrfnK7Zwuzp8nStXljX0BvRv2Bte8K1LWp3RG/0Adc3zBmA3fjq1xkbgsak+6JiTPvleqJiPzbtiVarjL9ET1QTxnbliabz86OQT4GhI2gvwNB9eMIlIfp1M7Toa1YMXTF0xdBVrmC5DP045FNlksnRT2NS3KN+sd9GuIrlDAYknUuqi17xAv8SnD2fd8cQialQ2yD+nBLvmjRWfN7F+GwEfy5wrR+p49l1+O4C003gfG8NWM7re7QF/wF9bcIzXGoBY4c38KxrYgjkkz/h+23QPrRi/xs86R71fQ//jd31njISGO876Huc7x4ok5xR3j2ozeYIGmkltORRbG/o5nJKFrfULtlotOQ1+DPhfF+3DPg0Ju2aBOxSJy/AJS1Ey75YTsmScFWVU0p6kTJtKaN7D2N38+vWq3c66VQddA3GHOkYchWyV3m9y+P12YK85ntk4i6rvL5Mmi1ejaU016CFcr2Ja+AjGCUT8DA+UX/2Isgw3fshuialhC2cgI5YIH/UmgbFG8hbE5CrGIPUA35BXkNGm8B/6Bc21mIL4z1dkeUrhP3P8NTrIDLgeq78Uxwrpf0UA1BGdMc0UpkFaQD2WmxMY/0E7qKSL6NyOaIMLZLZOmRTDIn46B1LrnxDd/8AyL8PuCYZOznC3fNctSld2YEY0me3m9IagSxtQr1L+sC8Cw0QtCSjVd/oaJX1N+493JCkrin+esN5+A18f6uMUyUev+Yd15v4VX8jRhOt0oQ06zbnkx5Hzs//lB2oRwz+gH/F+2s5ez9NzY5k9T68Kn/v05+U1vvsp4i9j94/3vtnKb1/q/i/iZcWE6chIF4pa98TCQrznvhUikSep+3G0Eg+R8zoyBEZK+z3I+WtE3EMWxi/Tta+xxI0sp/2RIrF/Cc9jCEhPkPbCnZ+rhzRr9f+E3xIzMp8IpbD56CFWY79ngT2W986+52n/3GZvqPz81hcHLXJe+a58hllPop7Bo/giis6N8g2CHoiz9BtzjdoETp31MflaNs00DZj67RN1t+4dpHtJOw/KJfk4914hz0A9LA3vJtddFv4O52vWeGFx3TLYkfxg5e4J+Yjl3nPRyGvL/W+uz5LLvWum9LuXaj/RFnvvahPuLD3qwXer7l13m9anysPuPKAKw+48oC3zwN+GB6BWsaGV2vOYU/ICzEpQ+1Q5npEax0aQg4bvZpRbD0EzS3TysrpWvhdjlb0ufdS57NlOez70JaPNBeNLfsc6FJyLcJOZL4d/eBJXFtjMr8Hd8V9i9OIlDvkTbB5WbY6o4wldmlNigqSQNzR6ro0PxrOcqlkiVEem7XE8h6vY8Ql0X/G86H+DtI97iHsw50/4jxTCUnoJAOdRs6IIksHSpNmsKM+kUUzPfnWEK1GEvN7vw6pfB/MajKZPKHVCjh/jRHhnl+7QIZWgzqDZjJNkodO90d5mJS7t4jXUP9xFFlQ16DYDb1Wl8aGsxZ5ZPd8RbKI3PVHaqf/fN8uXksj/O8AoTgP/pR69f9AOVKuYkz6HbLQHE0Iv5fhQ5S6S16IGUQmfhS+TZFJ2MtNjLadQMv2CMdryZrLomjrW4y2rL+bwP2Zcgjt+kQZtEuaFV8G00WjcTWIxo2tk8L83kfb8Hfy1qNnR9nFZ51PwYqGH6FHL8gXSv+zN2TbUG5+xnVxiVsgsTp5DTYgYpPX5/K1AiaNQJdsm0Y2zKJVdri+GeO+Op0xWpN/nt3z1du252TBwlx31LaJq+kagmX7e+q16avs5tm2R8pvCr7F5I8laEGD72FDudtBTlkn9sX9bWPSAtQTm2K5MWmAS9GdTjEc+p7r0IL0Xq9eA57BOezZRT2b59Ir83o19/mKtWtaU/4+2PsYP1pc6g5xOMZ4uNKMRXxsX0Iy4qttlO3Fvq6DeeWoP4ofXcjnwVV6Ov1n8XVaDRqFtYS19df3bQr/9F5vThJPoZ3vaf8Jq9kLVimWZcG4D2pusQ86r++r58KfiPHCFryhTOgN7f5fhj+VdX8Z41oC4/6ccf1t1t4lId9zSnN1OKvsj/99snp7YU1pfZuS5qi0VndMeTaHdMogq+twvxv/tWhHkr/6F23tlCw25hvWM/7Teh23jyM66w08xz8rn7R+kl75iZfi/oJ1z/XfV9i+w/gKcf/dA0fUlg9f+T7D+Nrp5b+VyE5cM3+noSZcMW+nIfpWRVe2i/NL1V5DNmtW7TX8evYa1gXt2+wOiu9Tdk3IWdh/P9wp3R9t/LpnOL8+Ji6+53v1TJzcd1hxccXFXx8X59/Nto49lWlc/AOgfEVe/QRGqL9rLXqsTPTtUkaZZTocnnlsRFYCsh3cKvDmZndwx3u6+lh7F9rhPy8ZDeEI8WNoQ3iXxg4x6ueMq7CfUOaQ73PSWYbLNbEEjra9BaU+oSxzjWxjg6Ru08x5Iyb1Mc06NGJSx/9cOnc98w95+v816sKPtMrmM+8r2y39GT6bXBq4GvYg8MZOCEvyqxaYhayT5Z7SyGZ56TrNT0Xz0jatfzFoDgr/Zd+xnNCx9cwFJ/u7joxEEZlEfT6cM2HWclOyaaxtvGb1e9tk9FSY2xxSH/GJmxtD1treh5Ld93XI6idasXapsLmNAfTykn9C/x19u6i0HoSrDlcsnxpIpUarzmq0+gz/tclWWuQdrUM+yd6uQyK7hP2UVs+iB+6vx/V36ffIZ7+lUf1OYe/2xMjujsZbtEdJryRfPiDd958nW5wxmlJE41Jsj/N6U7rCl+2IPNkajTSVv4VB535vA2pwFn49e/yL4Bhtz/fkDTmRvAFfseCdDECI3m/0b29/eDdrtrqXM9cdNya2a3gd9k2l/3mdXiDxBzTz9iZ8O1LgU7iJDM95ak2/fTaewX2HzUssDjpUDE4uZzp8G17ONK/Tb9Mp/T6rO2LFBRbe8KJ5N2MPvgfBD6Oi99CpX+9mr3pwTl31jng5HPwG94NeDI+hF8Pj9uWs5k5Ml3AYXnSWcyPv4KJ3N+ucDLELrW4fi16XetLbJ5C7p9j0HlbhTXpD/h2Q0Lz9XpcVA+z0/n6Lvu23qRjAbaZwZhsvOMSbqt4vvX9dziwsB+zrGSt6eP1h5xiLXwZ4zgjKA/Z1iLf7ZdAkYLs9QvQUG3c46OKx7uAcizYrugOSQGtwgpcdtAbYmdPXA/zWHdC3o+EJ3uRoyMigTYSCqvsnlbTg2Lvo0LkXJ9T+YZ9uB1dicdHep5t3LuAGind6Yt7N4J/Lme1R4bJCY4UqFFB28HxQH8ujAgjqdKCyew00Xuq8NKg8OG3hecP9LjWn9wqLC+yI5rWa53ROq0la12ru09H2Pn1rn9zNup2hO1NfWN7wrMc+9I/5keYZ/+C1Lghi7+QUmndy2qZ7er3DUwraeoDMWxq4mnd8QgLrHXdZgaf+FwzSAzIkWKq0bBmnr5uA7z9ogblNiz/2wWE5gKNogJpwRps7BS34tI//gZSgxd5xlwn3NUi6u/8ahvqvh3jgvE861+Wj9BU0aUy8MiJ/6NrrdgmikwGdd9Ki27SPSQFaXaSEA7xl61c8ftDFZ3ney2Po80t2kuclnqfy590Pn0NARJ+lsmdp2c86PjkMDlycdWhXJivYfky2G9P0aBhP2SiesEFcj43hqaZbEISd9UDKhg49HO5TT8S+eIf99t3s8OwCn3F49pqKAXwzbChfs9LnTRf+B1e0waYdtqlPh+1fI1WH7SMcd+2X+KizAfHg2YD0zOu1W/DYPoyakfeyf8LYsBUp+v8C7qjZTs0dGXUvviX11XHbnWl17wjVEsr+wcCd1XSvPzjHmzcPW9gKakMPcW2G3L5D89tvQEFZ3HwZWPKHUIMcjh5QD47/hf66z+LNfWKy5j402JjWvWb7GBvZPDnB8ds8oX40Bwd00oAGaRPpHIomCb3Z/JWK1im/AbMHzT7RZ7ND4DQ7NCSbp+zgANirYXtNZkGaQ3b34YA95ITdjxXH+9jKU2wVCPdMA/lDoeNt2mcGFR0N+brd0VlhYOHlQubfZcjQ3or35E/9g/usI5oln6wTM21BzLRVYbbLMWP29iPt6MO8bBY2JsNmmoGNKsXGcWLYqBnYOHWGDZJAQXQ0k8EzYvCMGDx1Bk+dwVP3Bj0gH2fsDQa8RKutg4UeDPiHfAA+5wCGW+HYCz+jZ0bBhBsTmrqVheYoB5qCpmWhKWjaaLmjkyC0bQmEg16T1QxYGYX0AYe0SeMRPONgvRAD1J/VYt71+zI6qblmcRyzRqzhlByxo6IjNg2dpwl0+nyt0GQup+XCaGFW2zxGvgYdUUQ3WUSD8rBaAStZABt1tfoTYrOg/izZj1gfQj6ltwmhd9T7OEaRmhiSWRjpWzrGtKWj9EyKUpu0iWWFvkSc9DXhNKRc1McvFidj6Tg9keLEeao4Rhtn7qwRZzGELIaQtRAvHfH0zucv0vZrcZ/dYjBZDKYRg2nEYJJ75EmYdgKYPtCCk/W5RZkuuGOW9ItUBo3KoFEZNCqDRmXQqDFoHnFo9oFh2C8VXtPK8HfBbAwDKJ9FQ5lG8LFNBhDVzwWobmYARLFdBKLJgrZfZwjpDCGTIWQyhEwW8KFYYxEfdoPCFThQBEM/bsb5g78U9l6/eYpmSIkqG0itwaHUx1nBswhlofC5NJh6Ix+YTziYLZoeYq8z9NMNn4VR26dJJVyi9j4GZm3C0Kw7PEHTWBLrZw3a0rGMXs+DYlGMfuAYYXr4VopOzU9fyUktKxzGS2P46BvHh9IHlKNpltKpbKITNWq6XIWSuxH6VimUD9C/gL/YbHEUINNiAGljQav8rKjKMHKyCMwd5Rl2ZCgiONncWOLVq9Gs3/ChPHdlaJOQwMoSV5Mm25C4PmRnljmImpE7jtZUszh3WSqDkDwZxNDNSvstB8QodrsBdmxHoUPz/lcCaq1gmjLbfxUITdMdKaUJuNWc4riZPFc64mPUmJi5bWd55Wv6mVMusfxIlvFE5OaBUtLpYDp6cTADP8TSGZokuJxoatPcRoJ5HgiiWwC6+/FkahHIiPPmxgnUW8IM/bCcmNlTPnAJqgOevV+qAvZB7/TpFD40k6SXb+D22CaY+ZOPwsB1zRx855olYPNNBh+3pHrLH7Y4Wge+84s2g3nB/oeYMtKHvmRE7wQQX9PM+4fIOyp8N3ik/D4nN1RnyDYYsmRCI8iqiwauJsOVqSEOrTo3xhSTILQ4l8UWCqVja/HwFfx1lgFpMHRtDq/N8bU5wIwF8cPYFWaU0BPsH5EhywdmsUA3HudSvFUywZ1HTZNo5lBUQ5cpqs2R5ECm4Rgoqo+jwJXzcRzS9LCj/F5kxOcCMp+XKEeSBjoa6vHSeZJGPI1mH8h+dOgzMkhH1GfSDi1EuKWlupfKRyGdF26v2+OL43+nJT9Z8Z0jzSToGcFKaIpK+EJLClfsxBx8dHiHjhACTY5QfVoATz+BfMTxDH82QUTTn4Mnl4ZUVo1RKXOEElQqjf7IVuV1yUcrhTM/VPdjA/r9cmf9cqas1OWshcmraVG9Eld35NOrNh+b6aM0xUAXIULNmuZJna55mDb9zGkyD/MDx+5MskSN/RwaeonzprlGZaeWkfPnoWQIjoxvMHwPkXgz4cZoOWIRPEpTXRwrvc4sBNmDfTJrxHG4BAbtg4klecG5MRzwDefvabtcDm3z8wp+ol4bTRdN1HMcLQHHuLrhCB7QAsl0s2vzaR6a7jFYiTgaDsORSoNKwpFw6xNevn0l/PT5+O0G+PkbUpJ2IFsLnXp+NZxMs5JbzkgaFAcBXmZmJsWdzokgeS/JdVn9Mz6ie/0QZdTW/iAZEMrg/UmedeAzJfkGfa3koM9lV3j04o6ELBjXVnMcG/OmbMz72kosafBRzmVA07d89g3K+HwIcxD7TF8Hfc4H/Dvqsebm5oHnES79QFtk9taj05gfyKHTOicFRxeUesITPSzin6PWQB5SqB2+bNPhBOvUxeiGtNn/IFd09sGPx1EuJCAUCIvQJTr/mIviFXtPAU+DRH8roogP5XJqduPU7I6WZOEW9S/l1k2XhUPMiYoCHkRBYgZ4PoYPApc9zxoGYf408NLzzdVjBrKgMxroMvH7QllL6fLjIJkUxujkZfkf+mcRE6gy6hBW0ebHOF/wrtdlpMxc1yUi7Mfuhp8WtvIDLHdaDZmy0tLjtMXJstxHn3taH5Q/hDnXDr1IWALd2IwRrT/Gi3gPmeviSc1l+Ti5+8UNmiFDzqnLWbbBPf4GTyE1bOa+ktny0xvN0Iz56Q4hFEgH0efK1xQ4ZXNlXAFz5Ytz4Rj3C8bS1TiCVyDlyjQfNi2hGZ/o4bCRzSkMH1vRlB0FGLLxK8zQqlL01PzokU4m4Rub8/PBAXxCPhjVmvBjHwz2gflV9Sn3q/AD2W9bZY4Vuax9ny5ZhJUPUz8+YC/1wi276E1dyrDVLD7E7fgQHxWw4raUG1UZN7KEcJl1UD4zxne+6JwaqTSoZJjZ3KSIdjsdtDAoZW/ipnebZaqjVXZRRQFjwnz7SGBfYMIMRrxUHfF4hx/vsOMBJZKhrnE7XWMa6VMjKeQR8zBl68nwLcTvlfCXYH03/x5H1lDaJWZua3nW4uXJ+xpx8xzXQOirJGbKF5/qdUmm5Ih5PkVwehjiBIGQ/66tTMSkjJhv+aIPmTafEh0pI2pTmVXW1grZ48AB/ED24x39yNrN3G1+2vLWnmfpWl26JAr90AhwepFsUhpwzAAPkoSXV+nYiwevcmwmWobSWfmzG4LSNeZ7Mf5MomAqlqRyjwLj+o69PYPewCEu6RRBs8smgbX8qfIgtDPs4tOvfmg3b2fpkR9pHCUjjXnQPQ/ijStalFc03yOfGVyc7WgZVCThM5Kr3jR/EliMQqTK53t9/SBrk3Ty8kLaY28UoQmeFUOamM82pJg26vEkmiu1u/L5CWFlgCPnQlloJ+58DtNn3JGJpiwZ+tDBmsXI0y4G/s8cfPbCIIe2h93wHzz0Xx8VCKa4GNhCwLyaLZVC3BwJdpwSFEkZFPJ9DJ5IM/iOKChJBnxdQVTNezzajqWAyOeMZJPr8WRyys6FNIE8ibgDf1FGaI+yR4UdAlqcVWAHQyAFc34MVPp1Ehjk5KBoSro5NcnCGJrrpAP+Bx/rHg/dsYssbxyJ5Sl/7HW67bvZ1r2hqRMN7ViD+IZoDOGEJkVrzlNryjVJZ02C4jBo0XNojxO8gGLCOeE28j6Fm8CPdfhMCBK3o/wOauu/rqJz+BKAx7cJ4c2P4fMhvhIIPrci786KVGl+FX//Cta9xjp18ftoJW/hV8F3gs6LiW6Xi65FO5Icel92UnyRXzMVxBetKSc+g4nPqMRXQnxPuPj6/OVw7Cfw4kJ8EohKds55jnPKCXbEBDuqBFtCsA+DcYmJRLSn0cDRjSQZ/brzjLpyAjSZAM1KgAuMTP/nHT6Qw8RhE0am/JzzHOcsRLmaVkm2hGRD92tELwAL1zO7PI3tHz9POV5OahaTmlUJbQGh9cjddCK71l0exfvHz1OOlxNajQmtVgltAaF1CJjwJxB84YTHz1OOlxNanQmtXgmthNAec6Ed8L2tH4n0ov7LYy4m2Rnnc88oJ9IGE2mjEmkJkd7nIm3S5OxNsH7ADfZBXQdjUDxaTlwOE5dTiauEuHaCoBBHDnsblBjPhzViPB/WlBPdhIluUoluAYv3SmHv1hYtXnj8POV4OaFNmdCmldAWiNV74cxPEBQ8DPzIaN15Rl05AbpMgG6sYY8CbcIXf7dJIu9oYsqfUPW1R6w/n1NfrpEazx5j2daiPz/Q1mPfjNg3M/ZtyARwSEnxSltzaWspnJ5ynHCO7QNNtd8qZ3zX0Nv5WOkNdWQ1UvpYc3gD52OV7z4bxuohxyry/gKoCxGyZc1yXdvGec9I1Qu97tfW1bqKihCtNS2/1raZmkRr7fBSQEaorFleRMPij40CCv9PCubLa/6W6EOfti81adXF3BHDni5vVkNVx3rOEZPvPhtGyGfhgHtDPp6Pk6g8ssblwSnPfTaM0w7HaUCv0mK/tzKHVxpGA+ScNjBNHf/SBubYGhtjLWVg2nZyxIcDczLFPykWSAZ1iVi+vOZviU1mvHJIS6Xx3CTDGPmYAX/NJmgi/pfaeplzs6qHbBjlZxEPEVDlaL8mq86WBs/B2adZKQQZ9Az/kzpGq3rIhnHeDbjtI593xteh/jGP32QKpkcrE35H2G59lOp2JFVTfVGPgJamt35zcpHb9rZ9w7rwXBhzkdE2j91ehG0ZA0ijtCExcaE6XtkQr8wceUt+0JZ4Fi36ucGPgmdhSk1zzbQ1odtG0O3xpO5Ygg4GtbajTzW52z51J2NnksR+M03YsFSeRKQyxgkPWlicHAFSdlFVoy5yROg6AYM0RrU01wmMiZ3BL8lLaxmXamKLcpHjVjd/S3ySA9r4QEtvaRV/4APO0w1dNZyE5QnA1caNmjZOA1ebmq5ppYBrj6aOqqWBm7yxJrYol25sdfOXmFc+6LTvZpEf4H1MntEb5ZgWXqPkg5/TDubhpsHejpFyW/Jndr/n3lfRH9mtUa1Nv2WJP56LP2btwBE9+JFd/OG8Ohyr0Y/sqvR7l3hmDf7VoAa/ebGn7kR+MnyofEbbxJ/4b/jjtpEzH0bOfEX7Wm6Vd/Gfwo2cHf0pcn891TXL2AXX1BRLuMb/2WV81QFtTaUf6IXRl9Kmx/TTgG8pY+r/oNZ7uu4muMKIXfGI3v11o/yeer74hPDtfm3+WpwRLVPxcfobSUPEKrwqaGHkfEPo+Q605op8g+kcKTyNnHlCq0Zv+c/QXJJX4V+lCVexnW8xnQ6Zj191X/lP+gFnpjnx5z6hvet/8vgXR8Ekcf0OXK9G/gzFFbA8ovxT9h3cyJ94h126wxXPYsnaH7lauHJAW9km1AvZlZGWC9gd8NeCg5bAyB/RmJvX96RGDEiX/wRJjJX/ZqN87s9uN0lqtzR+BqR5t6ma8dzfTMvPvE7VWPHKneBKcVyLZ67mJ7l3I4y7F+FcL/bz6PPZ+SFn599o7P2m4C8D6xVHVxy9co42K46uOLri6BwcvcM5ug+o4fNwzFUMXTH0qhnarhi6YuiKoQvkOPq0HeNtxc4VO6+cna2KnSt2rti5gP88gHvzt4FVDF0x9MoZWuTaiqErhq4YWsbQPyYZmp9PK0oV9nvmFWdXnL1qztYrzq44u+LsAl51ZOawYuiKoVfO0EbF0BVDVwwdMLREk7/JlXdaxc5bwM7VyruKnb92dg61cxF2/hZX3lUcvQ0cXa28qzi64ug8HP3trbyrGHobGLpaeVcxdMXQRXIc38bKu4qdt4Gdq5V3FTtX7FzEf/52Vt5VDL0NDF2tvKsYumLoPAxdrbyrOHs7OLtaeVdxdsXZRbzqb2flXcXQ28DQ1cq7iqErhg4Zug1nof5H5Bm8B5sxdPgbHm9iZ62XrUfAbw3FhL8J3K++FLbO1mJRB0eCd/cwdvW8ddbRc9mbRkN2MQVuiJ6bpnO1jJ4kOdIABKy16J6vT3sxXSmqe/6MCLcq35yu2cLs6fJ0rV5Y19Ab0b9gbXvCtS1qd0Rv9AHXN8wZgN346tcZG4LGpPuiYkz75XqiYj827YlWq4y/RE9UE8Z25Ymm8/OjkE+BoSNoL8DQfXjCJSH6dTO06GtWDF0xdMXQVa5guQz9OORTZZLJ0U9jUtyjfrHfRriK5QwGJJ1Lqote8QL/Epw9n3fHEImpUNsg/pwS75o0VnzexfhsBH8ucK0fqePZdfjuAtNN4HxvDVjO63u0Bf8BfW3CM1xqAWOHN/Csa2II5JM/4ftt0D60Yv8bPOke9X0P/43d9Z4yEhjvO+h7nO8eKJOcUd49qM3mCBppJbTkUWxv6OZySha31C7ZaLTkNfgz4Xxftwz4NCbtmgTsUicvwCUtRMu+WE7JknBVlVNKepEybSmjew9jd/Pr1qt3OulUHXQNxhzpGHIVsld5vcvj9dmCvOZ7ZOIuq7y+TJotXo2lNNeghXK9iWvgIxglE/AwPlF/9iLIMN37IbompYQtnICOWCB/1JoGxRvIWxOQqxiD1AN+QV5DRpvAf+gXNtZiC+M9XZHlK4T9z/DU6yAy4Hqu/FMcK6X9FANQRnTHNFKZBWkA9lpsTGP9BO6iki+jcjmiDC2S2TpkUwyJ+OgdS658Q3f/AMi/D7gmGTs5wt3zXLUpXdmBGNJnt5vSGoEsbUK9S/rAvAsNELQko1Xf6GiV9TfuPdyQpK4p/nrDefgNfH+rjFMlHr/mHdeb+FV/I0YTrdKENOs255MeR87P/5QdqEcM/oB/xftrOXs/Tc2OZPU+vCp/79OflNb77KeIvY/eP977Zym9f6v4v4mXFhOnISBeKWvfEwkK8574VIpEnqftxtBIPkfM6MgRGSvs9yPlrRNxDFsYv07WvscSNLKf9kSKxfwnPYwhIT5D2wp2fq4c0a/X/hN8SMzKfCKWw+eghVmO/Z4E9lvfOvudp/9xmb6j8/NYXBy1yXvmufIZZT6KewaP4IorOjfINgh6Is/Qbc43aBE6d9TH5WjbNNA2Y+u0TdbfuHaR7STsPyiX5OPdeIc9APSwN7ybXXRb+Dudr1nhhcd0y2JH8YOXuCfmI5d5z0chry/1vrs+Sy71rpvS7l2o/0RZ772oT7iw96sF3q+5dd5vWp8rD7jygCsPuPKAt88DfhgegVrGhldrzmFPyAsxKUPtUOZ6RGsdGkIOG72aUWw9BM0t08rK6Vr4XY5W9Ln3UuezZTns+9CWjzQXjS37HOhSci3CTmS+Hf3gSVxbYzK/B3fFfYvTiJQ75E2weVm2OqOMJXZpTYoKkkDc0eq6ND8aznKpZIlRHpu1xPIer2PEJdF/xvOh/g7SPe4h7MOdP+I8UwlJ6CQDnUbOiCJLB0qTZrCjPpFFMz351hCtRhLze78OqXwfzGoymTyh1Qo4f40R4Z5fu0CGVoM6g2YyTZKHTvdHeZiUu7eI11D/cRRZUNeg2A29VpfGhrMWeWT3fEWyiNz1R2qn/3zfLl5LI/zvAKE4D/6UevX/QDlSrmJM+h2y0BxNCL+X4UOUukteiBlEJn4Uvk2RSdjLTYy2nUDL9gjHa8may6Jo61uMtqy/m8D9mXII7fpEGbRLmhVfBtNFo3E1iMaNrZPC/N5H2/B38tajZ0fZxWedT8GKhh+hRy/IF0r/szdk21BufsZ1cYlbILE6eQ02IGKT1+fytQImjUCXbJtGNsyiVXa4vhnjvjqdMVqTf57d89XbtudkwcJcd9S2iavpGoJl+3vqtemr7ObZtkfKbwq+xeSPJWhBg+9hQ7nbQU5ZJ/bF/W1j0gLUE5tiuTFpgEvRnU4xHPqe69CC9F6vXgOewTns2UU9m+fSK/N6Nff5irVrWlP+Ptj7GD9aXOoOcTjGeLjSjEV8bF9CMuKrbZTtxb6ug3nlqD+KH13I58FVejr9Z/F1Wg0ahbWEtfXX920K//Reb04ST6Gd72n/CavZC1YplmXBuA9qbrEPOq/vq+fCn4jxwha8oUzoDe3+X4Y/lXV/GeNaAuP+nHH9bdbeJSHfc0pzdTir7I//fbJ6e2FNaX2bkuaotFZ3THk2h3TKIKvrcL8b/7VoR5K/+hdt7ZQsNuYb1jP+03odt48jOusNPMc/K5+0fpJe+YmX4v6Cdc/1/6C06PmfoIU3wRrd6LEyXOOS/8x43eF+ViMy78n2q6gg683uV4n3dPXMsgvt8J+XlD1m3H3GMISdgzs0vj9nXOVSTruRQ77Pab05w+WabB5ahb0FpT4hn7pGPlaDpG5TnrARk/qYYqxGTOr4n0vnrifaytP/r1EXfqQ5hc+8r2xvyGf4bHJp4Nz/QZD5OiEsaZ5sgZxLnaLrKY1s5oXXKRqPeuE2ZfsNirjxX/YdywkdW0/mK9nfdfBvEZlE97dghMj2hG5KNo21jdesfm+bjJ4KmZwh9RGfuLkxZK1t92d239chq59ofu6SR3ID6OUl/4S71Ec0jxdK60E4x7pi+dRAKjWaY6vRXBv+a5OttMg7Wod8kr1dh0R2CfsprRVAz9ZffeDvSepRpHJLoxo/fSQJXdJ434v1KOmV5Fvfkb7DfZ5sMT6ekv/u0rwzZjGmdIUv2xF5sjUaaSrfc6Zzv7cBNZhzXM+OpiI4RtvzPXlDTiSCSeZn7yvs7STxfaT+G8qOCN0PX/nbSOI7LJf/7lI7cc3895FowhXz3keCGdii+1/FVWjVG0nY2rrqjSRfzxtJ6oL2bXaf9fcpe6vlLOy/RfqU7o+ZwHWvg/z6mLj4m6FWz8TJt5NUXFxx8dfHxfnfebGON6/EuNjr7Q/vZs1W93LmuuPGxHYNr8O+qfQ/r9ML2PoBzba9Cd+IFPC1m+Dr89SafvtsPIP7DpuXWBx0qBicXM50+Da8nGlep9+mU/p9VnfEigssvOFF827GHnwPusIC8vfeyeDXu9mrHpxTV70jXg4Hv8H9oBfDY+jF8Lh9Oau5E9OlaGB40VnOjbyDi97drHMyxC60un0sel3qSW8fTocvp9j0HlbhTXpD/h2Q0Lz9XpcVA+z0/n6Lvu23qRjAbaZwZhsvOMSbqt4vvX9dziwsB+zrGSt6eP1h5xiLXwZ4zgjKA/Z1iLf7ZdAkYLs9QvQUG3c46OKx7uAcizYrugOSQGtwgpcdtAbYmdPXA/zWHdC3o+EJ3uRoyELiNpkRVLQ/qaRFxt5Fh869OKH2D/t0O7gSi4v2Pt28cwE3ULzTE/NuBv9czmyPCpcVGitUoYCyg+eD+lgeFUDCpwOV3Wug8VLnpUHlwWkLzxvud6k5vVdYXGBHNK/VPKdzWk3SulZzn4629+lb++Ru1u0M3Zn6wvKGZz32oX/MjzTP+AevdUEQeyen0LyT0zbd0+sdnt7g1EUPkHlL4avmHZ+QwHrHXVbgqf8FRrRO7sM+uRPocLSAAEw+zdiCo034tA/HNKptw9kdWhSyD2b+AL7h8h6UErTY674GEXf3X8MY//UQH3PeZ9Lm4W4X2vNZYa+/gWu6hMsJ04iTFull+5ik3uoiDxzg7Vq/YvVBFx5wfHIYHLg469CWSFawzZBsK6Tp0XiasuE0YaOpHhtMU023DM876wHchg56ONyH5uP/Xh4DkC9ZIzwv0ReN92UHyHEKZLkX9inWH431R83uT+J53mEbHM/D9hGOlPZLPONsQMx1NiDN8P4PjD+EKNo3NWMAAAC+bWtCU3icXU7LDoIwEOzN3/ATAIPAUcqrYasGagRvaGzCVZMmZrP/bsvDg3OZyczOZmSdGiwaPqJPHXCNHvUzXUWmMQj3VAml0Y8CavJWo+P2MtqDtLQtvYCgB4Nw6A2mdXm38aUBR3CUb2QbBmxgH/ZkL7ZlPsl2CjnYEs9dk9fOyEEaFLL8Gd2pmDbN9Lfw3NnZnkeVE8ODVHsbMfZICftRiWzESCc6imnRg46eq97Fj3DVYRgnRJk6GKQFX7oeX6ZDsdxFAAABf21rQlT6zsr+AH4SUwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAeJzt2E9Kw1AQB+DZ6QUq4h88h0vBnSII7lrcKh5G8CLuewlx5QlED+Cum5gJjSS1oi0pwfANfCT0TWHg95o8WuxcPBZriKIo+P+qPO+n7yuR/2BU+T+/zf7s6XUm/+FY59kv/wEpaxzbk7uI65vS7Q9yLXvGsTXJ7/Q+N53lv/JvX/6DMYrRw9cZ8Ld3f332k/9wlHUQcdbaA9OXj5ZG9mXvufwHZF6HEadL90Aj++yp+3ufm07zz9qNuPz2Lphnn2vN3t7npvP8s/Yjjlv/CZX3+dliX+9zs5H8s/Yiruqzft4v6+l9bjaWf9ZRxEmuV1f5AwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsOAT5zNrPTCrddYAAAR5bWtCVPrOyv4AfzjFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4nO2aiW3rMBAFXUgaSSEpJI2kkBSSRlKIPzb4YzxsSNmxZPiaBwx0kOKxy0Mitd8rpZRSSimllFJK/df39/f+6+trSoXfg7Iel0z7EulfU1Wf3W435fPzc//6+vpzfst1px5V1i1Vvn95eTnYY+v0r630//v7+y9Kdax6P6P/afvP4P+ZPj4+ftoAcwFto64rjHbBdYXVkfgVzr1ZmnXMOLO0+rN1ThnSP6RXUD7KMUpzpIpXaVb/5/yR/V91S/BFH/+Jz7iIL3KczPmjwohf4ppnS5VXXdexnpnNRVke8mNsyvMsW6afVJxZG0i7VL7P4P8Otpv5/+3t7fCOiH14pvfHTCN9QZsgvNLinPZH/J5WHcs3vJeRXvd9PpNp0p66si3nHPjo/p9p5v/sO32eTEr4sOxY7SbHVMpQ9zP9VN4jr/TfqB1n/67wSh8f1vlsDiAeZeT9J+89itb4P4XNmG/p5/lugO2xYfbr7Jv0vXw3GI0V+T6a/T/HkPRVliXLO6vvEo+irfyPL/Ft9rWeTn8v6ONJjrXZ92bzUdaD/Hp7yPE802TM6TbpZJlu+Tvor9rK/6WyUb4Dlm37e3v3Ne0k/cD7BGnRpnjmFP9nPMYk8iLNXr4lPer8r5RSSimlnlOX2ufNdO9lL/nWlOsgl7BhfRvNvmv699RftfZ5tT+sOdSayWzNeo3S/31tI7/zR9/8S2shrJv082soyznqR/zjMbu/lN7oepbXLK1RvybubM1pVua/iv2y3PsjX9Y88pz2wjO5zp5tJPdeOWcNl3s5JrB3sya82zrLmeuJdY/1Ztaa+rpShfc61r1MK21Xx/QZkFdeox6nxHol90mXve6lMp+j7pdsb6P+z1obtmY/vms09le83Mct6COs860JP1Yv7JdjXv+3IfchEHsZdcy1yrRVptnzGtm3/xNBnNH9kf9HZT5Hff4/xf8Zf/b+kHbinL0Zjvgz/8lYE35qvfqcl3sC+HpUp/RBt09ez/LKsNE+E/ezP3OdeY/KfK628H/fRymfUKY8LzHWMX4yltGe14afUi/CGDf4jwAb074Qc233fx9zco/ymP/5fyLzKPX73f+zMp+rY/7PuR079H6SdS318Sl9g7+Iyzy2Vfgxu2cYtuT9OudhxnDiYue0NXud+DP3KI+Vg39r8SFtJ23KntnI/6Myn/MuyH5b1il9R9/OumKP0VhF3Eyv59f92fvBmnDCluqVYdSDuaT7N+fy0TcYz/fnRnn1MNpA34tMGxM/856Vufe1S2hpvUA9vvS/UkoppZRSSimllFJKXU07EREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREZE75B+Hl45qN6ZdJgAAAVNta0JU+s7K/gB/VYkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHic7dbhaYNgFIZRB3ERB3EQF3EQB3ERB7G8gQu3piH/ignngUObT/vrTWzOU5IkSZIkSZIkSZIkSZIkSZIkSR/RcRznvu9P5znLtXf3v7pP929d13Mcx3OapsfP7Bj9LPfUvXUWy7I8XscwDH++h3TvsmOVfbNhdq3N+z21f9U3v/6N7l+263tWOeuf5XqdffvG2b+6XtP9y3O+71//1+d5fto/1+z/fWXbeu7X79u2/frM9+e//b+v+h7X96v3QK7Vd/ucRdWfHddrkiRJkiRJkiRJ+vcGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4QD8K+ay4PVSpiAAADtdta0JU+s7K/gB/n3gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHic7Z2NkRwpDIUdiBNxIA7EiTgQB+JEHMhe6eo+17tnSUDPz/5Yr2pqZ7tpEBII0IOel5fBYDAYDAaDwWAwGAwGg8HgP/z69evl58+ff3ziOveq5+JzpawAZfj3wf9R6fmK/jN8//795dOnT3984jr3Mnz58uXfzy6+ffv2O++wN2UE9PtHRtT7tJ6Vnk/1vwI20f6u9l/1Ufp2laaT1+3f+Z1dVPKs5ARdGr1epcuuZ+28ez5wauereuvsH+Vr33W5tG97HpoPeQWq/q95ZfWO+58/f/73e+gt0v348eP3vXiGuqgvC0Q6vR7pM0T+nibyiLy5F2WrXkgX1/V56qBpIy9PRx30evyNz6r/x9+vX7/+fu4KOvtzTWXR8iNNlM8zWZ8jPfcy+7sMUZ7bCJvH39CZponvjFtccz1FGp3zOLR9RT6kRxfIqelU7vigC9qyyh3XVB+qZy2f8X3X/vrMFaz8f1Zm1v/pf528gcz+6m+oU1Z37Bx6Vn3RLuKDL9A+qH6BPFZydrpAPsohP/cVVZ39+ZDPy98Z/+8xF7jF/ug8+iP17uSl/pX9fR3iwLbYPf5GWyB//vd+hqz0UdqLQvOhTpku8LcuK+2RuV5lf2TU5738TG8rW1zFLfanHWu77+QNZPZXf4fvzfoofd39j+o27nHd/SS+I7M/etA2lulC06nNaRfI7/bHP/JM/OUZzTeuIeMz7E9fUX3QnwF19e/qbxnfHJoemelb+j2epQ90a6XIi/v4TcD/kcbvISd9LwP1xodkutByMvnJX8dD+of/77Ko/DqXqfTpuh0MBoPBYDAYDDo495fdf83yb8E9uIQrOC3zNH3F257CY+XEpVjPZHGBe2JV/urZFZ/WcZiPwqnOrui44m3vIavGtqtnKs6q8h9VXHq3/Fv5tEdB5dY9E16nK3J18fx7tetMVuXV/P4J51WlPyn/Vj6t0pPzhs4p+h4F53iQhXycA1nprNKBxhW7Zx5pf/TjnFzFeWncXmPmVfrT8m/h0yo9EaMLwLPC8yHzyv7E7VQWlbPTWaUDtT9yZvJn/v/KHpoT+1ecl3PWyr1WHNlu+dT1Kp9W2R/uWPkj5RQ9/8xGyNz9f6oDz6uSf5crW6Eaq+BG9H7FeQVIq1xMl363/Fv5tM5P0oejjGgP9DWe3bW/jhme9lQHp/a/Fepv4BqUd698U2YXrvvcwdOflH8rn9bpKbO3zjsZF7TszEYB5RaztDs6eA3769jJx/fiKS+IT1POC3my61X6k/Jv4dMy3s5lA8opVmUzJ3eulOeRZ0dnmY4970r+rl6DwWAwGAwGg8EKxL6I+ZyCdSBrmFUsqksTc9sd/uce2JE1gG4eWeauLPcG52JYd3sMfwXiH6y/d9Ym3fr1mfsZM65R15SB+E6s8FFldtcfCY9dB6ivxre69q9nY0iv+sue5xnuab2d94p77pf0zEGmM57p9El/8ziGx2iz8nfyymTM0nXXd8vI9LiDVRxJ9+RX53GUg/A4re7V1+dJoz4HnSuXo/FA5eyUD3CZ9BxRxZ/h88hHY/5al6r8nfJcxqrM6vqOvMQbVcYTrOzfnbcEXczS+S/4Ou3/6MrPM2TnO8mrOmdCOchSnY3I9O98R1d+lZfu13cZqzKr6zvyZno8QcePkd+KZ+zsX+l/52wR+fqnyxd50P2Oz9L+nsXis/I9r52zhFWZ1fUdeTM9niAb/5Vb9DZf7fu52v8zXVX9X8vu7O8c9Kr/a95d/6/mf13/17KrMqvrO/Leav+Aji0+huGfdHzp+CuXaTX+q9xu/4Ce4avOn2e6Ws1ZfDz1MU55xax8RTf+a/qqzOr6jrz3sD/1rtb/ei9rm9zXPuQ8ms//PY3OkX1On83luxiBzoX5ngEZ/D7ldeVXea1krMqsrq/SZHocDAaDwWAwGAwq6NxcP1c4wEejksvXHx8Bz+ICWbv7HszVOoL90s9EFWer9mO+ZzyLC8z2MiuyuIDu2dX9/yfrV7UVsTa9nnFu2J97ngdy6HXnIne4PNJUa/TOLpke9FygcqSVvm7lG0/g++/VPlXsj5gTfmOHI1Q/o/Erruueefbve7xR+cIsjyxenXFGHS9Yxft2OLou1qlnE+HXM33tyLjiAk9Q+X/sjwx+biXjaFUH3kc0Dqfn+Chf+4VzbnxXfVRnJnheY+v0kyxG7f2Ftsf5FbDD0a24DvKr9LUr44oLPMHK/yMrfS/jVXc4Qs5SaF/Pyu/k0Xy7MzMhD22Wclw3VTmMberfKHvF0Z1wnZm+dmXc5QJ30Olb+6z6eK/rDkeo77XM+r+O313/37E/Zzv1LOdu39K9A9pvdzi6Xa6z0teV/q/P32J/9//I7uM/+sdPVum8Pfm4Wtlf887G/x37oyO/dmX8P+HodrnOTl9Xxv+ds44VqvW/ct5ZTIDr2m87jhD5sJ/OMbNnsjlwVl6VR7V+PplbX+HodrhOT7dT9x0ZnxUzGAwGg8FgMBi8f8Dn6NrvUbiSt75b4x7vvtfYwAl2ZX9PXBRrXjgA1pSPqAN2PAHrWmJ6uq+y2wdcAY7hFBpP7HCljq8FYha+biR+FvB9rL4Ox2/oepUzGPHRmA1tS+ML6KvjdlXGzv5dXrtptE66D97luFcdQfa7I7T3eI7rlKvpApHmat/KdMT17BwLcQuNszoHo7/PRT3QDXol1oXfcfkpQ2Px1VkBtUXF0e2kcZm0rsp5Ukf9LaErdQwoD0tcD/torFDTESel3Cpe2KGyv16v7K/xcdo9bRI9eXxL8/L4dsWrZfyJ21z9mHLIip00AbWfxx89jpvxe1fquPrdMdL7+wSdOz3dt+XyeBza6xNw+ztvQD76m5TImOkGVFzUjv0rHkOxkwY9Ku+Zyat8mL9H8EodT7hDyuUDV135lhV4jjEus5nvtaAPOV9Fn9CxqeINvf1W/XHH/gH1f8rjKXbSKOeo46DKkX3P7L9bR+UE8fkdd6icn+7HugId2/Tjey3ig2/0vRzcUx1k15Vfy57vzteDyv74MuXUHTtpVCafdyrfznf6h7eZkzoG1Aa6p8fHZ9ettpNT/k+h4wdzzOzeao/d6rrvJVqNW35fy69k6daut6TxsiudnNbx9LnMd13Z/zcYDAaDwWAw+Lug6xhdz9xrHtntSYx1kL4rZadMXasS787Wgu8Bb0Fej+ew7js9R1Khsz+cAOl27K+xFtY7PPcW9HmCtyBvFo8kTu4xG+e0iD0636VQ7lbjFQGedZ+jPLTHIDwmq/y/6jNLq3kTQ6m4GC8X+TSWoxxyxylpPbX+Ki98zo5ekF3LUblO0J0xcY5HuQiNpXc+w7l75ZXhCzxGqvXz843OwVb+n3KyMr1u2d5sb//Yjdinx3yxbbZvm7YCJ+JxYuyt7aLTi8vucp1gZX/s6mVmsf8Vj+g2CjAHqGx6kp9zQd5fsryrGLDuD9J4N7HW7LejKu5VfY3urVKuJfMZK724v0OuE6z8v9tf5wm32p9+SVz9UfbXfrFrf/wGeanPI1+3/2pvB35EeVXlD8CuXqr6nmA1/6OecIy6B+UW+2u57odvtT86pBzVy679yUPHDrW57nfZyQd/rvyfy+s+P9NLds/lOkG2/vN9RTq3yM5fq24cK3vR/nX/wz3sr/O/6txyoLOb93HNk77Ms10+Pv/LZNF9GCu9+PzP5Rp8TLyF9eLg9TD2/7sx/P5gMBgM7oVs/beKZYC39K75jmc6ha7XuvG2ip2eYFfX9ywzy0/jP6u9kQFdl74FXDn7UIH41+5+zVuwo2tP/wj7V/lp7EdjFX7GKeMIHcQtPJ4Od6a8Lv2PM3HMfZUP455/J3aqdfB3JFaxkqxuGpPRduHyKLJysrrC/7iuNY7vMqm9iFM7V7iLyv9rjF/PS9HPlPOtOEIvB93BnWj56EXP1aAflyeLOep3P39LO9J4OvJ4G/C6BTyW7HxAtg/bY7PEz72uFYen+Vb64HnixhUHu2N/9/9A25aOUx53zThCBxyV8nGuw+7/XfujFz2P6TIH9GyPQtNlNlZ9Zfb3uYieravyUv0ot9jpw8vh3glW/t9lyvZaVByh64Q03fsf72F/ZKKtZTIH3pL9K27xWfbP5n/4QvWXuo8Cn1RxhK5T/H/X/wO7/g7flOk8m8Pv+H+tWybPPfx/Zv+OW3yG//cP9fdzsHruUOcpGUfo5ejZwap9e1rXhc4zq7OZbjfFav4XcPtX87/Od2bldPbvuEW/d8/531vHvdc7g/eFsf9gbD8YDAaDwWAwGAwGg8FgMBgMBoPBYPD34RF70dn79JHBfhP/rPa9s8fS32kRYG9M9nmEPnVvqcPfaVxxiexL83x9/wjvANIP+zeeyVN2dTnNR/ft8ansr79jwr4j9tnpPrcsz2pv8K3yd3v11Yb6HhCH1hvdsodM+wT5PattV+jq8sgydV+k9o2s/zjYr5bl6Z9qb54/u9obsmt/3stE+vjf37Gh9n9tvIb9/XcH1D70ww7sI66gfanbyxbX9bdFOqzsT9uhTzs8/6z/c538eZeb7qHUfZsB2pu+a4l9fvqM7rHVfLVNkobvJzgZQ1QX/q6hrG8rqFtXnvqCzPaMvfiGVZnkqe/vUZn1/XIn9ve97lznf60n55J0nFRZuM939IrMei5E86U9qNxXfNPJfnE9X6G+AHmqvk273PHn2dkBzcf3lq/kx49r/gF0p+9iUz0y5vt8pdKxz3m0TtpffU+v7mXX+ZTmkb3bj/bg/fB0TOCcUzafcWBD/+3Mahxm/bQzliPL6dywsz961TEL/+ntSO2v/l33mpPnif31XCLtV8vM3l3l86zK/vxPO74yJ0C+7ONAfnRHG878Orqr/Krne+XddYHK/uo3AW0xixXomVFd31BXnR9W5xsy+1OujuV6Xc+lep/Scx+d/ZHJ29cz0MVdducWke6q3N14d9Ke9N062pc+2nmKwWDwofEPiCRqoj90VfkAAAq1bWtCVPrOyv4Af69+AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4nO2djZHbOAxGU0gaSSEpJI2kkBSSRlJIbpCbd/PuC0jJWa8d23gzntXqh6QIEqIAkPr5cxiGYRiGYRiGYRiGYXhJvn///tvvx48f/x27J1WOe5fh2fnw4cNvv69fv/6q99q+Z/1XOaoMw/uBvM/i9vCW/rm7to7Vbyd/rkdXDXs+fvzY1tVK/u7/bH/69OnX32/fvv388uXLf/qi9he1r/IpKi/O5RjnkU79XK7az7Hab/mTdp1baVpf1bFhz0rOnf4vOvl//vz51zb1T/8tuZQMkDkyYj/nVP7IFJnX/mwX9GvOJT+3E9oC5Rv27ORfMvL4r+jkzzHkQn+1DJFztRX3WeTHNeA+vjqGPgDKYz0x7NnJ/6z+T/l37wzoeeRef6stINfatiz9zFjJ33oA6PuVnnXD0HNN+SPXklVd6z5IX/eYwHn4WZLHdroh24n1jOVfbcRpDP9SdeL+c7QfXc1YnG0fp19n+ylZWd4pD/pt5l3XeSyXsqxt2iB6hjHJ6pphGIZhGIZheEUYx9+TR7DXp//zby/vWfLd+h5c6mu6NvWueITL6O1qB8/mZ0id8Jb2vruW9/Od/M/Y8Y98hnme93W+xC69lfz/hv7zFlz+9LNhz8Omjk0m/Xfp28MX5GvpI53PkPokP85d+QNN52+kjFyP/ci+LNsv7d/apZfytx/iUdtAyt9+Nh9zPyl9ic4suSAbbL7s55z0C9hnWCAj7HYF51HntA+T9me3HdoM90KemRby7uzZmV7K33X0qOOBrv8DdWi94L5tP459e12M0C5+yH3Qdl/3/0o763jnb8xnSvbr9Fldkt6z639AtukDLuyrKZnhb3F/Q5b8v5M/fd8+QMf7WJ/Azt+Y8ict/ADk08n/KL1XkT/P9vqbsrG8i/TF2xfn+t7pBvSJ2wm6xboYdv7GlL/P6+RPnMqZ9FL+nNf5w/527FtLP1tBfaU/Lf139u3ltdRt0dWR/X08R8hj5UuElb8xfYi8p3Xl8XjmTHreph4eVf7DMAzDMAzDUGNb7Jv8PD6/Z1w99oAZY78ftn3xs02+iwu9FX/D/MNnZ2fT6vzg1gnoDseE59zA9C1CXuvza19nP8zyoK9GP5yjs6sg/5Xd13YwfHzYjtAb2H89x6dIv1DG7ttn53Pst+Mvx2gf2JHxSQ3HdP3cfhfXe5Hy5/puXqd9gbbvWub4D7p5RJ7rl/PP7LfzNeiI6f/nWMl/pf9XdvD0padPHRsp7SL7sWMwzhzLdlngk9jFCwz/51ry73x+4LlfJS/PBSzO9H9wXIDLybl5zrDnWvIv0MnpOy94hhfW4c5z9fxf6Qa3OT//HatQzNyvNd27XO1bveN5fN7ZAhjD5/XEjTid1M/d+J9nAOT7v8vKsUx75D8MwzAMwzAM5xhf4GszvsDnhj60kuP4Ap8b29zGF/h65BqryfgCX4Od/McX+PxcU/7jC3w8rin/YnyBj8XK5ze+wGEYhmEYhmF4bi61lXTrhhxhfxI/bMT3XkPjld8RdmutrNi9I67g/dx+ZfuQ7in/tDM8M17XB9sbtrnCa/CsZGz5Y3/BJrdqSyubnOVvfyJl8vo8LuPKnmCbwepeKDN6zPLP9uh1Cp/BpmzbKza7+t92tO6bPJmG1xDDr4cNvms3Xf8vbNNjG1tg/U/a9vnQbn291+fymoSr7wuRR8rf646xBprXxHp0kBG4Xnbf5DIpfz87V23GcvU1nfwdb+Rj9h+zn/5Jeuw/+r6Yj5FP7vd6ePeMe7km2Mch+4VluXou/qn8u/2d/NMX1MUi0a/R7aR/9A253TH8FNbz5MHxR2fX/+17K9KPA7eSf9cebPt3PAH9PX1H3b3s2kbGqJBe+ikf9Z2Btux6SR1w5Ee/lfwLr+NL7ACs1pzOe8172cnfZcjvC/uaR5V/kTEy6cfbra/Pca+nmWl1bWYXl5M+vy6/1f7dfayuzevynK5+nmHsPwzDMAzDMAywmlt1tL+bK/A3+FN2cazD7+zm1q32ec6F5wodvT/egpF/j30YtqHlnBpY+ed37cW2kdp2zD/f5bDfqfD3RPD/gY/5WtuT8C1xL5Y/37PxPb/qPBHLzH62jJuHI/3f2eat/9nmuz6209lGa/+M2yJx/vh6sAFyrb9R6G8JOcbEcqYs+IjuraduzVlbOxztp2/mOgEpf0APuC1g16ct2DeL/Ch7zhux36+bU9Ltp936u0CvwrXl3/WfS+TvOR/o7vzWoL/JuJN/Pg86n27BM+kV5wpfW/9fKn/rbXSwY23sw0M+5HGk/1P+tI1Mk/gQxwg8sj/nEjxuoo/Rr24h/8I+Pffn3TzyvDbHfzv548er9HP89+j+3GEYhmEYhmEYhnvgeMuMmVzFf96K3fvqcB1457Y/MNeLvBcj/zWe3+D4eubH0Y+Zg2O/XaazsqF4Dl766myH8ryglQ/QxygT12b5sf86fh+fpsvT2aNeAWygaQ/Fbuc1Gjmvs6kXnlfHz363XDsU2z92/m6Ol+279ueSNmXMcqXf0f2/81ViU352+af+o16591UMTzdPKOl8Oyv5U8/pR/T8NHw/2GbtH7T/0Pe2Kj/Hco6X91d+zzLPb8VO/pbZn8p/pf9T/jn/135kjmGr55jn8u7Wh9zJ320USIs29uxtwFj/W//dSv6F/ZB+znMu4xLaA3mc0f+QbYM02bZP3O3vFXxCHv+tZPye8vf4L+f42QeY/sFiNf7byb/Ief7d+O9V5D8MwzAMwzAMwzAMwzAMwzAMwzAMwzC8LsRQFpd+DwQf/irWzjFAR1zin7/k3EvK8N4Q33JLWP+YtXMyf+KxKN+l8ue6jkrr7LcWujiUjownPuKSWEDilrwOzlGs+1H9GmKj4Npx9I6d8nd4iQvsYvcpk7/r7rhfykt8lY+Rds4XIN7cMeeO1U28NhBrCGWfZS0yx5vv+jX5nzmX8x0/S16ORbqkfok58s+xUe+xrlmu10a5OJbrfxEPTj/lfjs6PUo8l+/b3/6hLex0APG6xJJ5TkHeG8fpZ7v+Q/6OCVzh+0794ljKS+qXcykn6V5L/2dcfuLnMn2bNu191LO/t+HvKbke3G5dT7v7ct4dXhvM97Nqh36GIrfuex9w5rni+TI5d4A2lBzVL9AuHJ96LXbtOvsr/cf/o/OyTXveV5ce/Y/7Slm5r1r3rcrqtaJgJbeMDe3SpGw5j4W8EueV7Z62mRzVr88jT89VeivowVX/Pzvu/RP5c47n3GSafh528eBOt5uHRJ3nNyouWeerGyt2OtN5ZTv0+DjLfaZ+6f/dfIW3sivDkd6FTv45f6Pg3cB9lXtCxp4jdAav6ZjXeO6Q49Wtc49Yyb9rr4xTrB9W7Zv8L9Xnu3VKPW/qDEf9v/A8i9W7TCf/o7LzTKzyOg/kRF2yNtxqrGadmfJnTJjrBHqdL68r2L1be46Z3x26cvDdQ/RNrlnXcaZ+4ehbuxx7j3mLvKOu8s15GgljBch6Qb+n3vS79JHeO9Pud++Eq7GAxzmXrBN6yXN6V7+U+0iunPPs81aHYXgz/wCggvogrdejwgAAKhdta0JU+s7K/gB/1PAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHic7X0ruOwo1vaSSCwSicQikUgkFhmJxCIjkVgkEhmJjYyMjI0smX9R+5zunp7p+dT/1Ihac+k+VXvXCbAu77suVObnfTaeANqzkS3G10Zgh6PDAnBdxQVrAN+FfsPzYh3ggQoQAbYKG9CeJMF33ZPZsYTB8c18c/zxQ28AlZvdQSvVcTO2vmxPFRTgeJ1A4SjpMPBhua8rP/cJEqDcVCykX40DrzeBuHNcndvez5heQmwxKfxDEfOV0g8PK9Rr2yjuRnlOIjj1lmRQQ8xfORbI0j5PBjAmbKs0uI9JbSv+7utukHfu20cXj3LFsPiNmeABPFGqg3EJD9EUCSuvl7KFSJN9DPqhrsFlobcdf3GPua5+foJbKS6jNWODiTYs1vq4xcDBgm0Onh0EdU+g+O+oOXBc+NP9PC8bDy8/vPy3uE7EOhKek03CmwVwKbYVIBX2xJwtHNUeMnDAJw+HdUtxYAK+tM1ft+Da5sAf1S+4mfs2/DQdPH4AhQu0Hjc3U+obgcfhTt3VQlHX4dbt8+unqJR1TeD3e4+O+zXIJS5Cpk7JigsYazoYCWubTsC8bYE52A/85wIqp3WBVcV8MqiG2SU70e8RgZurHbhdRuFh15IpzwuqUkUlSFdjME1nA8Y+u/gpL3RpaJNmmPXVCdG4WIY+ysocqBLLRcvF8uMpFZbUPA8s6Tb2czTF4cB/1jWbeuBi8D+kokof8OD2XBs8GU8cTSVPIyg35DbgOqcWPQmdqur904sHWUGj98KDSA22qwiQTKBzNpvOA02DWOrI+UJjWJ0mx5hKvRN0BGW7Lsr2EvyozwkzLhhqZSiUzz/UPD+dLTHpJHCdTwE9AP1/eBQaEowL/9r9CR9dPEp0wqG3VmebmmB8SSw85LiVfeBG8w5Ral3QbyVbUGHR/QGINv0YWBJZv8084ReqPxCoWW9oAIBGnhf8MDY34YGtHzZKRvGXR1vwhQV3dimazzc/LBzkQHeOCo0Gbk3gx6bdE23MBcprPj/16MlM2mrvD7MVPYDdD9old4NaiGl6RlR4BoEQ9IQkEYGva1D2OJtFt5Bt8vgJakFPmfHU1/regKueHD5+/pKG5dzg2IaRugbpQjn6teIJhgvWpAI4Va2rSxwOQ8N2tGpi6w9MC+jl50O8Au+Aea8FoQvnHo07pG0XagtQLtQFIJf44+9Ea/EVwup3/qFV/0XCwoAz9NyowZSRlZI4eOtVwIVKyvy5cxKPoxKJnlyEswgO6Mmfjis7Bn0HBHOtGEYQ4x1RKB5LSa3u96ZY3ZuExqgKuTELy/r+K0uP+qjoZFiMH107SsSjju9jCIh4JJ2nRNHXt94PEJ6iE1hgadceIOyo69EQQGzMj/tybrBtJIGoxl7XOc6E73pCR8+eoFE9FcZuZhDka4RE6vasZTsKPKj9+BZh0/w+LLXiop6basbva4cwQp9bcCj14iS/HQC6h8egkdv2zHD9NAxuyxnLcWCUWMaT+Qn6ds+19ugY2S549UhujPuNb3KfSr6AzzWs8cHg/0jgHHWpifHq64eXjwtm4KcWDO3X12HsGJWGiVtaFxk6PjzHTUBKoznzAv0CrOIk03FdFQGhAH09SIUWDGsE0P4zxsoYuuOv+emyunS/UZM9f4IBLAk3xscGtd+7/ezq53MNxD6Q46Iz+Lbv3tw2W6bRZ5WolwxSTI3Yjaqo+RGtPxe3KAyNJnfdLjdDI35CewiCXa/TCtfil1XUVwKyDDeZ0jF/amt+gmWUY0e7v3IWy8f5H9DjRNguGxI99MtLtNzu6wjFQN1X3cexTRID+zDlgJAD4/vt6OS8MM5cBtryeH+Q8652z3HfTlqiCz4jBMYNg4SM4EJFlwmZpSmVgromedhBfXTlP0L76gtZ7G0owldJcOGBybHygPELuHy9Mpcr6P3gXDK39iDt3imQbNw4t9Z0bBgFHMFAWi5CvYCj7xgElWXxhYuNg1JT3/SBxoNtPmSYSYHp/mz+9PInTg1hhmTEokczuSWNhrwjqyk/6LzPJAUBcx8c3wkDXzU9E7LtWRzHQlIjLWsicUdQLdBlEv4i52atwQjC4SXWqS3PkzMeN+rQ5MzIONRNOZkZgc+KGYosG6zo5F8qbjtIgsH6xkUWQsaxhh3WY2y/fvjO7rHnDcudW4OOL3Nhn2e4SRUXRQgy5Sx6A9Ix2hd0gRs6kmtMxtPnzsEGoc3tHMiZCA/lo4tHKeYc1HsSN8pv8MvFbmSo+KTot/DhlXtAcvVQmD4QxmvCd4xr172+oQsjuA9rWBdmeZES1kXH95rIQanNQsI5wnVNELDb3jRQPblfBNNskpDGZ1ePrtiH3U6VFNUjll9umYdH76RwA3ALLFqFHhL/VXWbNsiT98NWppvTsLjlMEVLkTcqfLf9GF2ve538NzVGXOnUtrv6elHYFaB6IeGCxwcJdRVIgD7u//OmdXCastr29VTZo7tvM1ApiPi0W+Be1Tbj1trz42AgLZpkJhLhKj22JcTAymZZkjy/XpKD2LdgXzadqN/IfGgduMzrBTPYoT6AhDIgGVC6EPpx/9c3BxXPjrML/dUO/CxOc75qu0aZPUK1ivxgC6jtgbOVQ6fy9gRpjlWSKQFS6ZCPQEzF3wbSroSL/4kdArfHp21iPDITRkiTUnGwshzDuUa9HuXj+PdYHLppjeSOsvVPbaxHQf3dELf00n06tioavssTdQzEZgXYOh1AyqtSSJkuA/LZ74qwNsLxvLHDNo5qkOUBp2PmR09wTy0NEPqtNh1IF9L9+tzKf0udyUrm21XAzuwWOrpKx4O+nYr9yXY8Z3qO44zoBPEg8f8IMUYqcW2ZLTuTDUnyjRQANw0/A94e4k/sKFlyDdlkZccKz8lGBsoXDeWZCdL60aX/lnLF2EiWEB/LwWHsx8fboeilPhjGEAAsoZW4rzP/ixtE7FoIi7lF8crGrgHScXHw7Ng3cBuBP7iDyIzeS6wGkPfFJQ7IpySBOw/ivD8e/VGschiNNrNwUAM3YLxhmYa46V49hAeE/clS57ZfF4b1mbMpbaOExz7ARDMjHsKjDLxfJw3nSf7CHcmtdQ/Ni0PByi1SjW4QZeOvhLOyz/Mfc3OVwO5Mz8w8yK0vE7XgG1IpfEx0XzG76fLBPHX1fUUKRMh6bMLxJBRI0xEOK+9OCB1fFTLsv3MHYwHbry3yckiRVi6gGbOliPQa/87U1o8ngJHvjJmFKH0L4G8Jsu06Xeisp9s2p0ZobHexhrxAjNJ6xns2ulBfmT8MAbYNResb0t0Y0GizovbfuaODw3ai5kurDC/7QukiTdL+smg7wNfx8foX5wTQsaFvv+spZ1ICbSDDJKw1vywglEWDePwoP6o6E7ZnwFXrtYUXRrw0npnqwCAJ6OAWCPO137nDRTSMgQYhlrNxPxBs5JgHkPVBrvUOiJ8WWXa07nM6bVIeqihHB/+wWt952kdxhCt3MBEpTnr79ufhdYhZ9C3FJpWnj+jAIqJZEAk9J0mG/c4dgzjwt+gYe7uZbYgbTC9+hLmPGYPCIf6Px/v/LuNC767g2NHMQT2onvjnvLFZmcsMfHoE9PA6ZokbI8Ksf29ouTJYaoH4x7xJfDHW2GkzE0EofPmndhBmMcUDE6XWDU5LgIiaTMDNqxraLp/r0+s/0nLZXcNxQlOgXiNvFvL+LmyAJQR6AuLigYsNr8T3WdLjfmmI5JSDUK4AiHEQHut1JjcohAUc+VU7QgKhkmwgekbreNeOBrOBootNm/fL8gssfFBmDFb11qD2a4KRJ5tOuvRizJQvoSRFTpW5qgpIA0HXad77UQs9gnUtHy9U5lFBRDmTo6jSZ9XsV+3w4CVZWu+uXICf2mHUpaTjNZBPrWpyqA/L0fGp+HUiOePWQth6cIPMrNZ2bKWtbD0LgxCPHhXJuFns6Md5nxXcvjV0A/2FptIRC9dtRYOBep4r/Kod700bsb6LPqhMv2vHPYtycgw0jQP57Oqn/BQvZ/0PmkXAchL+wH5QhhimbkLfW6CuXGdbFXuhq4eSZxqj41nbA3ZSn1cnG4aHCntGZbBtMe/eAYx7CwLdd74HA0z/1TuQHTeoJiSR5/54+mPa+MPQMJ8LgY6ebt32ifPtJhH62nXFQDVzQ+gUQ9WxbZzxHzhIGIPjZWbx77nGdAySzjxQSlr/9I6wQIOP75D5yNz/6B2huxY0nUt8ro8jYA4XfRdhn2sRUk7i/6Anl35JVSHCa/JXAYCBTIybWtf1RJgETkuVwaUF98yhVeMGDKOcz8T3/d07tJpnzBLvTH5hKF3lr94hQmp26CjRZvLH9R+jv7n0XLfzQuUFfZJBdUj3UqGkoBEGzgIA1Wfr95juGk0f7guoPDeHDE+LtzrI7cpb9202de129o7dxzszjua1Pcj87ncd6ad3jG4e6Puv//j6j5cEpKQzcEv+zk2ipLalg6ire/MuAHQLriKhA/NudJoaPxPg641kafGwYsxDNrPzPbDKRQmzGaAerR7VDoUsgKUb0a5PyAqynPUwuWj+dofLRxePkjsePbrv9U1WJaUT9vebyqqIcvynAMDkwjSdSBgNHThy5NnUBkvsjYDJeLrtQRz0OsoyDdoRZcAuqawB192fME48Z53r5IP4mSeIpsruzTaj6YclwcNHzDHW1rdtfe6hXmqubu3SvdNT/TAMQ3oBi8ftTFiGM/2cyFWD9oRNO14F4v5eFX5YY7C9joABYQEa6HYDR0gFdSLh5w0xivNrTtdL/VSCPyyI2edygz3u3I6GWH02Q0IQVzbbuwCQRt8XqFzuM5ZtezQhXTn/4but19xKNG7pFNgTNUrTc4R3gtxeDKpEn/doqA+CjfSMevaCu7aj3/04/5XgHFDrlF2Xep0X8PO6MbYbeKXifhcA/LVKOCNjviWBz74TrrdjRntk85cb3d8DHbq9bx33iEB3xTCJUXNQr+O5EppfFcyBziA/CDN5QjLEkHt8vv8FNbOnuId9yz54e3EoYb+y29GCYaE/BYCO0P5RkyXyp8xswaz2NPSCpM+CeG1XSdeGgEftr6ZD6BrS9OwxEuoSkgjbEmvXUdb9jDNpSmgb3CzH/4D64/qJGku6mlKI98XE8KIVxMLI9shPAWD6yOeFyrK7ho88IfONWxCeuE532fS2YcTc+LaiWoCOwHiJXFJ0dpoB0l5aSu3dYVwoAcoeyFqZUEWWj+v/7iAxipreowWhaI7g953seQYw91MAkEwhyHkOzVEDUA/MnhDtI1JA07EmNK9hnzkQAicyyQGexIvgtkkVrEXHOFjJ+Ely1cQKNKgTlip5nv1iH89/i8u80xovI4kNeLDd0dw7xjJSfhcAqosB9eIZ1uFPN8/tomjvk9WYVY7zXginawT0DbuapeOnKOS+oCyliJ8yGIf81ynPQwf3OijZkDuXHFEzPr3+NOEp+iWI+dRiNu4XQjgB/VygFB+zAHC19ZrJ7KtlPOq67VPpuRCQgtjs2ivTanPwxHCMhLgI3yU8Jhl0ezM/jKMIrHxOBilwNxFimdQCf+7j6T/UYaRp5EQTtVdsCH+SFgGhvfCIWJefAsBa2j47dfidKaRrbwMpI1fhyM1Tmm6uY1K9ePSUe1vAc1h2MaSsOTWJEV+sGqwwS+kY9cEYihG21Zk32j6eAFRwoTWHi7jZtKRsGjOlU/wi2J3qTO69iFiQ6oXnnatb4TVt9qH4Dgy6v1EAPSJ1ffaRxnDPmCp4jWL21Ym67uOX4yNpTSuz+UC7WiGQCf63z65+auDSWZTdrBUYkaG00iQePzWKlaBtBnTqdYhdIIcljkCO992FOg40aDjbg7iYobt0dewXM8A7+grOkU+kMUEvcou/BL6ZBQobxhHPUio1wMf7/8vsadwmaiMEWR4yOrokWggoYa1k5kDfPid6Cp4UBoTXTBCsr7Os2wIX64e2qb02WpDRwDh8YBvGNt0iAuWMWAEx31+AD3oFJxAN7kYtqfe70Y/7P7D6WF4C8gtBOj8xCKIHO9jMaC9LGJ5WQif1Bwz8dk9uEh8ZzwRGU/KCvMkM9QbGpOqw78zeUXs9a2g3mcAXTeWvwHdYUflw/Fx2782Tzk8v/7Yuxfba8bkK9I1OM7fNSEtS8MlsikuWIptxHQ/ylB6JXlfcBLNogbwxd3T5HuOgC2hABwKnrNEz8GUSHzb+TnyWkhe2wamLSTt57o/zPx8DOHRbBoNb6SGRC/qltSQsH86uTK23ZZYijwV6puUlSd6GQepr3MwXEVLkbCEzdfo44NqBeRPf6z8TX55Xxem9KYNBYkPS9en1T/khcnq/hGGipDVTsc1u1pejs4gRI8IUPP00M3mP3DYiqhWg0lL96tH034NDgYJRBOW/Jj64W4+8IwpCAEjNx73fe3ahZeAF12tPw9dUyWxxKI9VSAPwzbVojw8Mu92UOBC6LEB0sLX2yMPVgkzbe3AItBmV/B+JL9gqy0wijRRkX3kMH+9/n2ssNO4LR8yW/dFiRD4swc8ub2sSIv1EO4Z8N5ZbLhUctUTWQ+0XQZyfEeQjiWnH5uls//yvic+foUnWrNAW8gji894fRL9xvV0r3hhlRQmV8pZfqy0toJmDpgvasGOpHJuz6OeAXvi/pUz0EphxsTF+EesQQ5DfQ5P/lPieQ5M5oY4IZ06NEeTz/f/7GpP1SMgEOEIWa2jq56tKwY4jWqQtYPpWgW+nmU3LYSA5chgRFyQAE+7VuhQDWi28aPNraPIfCh8/Q5Mktwn7XpbxdMSP9785ZCiROBZQ3YVd2raao9d3WxKiAXdsGOnPO7WMZJXUbpfXhvRvzkur6I1k+QxIGqbehChE+q+Fr5+hSW78ScwgTe/j/F8oAPmBvA4Z8Bqckhju8DUpNhJIL/b1zFnNMYe4ILFRUuaMax8sbsvW+1hIva0GyonwDpGDyss/FD7/GJpkZpMEAecmNrN//Py9XkV/FUqWbYsSFKrpdN7Ie6VDl7WbvcxDrAJjYL3u2TDKhXYeNR3Dwng85IPzXDlZArfd/2Ph+9fQ5H0x2jA2Ite0IdaP85/rOepkbDonlgz7MUgiwTxITrYCJl0LxDXP9o82tjnHIRZJ7TE7IpDJHvjuWXhBz9dLLZd59X9tfGh/H5oMZBwNoiJd8M/X/9vruQhVuS5ha6tnYmJ3MjSsjab9mIPAai25IFEOqszCAE9kli3WBNbBOk6KFAlkR6eXy6VN2f6l8eX496FJCVb4Rz2zV/h/IQFyNumbd9FIM/OxGLsW+9JwIvEd19uLFwwBuaGCoyNnNip4pTkf8K6E72t7SJCuPFeQqPYI7dxCFlHfjU/nvw9NVgQR+YV7S2j1n148zEZ/FYlXDR085LVMwIbH/Tp3JHywb1mAnC1RXTwTyqvN2iHhIeWeufvwRs8ecUAQfTNmoVL4JR27mI1vFcS/D02Oo9AGcq9E9fLx/g8ry0587FnNWfyZjjb9ahuXcgMx0TEVazT4+mknWMkZ/GaDXDrcZa7evPcg3H65UDma5dIx7d+Nj7MK9h+GJjeOOFGhYXBl9cfx74bo9og1IDlvc6ZN2nmXCfVLBC3R23WKpHUWOebcB0JkeDdIh1aZvtbYJqZfD6ivnSFD8qNsARhnTA4g/zA0ibF/t3lT9wKlfXz+cdmz3mvQ8OwB2frMYq5zOgFmuicv0PyCwA4d47yzQCH+XSW5g9x6I9c9xEqkc8dgM5d/VyBlejyNUElH8g9Dk4Ku+zCoQOg07cf7vwsD1d4e+zW4AjVntZV4/2OO7VS/R/Tc+1UZ9COvUtQbQ0PGP3RkeMcc9Ib4TGCMxoE4p/Xr6WRnc1TiPw9NNn0sDAJfnZqTIB+WXIJr2awE3viebHTOhGyvc6CLOm0iMtfjNbdiAWVcXQhc8gzLm9zke3hh30xvuYtR039sUHdLN43s6T8PTe6liQBeYSzVH1/+bGIo1MAxhz/xv+uDBu3zDs8zkx2E3YxeN6Lb9jrwEIXL3oPDw166dXOsz5pxQrk4KsGN6GiAR3iMH7BZ/g9Dk201AoNNfu17Ux9nwDlu6JFSWJYdQ31b+auLF59oB0/OdEOblzEjVzPoByqa+zo7vSZfGIdHFNvbgrQmnEh8id3Q4MHoNYJMkYn/PDTJg+/yXGIFpvvH+7+GEZdEP11mTXtWNiqCU+Q8h5vZ22WZjTAsoCGr2A1BtMvYvrzn9oXkofaMS7gIn22knG2dwcbfjcNyi529T/dvQ5OtpJr8vDKJCggf93/W4SODw3AnJLRGkMu/QCHSezCeF1aEEaZZV6nYwm9lrSypiieqi0gnur/3YOdy/THO4troFYMjms2/D01SU5Ya3RATWbqP33+SWkId0GjEfJZ4srdI80ANNttZemlXH2yEd1ETwQwRHOF9gnlxDxdz4K3ssyFgq7Mffnkjoi1PGN0L1ZGq9rehSaJYlfeQbdbLERR/vP4H8ajMec/xgdH1n3zv/Cowb0CigRtd25OJXihgUA8RynHtq8KDdratZWa3AenPdu4nmk9BPUKA+x6Mg92CcOTvQ5NKIwq8qBAM1p6ej6f/cZXmNbENUtHD7he6gOuBd1Ym7YUpDNSpg9luQHBv743nsl3dzHszrHa2Ogv6DhjH+rWG3sNZkejNZiphV+/SX4cmJwpKazBupYmir0S4eOiP+38LlFwvSJPczMlEDOF1A85xD1qWXNqMRyvllbVYC3/sWqVUPnonETf5UYeBcRGbhLmOvrnJjO0CI0viUi7yL0OTuwdW1txnx1HXyKyo5enj8x9cC+IQ7GC4tz9k3NsXMXmzlOV1Tds2xrU4WlhdOMP4XnCFqndR6xZFvucNJgjvjIetMRZmchNSmgPBS2n78efQJBBHpBbOE9Pw1N2cnY/bxwHQlRgejK/waDMngcCuwviUt5MGx3u8HBQBsZoeHjs71n5GoPZL7jM30GuaFJbMdTwIcPa1ZMqO5eiIK0OofxmapAiZDI1S4Q+R9016ucaP5783GyluANKACKnmBPbUIGxFAw5HHRt5zWy9hzoSzJH/SY3e7ZJvH7FC7DxBXI6Mmlw2j2Tw6P1GpuBxH+DPocmFUYlb4rUxPGuo7t1Owz7e/5dTJXzrgs7Qle9zAVR1xmxlwfWSYppBfUG46+btFp7NtP4x4/0bMMBBex/JS/mTypgbFNO6vHRq0Qfyx9BkFkxJPXKeCREPolBSZ/P7x/NfTGK4UrOj6Q3FnusQbD+r4pCUnikhsNZbq4lGwuYIb9bnC3dpJgJrXpRDVih0QHD8VzLT97IO83to0niBSJdHUm6yBM2JjGURBENi+ngF1ImwgarpNkfBs6n3HZGsjVGF1mQyN1zM2KtknFORG8k9XLtGAqdmKrww6ZEdA9ujANwOT1ADkPrHNShyhFrfmRN4UZEQWhY+CKV+R6BBZR5OLfXj+f9qWfTcN5fSvm47+m4/07kiULeveNJ9Foe3lRoWEB0v4E7k9hgA3lc63YomtJfXvobZOngiDOqtpdGDEDuGxFLnFO2OlLkXDIGuY+SbhdGZ9bHx3BX9/P0XRWxtR8KnYT2PCxdoCPIWwqhCR1/mdYWz11luWuyrrUZZcyD0Vem1IhV6TRsmyzrL3UduuAHPde0u9URYiRqDyTVYbhQcmsGh9gKbO959ttSrJVhPP71+Mib53dgc7rgHRnJqaqIRGKIdhTiImwt5QcrG5BcqsVcQCRGhsxOJgKnSEEmQ0hGY9wSTOS+5p3WCYin1gVqzbBg66wxz4bwOuSA4sgg1wMBK9Zo+fv9ptIGcgZDQ85hJPJBrne0OwrYNiNmk416iU9d4mluL6Aey1nMOgK1HRBe44RbA4yiGACuJlyJFo7mzSG7WhkFfm+FcRrALWvm92Rkl0swbi5LE0j/e/zRgtQSsrHed1x5fe9k3oRwcErkQIvTdMKtZ7QbxrkCTZn2YpbbJ/+fFUEVqr23I2nY671HIHh2IvwTv0t5yTr6vW3fM9J164Cr2sYo1HAiLYz+iah+f/+UYlKyUZp03tbWXP0tf0RpQndEnLCBzWihvVA18kerDk1wtJerolJL7aISS7HmDwfjF88pcCWNLLxcJy6dZR9S72pD+ho0S0XomYyIMKscoLN/Rf9z/t3ntRZ9xKJp5B5hb9byyHHFg5WGgN1jEvN3gfhD/wf6kvlKupdAv5sl7aJJohfHMIqZn+MMaET13CJiO992g+9WXiIqEP/rT6f/MtpF1Ek4daHvcZxcP8/o/dHGqnoht7SzlonWiW/dZwvPab3T/BqEr9IAUIatoZtrnLjJd7N25P4cmlZx3QeFSiLS+RsPEvuu2vhFVZa2Cqwcl/Z1kz8tsAhuzafiBi9r+cf6XTXMm5zaZWJt3Fi0mzh4WWe2+hTMopa2ZRzmRrHtj14HM1qzHvw9N5t07o6Kt6Rx23vD6gG6BIpfOCAHtYrUduSkEvTyD177N3PGHZV/wMbYVHfyccOjo9+d996sxMfTdRiOR31lYg4FwFaRxFBpdl9xzjn8fmixbwiUqJhyhBrFAgx1EvGbzw9K5QYfZmWZzlAy9yyyog94+v/4zWc8c1JUXCDvnOiNoRUys151bAVJPZIvKEV5H6ZpBjcupZt9+WSH9y9DkReXqGPEIbhe3DvT8MK9+xeAvq0EO3fKBCpZL5W33ggGxED5e/91XWaJxhiK1ARITpeI8GAjRhkaKss7rKmMHub06Gnjbd4R8pM2ed62XJf1laFJnsOXY+gHm3OZkvznntPzMlarLw3aeM8B2DURnmY1o5z4+P//yM+mJaJ9ZRGuQZ0PjKAPKuRDCg6rUlY3011PJAbeGrNScfOgNETJRwfw5NKko8b0/T0cUlVEzNIUNZutjY7O2UG9wA1SAWWGDllcooz4fx/9ArXTjWDSIYPBMR6bZnnCVCIvJhONh7+OaxbBsHlykWzmCY/syNvPiVQ5/DE02Ziy6ivK8ywAnmxekEYUGnkPQ1vE0+Gk8RPduBLLvoSP4ePyX0LMNSHo1574PW6oKsl+pz8G36Bu0UXScwW2Jdk7LQ1/M8WCgh3jo0fzifg1NYggNcwAW1xRQRXi7hsfYhzviwPdjV8EXjCpuXAKY1j+Z/4/Xv3aDOk8I9bEzQGa+H4PC0lLPJsZl2/L18x0V78dtBZZbbdmcQweEh+o1Zhco/AxN1uTW2U5pA7+OWVjQeNCoE6Xm1T2nNAp5xEgYT5E85J4wfJqP538cEzP0pcwQCMxb//ZCCTp/ZDGRIlrZTyQrS3j3acySPe9zmOVKuP6A1GemiMgMBX7faVtSeieGGLyaB8ZHFZ4jr3aRl33aPqU/V35wH69zz6A/nv9rs95B99dLw3LFtcTFzmtAlknwfD5eePBzuD/9XNXwYCxEG+jk9cySAamMsI77Na8H6Z1XAxeP2/zJXqMT6PjndwuARNMZtU0HiOEW+FhmXzg8JXweABM4X+yZiXASUPMxhoXj7oRX/sBsbd+DmJOKZj80nv28uzq98syBD5Nfo9SUdiD7jx37TeA7a546cM3Wf7IfDuIcjV/W+eFzatiOcXddJEaHo30c/6IVu3mrDdfX+yxiGCfV6LBOh87+PdRvufbW9NQwLAr1qMf/urvifpbGTYseg8T7ClmVUrSJpTTiNishj5R9QH51h2qwY3SdQ9T64PVQLsVZKP14/9eOj6C913q1PzcSMMZXWEbco75vGwOMG723r4szeg6LgYqAMAh/sBauEMFjOKhSo+pHsaJnH5sw4PYTDAKmVJdV6xr48oS9uwSLnXetIi80s97Wj4/3v77uQ75RYFsFe0+zkwS6Y8hur12VA7YrlXvbe63nvN7VzgtOESGBM5WBPK7ex1btgux5eOksIUMK5plisi6g6ghsZtbX5cH4Jw6E0sFcINefzs/t4+tndSwQzry3uJp3LS8W9N8z26X5uvHtTrDt4lgom2MNg47T4m/1TRFE8JFzyhmiYbcj/CMwe2MNwcjA8CW1dURXQ0IBE6VagEHpzVo2uyzYj+f7eP0LKFolh7G12Od3gNHA4YpIYgZoVGIy+f48JPfGKmPAvOYIbmv3s5Rf99eQlfCr0Pe/I3tEK0IQPJkh4sf8Uy+8Z/8Dw49g+DmUrS5eB12fj8OfmcZD7cwrPpnsM++DK5UF/TXG612kBnGdh4TEcKZqJwpyrzm1vEZEyKwpfjoM4+gTup+XOUdt3OyTeDKSpfktP3MGlnJhRyJ5dlWzgXBhO1IPDwKr5+P498SDnBcgzEGfXCYX+rmTCv8/jSPEB+xuCdvtMNplZY29tJNkfm+SceW2ra8hACHHslBeSCk+vm+168iRLq7EvAiR1LY9SHm7GTe0U7QtTQK9CuE/3v/0OHmjY7bOEZnfp3EThHzcIwjeNSL5MtCRC4dstW0jl/1VidHKDrvs/WX8zqTOVobOyGIXTZAUg6TNmAX3akHMYzcGvlofCuRdPgs0vWdi9grEFf3x9XMJMldScxVLZwPtNt4I5ucNJ3M4cR8bevFUVFuUUptbd8QAzSlJi5c5+DV4pY7cV2r92g0jlCFuTit6UJLE2pQT4gnBSxBn4rLB3lRFjCwHwgHB+cfrP7Ole+leUn+oRN2lPbQEUqV1XnrDrmOvkqezzAelJkQOvASJJ2k3NPhTFctKvRzflI/tJkil5lWpG0fguxxbEfuC4WNyCMPNpoGKPPqSi6Ee179+Hv6JNH3ahRie7WiisM47r/zybHBBWvC0JZJY1FoWO3SuUT+EE7H39x0OnvN5me9rMSvGs3U2wh1bq6nM1uiGDOFE9ZljNL/GnNrz0N0qZISVQiMhfd7/ZT7Hc2FtaKG5/+pHM2Ne5x7mlzh1OfO8tZUb4riI34LPVel5h4dCO2YLIlmQaT3WRKcLPcriHILBNJHtiiahjpLe13y+Q/2T0jO7xPeaZ13Yfvz+m1dnagZoU0lYVQ6TkSIxQTVGHn9yNAbXEnv84dzrQeSX6Wxqn3e4VPDO4ZbddDY8He8vTsGgII1c+6T186tSpXTH+w6YYXwMxmmozM0+iVQumldvPj7/eIyVz6+8WbzmyHvnt7cAbSwHSrJ7Z2d9yXZ+KepdDxfR5nMhP3f46PdYm4mB5uiYHkeXRrClbCE3joZVnNZ8Q27hFmbvs4U6LkBtcSWuweiHlLF/3P/TUgYXdT8HLpaPOq/oYULrvNa6zMwPRSNHHINnJ3lYq0Tl/3WHU1e65JnHikQpjJgyMdfRtRmJVrWIYWdXrOBQjrOycY2956vPyJLPCwPNFnOUHz9/wraVQOVnIimq7arnqXNc1lTy4vR73gHqq2YzZ/eJbwLR/s8dXhB3Ol7rvCIAld17uRiqZCOzFRghz4Z04H2pLG7GeVdGS3YIj8KEWJQSNJaDfDz7jUIrBKDorsI4iGk9jy07tAizWAk1HGw9L3hs6vOOd5WW5fcdbrNd7CAKGeArU9vTvCx71Z4Ary/QlOJWAKH7uys8PA3YzAikrsBvIB6f4t7n6NSHZU5w+V5P//4WvNn5jk92C3FStiCjE3dIAUYz+92B3z1v/Y87/GB+a5JSzwN3Q9/P7bKUdcKm4xlroWpFmBN8+4lxz6mO1BQEgktWLM8L4M8qP97//nhr4dx9UZB4wVW56RMGnC9N2/zeA8TC4YE9nQuk1bBw/b7K5j3nipAIHs5eePpCFsuP9xfe2kt4q6fTQPBbkPLOSZm+1FlCXRZUqqbinpAHmY/n//rRS3EFyS4C4b2AUNbbdxv/vMPTQUdc9JpXws+LgdjiOfnjDs8yUx6zl+VBXOiTWVyc33k9x6jwR2r3vszpx/XVosJN7kAa4ox01IK2hHYDRH++/IMOes4rstnMQg7Euly3n6z8vMPVrIX32es2y9trmTZM/rjKptpS319y/W6dbHxVQc+vEDwRCqK5y3ymsiGCuDu6EsE4mV8x3Gfpc96N+cZDn4f/v+QgCz7qVkKJfuYstrmuGaDLmF//JmaZ5NVqcPEvV9nUjcp3YQD5TyC8mrBIDBIzydv7/r4BSWCYyPJ12PkVu/W4MerNpMn7twjIz/f/f+UrX/nKV77yla985Stf+cpXvvKVr3zlK1/5yle+8pWvfOUrX/nKV77yla985Stf+cpXvvKVr3zlK1/5yle+8pWvfOUrX/nKV77yla985Stf+cpXvvKVr3zlK1/5yle+8pWvfOUrX/nKV77yla985Stf+cpXvvKVr3zlK1/5yle+8pWvfOUrX/nKV77yla985Stf+cpXvvKVr3zlK1/5yle+8pWvfOUrX/nKV77yFYD/B92aGZl3Kab3AAAyJWlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS4wLWMwNjAgNjEuMTM0Nzc3LCAyMDEwLzAyLzEyLTE3OjMyOjAwICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iPgogICAgICAgICA8eG1wOkNyZWF0b3JUb29sPkFkb2JlIEZpcmV3b3JrcyBDUzUuMSAxMS4xLjAuMjA1IE1hY2ludG9zaDwveG1wOkNyZWF0b3JUb29sPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNC0wOS0yMlQyMDoxMDo0Mlo8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxNC0wOS0yNFQxNToyNzoyMlo8L3htcDpNb2RpZnlEYXRlPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIj4KICAgICAgICAgPGRjOmZvcm1hdD5pbWFnZS9wbmc8L2RjOmZvcm1hdD4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgCjw/eHBhY2tldCBlbmQ9InciPz7OxBilAAABKUlEQVQ4jc3UsUrDQBzH8e9VoQ4OSkhKH8KtS8Y6CDYQiXT0AQQHVx8hU8FBRyfniMEqBXF1yVDwHVoaER0cTMGcQ5o210ZNJYM3JeT/+3D3I4mQUlLGqpSi/EtoNb2o7V0FfwFG105DgQBOjsylEPfscXFHANtbWmEkjsHN3CvQzuHNUjvKLpG+R0IIWDvY5aOyDnwC4puMBFaoxu9El3fTfBYybG+pwkN/v5HmZ0fTTzchKfy3rh6eXpSiVej5+DX0rZYLt0yw0VukDNc2qlMk9C9a+RAA3TD0I8uF7jymIucW3IdKVErJ4ofraIbtBZ3eMOgPxkF/MA46vWGQdOhoufl8CMA0UmyGmMb8VAEIoK0btjdB2nreREEIoFlPnjfrP0GirB/bFy2PpzKb9kV5AAAAAElFTkSuQmCC";
    });
    handle.addEventListener( "mouseleave", function(e) {
        image.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAKQWlDQ1BJQ0MgUHJvZmlsZQAASA2dlndUU9kWh8+9N73QEiIgJfQaegkg0jtIFQRRiUmAUAKGhCZ2RAVGFBEpVmRUwAFHhyJjRRQLg4Ji1wnyEFDGwVFEReXdjGsJ7601896a/cdZ39nnt9fZZ+9917oAUPyCBMJ0WAGANKFYFO7rwVwSE8vE9wIYEAEOWAHA4WZmBEf4RALU/L09mZmoSMaz9u4ugGS72yy/UCZz1v9/kSI3QyQGAApF1TY8fiYX5QKUU7PFGTL/BMr0lSkyhjEyFqEJoqwi48SvbPan5iu7yZiXJuShGlnOGbw0noy7UN6aJeGjjAShXJgl4GejfAdlvVRJmgDl9yjT0/icTAAwFJlfzOcmoWyJMkUUGe6J8gIACJTEObxyDov5OWieAHimZ+SKBIlJYqYR15hp5ejIZvrxs1P5YjErlMNN4Yh4TM/0tAyOMBeAr2+WRQElWW2ZaJHtrRzt7VnW5mj5v9nfHn5T/T3IevtV8Sbsz55BjJ5Z32zsrC+9FgD2JFqbHbO+lVUAtG0GQOXhrE/vIADyBQC03pzzHoZsXpLE4gwnC4vs7GxzAZ9rLivoN/ufgm/Kv4Y595nL7vtWO6YXP4EjSRUzZUXlpqemS0TMzAwOl89k/fcQ/+PAOWnNycMsnJ/AF/GF6FVR6JQJhIlou4U8gViQLmQKhH/V4X8YNicHGX6daxRodV8AfYU5ULhJB8hvPQBDIwMkbj96An3rWxAxCsi+vGitka9zjzJ6/uf6Hwtcim7hTEEiU+b2DI9kciWiLBmj34RswQISkAd0oAo0gS4wAixgDRyAM3AD3iAAhIBIEAOWAy5IAmlABLJBPtgACkEx2AF2g2pwANSBetAEToI2cAZcBFfADXALDIBHQAqGwUswAd6BaQiC8BAVokGqkBakD5lC1hAbWgh5Q0FQOBQDxUOJkBCSQPnQJqgYKoOqoUNQPfQjdBq6CF2D+qAH0CA0Bv0BfYQRmALTYQ3YALaA2bA7HAhHwsvgRHgVnAcXwNvhSrgWPg63whfhG/AALIVfwpMIQMgIA9FGWAgb8URCkFgkAREha5EipAKpRZqQDqQbuY1IkXHkAwaHoWGYGBbGGeOHWYzhYlZh1mJKMNWYY5hWTBfmNmYQM4H5gqVi1bGmWCesP3YJNhGbjS3EVmCPYFuwl7ED2GHsOxwOx8AZ4hxwfrgYXDJuNa4Etw/XjLuA68MN4SbxeLwq3hTvgg/Bc/BifCG+Cn8cfx7fjx/GvyeQCVoEa4IPIZYgJGwkVBAaCOcI/YQRwjRRgahPdCKGEHnEXGIpsY7YQbxJHCZOkxRJhiQXUiQpmbSBVElqIl0mPSa9IZPJOmRHchhZQF5PriSfIF8lD5I/UJQoJhRPShxFQtlOOUq5QHlAeUOlUg2obtRYqpi6nVpPvUR9Sn0vR5Mzl/OX48mtk6uRa5Xrl3slT5TXl3eXXy6fJ18hf0r+pvy4AlHBQMFTgaOwVqFG4bTCPYVJRZqilWKIYppiiWKD4jXFUSW8koGStxJPqUDpsNIlpSEaQtOledK4tE20Otpl2jAdRzek+9OT6cX0H+i99AllJWVb5SjlHOUa5bPKUgbCMGD4M1IZpYyTjLuMj/M05rnP48/bNq9pXv+8KZX5Km4qfJUilWaVAZWPqkxVb9UU1Z2qbapP1DBqJmphatlq+9Uuq43Pp893ns+dXzT/5PyH6rC6iXq4+mr1w+o96pMamhq+GhkaVRqXNMY1GZpumsma5ZrnNMe0aFoLtQRa5VrntV4wlZnuzFRmJbOLOaGtru2nLdE+pN2rPa1jqLNYZ6NOs84TXZIuWzdBt1y3U3dCT0svWC9fr1HvoT5Rn62fpL9Hv1t/ysDQINpgi0GbwaihiqG/YZ5ho+FjI6qRq9Eqo1qjO8Y4Y7ZxivE+41smsImdSZJJjclNU9jU3lRgus+0zwxr5mgmNKs1u8eisNxZWaxG1qA5wzzIfKN5m/krCz2LWIudFt0WXyztLFMt6ywfWSlZBVhttOqw+sPaxJprXWN9x4Zq42Ozzqbd5rWtqS3fdr/tfTuaXbDdFrtOu8/2DvYi+yb7MQc9h3iHvQ732HR2KLuEfdUR6+jhuM7xjOMHJ3snsdNJp9+dWc4pzg3OowsMF/AX1C0YctFx4bgccpEuZC6MX3hwodRV25XjWuv6zE3Xjed2xG3E3dg92f24+ysPSw+RR4vHlKeT5xrPC16Il69XkVevt5L3Yu9q76c+Oj6JPo0+E752vqt9L/hh/QL9dvrd89fw5/rX+08EOASsCegKpARGBFYHPgsyCRIFdQTDwQHBu4IfL9JfJFzUFgJC/EN2hTwJNQxdFfpzGC4sNKwm7Hm4VXh+eHcELWJFREPEu0iPyNLIR4uNFksWd0bJR8VF1UdNRXtFl0VLl1gsWbPkRoxajCCmPRYfGxV7JHZyqffS3UuH4+ziCuPuLjNclrPs2nK15anLz66QX8FZcSoeGx8d3xD/iRPCqeVMrvRfuXflBNeTu4f7kufGK+eN8V34ZfyRBJeEsoTRRJfEXYljSa5JFUnjAk9BteB1sl/ygeSplJCUoykzqdGpzWmEtPi000IlYYqwK10zPSe9L8M0ozBDuspp1e5VE6JA0ZFMKHNZZruYjv5M9UiMJJslg1kLs2qy3mdHZZ/KUcwR5vTkmuRuyx3J88n7fjVmNXd1Z752/ob8wTXuaw6thdauXNu5Tnddwbrh9b7rj20gbUjZ8MtGy41lG99uit7UUaBRsL5gaLPv5sZCuUJR4b0tzlsObMVsFWzt3WazrWrblyJe0fViy+KK4k8l3JLr31l9V/ndzPaE7b2l9qX7d+B2CHfc3em681iZYlle2dCu4F2t5czyovK3u1fsvlZhW3FgD2mPZI+0MqiyvUqvakfVp+qk6oEaj5rmvep7t+2d2sfb17/fbX/TAY0DxQc+HhQcvH/I91BrrUFtxWHc4azDz+ui6rq/Z39ff0TtSPGRz0eFR6XHwo911TvU1zeoN5Q2wo2SxrHjccdv/eD1Q3sTq+lQM6O5+AQ4ITnx4sf4H++eDDzZeYp9qukn/Z/2ttBailqh1tzWibakNml7THvf6YDTnR3OHS0/m/989Iz2mZqzymdLz5HOFZybOZ93fvJCxoXxi4kXhzpXdD66tOTSna6wrt7LgZevXvG5cqnbvfv8VZerZ645XTt9nX297Yb9jdYeu56WX+x+aem172296XCz/ZbjrY6+BX3n+l37L972un3ljv+dGwOLBvruLr57/17cPel93v3RB6kPXj/Mejj9aP1j7OOiJwpPKp6qP6391fjXZqm99Oyg12DPs4hnj4a4Qy//lfmvT8MFz6nPK0a0RupHrUfPjPmM3Xqx9MXwy4yX0+OFvyn+tveV0auffnf7vWdiycTwa9HrmT9K3qi+OfrW9m3nZOjk03dp76anit6rvj/2gf2h+2P0x5Hp7E/4T5WfjT93fAn88ngmbWbm3/eE8/syOll+AAAACXBIWXMAAAsTAAALEwEAmpwYAAACw2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIj4KICAgICAgICAgPHRpZmY6WVJlc29sdXRpb24+NzI8L3RpZmY6WVJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlhSZXNvbHV0aW9uPjcyPC90aWZmOlhSZXNvbHV0aW9uPgogICAgICAgICA8eG1wOkNyZWF0ZURhdGU+MjAxNC0wOS0yMlQyMDoyMDo1MDwveG1wOkNyZWF0ZURhdGU+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+QWRvYmUgRmlyZXdvcmtzIENTNS4xIDExLjEuMC4yMDUgTWFjaW50b3NoPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6TW9kaWZ5RGF0ZT4yMDE0LTA5LTI0VDE1OjIzOjQzPC94bXA6TW9kaWZ5RGF0ZT4KICAgICAgPC9yZGY6RGVzY3JpcHRpb24+CiAgIDwvcmRmOlJERj4KPC94OnhtcG1ldGE+Cj190pwAAADZSURBVDgR7ZKxDcIwEEWP4IppUiBcpGCQ1LCBp/AGiNaDUEaiyATpsgJVBNyPZOscBVknRIcL5/vu+8X5MdF/lBLYRIO19h615tl13R5+IzeFEOSyqNu2TZ4qqS9FdiL5Bi03ZYSNxpjjNE07ls8CqGLvg7236MtA2sBj0IBln4ZCXdfknIP8OLz31Pd91t/K1TiOVz7yaRgGappGtpKOED7NgYuv2MhAaDDswrDzGkxAcHcSBLAlCDVagy0gs09OWdiyAY3wkRkGMpHhzkXNBJj2b2r4v/O+AQ/0UQF3+ePEAAAAAElFTkSuQmCC";
    });

    parent.appendChild( handle );

    // Add the RMB menu.
    var homeViewMenu = document.createElement('div');
    homeViewMenu.className = "homeViewMenu";
    this.container.appendChild( homeViewMenu );

    var setHome = document.createElement('div');
    setHome.className = "homeViewMenuItem";
    setHome.textContent = Autodesk.Viewing.i18n.translate("Set current view as Home");
    homeViewMenu.appendChild( setHome );

    setHome.addEventListener( "click", function(e) {
        autocam.setCurrentViewAsHome(false);
        hideHomeViewMenu(e);
    });

    var focusAndSetHome = document.createElement('div');
    focusAndSetHome.className = "homeViewMenuItem";
    focusAndSetHome.textContent = Autodesk.Viewing.i18n.translate("Focus and set as Home");
    homeViewMenu.appendChild( focusAndSetHome );

    focusAndSetHome.addEventListener( "click", function(e) {
        autocam.setCurrentViewAsHome(true);
        hideHomeViewMenu(e);
    });

    var resetHome = document.createElement('div');
    resetHome.className = "homeViewMenuItem";
    resetHome.textContent = Autodesk.Viewing.i18n.translate("Reset Home");
    homeViewMenu.appendChild( resetHome );

    resetHome.addEventListener( "click", function(e) {
        autocam.resetHome();
        hideHomeViewMenu(e);
    });

    parent.addEventListener( "mouseover", function(e) {
        if (mode === "2d" || (self.prefs && !self.prefs.viewCube) ) {
            handle.style.display = "block";
        }
    });

    parent.addEventListener( "mouseleave", function(e) {
        handle.style.display ="none";
    });

    handle.addEventListener("click", function(e) {
        if (mode === "2d" || (self.prefs && !self.prefs.viewCube) ) {
            homeViewMenu.style.display = "block";
            document.addEventListener("click", hideHomeViewMenu );
        }
        e.stopPropagation();
    });

    parent.addEventListener( "contextmenu", function(e) {
        if (mode === "2d" || (self.prefs && !self.prefs.viewCube) ) {
            homeViewMenu.style.display = "block";
            document.addEventListener("click", hideHomeViewMenu );
        }
    });

};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initViewCube = function()
{
    this.viewcube = document.createElement("div");
    this.viewcube.className = "viewcube";
    this.container.appendChild(this.viewcube);

    this.cube = new Autocam.ViewCube("cube", this.autocam, this.viewcube, LOCALIZATION_RESOURCE_ROOT);
    
    this.displayViewCube( this.prefs.viewCube );
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initInfoButton = function()
{
    this.infoButton = document.createElement('div');
    this.infoButton.className = "infoButton";
    this.infoButton.style.cursor = "pointer";

    this.container.appendChild(this.infoButton);

    var self = this;
    this.infoButton.addEventListener("click", function (e) {
        var propertyPanel = self.getPropertyPanel(true);
        var visible = !propertyPanel.areDefaultPropertiesShown() || !propertyPanel.isVisible();

        if (visible) {
            propertyPanel.showDefaultProperties();
        }

        if (visible !== propertyPanel.isVisible()) {
            propertyPanel.setVisible(visible);
        }
    });
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.displayViewCube = function(display) {
    this.prefs.set('viewCube', display);
    this.viewcube.style.display = (display ? "block" : "none");

    if (this.homeViewContainer) {
        var homeButtonBounds = this.homeViewContainer.getBoundingClientRect();
        var viewCubeBounds = this.viewcube.getBoundingClientRect();
        var infoButtonBounds = this.infoButton.getBoundingClientRect();
        var containerBounds = this.container.getBoundingClientRect();
        if (display) {
            this.homeViewContainer.style.right = (containerBounds.width + containerBounds.left -
                                                  viewCubeBounds.left - homeButtonBounds.width) + "px";
        } else {
            this.homeViewContainer.style.right = (containerBounds.width + containerBounds.left -
                                                  infoButtonBounds.left + homeButtonBounds.width / 2) + "px";
        }
    }

    if( display ) {
        this.impl.invalidate(true);
        this.autocam.refresh();
    }
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.initSearchBox = function() {

    var searchMenuId = "searchBox";
    this.searchMenu = this.toolbar.addSubToolbar( searchMenuId, false );

    this.searchMenu.setVisibility( false ); // initially it is not visible.

    // Search box
    var lisearch = document.createElement("li");
    var searchbox = document.createElement("input");
    searchbox.type = "search";
    searchbox.results = 5;
    searchbox.placeholder = Autodesk.Viewing.i18n.translate("Search");
    searchbox.incremental = "incremental";
    searchbox.autosave = this.container.id + "search_autosave";
    searchbox.setAttribute("data-i18n", "[placeholder]Search");

    lisearch.appendChild(searchbox);

    this.toolbar.addToSubToolbar( searchMenuId, lisearch );

    var self = this;

    searchbox.addEventListener("change", function(e) {
        stderr("search " + searchbox.value);
        self.search(searchbox.value, function(resultIds)
            {
                self.isolateById(resultIds);
            }
        );
    });

    // Allow Escape key to clear search box even if browser doesn't support
    // that natively (Chrome/WebKit do, Firefox does not). 
    searchbox.addEventListener("keypress", function(e) {
        if (e.keyCode === 27) {
            // Clearing the value immediately doesn't seem
            // to work (??) so do it from a timer.
            setTimeout(function() {
                // prevent flicker
                if (searchbox.value !== "") {
                    searchbox.value = "";
                }
            }, 0);
        }
    });


    // Drop focus from search field after mouse has been out of the toolbar
    // for a few seconds.
    //
    // Because the toolbar fades out, it is counterintuitive for the search
    // field to keep focus indefinitely- none of the keyboard controls will
    // work, and text will still be showing up in the search field. But, we
    // still want a little bit of "grace period"...
    this.toolbar.addEventListener("mouseleave", function(e) {
        var id;

        function reset() {
            clearTimeout(id);
        }
        self.toolbar.addEventListener("mouseenter", reset);

        function clearFocus() {
            if (self.toolbar) {
                self.toolbar.removeEventListener("mouseenter", reset);
            }
            if (document.activeElement === searchbox) {
                self.canvas.focus();
            }
        }
        // if focus drop seems too fast/slow, tweak this number
        id = setTimeout(clearFocus, 2000);
    });

};

// document structure button
Autodesk.Viewing.Private.GuiViewer3D.prototype.setPropertiesButtonEnabled = function(enabled) {
    if (enabled)
        this.modelTools.select(this.modelTools.propertiesbutton.id );
    else
        this.modelTools.deselect(this.modelTools.propertiesbutton.id );
};

// model structure button
Autodesk.Viewing.Private.GuiViewer3D.prototype.setStructureButtonEnabled = function(enabled) {
    if (enabled) {
        this.modelTools.select(this.modelTools.structurebutton.id );
    }
    else {
        this.modelTools.deselect(this.modelTools.structurebutton.id);
    }
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.showModelStructurePanel = function(show) {
    this.modelstructure.setVisible(show);
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.onPanelVisible = function(panel, viewer) {
    if(!viewer) {
        viewer = this;
    }

    // Shift this window to the top of the list, so that it will be closed first
    //
    viewer.dockingPanels.splice(viewer.dockingPanels.indexOf(panel), 1);
    viewer.dockingPanels.splice(0, 0, panel);
};


Autodesk.Viewing.Private.GuiViewer3D.prototype.initFocalLengthOverlay = function() {

    var container = this.focallength = document.createElement("div");

    container.className = "focallength";

    var table = document.createElement("table");
    var tbody = document.createElement("tbody");
    table.appendChild(tbody);

    container.appendChild(table);
    this.container.appendChild(container);

    var row = tbody.insertRow(-1);
    var cell = row.insertCell(0);
    cell.setAttribute( "data-i18n", "Focal Length" );
    cell.textContent = Autodesk.Viewing.i18n.translate( "Focal Length" );
    cell = row.insertCell(1);
    cell.textContent = '';
    cell.style.width = "4em";
    cell.style.textAlign = "right";
    this.fovCell = cell;

    container.style.visibility = "hidden";
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.showFocalLengthOverlay = function(state)
{
    var self = this;
    var myFocalLength = 0;

    function showFovHudMessage(yes) {
        if( yes ) {
            // Display a hud messages.
            var messageSpecs = {
                "msgTitleKey"   : "Orthographic View Set",
                "messageKey"    : "The view is set to Orthographic",
                "messageDefaultValue" : "The view is set to Orthographic. Changing the focal length will switch to Perspective."
            };
            Autodesk.Viewing.Private.HudMessage.displayMessage(self.container, messageSpecs);
        }
        else {
            Autodesk.Viewing.Private.HudMessage.dismiss();
        }
    }

    function showFov(yes) {
        if (yes) updateFOV();

        if( self.focallength )
            self.focallength.style.visibility = yes ? "visible" : "hidden";
    }

    function updateFOV() {
        var camFocalLength = self.getFocalLength();
        if( myFocalLength !== camFocalLength )
        {
            myFocalLength = camFocalLength;
            self.fovCell.textContent = camFocalLength.toString() + " mm";
        }
    }

    function watchFOV(e) {
        updateFOV();
        // If camera changed to ORTHO and we are still in FOV mode
        // put up the warning message that the system will switch to perspective.
        //
        if (self.toolController.getActiveToolName() === "fov") {
            var camera = self.navigation.getCamera();
            var isOrtho = camera && !camera.isPerspective;

            showFov(!isOrtho);
            showFovHudMessage(isOrtho);
        }
    }
    var camera = self.navigation.getCamera();
    var isOrtho = camera && !camera.isPerspective;

    showFov(state && !isOrtho);
    showFovHudMessage(state && isOrtho);

    if( state ) {
        this.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, watchFOV);
    }
    else {
        this.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, watchFOV);
    }
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.updateScreenModeButton = function (mode) {
    this.container.classList.remove('screenMode-kFullBrowser');
    this.container.classList.remove('screenMode-kFullScreen');

    var cls;
    switch (mode) {
        case Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal:
            if (!this.isScreenModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser)) {
                cls = 'screenMode-kFullBrowser';
            }
            break;
        case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser:
            if (this.isScreenModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen)) {
                cls = 'screenMode-kFullBrowser';
            } else {
                cls = 'screenMode-kFullScreen';
            }
            break;
        case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen:
            cls = 'screenMode-kFullScreen';
            break;
    }

    if (cls) {
        this.container.classList.add(cls);
    }
};

Autodesk.Viewing.Private.GuiViewer3D.prototype.localize = function () {

    Autodesk.Viewing.i18n.localize();

    if (this.viewerOptionButton && this.viewerOptionButton.subMenu ) {
        var mode = this.viewerOptionButton.subMenu.mode;
        this.removeViewerOptionsMenu( mode );
        this.createViewerOptionsMenu( mode );
    }

    if (this.debugMenu && this.debugMenu.debugSubMenuButton) {
        this.debugMenu.debugSubMenuButton.removeChild( this.debugMenu.subMenu );
        this.createDebugSubmenu( this.debugMenu.debugSubMenuButton );
    }
};
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Private');

Autodesk.Viewing.Private.GuiViewer2D = function (container, config) {
    Autodesk.Viewing.Viewer2D.call(this, container, config);
};

Autodesk.Viewing.Private.GuiViewer2D.prototype = Object.create(Autodesk.Viewing.Viewer2D.prototype);
Autodesk.Viewing.Private.GuiViewer2D.prototype.constructor = Autodesk.Viewing.Private.GuiViewer2D;

Autodesk.Viewing.Private.GuiViewer2D.prototype.initialize = function () {
    var viewerErrorCode = Autodesk.Viewing.Viewer2D.prototype.initialize.call(this);
    if (viewerErrorCode > 0) { // Error was generated when initializing.
        return viewerErrorCode;
    }

    // Create toolbar that is attached to the bottom of the panel.
    this.toolbar = new Autodesk.Viewing.UI.Toolbar( this.container );

    this.initNavTools();
    this.initModelTools();

    this.initEscapeHandlers();
    this.initHomeButton();

    var self = this;
    this.addEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, function (e) {
        self.updateScreenModeButton(e.mode);
    });
    this.updateScreenModeButton(Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal);

    // Now that all the ui is created, localize it.
    this.localize();
    
    // dispatch a toolbar created event
    this.fireEvent({type:Autodesk.Viewing.TOOLBAR_CREATED_EVENT});

    return 0;
};

Autodesk.Viewing.Private.GuiViewer2D.prototype.initNavTools = function () {
    var viewer = this;

    var navToolsId = "navTools";
    this.navTools = this.toolbar.addSubToolbar( navToolsId, true );

    this.navTools.panbutton = this.addMenuButton( navToolsId, "toolbar-panTool", "Pan", function(e) {
        viewer.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN);
    });

    this.navTools.dollybutton = this.addMenuButton( navToolsId, "toolbar-zoomTool", "Zoom", function(e) {
        viewer.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.ZOOM);
    });

    this.navTools.select( this.navTools.panbutton.id );  // make pan a default one.

    this.addEventListener(Autodesk.Viewing.NAVIGATION_MODE_CHANGED_EVENT, function (event) {
        viewer.navTools.deselectAll();

        switch (event.value) {
            case VIEWER2D_NAVIGATION_MODE.PAN:
                viewer.navTools.select( viewer.navTools.panbutton.id );
                viewer.impl.container.style.cursor = "url(data:image/x-icon;base64,AAACAAEAGBgAAAAAAACICQAAFgAAACgAAAAYAAAAMAAAAAEAIAAAAAAAYAkAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0NDUsNDA2zMjEy31lZWfNQUFDrKysrwwkJCZAMDAxgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPDw8ZDQ0NoVxcXfbLy8v/4ODh//b29//y8fL/3Nzc/8nJyf98e3z/FRUWuQ0NDSYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCT0mJSbSlpaW//7+/v//////////////////////////////////////uLe4/zc2N+MNDQ00AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUFBQFCgoJcD4+P/HMzM3//////////////////////////////////////////////////////8/Pz/8kJCTCEREREwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8PD0oTExOPcXFy//Ly8v//////8/Pz//v7+/////////////////////////////////////////////////+AgID/BAQEQQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwcHLpNTU36+vr6/+fn5/99e33/Ly8v83d3eP3///////////////////////////////////////////////+bm5v/CQkJXQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABISElIbGxuaZGRk/zIyMusODg6GCQkJXVFRUvj8/Pz///////////////////////////////////////////+dnZ3/DAwMaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUFBQKBwcHPA8PDykAAAAADg4OUnBvcP7///////////////////////////////////////////////+BgYH/BAQEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhYWqcPDw////////////////////////////////////////////+Xl5f8tLS2+Dw8PDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBA4Pz8/6/////+7u7z/1dXW///////4+Pj//////////////////////6Ojo/8HBwdwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABUVFQELCwuTsLCw//39/v+Dg4T/19fX/+Li4v+ZmJr//////9vb2/+6urv//////zMzM94SEhIUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDCc7Ozzx8fDx/8zMzf+SkZP//////5qam/+np6f//////5mYm//Hx8j/ubm5/xEREZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkJCWqSkpL//////5iXmf/P0ND/8/Pz/3h3ef/o6Oj/7e3u/3Fxc///////Tk5O+woKChwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADg4OBy0tLeri4eL/9/f3/29tcP//////qqqr/5qZmv//////mZma/8zMzf/Kysr/HR0engAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQByMjI8+mpqb/mZiZ/8LCw//6+vr/fn6A/9LS0v/8/P3/a2pu//////92dnb4BAQEOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQUFBwHBweAGhoa5f/////Kysr/i4qM//////+vr7D/MC8x/3x8fP8mJiawERERCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhYWok5OTvY0NDT1Pj4++aGhof86OjvNCQkJTAgICGATExMnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNAAAA9gAAAI0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFRUVCAoKCg8NDQ0KEBEQKxQUFH4SEhIpAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD29vb2/0hISP8AAACQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///////n5+f9OTk7/AAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////5+fn/Tk5O/wAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////+fn5/wAAAPkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACWAAAA/wAAAP8AAAD/AAAA+QAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8x/+AfO/+AB1D/AANy/AABRvgAAXP4AAFk+AABXPxAAVz/wAFn/4ADIP8AA2X/AAd4/wAHXP4AD2P+AA9t/wAPVP/AH3QfwP87D///cAf//28D//9cA///XAP//2c=), wait";
                break;

            case VIEWER2D_NAVIGATION_MODE.ZOOM:
                viewer.navTools.select( viewer.navTools.dollybutton.id );
                viewer.impl.container.style.cursor = "url(data:image/x-icon;base64,AAACAAEAGBgAAAAAAACICQAAFgAAACgAAAAYAAAAMAAAAAEAIAAAAAAAYAkAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANQAAAJ4AAACeAAAANQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5CQkJ/56env+enp7/CQkJ/wAAADkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8JCQn/oqKi////////////oqKi/wkJCf8AAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATQsLC/+oqKj//////////////////////6ioqP8LCwv/AAAATQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABYDg4O/7a2tv////////////////////////////////+2trb/Dg4O/wAAAFgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQMDAz/wcHB////////////////////////////////////////////wcHB/wwMDP8AAABkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYxoaGv/Nzc3//////////////////////////////////////////////////////83Nzf8aGhr/AAAAYwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoKCgo/8zMzP/////////////////////////////////////////////////////////////////MzMz/KCgo/wAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA7Ozs7/2lpaf9qamr/gICA/76+vv////////////////////////////////++vr7/gICA/2pqav9paWn/Ozs7/wAAADsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOwAAAGkAAABqAAAAgE5OTv////////////////////////////////9OTk7/AAAAgAAAAGoAAABpAAAAOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCQkJP////////////////////////////////8kJCT/AAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgICAv/29vb///////////////////////b29v8CAgL/AAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMzMzMz//////////////////////8zMzP8AAADMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ2dnZ3//////////////////////52dnf8AAACdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGhoaGj//////////////////////2hoaP8AAABoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgAAADs7Ozv//////////////////////zs7O/8AAAA7AAAABgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGBgYG/wAAAGQAAAD7+/v7////////////+/v7/wAAAPsAAABkBgYG/wAAAAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBA/2RkZP9RUVH/8vLy////////////8vLy/1FRUf9kZGT/QEBA/wAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACNAAAA9gAAAI0AAAAAAAAAEQAAAAAAAAAmJiYm/6mpqf////////////////////////////////+pqan/JiYm/wAAACYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD29vb2/0hISP8AAACQAAAAAAAAABEAAAAAAAAAQAAAAKlZWVn/6enp////////////6enp/1lZWf8AAACpAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///////n5+f9OTk7/AAAAkAAAAAAAAAADAAAAAAAAAAAAAACAJycn/729vf+9vb3/Jycn/wAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD////////////5+fn/Tk5O/wAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAVAAAAL0AAAC9AAAAVAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////+fn5/wAAAPkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACWAAAA/wAAAP8AAAD/AAAA+QAAAJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8x////O8A8A1CAGAFyAAAARgAAAHMPAPBkDwDwXA8A8FwPAPBnAAAAIAAAAGWAAAF4gAABXMAAA2PAAANt4AAHVOAAB3QQAA87CBgPcAQ8H28D//9cA///XAP//2c=), wait";
                break;

            default:
                viewer.impl.container.style.cursor = "auto";
                break;
        }
    });

    this.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN);
};

Autodesk.Viewing.Private.GuiViewer2D.prototype.uninitialize = function () {
    this.modelTools = null;
    this.navTools = null;
    this.toolbar = null;
    
    Autodesk.Viewing.Viewer2D.prototype.uninitialize.call(this);
};

Autodesk.Viewing.Private.GuiViewer2D.prototype.initModelTools = function () {
    if (this.canChangeScreenMode()) {
        var modelToolsId = "modelTools";
        this.modelTools = this.toolbar.addSubToolbar( modelToolsId, false );

        var viewer = this;
        this.modelTools.fullscreenbutton = this.addMenuButton( modelToolsId, "toolbar-fullscreenTool", "viewer-toolbar:Full screen", function(e) {
            viewer.nextScreenMode();
        });
    }
};

Autodesk.Viewing.Private.GuiViewer2D.prototype.initEscapeHandlers = function () {
    var viewer = this;

    this.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, function (event) {

        // Reset default navigation mode.
        //
        if (viewer.impl.setNavigationMode(VIEWER2D_NAVIGATION_MODE.PAN)) {
            return;
        }

        // Exit full screen.
        //
        if (viewer.escapeScreenMode()) {
            return;
        }

    }, false);
};

Autodesk.Viewing.Private.GuiViewer2D.prototype.initHomeButton = function () {
    var viewer = this;

    this.homeViewContainer = document.createElement('div');
    var homeViewContainer = this.homeViewContainer;
    homeViewContainer.className = 'homeViewWrapper';
    var homeView = document.createElement('img');
    homeView.className = 'homeView';
    homeView.src = RESOURCE_ROOT + 'icons/resetview_icon.png';
    homeView.style.cursor = 'pointer';
    homeViewContainer.appendChild(homeView);
    homeViewContainer.style.width = 'auto';
    this.container.appendChild(homeViewContainer);

    homeView.addEventListener('click', function () {
        viewer.impl.goHome();
    });
};

Autodesk.Viewing.Private.GuiViewer2D.prototype.addMenuButton = function(subToolbarId, id, tooltip, onclick) {
    var button = Autodesk.Viewing.UI.Toolbar.createMenuButton( id, tooltip, onclick );
    this.toolbar.addToSubToolbar( subToolbarId, button );
    return button;
};

Autodesk.Viewing.Private.GuiViewer2D.prototype.updateScreenModeButton = function (mode) {
    this.container.classList.remove('screenMode-kFullBrowser');
    this.container.classList.remove('screenMode-kFullScreen');

    var cls;
    switch (mode) {
        case Autodesk.Viewing.Viewer.prototype.ScreenMode.kNormal:
            if (!this.isScreenModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser)) {
                cls = 'screenMode-kFullBrowser';
            }
            break;
        case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullBrowser:
            if (this.isScreenModeSupported(Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen)) {
                cls = 'screenMode-kFullBrowser';
            } else {
                cls = 'screenMode-kFullScreen';
            }
            break;
        case Autodesk.Viewing.Viewer.prototype.ScreenMode.kFullScreen:
            cls = 'screenMode-kFullScreen';
            break;
    }

    if (cls) {
        this.container.classList.add(cls);
    }
};
;/** @license Copyright (c) 2014 Autodesk Inc. */
/** Version : @buildnum@ */

AutodeskNamespace('Autodesk.Viewing.Extensions');

Autodesk.Viewing.Extensions.ViewerModelStructurePanel = function(viewer, title, options)
{
    this.viewer = viewer;

    Autodesk.Viewing.UI.ModelStructurePanel.call(this, viewer.container, viewer.container.id + 'ViewerModelStructurePanel', title, options);

    this.clickConfig = (options && options.docStructureConfig) ? options.docStructureConfig : null;

    this.isMac = (navigator.userAgent.search("Mac OS") !== -1);
    this.visibleNodes = [];
    this.hiddenNodes = [];
};

Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype = Object.create(Autodesk.Viewing.UI.ModelStructurePanel.prototype);
Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.constructor = Autodesk.Viewing.Extensions.ViewerModelStructurePanel;

Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.initialize = function()
{
    Autodesk.Viewing.UI.ModelStructurePanel.prototype.initialize.call(this);

    var that = this;

    that.addEventListener(that.viewer, Autodesk.Viewing.SELECTION_CHANGED_EVENT, function(event) {
        that.setSelection(event.nodeArray.slice());
    });
    that.addEventListener(that.viewer, Autodesk.Viewing.ISOLATE_EVENT, function(event) {
        that.setIsolation(event.nodeIdArray.slice());
    });
    that.addEventListener(that.viewer, Autodesk.Viewing.HIDE_EVENT, function(event) {
        that.setHidden(event.nodeIdArray.slice(), true);
    });
    that.addEventListener(that.viewer, Autodesk.Viewing.SHOW_EVENT, function(event) {
        that.setHidden(event.nodeIdArray.slice(), false);
    });
};

Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.uninitialize = function() {
    this.viewer = null;
    Autodesk.Viewing.UI.ModelStructurePanel.prototype.uninitialize.call(this);
}

Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.setModel = function(modelRoot, modelTitle)
{
    this.visibleNodes = [];
    this.hiddenNodes = [];

    Autodesk.Viewing.UI.ModelStructurePanel.prototype.setModel.call(this, modelRoot, modelTitle);
};

Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.handleAction = function(actionArray, node) {
    for (var action in actionArray) {
        switch(actionArray[action]) {
            case "selectOnly":
                this.viewer.select([node.dbId]);
                break;
            case "deselectAll":
                this.viewer.select([]);
                break;
            case "selectToggle":
                this.viewer.toggleSelect(node.dbId);
                break;
            case "isolate":
                this.viewer.isolate(node);
                break;
            case "showAll":
                this.viewer.isolate(null);
                break;
            case "focus":
                this.viewer.fitToView();
                break;
            case "hide":
                this.viewer.hide(node);
                break;
            case "show":
                this.viewer.show(node);
                break;
            case "toggleVisibility":
                this.viewer.toggleVisibility(node);
                break;
        }
    }
};

Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.ctrlDown = function(event) {
    return (this.isMac && event.metaKey) || (!this.isMac && event.ctrlKey);
};

Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.onClick = function(node, event)
{
    if (this.isMac && event.ctrlKey) {
        return;
    }
    
    var that = this;

    var key = "click";
    if (that.ctrlDown(event)) {
        key += "Ctrl";
    }
    if (event.shiftKey) {
        key += "Shift";
    }
    if (event.altKey) {
        key += "Alt";
    }

    if (this.clickConfig && this.clickConfig[key]) {
        that.handleAction(this.clickConfig[key]["onObject"], node);
    }
    else {
        this.viewer.select([node.dbId]);
    }
};

Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.onDoubleClick = function(node, event)
{
    this.handleAction(["focus"], node);
};

Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.onRightClick = function(node, event)
{
    // Sometimes CTRL + LMB maps to a right click on a mac. Redirect it.
    if (this.isMac && event.ctrlKey && event.button === 0) {
        if (this.clickConfig && this.clickConfig["clickCtrl"]) {
            this.handleAction(this.clickConfig["clickCtrl"]["onObject"], node);
        }
        else {
            this.viewer.select([node.dbId]);
        }

        return null;
    }

    var dbIds = [];

    // If the shift/control/command key is held down when right-clicking, then add this node
    // to the selection, instead of selecting only this node. This control/command key logic is
    // like the ViewController, which is slightly different than ctrlDown() here.
    // TODO: is this difference intentional?

    // Also: on the Mac, a control + left mouse button click is treated like a right mouse
    // button click, so ignore the control key in that case.
    //
    var shouldSelectNode = true;
    if (event.shiftKey || ((this.isMac && event.metaKey) || (event.ctrlKey && (this.isMac || event.button === 2)))) {
        var selectedNodes = this.viewer.impl.selector.getSelection();
        for (var i = 0; i < selectedNodes.length; ++i) {
            if (selectedNodes[i].dbId !== node.dbId) {
                dbIds.push(selectedNodes[i].dbId);
            } else {
                shouldSelectNode = false;
            }
        }
    }

    if (shouldSelectNode) {
        dbIds.push(node.dbId);
    }

    this.viewer.isolateById(dbIds);
    this.viewer.select(dbIds);

    return this.viewer.contextMenu.show(event);
};

Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.setHidden = function(nodes, hidden)
{
    if(nodes.length > 0) {
        for(var i=0; i<nodes.length; ++i) {
            var node = nodes[i];
            if(hidden) {
                if(this.hiddenNodes.indexOf(node) === -1){
                    if (this.addClass(nodes[i].dbId, 'dim')) {
                        this.hiddenNodes.push(nodes[i]);

                        var index = this.visibleNodes.indexOf(node);
                        if (index > -1) {
                            this.removeClass(nodes[i].dbId, 'visible');
                            this.visibleNodes.splice(index);
                        }
                    }
                }
            } else {
                if(this.visibleNodes.indexOf(node) === -1){
                    if (this.addClass(nodes[i].dbId, 'visible')) {
                        this.visibleNodes.push(nodes[i]);

                        var index = this.hiddenNodes.indexOf(node);
                        if (index > -1) {
                            this.removeClass(nodes[i].dbId, 'dim');
                            this.hiddenNodes.splice(index);
                        }
                    }
                }
            }
        }
    }
};

Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.setIsolation = function(nodes)
{
    for(var i=0; i<this.hiddenNodes.length; ++i) {
        this.removeClass(this.hiddenNodes[i].dbId, 'dim');
    }

    for(var i=0; i<this.visibleNodes.length; ++i) {
        this.removeClass(this.visibleNodes[i].dbId, 'visible');
    }
    this.hiddenNodes = [];
    this.visibleNodes = [];

    if(nodes.length > 0) {
        // If the root is isolated, we don't want to dim anything.
        //
        if(nodes.length === 1 && nodes[0] === this.modelRoot) {
            return;
        }
        this.setHidden([this.modelRoot], true);

        for(var i=0; i<nodes.length; ++i) {
            this.setHidden([nodes[i]], false);
        }
    }
};
;AutodeskNamespace('Autodesk.Viewing.Extensions');

/** @constructor */
Autodesk.Viewing.Extensions.ViewerPropertyPanel = function (viewer) {
    this.viewer = viewer;
    this.currentNodeIds = [];
    this.isDirty = true;
    this.propertyNodeId = null;
    Autodesk.Viewing.UI.PropertyPanel.call(this, viewer.container, 'ViewerPropertyPanel', 'Object Properties Loading...');
};

Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype = Object.create(Autodesk.Viewing.UI.PropertyPanel.prototype);
Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype.constructor = Autodesk.Viewing.Extensions.ViewerPropertyPanel;

Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype.initialize = function () {
    Autodesk.Viewing.UI.PropertyPanel.prototype.initialize.call(this);

    var that = this;

    that.addEventListener(that.viewer, Autodesk.Viewing.SELECTION_CHANGED_EVENT, function (event) {
        that.currentNodeIds = event.dbIdArray;
        that.isDirty = true;
        that.requestProperties();
    });

    function getIds(nodes) {
        var ids = [];
        for (var i = 0; i < nodes.length; i++) {
            var dbId = nodes[i].dbId;
            if (dbId) {
                ids.push(dbId);
            }
        }
        return ids;
    }

    that.addEventListener(that.viewer, Autodesk.Viewing.ISOLATE_EVENT, function (e) {
        that.currentNodeIds = getIds(e.nodeIdArray);
        that.isDirty = true;
        that.requestProperties();
    });

    that.addEventListener(that.viewer, Autodesk.Viewing.HIDE_EVENT, function (e) {
        that.isDirty = true;
        that.requestProperties();
    });

    that.addEventListener(that.viewer, Autodesk.Viewing.SHOW_EVENT, function (e) {
        that.isDirty = true;
        that.requestProperties();
    });

    // Populate the ids with the current selection or isolation.
    //
    this.currentNodeIds = getIds(that.viewer.getSelection());
    if (this.currentNodeIds.length === 0) {
        this.currentNodeIds = getIds(that.viewer.getIsolatedNodes());
    }
};

Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype.setTitle = function (title, options) {
    if (!title) {
        title = 'Object Properties';
        options = options || {};
        options.localizeTitle = true;
    }
    Autodesk.Viewing.UI.PropertyPanel.prototype.setTitle.call(this, title, options);
};

Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype.setVisible = function (show) {
    Autodesk.Viewing.UI.DockingPanel.prototype.setVisible.call(this, show);
    this.requestProperties();
};

Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype.requestProperties = function () {
    if (this.isVisible() && this.isDirty) {
        if (this.currentNodeIds.length > 0) {
            this.setNodeProperties(this.currentNodeIds[this.currentNodeIds.length - 1]);
        } else {
            this.showDefaultProperties();
        }
        this.isDirty = false;
    }
};

Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype.setNodeProperties = function (nodeId) {
    var that = this;
    this.propertyNodeId = nodeId;
    that.viewer.getProperties(nodeId, function (result) {
        that.setTitle(result.name);
        that.setProperties(result.properties);
        that.highlight(that.viewer.searchText);

        var dimensions = that.viewer.getDimensions();
        that.resizeToContent({maxHeight: dimensions.height});

        if (that.isVisible()) {

            // Does the property panel overlap the mouse position? If so, then reposition
            // the property panel. Prefer a horizontal vs. vertical reposition.
            //
            var toolController = that.viewer.toolController,
                mx = toolController.lastClickX,
                my = toolController.lastClickY,
                panelRect = that.container.getBoundingClientRect(),
                px = panelRect.left,
                py = panelRect.top,
                pw = panelRect.width,
                ph = panelRect.height,
                canvasRect = that.viewer.canvas.getBoundingClientRect(),
                cx = canvasRect.left,
                cy = canvasRect.top,
                cw = canvasRect.width,
                ch = canvasRect.height;

            if ((px <= mx && mx < px + pw) && (py <= my && my < py + ph)) {
                if ((mx < px + (pw / 2)) && (mx + pw) < (cx + cw)) {
                    that.container.style.left = Math.round(mx - cx) + 'px';
                    that.container.dockRight = false;
                } else if (cx <= (mx - pw)) {
                    that.container.style.left = Math.round(mx - cx - pw) + 'px';
                    that.container.dockRight = false;
                } else if ((mx + pw) < (cx + cw)) {
                    that.container.style.left = Math.round(mx - cx) + 'px';
                    that.container.dockRight = false;
                } else if ((my + ph) < (cy + ch)) {
                    that.container.style.top = Math.round(my - cy) + 'px';
                    that.container.dockBottom = false;
                } else if (cy <= (my - ph)) {
                    that.container.style.top = Math.round(my - cy - ph) + 'px';
                    that.container.dockBottom = false;
                }
            }
        }
    });
};

Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype.showDefaultProperties = function () {
    var rootId = this.viewer.model.getRoot() ? this.viewer.model.getRootId() : null;
    if (rootId !== null) {
        this.setNodeProperties(rootId);
    } else {
        this.propertyNodeId = null;
        this.setTitle('Model Properties', {localizeTitle: true});
        Autodesk.Viewing.UI.PropertyPanel.prototype.showDefaultProperties.call(this);
    }
};

Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype.areDefaultPropertiesShown = function () {
    var rootId = this.viewer.model.getRootId();
    return this.propertyNodeId === rootId;
};

Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype.uninitialize = function () {
    Autodesk.Viewing.UI.PropertyPanel.prototype.uninitialize.call(this);
    this.viewer = null;
};

Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype.onCategoryClick = function (category, event) {
    Autodesk.Viewing.UI.PropertyPanel.prototype.onCategoryClick.call(this, category, event);
    var dimensions = this.viewer.getDimensions();
    this.resizeToContent({maxHeight: dimensions.height});
};

Autodesk.Viewing.Extensions.ViewerPropertyPanel.prototype.onCategoryIconClick = function (category, event) {
    Autodesk.Viewing.UI.PropertyPanel.prototype.onCategoryIconClick.call(this, category, event);
    var dimensions = this.viewer.getDimensions();
    this.resizeToContent({maxHeight: dimensions.height});
};
;AutodeskNamespace('Autodesk.Viewing.Extensions');

/**
 * ViewerLayersPanel
 * This is a panel for displaying the layers in a file.
 * @class
 *
 * @param {Viewer} viewer - The parent viewer.
 * @constructor
 */
Autodesk.Viewing.Extensions.ViewerLayersPanel = function (viewer) {
    var parentContainer = viewer.container;
    Autodesk.Viewing.UI.LayersPanel.call(this, viewer, parentContainer, parentContainer.id + "ViewerLayersPanel");
};

Autodesk.Viewing.Extensions.ViewerLayersPanel.prototype = Object.create(Autodesk.Viewing.UI.LayersPanel.prototype);
Autodesk.Viewing.Extensions.ViewerLayersPanel.prototype.constructor = Autodesk.Viewing.Extensions.ViewerLayersPanel;

/**
 * Override this method to do something when the user clicks on a tree node
 * @override
 * @param {Object} node
 * @param {Event} event
 */
Autodesk.Viewing.Extensions.ViewerLayersPanel.prototype.onClick = function (node, event) {
    this.isolateLayerVisible(node, event);
};

/**
 * Override this to do something when the user clicks on an image
 * @override
 * @param {Object} node
 * @param {Event} event
 */
Autodesk.Viewing.Extensions.ViewerLayersPanel.prototype.onImageClick = function (node, event) {
    this.toggleLayerVisible(node);
};

/**
 * Override this method to be notified when the user clicks on the title.
 * @override
 * @param {Event} event
 */
Autodesk.Viewing.Extensions.ViewerLayersPanel.prototype.onTitleClick = function (event) {
    this.viewer.setLayerVisible(null, true);
};

/**
 * Override this method to be notified when the user double-clicks on the title.
 * @override
 * @param {Event} event
 */
Autodesk.Viewing.Extensions.ViewerLayersPanel.prototype.onTitleDoubleClick = function (event) {
    this.viewer.fitToView();
};
;AutodeskNamespace('Autodesk.Viewing.Extensions.RaaS');

/** @constructor */
Autodesk.Viewing.Extensions.RaaS.RaaSPanel = function (viewer) {

    var self = this;
    this.viewer = viewer;
    Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, 'RaaSPanel', 'Gallery');

    this.thumbnailPanel = document.createElement("div");
    this.thumbnailPanel.id = "thumbnailPanel";

    this.imageNum = 0;
    this.thumbList = [];
    this.imageList = [];
    this.imageIndex = 0;

    //TODO: make panel resizable
    this.container.style.width = 120 + 20 + "px";
    this.container.style.top = "200px";
    this.container.style.left = "150px"; // just needs an initial value dock overrides value
    this.container.style.height = 500 + 60 + "px";

    this.container.dockRight = true;
    this.container.style.display = "none";

    this.addEventListener(this.viewer, Autodesk.Viewing.GEOMETRY_LOADED_EVENT, function() { self.syncUI(); });

};

Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype.constructor = Autodesk.Viewing.Extensions.RaaSPanel;

Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype.syncUI = function() {

};

Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype.screenCapture = function(viewer) {
    return viewer.impl.renderer().screenCapture();
};

Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype.addImage = function() {
    var self = this;

    // Add thumbnail
    var thm = new Image();
    thm.src = this.screenCapture(this.viewer);
    thm.className = "thumbnail";
    thm.style.top = 130 * this.imageNum + "px";
    thm.index = this.imageNum;

    // Store camera data
    var camera = this.viewer.getCamera();
    thm.cameraPosition = camera.position.clone();
    thm.cameraTarget = camera.target.clone();
    thm.cameraUp = camera.up.clone();

    this.thumbList.push(thm);
    this.thumbnailPanel.appendChild(this.thumbList[this.imageNum]);

    // Add image
    var img = new Image();
    img.src = "";
    img.status = "progress";
    this.imageList.push(img);

    this.imageNum++;

    this.container.appendChild(this.thumbnailPanel);
    this.imageIndex = this.imageNum - 1;

    this.addEventListener(this.thumbList[this.imageIndex], "click", function () {
        if (self.imageList[this.index].status == "progress") {
            self.imageIndex = this.index;
        }
        else if (self.imageList[this.index].status == "complete") {
            self.imageIndex = this.index;
            self.displayImage(self.imageList[self.imageIndex], self.imageIndex);
        }
        else if (self.imageList[this.index].status == "error") {
            self.imageIndex = this.index;
        }
    });

    this.zoomin();

};

Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype.loadThumbnail = function(url, imageNo) {
    this.thumbList[imageNo - 1].src = url;
};

Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype.loadImage = function(url, imageNo) {
    this.imageList[imageNo - 1].src = url;
    this.imageList[imageNo - 1].status = "complete";
};

Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype.imageError = function(imageNo) {
    this.imageList[imageNo - 1].status = "error";
};

Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype.displayImage = function(img, imageIndex) {
    if (document.getElementsByClassName("imageContainer").length != 0) {
        var imgContainer = document.getElementsByClassName("imageContainer")[0];
        imgContainer.parentNode.removeChild(imgContainer);
    }
    var modelContainer = this.viewer.container;
    var imageContainer = document.createElement("div");
    imageContainer.className = "imageContainer";
    imageContainer.style.width = modelContainer.style.width;
    imageContainer.style.height = modelContainer.style.height;
    modelContainer.parentNode.appendChild(imageContainer);

    var canvas = document.createElement("canvas");
    imageContainer.appendChild(canvas);

    canvas.style.width = modelContainer.style.width;
    canvas.style.height = modelContainer.style.height;
    canvas.width = this.viewer.canvas.width;
    canvas.height = this.viewer.canvas.height;
    this.addEventListener(canvas, "click", function () {
        modelContainer.style.zIndex = "";
        if (imageContainer.parentNode != null) {
            imageContainer.parentNode.removeChild(imageContainer);
        }
    });

    modelContainer.style.zIndex = -1;
    imageContainer.style.zIndex = 1;

    if (img.complete) {
        toggleAnim(canvas, img);
    } else {
        img.onload = function () {
            toggleAnim(canvas, img);
        };
    }

    var camera = this.viewer.getCamera();
    camera.position = this.thumbList[imageIndex].cameraPosition.clone();
    camera.target = this.thumbList[imageIndex].cameraTarget.clone();
    camera.up = this.thumbList[imageIndex].cameraUp.clone();
    camera.updateProjectionMatrix();
};

Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype.uninitialize = function () {
    this.viewer = null;
    this.thumbnailPanel = null;
    this.imageNum = null;
    this.thumbList = null;
    this.imageList = null;
    this.imageIndex = null;
    Autodesk.Viewing.UI.DockingPanel.prototype.uninitialize.call(this);
};

Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype.getContentSize = function () {
    return {height: 130 * this.thumbList.length + 45, width: 130};
};

// Animation for the canvas zoom into the thumbnail
Autodesk.Viewing.Extensions.RaaS.RaaSPanel.prototype.zoomin = function() {
    var self = this;
    var imgTemp = new Image();
    imgTemp.src = this.screenCapture(this.viewer);
    var modelContainer = this.viewer.container;
    var imageContainer = document.createElement("div");
    imageContainer.id = "imageTemp";
    imageContainer.style.width = modelContainer.style.width;
    imageContainer.style.height = modelContainer.style.height;
    modelContainer.parentNode.appendChild(imageContainer);

    imgTemp.style.width = modelContainer.style.width;
    imgTemp.style.height = modelContainer.style.height;

    imageContainer.appendChild(imgTemp);
    modelContainer.style.zIndex = -1;
    imageContainer.style.zIndex = 1;

    // Calculate the position for translate
    // Do the translate and scale
    setTimeout(function(){
        var x = (self.thumbList[self.imageIndex].getBoundingClientRect().left +
            self.thumbList[self.imageIndex].getBoundingClientRect().right) / 2.0 - (imageContainer.getBoundingClientRect().left +
            imageContainer.getBoundingClientRect().right) / 2.0;
        if (self.thumbList[self.imageIndex].getBoundingClientRect().bottom <= self.thumbnailPanel.getBoundingClientRect().bottom) {
            var y = (self.thumbList[self.imageIndex].getBoundingClientRect().top +
                self.thumbList[self.imageIndex].getBoundingClientRect().bottom) / 2.0 - (imageContainer.getBoundingClientRect().top +
                imageContainer.getBoundingClientRect().bottom) / 2.0;
        } else {
            var y = self.thumbnailPanel.getBoundingClientRect().bottom - self.thumbList[self.imageIndex].offsetHeight / 2.0 - (imageContainer.getBoundingClientRect().top +
                imageContainer.getBoundingClientRect().bottom) / 2.0;
        }
        var scaleX = self.thumbList[self.imageIndex].clientWidth / modelContainer.clientWidth;
        var scaleY = self.thumbList[self.imageIndex].clientHeight / modelContainer.clientHeight;
        imageContainer.style.webkitTransform = "translate(" + x + "px," + y + "px) scale(" + scaleX + "," + scaleY + ")";
        imageContainer.style.transform = "translate(" + x + "px," + y + "px) scale(" + scaleX + "," + scaleY + ")";
    }, 10);

    // End the zoomin animation
    setTimeout(function(){
        imageContainer.parentNode.removeChild(imageContainer);
        modelContainer.style.zIndex = "";
    }, 500);
};

// animation for image display
function toggleAnim(canvas, img) {
    var v = 0;
    var dx = 0.5; // "speed"
    // start loop
    anim();

    // animation loop
    function anim() {
        v += dx;
        pixelate(v, canvas, img);
        // loop
        if (v <= 100) requestAnimationFrame(anim);
    }

    // pixelate image with current value
    function pixelate(v, canvas, img) {
        var ctx = canvas.getContext('2d');
        // turn off image smoothing - this will give the pixelated effect
        ctx.mozImageSmoothingEnabled = false;
        ctx.webkitImageSmoothingEnabled = false;
        ctx.imageSmoothingEnabled = false;

        var size = v * 0.01;
        // cache scaled width and height
        var w = canvas.width * size;
        var h = canvas.height * size;

        ctx.drawImage(img, 0, 0, w, h);
        ctx.drawImage(canvas, 0, 0, w, h, 0, 0, canvas.width, canvas.height);
    }

    // poly-fill for requestAnmationFrame with fallback for older browsers which do not support rAF.
    window.requestAnimationFrame = (function () {
        return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (callback) {
            window.setTimeout(callback, 1000 / 60);
        };
    })();
}
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.RaaS');

Autodesk.Viewing.Extensions.RaaS.RaaSExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

Autodesk.Viewing.Extensions.RaaS.RaaSExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.RaaS.RaaSExtension.prototype.constructor = Autodesk.Viewing.Extensions.RaaS.RaaSExtension;

Autodesk.Viewing.Extensions.RaaS.RaaSExtension.prototype.load = function() {
    // Setup UI
    var self = this;
    var viewer = this.viewer;

    var toolbar = viewer.getToolbar(true);
    this.raaSTools = toolbar.addSubToolbar("raaSTools", false);

    var gallery = this.raaSPanel = new Autodesk.Viewing.Extensions.RaaS.RaaSPanel(viewer);
    viewer.addPanel(this.raaSPanel);

    function onSuccess(renderings) {
        gallery.loadThumbnail(renderings.thumbnail, renderings.imageNo);
        gallery.loadImage(renderings.image, renderings.imageNo);

        var raaSImage = new Image();
        raaSImage.src = renderings.image;
        gallery.displayImage(raaSImage, renderings.imageNo - 1);
    }

    function onError(error) {
        if (error.imageNo) {
            gallery.imageError(error.imageNo);
        }
    }

    this.raaSTools.renderButton = viewer.addMenuButton(this.raaSTools.id, "toolbar-raaSTool", "RaaS", function(e) {
        self.showRaaSPanel(true);
        self.raaSPanel.addImage();
        viewer.impl.svfloader.svfToSpdTranslator(viewer, self.raaSPanel.imageNum, onSuccess, onError);
    });

    this.raaSTools.galleryButton = viewer.addMenuButton(this.raaSTools.id, "toolbar-raaSThumbnailTool", "Gallery", function(e) {
        self.showRaaSPanel(!gallery.isVisible());
    });

    return true;
};

Autodesk.Viewing.Extensions.RaaS.RaaSExtension.prototype.showRaaSPanel = function(show) {
    if (this.raaSPanel) {
        this.raaSPanel.setVisible(show);
    }
};

Autodesk.Viewing.Extensions.RaaS.RaaSExtension.prototype.unload = function () {
    // Remove the UI
    var viewer = this.viewer;

    viewer.removePanel(this.raaSPanel);
   
    var toolbar = viewer.getToolbar(false);
    if (toolbar) {
        toolbar.removeFromSubToolbar( this.raaSTools.id, this.raaSTools.renderButton );
        toolbar.removeFromSubToolbar( this.raaSTools.id, this.raaSTools.galleryButton );
        toolbar.removeSubToolbar(this.raaSTools);
    }

    this.raaSPanel.uninitialize();

    this.raaSPanel = null;
    this.raaSTools = null;
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.RaaS', Autodesk.Viewing.Extensions.RaaS.RaaSExtension);;AutodeskNamespace('Autodesk.Viewing.Extensions');

/**
 * Constructs a ViewerObjectContextMenu object.
 * @param {Viewer} viewer
 * @constructor
 */
Autodesk.Viewing.Extensions.ViewerObjectContextMenu = function (viewer) {
    Autodesk.Viewing.UI.ObjectContextMenu.call(this, viewer);
};

Autodesk.Viewing.Extensions.ViewerObjectContextMenu.prototype = Object.create(Autodesk.Viewing.UI.ObjectContextMenu.prototype);
Autodesk.Viewing.Extensions.ViewerObjectContextMenu.prototype.constructor = Autodesk.Viewing.Extensions.ViewerObjectContextMenu;

/**
 * Builds the context menu to be displayed.
 * @override
 * @param {Event} event - Browser event that requested the context menu
 * @param {Object} status - Information about nodes: numSelected, hasSelected, hasVisible, hasHidden.
 * @returns {?Array} An array of menu items.
 */
Autodesk.Viewing.Extensions.ViewerObjectContextMenu.prototype.buildMenu = function (event, status) {
    var that = this,
        menu = [],
        is2d = this.viewer.model.is2d();

    if (!is2d && status.hasSelected) {
        menu.push({
            title: "Isolate",
            target: function () {
                var selected = that.viewer.getSelection();
                that.viewer.clearSelection();
                that.viewer.isolate(selected);
            }
        });
        if (status.hasVisible) {
            menu.push({
                title: "Hide Selected",
                target: function () {
                    var selected = that.viewer.getSelection();
                    that.viewer.clearSelection();
                    that.viewer.hide(selected);
                }
            });
        }
        if (status.hasHidden) {
            menu.push({
                title: "Show Selected",
                target: function () {
                    var selected = that.viewer.getSelection();
                    that.viewer.clearSelection();
                    that.viewer.show(selected);
                }
            });
        }
    }

    if (is2d) {
        menu.push({
            title: "Show All Layers",
            target: function () {
                that.viewer.setLayerVisible(null, true);
            }
        });
    } else {
        menu.push({
            title: "Show All Objects",
            target: function () {
                that.viewer.showAll();
            }
        });
    }

    if (!is2d && status.hasSelected) {
        menu.push({
            title: "Focus",
            target: function () {
                that.viewer.fitToView();
            }
        });
    }

    if (status.hasSelected) {
        menu.push({
            title: "Clear Selection",
            target: function () {
                that.viewer.clearSelection();
            }
        });
    }

    return menu;
};
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.CAM360');

Autodesk.Viewing.Extensions.CAM360.CAM360Extension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

Autodesk.Viewing.Extensions.CAM360.CAM360Extension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.CAM360.CAM360Extension.prototype.constructor = Autodesk.Viewing.Extensions.CAM360.CAM360Extension;

Autodesk.Viewing.Extensions.CAM360.CAM360Extension.prototype.load = function() {
    var modelStructurePanel = new Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel(this.viewer, 'CAM Model Structure Loading', this.options);
    this.viewer.setModelStructurePanel(modelStructurePanel);

    // Change these viewer settings for CAM files.
    //
    this.viewer.hideLines(false);
    this.viewer.setGhosting(false);
    this.viewer.setQualityLevel(false, true);

    this.viewer.impl.setLightPreset(0, true);

    return true;
};

Autodesk.Viewing.Extensions.CAM360.CAM360Extension.prototype.unload = function () {
    // Remove the panel from the viewer.
    //
    this.viewer.setModelStructurePanel(null);
}

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.CAM360', Autodesk.Viewing.Extensions.CAM360.CAM360Extension);;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.CAM360');

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel = function (viewer, title, options) {
    Autodesk.Viewing.Extensions.ViewerModelStructurePanel.call(this, viewer, title, options);
    this.viewer = viewer;
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype = Object.create(Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype);
Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.constructor = Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel;

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.sortCamNodes = function (modelRoot, onCamNodesSorted) {
    this.camNodes = [];
    this.camModelNodes = [];
    this.camSetupNodes = [];
    this.camStockNodes = [];
    this.camOperationNodes = [];
    this.camToolNodes = [];
    this.camFolderNodes = [];

    var that = this;

    // Find all of the nodes to process.
    //
    var nodesToProcess = [];
    function getAllNodes(root) {
        if(root.children) {
            for (var k = 0; k < root.children.length; k++) {
                var child = root.children[k];
                nodesToProcess.push(child);
                getAllNodes(child);
            }
        }
    }
    getAllNodes(modelRoot);

    function processNode(node, onNodeProcessed)
    {

        // Gets the p
        function getPropertyValue(properties, propertyName){
            for(var i = 0; i < properties.length; ++i) {
                var property = properties[i];
                if(property.displayName === propertyName) {
                    return property.displayValue;
                }
            }
            return null;
        }

        function onPropertiesRetrieved(result) {
            // Sort the nodes into the proper containers here.
            //
            var name = getPropertyValue(result.properties, '9429B915-D020-4CEB-971B-6ADD0A5D4BFA');

            if (name) {
                if(name == 'CAM_Setup') {
                    that.camSetupNodes.push(node);
                }
                else if(name == 'CAM_Operation') {
                    that.camOperationNodes.push(node);
                }
                else if (name === 'CAM_Tool') { // Check this.
                    that.camToolNodes.push(node);
                } else if (name === 'CAM_Stock') {  // Check this.
                    that.camStockNodes.push(node);
                } else if(name == 'CAM_Folder') {
                    that.camFolderNodes.push(node);
                }

                that.camNodes.push(node);

            } else {
                that.camModelNodes.push(node);
            }

            onNodeProcessed();
        }

        function onError(status, message, data) {
            onNodeProcessed();
        }

        that.viewer.getProperties(node.dbId, onPropertiesRetrieved, onError);

    }

    // Process the nodes one by one.
    //
    function processNext() {
        if(nodesToProcess.length > 0) {
            processNode(nodesToProcess.shift(), processNext);
        } else {
            // No more nodes to process - call the provided callback.
            //
            onCamNodesSorted();
        }
    }
    processNext();
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.setModel = function (modelRoot, modelTitle) {
    // Sort all of the cam nodes.  Once done, call setModel on the base class to build the UI, and
    // set the visibilities properly.
    //
    var that = this;
    that.sortCamNodes(modelRoot, function(){
        Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.setModel.call(that, modelRoot, modelTitle);
        that.SetCAMNodeVisible(false);
        that.setVisible(true);

		// expand the setup node
		that.ExpandSetupNodes();
    });
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.initialize = function() {
    Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.initialize.call(this);

    var that = this;

    function onGeometryLoaded(e) {
        that.SetCAMNodeVisible(false);
        that.removeEventListener(that.viewer, Autodesk.Viewing.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
    }

    if (!this.viewer.model || !this.viewer.model.isLoadDone()) {
        that.addEventListener(that.viewer, Autodesk.Viewing.GEOMETRY_LOADED_EVENT, onGeometryLoaded);
    }

    that.addEventListener(that.viewer, Autodesk.Viewing.SHOW_EVENT,
        function(e) {
            var nodes = e.nodeIdArray;
            if(nodes) {
                for (var k = 0; k < nodes.length; k++)
                    that.setCamNodeVisibility(nodes[k]);
            }
        });

    that.addEventListener(that.viewer, Autodesk.Viewing.SELECTION_CHANGED_EVENT,
        function(e) {
            var nodes = e.nodeArray;
            if(nodes) {
                for (var k = 0; k < nodes.length; k++)
                    that.HideHightlightCAMNode(nodes[k]);
            }
        });

    that.addEventListener(that.viewer, Autodesk.Viewing.ISOLATE_EVENT,
        function(e) {
            var nodes = e.nodeIdArray;
            if(nodes) {
                // show all
                if(nodes.length == 0) {
                    that.SetModelVisible();
                    that.SetCAMNodeVisible(true);
                }
                else {
                    for (var k = 0; k < nodes.length; k++)
                        that.setCamNodeVisibility(nodes[k]);
                }
            }
        });
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.IsCAMNode = function (node) {
    return this.camNodes.indexOf(node) !== -1;
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.IsCAMSetupNode = function (node) {
    return this.camSetupNodes.indexOf(node) !== -1;
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.IsCAMStockNode = function (node) {
    return this.camStockNodes.indexOf(node) !== -1;
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.IsCAMToolNode = function (node) {
    return this.camToolNodes.indexOf(node) !== -1;
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.IsCAMOperationNode = function (node) {
    return this.camOperationNodes.indexOf(node) !== -1;
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.IsCAMFolderNode = function (node) {
    return this.camFolderNodes.indexOf(node) !== -1;
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.shouldInclude = function (node) {
    // Exclude all stock nodes.
    //
    return !this.IsCAMStockNode(node);
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.isGroupNode = function (node) {
    // We consider cam operation nodes leaf nodes.
    //
    return this.IsCAMOperationNode(node) ? false : Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.isGroupNode.call(this, node);
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.setNodeVisibility = function(node, visible) {
    if(visible){
        this.viewer.show(node);
    } else {
        this.viewer.hide(node)
    }
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.SetModelVisible = function () {
    if (!this.camModelNodes) return;

    for (var k = 0; k < this.camModelNodes.length; k++)
        this.setNodeVisibility(this.camModelNodes[k], true);
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.SetCAMNodeVisible = function (visible) {
    if (!this.camNodes) return;

    for (var k = 0; k < this.camNodes.length; k++) {
        this.setNodeVisibility(this.camNodes[k], visible);
    }
    this.SetToolNodeVisible(false);
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.SetToolNodeVisible = function (visible) {
    if (!this.camToolNodes) return;

    for (var k = 0; k < this.camToolNodes.length; k++)
        this.setNodeVisibility(this.camToolNodes[k], visible);
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.HideHightlightNode = function (node) {

    var viewer = this.viewer.impl;
    (function makeInVisibleRec(node) {
        var fragIds = node.fragIds;
        if (typeof fragIds != "undefined") {
            if (!Array.isArray(fragIds))
                fragIds = [fragIds]; //could be just single fragment index in the node, in which case it's not an array

            for (var i = 0; i < fragIds.length; ++i) {
                var fragId = fragIds[i];
                viewer.highlightFragment(this.modelRoot, fragId, false);
            }
        }

        if (node.children)
            for (var k=0; k<node.children.length; k++)
                makeInVisibleRec(node.children[k]);

    })(node);
};

// this is to hide the specific child node
Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.HideHightlightCAMNode = function (node) {

    var isCamSetupNode = this.IsCAMSetupNode(node);
    var isCamOperaNode = this.IsCAMOperationNode(node);
    var isCamFolderNode = this.IsCAMFolderNode(node);

    if (isCamSetupNode) {
        for (var k = 0; k < node.children.length; k++) {
            var childNode = node.children[k];
            if (!this.IsCAMStockNode(childNode)) {
                this.HideHightlightNode(childNode);
            }
        }
    }
    else if (isCamOperaNode) {
        // hide the tool node
        for (var k = 0; k < node.children.length; k++) {
            var childNode = node.children[k];
            if (this.IsCAMToolNode(childNode)) {
                this.HideHightlightNode(childNode);
            }
        }
    }
    else if(isCamFolderNode) {
        for (var k = 0; k < node.children.length; k++)
            this.HideHightlightNode(node.children[k]);
    }
};


Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.setCamNodeVisibility = function (node) {
    var isCamSetupNode = this.IsCAMSetupNode(node);
    var isCamOperaNode = this.IsCAMOperationNode(node);
    var isCamFolderNode = this.IsCAMFolderNode(node);
    if (isCamSetupNode) {
        for (var k = 0; k < node.children.length; k++) {
            var childNode = node.children[k];
            if (this.IsCAMStockNode(childNode)) {
                this.setNodeVisibility(childNode, true);
            }
            else {
                this.setNodeVisibility(childNode, false);
            }
        }
    }
    else if (isCamOperaNode) {
        // hide the tool node
        for (var k = 0; k < node.children.length; k++) {
            var childNode = node.children[k];
            if (this.IsCAMToolNode(childNode)) {
                this.setNodeVisibility(childNode, false);
            }
        }
    }
    else if(isCamFolderNode) {
        for (var k = 0; k < node.children.length; k++) {
            this.setNodeVisibility(node.children[k], false);
        }
    }

};


Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.onClick = function (node, event) {
    Autodesk.Viewing.Extensions.ViewerModelStructurePanel.prototype.onClick.call(this, node, event);

    this.SetModelVisible();

    this.setCamNodeVisibility(node);
	
	this.viewer.fitToView();
};

Autodesk.Viewing.Extensions.CAM360.CAMModelStructurePanel.prototype.ExpandSetupNodes = function () {    

    if (!this.camSetupNodes) return;

    for (var k = 0; k < this.camSetupNodes.length; k++)
        this.tree.setCollapsed(this.camSetupNodes[k].dbId, false);
};;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Fusion360');

/**
 * AnimationExtension adds a toolbar with buttons (play/pause/forward/backward/goto start/end)
 * and timeline scrubber to control animation playback. It also adds an event listener that
 * converts animations to keyframe animations after geometry is loaded. 
 */
Autodesk.Viewing.Extensions.Fusion360.AnimationExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
    this.viewer = viewer;
    this.animTools = null;
    this.animToolsId = "animationTools";
    this.playButton = null;
    this.resetButton = null;
    this.prevExplodeValue = 0;
    this.prevAnimationTime = -1;
};

Autodesk.Viewing.Extensions.Fusion360.AnimationExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Fusion360.AnimationExtension.prototype.constructor = Autodesk.Viewing.Extensions.Fusion360.AnimationExtension;

Autodesk.Viewing.Extensions.Fusion360.AnimationExtension.prototype.load = function() {
    var that = this;
    var viewer = this.viewer;
    var impl = viewer.impl;

    function updatePlayButton(button, isPaused) {
        var btn = button.getElementsByClassName("toolbar-button")[0];
        var tooltip = button.getElementsByClassName("toolbar-tooltip")[0];
        if (btn && tooltip) {
            btn.id = isPaused? "toolbar-animationPlayButton": "toolbar-animationPauseButton";
            tooltip.textContent = isPaused? Autodesk.Viewing.i18n.translate("Play") : Autodesk.Viewing.i18n.translate("Pause");
        }
    }

    function hideAnimateToolbar() {
        viewer.toolbar.container.className = 'toolbar-menuplacer';
        that.animTools.setVisibility(false);
    }

    function resetExplode(value, setSlider) {
        if (!viewer.model.is2d() && viewer.getExplodeScale() !== 0) {
            that.prevExplodeValue = viewer.explodeslider.value;
            if (setSlider) viewer.explodeslider.value = value;
            viewer.explode(value);
        }
    }

    function updateToolbarBackground(input) {
        var percentage = input.value;
        var col1 = "#ffffff", col2 = "#393939";
        input.style.background = "-webkit-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
        input.style.background = "-moz-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
        input.style.background = "-ms-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
        input.style.background = "-o-linear-gradient(left,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
        input.style.background = "linear-gradient(to right,"+col1+" "+percentage+"%, "+col2+" "+percentage+"%)";
    }

    function convertSecsToHMS(time) {
        var sign = "";
        if (time < 0) {sign="-"; time = -time;}
        var hrs = ~~(time / 3600);
        var mins = ~~((time % 3600) / 60);
        var secs = time % 60;
        var ret = sign;
        if (hrs > 0)
            ret += hrs + ":" + (mins < 10 ? "0" : "");
        ret += mins + ":" + (secs < 10 ? "0" : "");
        ret += secs.toFixed(2);
        return ret;
    }

    // Add the ui.
    if (this.viewer.toolbar && this.viewer.toolbar.getSubToolbars().length > 0) {
        onToolbarCreated();
    } else {
        this.viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
    }

    function onToolbarCreated(e) {
        viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);

        // hide reset buttons
        if (viewer.modelTools.resetModelButton) {
            viewer.modelTools.setToolVisibility(viewer.modelTools.resetModelButton.id, false);
        }

        that.animTools = viewer.toolbar.addSubToolbar(that.animToolsId, false);
        that.animTools.setVisibility(false);

        // play button at first of modelTools
        that.playButton = viewer.addMenuButton(viewer.modelToolsId, "toolbar-animationPlay", "Play", function(e) {
            resetExplode(0);
            var animator = viewer.impl.keyFrameAnimator;
            if (animator !== undefined && animator) {
                // restore previous animaton if set
                if (that.prevAnimationTime > 0) {
                    animator.goto(that.prevAnimationTime);
                    that.prevAnimationTime = -1;
                }
                animator.play(0, function(value) {
                    input.value = value;
                    lapse.value = convertSecsToHMS(animator.currentTime);
                    lapseLeft.value = convertSecsToHMS(animator.currentTime-animator.duration);
                    if (value >= 100) {
                        updatePlayButton(that.playButton, true);
                    }
                    updateToolbarBackground(input);
                });
                updatePlayButton(that.playButton, animator.isPaused);
                viewer.toolbar.container.className = 'toolbar-animationMenuplacer';
                that.animTools.setVisibility(true);
                if (!that.animTools.isPositionAdjusted) {
                    adjustToolbarPosition();
                    that.animTools.isPositionAdjusted = true;
                }
            }
        });
        viewer.modelTools.insertToolAtIndex(that.playButton, 0);

        // explode button
        that.onExplodeChange = function() {
            // reset animation
            var animator = viewer.impl.keyFrameAnimator;
            if (animator !== undefined && animator) {
                if (animator.currentTime !== 0) {
                    that.prevAnimationTime = animator.currentTime;
                    animator.goto(0);
                }
                updatePlayButton(that.playButton, true);
            }
            hideAnimateToolbar();
        };
        viewer.addEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT, that.onExplodeChange);

        // reset button
        that.resetButton = viewer.addMenuButton(viewer.modelToolsId, "toolbar-resetTool", "Reset model", function(e) {
            var animator = viewer.impl.keyFrameAnimator;
            if (animator !== undefined && animator) {
                animator.goto(0);
                input.value = 0;
                lapse.value = convertSecsToHMS(0);
                lapseLeft.value = convertSecsToHMS(-animator.duration);
                updatePlayButton(that.playButton, true);
            }
            resetExplode(0, true);
            viewer.showAll();

            updateToolbarBackground(input);
        });
        viewer.modelTools.insertToolAtIndex(that.resetButton, 3);

        // backward button
        that.animTools.backwardButton = viewer.addMenuButton(that.animToolsId, "toolbar-animationBackward", "Previous keyframe", function(e) {
            var animator = viewer.impl.keyFrameAnimator;
            if (animator !== undefined && animator) {
                animator.prev();
                input.value = animator.duration > 0 ? animator.currentTime / animator.duration * 100 : 0;
                lapse.value = convertSecsToHMS(animator.currentTime);
                lapseLeft.value = convertSecsToHMS(animator.currentTime-animator.duration);
                updatePlayButton(that.playButton, animator.isPaused);
                updateToolbarBackground(input);
            }
        });
        var btn = that.animTools.backwardButton.getElementsByClassName("toolbar-button")[0];
        if (btn) btn.className = "toolbar-animationButton";

        // forward button
        that.animTools.forwardButton = viewer.addMenuButton(that.animToolsId, "toolbar-animationForward", "Next keyframe", function(e) {
            var animator = viewer.impl.keyFrameAnimator;
            if (animator !== undefined && animator) {
                animator.next();
                input.value = animator.duration > 0 ? animator.currentTime / animator.duration * 100 : 0;
                lapse.value = convertSecsToHMS(animator.currentTime);
                lapseLeft.value = convertSecsToHMS(animator.currentTime-animator.duration);
                updatePlayButton(that.playButton, animator.isPaused);
                updateToolbarBackground(input);
            }
        });
        btn = that.animTools.forwardButton.getElementsByClassName("toolbar-button")[0];
        if (btn) btn.className = "toolbar-animationButton";

        // current time lapse
        that.animTools.timeText = viewer.addMenuButton(that.animToolsId, "toolbar-animationTimeline", "", null);
        var lapse = document.createElement("input");
        lapse.type = "text";
        lapse.value = "0";
        lapse.className = "animationTimeLapse";
        lapse.disabled = true;
        that.animTools.timeText.appendChild(lapse);

        // timeline
        that.animTools.timeline = viewer.addMenuButton(that.animToolsId, "toolbar-animationTimeline", "", null);
        var input = that.animTools.input = document.createElement("input");
        input.type = "range";
        input.value = "0";
        input.className = "animationTimeline";
        that.animTools.timeline.appendChild(input);
        input.addEventListener("input", function(e) {
            var animator = viewer.impl.keyFrameAnimator;
            if (animator !== undefined && animator) {
                var time = input.value * animator.duration / 100;
                lapse.value = convertSecsToHMS(time);
                lapseLeft.value = convertSecsToHMS(time-animator.duration);
                animator.goto(time);
                updatePlayButton(that.playButton, animator.isPaused);
                updateToolbarBackground(input);
            }
        });
        // tooltip for slider
        var inputTooltip = document.createElement("div");
        inputTooltip.className = "toolbar-tooltip";
        inputTooltip.textContent = Autodesk.Viewing.i18n.translate("Click-drag to scrub");
        that.animTools.timeline.appendChild(inputTooltip);
        input.addEventListener("mouseover", function(e) {
            if (e.target === input)
                inputTooltip.style.visibility = "visible";
        });
        input.addEventListener("mouseout", function(e) {
            if (e.target === input)
                inputTooltip.style.visibility = "hidden";
        });

        // remaining time lapse
        that.animTools.timeLeftText = viewer.addMenuButton(that.animToolsId, "toolbar-animationTimeline", "", null);
        var lapseLeft = document.createElement("input");
        lapseLeft.type = "text";
        lapseLeft.value = "0";
        lapseLeft.className = "animationTimeLapse";
        lapseLeft.disabled = true;
        that.animTools.timeLeftText.appendChild(lapseLeft);

        // close button
        that.animTools.closeButton = viewer.addMenuButton(that.animToolsId, "toolbar-animationClose", "Close animation timeline", function(e) {
            hideAnimateToolbar();
        });
        btn = that.animTools.closeButton.getElementsByClassName("toolbar-button")[0];
        if (btn) btn.className = "toolbar-animationCloseButton";

        that.onEscape = function (event) {
            var animator = viewer.impl.keyFrameAnimator;
            if (animator !== undefined && animator) {
                if (!animator.isPaused)
                    animator.pause();
                else
                    hideAnimateToolbar();
                updatePlayButton(that.playButton, animator.isPaused);
            }
        };
        viewer.addEventListener(Autodesk.Viewing.ESCAPE_EVENT, that.onEscape);

        that.onCameraChange = function() {
            if (viewer.toolController.cameraUpdated) {
                var animator = viewer.impl.keyFrameAnimator;
                if (animator !== undefined && animator) {
                    if (animator.isPlaying && !animator.isPaused && !animator.areCameraAnimationsPaused)
                        animator.pauseCameraAnimations();
                }
            }
        };
        viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, that.onCameraChange);
    }

    function adjustToolbarPosition() {
        // align toolbar with nav tools
        that.animTools.subtoolbar.className = 'toolbar-animationSubtoolbar';
        // reset toolbar left before getting offset from modelTools
        that.animTools.subtoolbar.style.left = 0 + 'px';
        var offset = that.animTools.subtoolbar.getBoundingClientRect().left - viewer.modelTools.subtoolbar.getBoundingClientRect().left + 10;
        var width = viewer.navTools.subtoolbar.getBoundingClientRect().width + offset;
        that.animTools.subtoolbar.style.left = -width + 'px';

        // set timeline width 
        var fullwidth = viewer.navTools.subtoolbar.getBoundingClientRect().width + viewer.modelTools.subtoolbar.getBoundingClientRect().width + 10;
        var inputWidth = fullwidth - (3 * that.animTools.backwardButton.getBoundingClientRect().width + 2 * that.animTools.timeLeftText.getBoundingClientRect().width + (that.animTools.timeline.getBoundingClientRect().width - that.animTools.input.getBoundingClientRect().width) + 2);
        that.animTools.input.style.width = inputWidth + 'px';
    }

    function convertAnimations() {
        var svf = viewer.model.getData();
        if (!svf || !svf.animations) {
            return;
        }

        var animations = svf.animations["animations"];
        var duration = svf.animations["duration"];
        var animator = impl.keyFrameAnimator = new Autodesk.Viewing.Private.KeyFrameAnimator(impl, duration);

        for (var a in animations) {
            animator.add(animations[a]);
        }
        
        viewer.removeEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, convertAnimations);
        viewer.removeEventListener(Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT, checkGeomAndConvert);
    }

    function checkGeomAndConvert() {
        if (viewer.model && viewer.model.isLoadDone()) {
            convertAnimations();
        } else {
            viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, convertAnimations);
        }
    }

    // convert animations after object tree created and geometry loaded
    if (viewer.model && viewer.model.isObjectTreeCreated()) {
        checkGeomAndConvert();
    } else {
        viewer.addEventListener(Autodesk.Viewing.OBJECT_TREE_CREATED_EVENT, checkGeomAndConvert);
    }

    return true;
};

Autodesk.Viewing.Extensions.Fusion360.AnimationExtension.prototype.unload = function () {
    var viewer = this.viewer;
    viewer.removeMenuButton(viewer.modelToolsId, this.playButton);
    viewer.removeMenuButton(viewer.modelToolsId, this.resetButton);
    viewer.removeMenuButton(this.animToolsId, this.animTools.timeText);
    viewer.removeMenuButton(this.animToolsId, this.animTools.timeline);
    viewer.removeMenuButton(this.animToolsId, this.animTools.timeLeftText);
    viewer.removeMenuButton(this.animToolsId, this.animTools.forwardButton);
    viewer.removeMenuButton(this.animToolsId, this.animTools.playbutton);
    viewer.removeMenuButton(this.animToolsId, this.animTools.backwardButton);
    viewer.removeMenuButton(this.animToolsId, this.animTools.closeButton);
    viewer.toolbar.removeSubToolbar(this.animToolsId);

    // Remove event listeners
    viewer.removeEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT, this.onExplodeChange);
    viewer.removeEventListener(Autodesk.Viewing.ESCAPE_EVENT, this.onEscape);
    viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);

    // show reset button
    if (viewer.modelTools.resetModelButton) {
        viewer.modelTools.setToolVisibility(viewer.modelTools.resetModelButton.id, true);
    }

    return true;
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Fusion360.Animation', Autodesk.Viewing.Extensions.Fusion360.AnimationExtension);
;AutodeskNamespace('Autodesk.Viewing.Extensions.Markers');

/**
 * Constructs a ViewerMarkers object. ViewerMarkers is an extension to viewer that permits to add
 * markers over the viewer view. This first implementation uses a canvas 2d to draw lines over the
 * viewer fragments and connect them to html nodes provided to the extension and added ont top of this
 * canvas.
 * @param {Autodesk.Viewing.Viewer} viewer
 * @constructor
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers = function (viewer) {

    Autodesk.Viewing.Extension.call(this, viewer);
}

Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.constructor = Autodesk.Viewing.Extensions.Markers.ViewerMarkers;

/**
 * Initializes the extension and create its needed resources. 
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.load = function () {

    // We only support Viewer3D. Bail out early if not.
    if (!(this.viewer instanceof Autodesk.Viewing.Viewer3D)) {
        return false;
    }

    this.markups = [];
    this.markerGroups = [];
    this.modelMarkers = [];
    this.lines = [];

    this.markersVisible = true;
    this.linesVisible = true;

    this.minimumGroupMarkerWidth = 80;

    // its not possible to composite canvas with children divs, so we add a wrapper for the line canvas
    // and the markers.
    this.markersWrap = document.createElement("div");
    this.markersWrap.id = "markers-wrap";
    this.markersWrap.style.left = 0;
    this.markersWrap.style.top = 0;
    this.markersWrap.style.right = 0;
    this.markersWrap.style.bottom = 0;
    this.markersWrap.style.width = "100%";
    this.markersWrap.style.height = "100%";
    this.markersWrap.style.backgroundColor = "transparent";
    this.markersWrap.style.position = "absolute";

    // Create the canvas where lines will be draw.
    this.markerLines = document.createElement("canvas");
    this.markerLines.id = "markers-lines";
    this.markerLines.style.left = 0;
    this.markerLines.style.top = 0;
    this.markerLines.style.right = 0;
    this.markerLines.style.bottom = 0;
    this.markerLines.style.width = "100%";
    this.markerLines.style.height = "100%";
    this.markerLines.style.backgroundColor = "transparent";
    this.markerLines.style.position = "absolute";

    // Insert the markerWrap as the first child of the viewer container,
    // the lines should no be over other parts of the ui.
    this.container = this.viewer.container;

    if (this.container.firstChild) {
        this.container.insertBefore(this.markersWrap, this.container.firstChild);
    } else {
        this.container.appendChild(this.markersWrap);
    }
    this.markersWrap.appendChild(this.markerLines);

    // Disable mouse event handling to allow the viewer to consume them.
    // The support of pointer-events property is recently added to all mayor browsers.
    this.markersWrap.style.pointerEvents = "none";

    // Create an overlay to highlight geometry associated with markups.
    this.highlightedMeshes = {};
    this.materialBase = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, opacity: 0.25, transparent: false });
    this.materialTop = new THREE.MeshBasicMaterial({ color: 0xFFFFFF, opacity: 0.01, shading: THREE.NoShading, transparent: true });

    this.viewer.impl.createOverlayScene("markers", this.materialBase, this.materialTop);

    this.htmlBounds = new THREE.Box2();
    this.viewerBounds = new THREE.Box2();
    this.modelMarkersBoundingBox = new THREE.Box2();
    this.modelMarkersBoundingBox.min.x = -100000; // big negative value to collide with markers pushed outside viewer bounds
    this.modelMarkersBoundingBox.min.y = -100000; // big negative value to collide with markers pushed outside viewer bounds
    this.cameraTransitionActive = false;

    // Add event listeners
    this.onCameraChange = function (event) {

        var transitionActive = this.viewer.navigation.getTransitionActive();

        // Several camera change events while the camera is not being modified are fired after a camera transition ended.
        // This is a side effect of a solution used to avoid extreme flickering (progressive rendering is delayed some
        // miliseconds after the camera stops moving).
        // ToolController has a property that states if the camera was dirty and truly updated.
        var cameraUpdated = this.viewer.toolController.cameraUpdated;
        if (cameraUpdated) {

            // After a navigation transition ends, the camera stays dirty one more frame.
            // For that reason, to know if the camera change was made by the user the previous frame is checked too.
            var changedByUser = !transitionActive && !this.cameraTransitionActive;
            if (changedByUser) {
                this.clearMarkups();
            }
        }
        this.cameraTransitionActive = transitionActive;
        this.update();

    }.bind(this);

    this.onExplodeChange = function () {
        this.update();
    }.bind(this);

    // TODO: a better fix would be to update matrices before sending resize event.
    this.onViewerResize = function () {

        this.clientWidth = this.container.offsetWidth;
        this.clientHeight = this.container.offsetHeight;

        this.viewerBounds.min.x = 0;
        this.viewerBounds.min.y = 0;
        this.viewerBounds.max.x = this.clientWidth;
        this.viewerBounds.max.y = this.clientHeight;

        this.htmlBounds.min.x = this.viewerBounds.min.x + 50;
        this.htmlBounds.min.y = this.viewerBounds.min.y + 50;
        this.htmlBounds.max.x = this.viewerBounds.max.x - 50;
        this.htmlBounds.max.y = this.viewerBounds.max.y - 50;

        this.viewer.impl.updateCameraMatrices();
        this.update();
    }.bind(this);

    // Add UI entry in Viewer3dSettingsPanel.js
    var that = this;
    var registerUiOption = function() {
        that.viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, registerUiOption);
        // KLUDGE Solution. TODO: Figure out a better approach.
        that.viewer.vieweroptions.addMarkersOption(that);
    }
    if (this.viewer.vieweroptions) {
        registerUiOption();
    } else {
        this.viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, registerUiOption);
    }

    this.viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
    this.viewer.addEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT, this.onExplodeChange);
    this.viewer.addEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onViewerResize);

    this.onViewerResize();
    return true;
}

/**
 * Dispose resources created for this extension and remove event listeners.
 * @returns {boolean} True if unloading was successful
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.unload = function () {

    // remove event listeners
    this.viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, this.onCameraChange);
    this.viewer.removeEventListener(Autodesk.Viewing.EXPLODE_CHANGE_EVENT, this.onExplodeChange);
    this.viewer.removeEventListener(Autodesk.Viewing.VIEWER_RESIZE_EVENT, this.onViewerResize);


    this.markerGroups.splice(0, this.markerGroups.length);
    this.modelMarkers.splice(0, this.markerGroups.length);
    this.lines.splice(0, this.lines.length);
    
    this.markersWrap.parentNode.removeChild(this.markersWrap);
    this.viewer.impl.removeOverlayScene("markers");

    this.materialBase.dispose();
    this.materialTop.dispose();

    return true;
}

/**
 * Clear the canvas and reposition and redraw markers and lines.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.update = function () {

    if(!this.visible || !this.viewer.model) {
        return;
    }

    // hightlight model if it's required
    if (this.isModelHightlighted) {

        var fragIds = [];
        var fragId2dbId = this.viewer.model.getData().fragments.fragId2dbId;
        var fragId2dbIdCount = fragId2dbId.length;

        for (var i = 0; i < fragId2dbIdCount; ++i) {
            fragIds.push(i);
        }

        this.viewer.model.getRoot().fragIds = fragIds;
        this.highlightNode(this.viewer.model.getRoot(), -1);
    }

    this.markerLines.width  = this.markerLines.clientWidth;
    this.markerLines.height = this.markerLines.clientHeight;

    var ctx = this.markerLines.getContext("2d");
    if (!ctx) {
        return;
    }

    ctx.clearRect(0,0,this.markerLines.width,this.markerLines.height);

    var modelBoundingRectangle = this.getModelBoundingRectangle(this.viewer.model);

    this.updateMarkups(ctx);
    this.updateModelMarkers(ctx);
    this.updateMarkerGroups(ctx, modelBoundingRectangle);
    this.updateLines(ctx);
};

/**
 * Reposition and redraw markups.
 * @param {CanvasRenderingContext2D} ctx Context used to draw markups.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.updateMarkups = function (ctx) {

    var markups = this.markups;
    var markupCount = this.markups.length;

    for( var i = 0; i < markupCount; ++i) {
        this.drawMarkup(ctx, markups[i]);
    }
}

/**
 * Reposition and redraw marker groups.
 * @param {CanvasRenderingContext2D} ctx Context used to draw lines and other shapes associated to markers.
 * @param {THREE.Box2} modelBoundingRectangle Rectangle that fits all the screen projected points of the model's bounding box.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.updateMarkerGroups = function (ctx, modelBoundingRectangle) {

    if (!this.markersVisible || !this.viewer.prefs.showCommentMarkers) {
        return;
    }

//  used for testing
//  this.drawBoundingBox(ctx, modelBoundingRectangle, "#FF00FF", 0.50);
    this.updateProxiesCenters();
    this.sortMarkerGroups();

    // update markers positions and resolve their collisions
    var model = this.viewer.model;
    var modelCenter = this.getModelCenter(model);

    var markerGroups = this.markerGroups;
    var markerGroupCount = markerGroups.length;

    var minX = modelBoundingRectangle.min.x;
    var maxX = modelBoundingRectangle.max.x;

    for (var i = 0; i < markerGroupCount; ++i) {
        this.updateMarkerGroup(markerGroups[i], modelCenter, minX, maxX);
    }
    this.resolveMarkersCollisions(modelCenter, minX, maxX);

    // draw lines and place html
    ctx.lineWidth = 1;

    for(var i = 0; i < markerGroupCount; ++i) {

        var group = markerGroups[i];
        
        // move html node to marker position
        var markers = group;
        var markerCount = markers.length;

        if(group.clipped) {

            var html = markers[0].html;

            html.data.setDirection(!group.flip ? "outside_left" : "outside_right");
            html.style.display = group.visible ? "" : "none";

            if(group.flip) {
                html.style.left = Math.round(group.x - html.offsetWidth)+ "px";
                html.style.top = Math.round(group.y - html.offsetHeight * 0.5) + "px";
            } else {
                html.style.left = Math.round(group.x) + "px";
                html.style.top = Math.round(group.y - html.offsetHeight * 0.5) + "px";
            }

            for(var j = 1; j < markerCount; ++j) {
                var html = markers[j].html;
                html.style.display = "none";
            }
        } else {

            this.drawLine(ctx, group.proxyCenter.x, group.proxyCenter.y, group.x, group.y, "#FFFFFF");
            this.drawCircle(ctx, group.proxyCenter.x, group.proxyCenter.y, 4, "#FFFFFF");

//          used for testing
//          this.drawBoundingBox(ctx, group.wholeBoundingBox, "#FF00FF", 0.50);
//          this.drawBoundingBox(ctx, group.htmlBoundingBox, "#00FF00", 0.50);

            var htmlClass = group.flip ? "left" : "right";
            var htmlDirection = group.flip ? 1 : -1;

            for(var j = 0; j < markerCount; ++j) {

                var html = markers[j].html;

                html.data.setDirection( j == 0 ? htmlClass : "" );
                html.style.display = "";

                var htmlX = group.x - html.offsetWidth * 0.5 + html.offsetWidth * j * htmlDirection;
                var htmlY = group.y - html.offsetHeight * 0.5;

                html.style.left = Math.round(htmlX) + "px";
                html.style.top = Math.round(htmlY) + "px";
            }
        }
    }
}

/**
 * Reposition and redraw model markers (markers not linked to a model node).
 * @param {CanvasRenderingContext2D} ctx Context used to draw lines and other shapes associated to markers.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.updateModelMarkers = function (ctx) {

    var markers = this.modelMarkers;
    var markerCount = markers.length;

    if (markerCount == 0) {
        return;
    }

    var markerPositionX = 10;
    var markerPositionY = 10;
    var markerSeparation = 5;

    if (this.markersVisible && this.viewer.prefs.showCommentMarkers) {

        // markers are drawn from left to right at the top of the viewer
        for (var i = 0; i < markerCount; ++i) {

            var marker = markers[i];
            var html = marker.html;

            html.style.display = "";
            html.style.left = markerPositionX + "px";
            html.style.top = markerPositionY + "px";

            markerPositionX += parseInt(html.offsetWidth + markerSeparation);

            this.modelMarkersBoundingBox.max.x = markerPositionX;
            this.modelMarkersBoundingBox.max.y = markerPositionY + html.offsetHeight;
        }
    } else {

        for (var i = 0; i < markerCount; ++i) {

            var html = markers[i].html;
            html.style.display = "none";
        }

        this.modelMarkersBoundingBox.max.x = markerPositionX;
        this.modelMarkersBoundingBox.max.y = markerPositionY;
    }

//  used for testing
//  this.drawBoundingBox(ctx, this.modelMarkersBoundingBox, "#0000FF", 0.50);
}

/**
 * Reposition and redraw lines.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.updateLines = function (ctx) {

    if(this.linesVisible) {

        ctx.lineWidth = 1;

        var lines = this.lines;
        var lineCount = lines.length;

        for (var i = 0; i < lineCount; ++i) {

            var line = lines[i];
            var proxyCenter = this.getProxyCenter(line.fragId);

            this.drawLine(ctx, proxyCenter.x, proxyCenter.y, line.x, line.y, "#FFFFFF");
            this.drawCircle(ctx, proxyCenter.x, proxyCenter.y, 4, "#FFFFFF");
        }
    }
}

/**
 * Clear all markups.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.clearMarkups = function() {

    if (this.markups.length != 0) {

        this.markups.splice(0, this.markups.length);
        this.update();
    }
}

/**
 * Adds a new rectangle markup.
 * @param {number} x Position in x-axis in client space coordinates of the rectangular markup to add.
 * @param {number} y Position in y-axis in client space coordinates of the rectangular markup to add.
 * @param {number} width Width in pixels of the rectangular markup to add.
 * @param {number} height Height in pixels of the rectangular markup to add.
 * @param {number} strokeWidth Width in pixels of the stroke used to draw the markup.
 * @param {string} strokeColor Color used to draw the markups.
 * @returns {number} Index of the markup created.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.addRectangularMarkup = function(x, y, width, height, strokeWidth, strokeColor) {

    this.setRectangularMarkup(this.markups.length, x, y, width, height, strokeWidth, strokeColor);
    return this.markups.length-1;
}

/**
 * Sets a new rectangle markup at the provided index.
 * @param {number} index Position used to replace a marker for a new rectangular one.
 * @param {number} x Position in x-axis in client space coordinates of the rectangular markup to add.
 * @param {number} y Position in y-axis in client space coordinates of the rectangular markup to add.
 * @param {number} width Width in pixels of the rectangular markup to add.
 * @param {number} height Height in pixels of the rectangular markup to add.
 * @param {number} strokeWidth Width in pixels of the stroke used to draw the markup.
 * @param {string} strokeColor Color used to draw the markups.
 * @returns {number} Index of the markup created.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.setRectangularMarkup = function(index, x, y, width, height, strokeWidth, strokeColor) {

    if(index < 0) {
        return;
    }

    // save path in homogeneous screen space coordinates so it's easy to apply paths to different viewport sizes.
    var invClientWidth = 1 / this.clientWidth;
    var invClientHeight = 1 / this.clientHeight;
    var invAspectRatio = invClientHeight / invClientWidth;

    var markup = {
        path: [
            "M",        ((x *invClientWidth)*2-1)*invAspectRatio, -((        y *invClientHeight)*2-1),
            "L", (((width+x)*invClientWidth)*2-1)*invAspectRatio, -((        y *invClientHeight)*2-1),
            "L", (((width+x)*invClientWidth)*2-1)*invAspectRatio, -(((height+y)*invClientHeight)*2-1),
            "L",        ((x *invClientWidth)*2-1)*invAspectRatio, -(((height+y)*invClientHeight)*2-1),
            "z" ],
        strokeWidth: strokeWidth,
        strokeColor: strokeColor
    };

    if(index < this.markups.length) {
        this.markups[index] = markup;
    }else {
        this.markups.push(markup);
    }
    this.update();
}

/**
 * Removes a markup.
 * @param index
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.removeMarkupAt = function(index) {

    this.markups.splice(index, 1);
    this.update();
}

/**
 * Add a node marker to viewer. A node marker is a html element attached to a node in the model with a line.
 * @param {string} id The id of the marker to add.
 * @param {number} nodeid The id of the three node the marker will be attached.
 * @param html Html DOM node object to place as marker.
 * @returns {boolean} True if the marker was added successfully.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.setNodeMarker = function (id, nodeId, html) {

    var fragId = this.getFragmentId(nodeId);
    if( fragId == -1 || !html)  {
        return false;
    }

    var marker = {
        id: id,
        html: html
    };

    html.style.display = (this.markersVisible && this.viewer.prefs.showCommentMarkers) ? "block" : "none";

    // add/override marker.
    var groupIndex = this.getIndexFromId(nodeId, this.markerGroups);
    if(groupIndex != -1) {

        var markers = this.markerGroups[groupIndex];
        var markerIndex = this.getIndexFromId(id, markers);

        if(markerIndex != -1) {

            this.markersWrap.removeChild(markers[markerIndex].html);
            markers.splice(markerIndex, 1, marker);
        } else {
            markers.push(marker);
        }
    } else {

        var markerGroup = [marker];

        markerGroup.id = nodeId;
        markerGroup.fragId = this.getFragmentId(nodeId);
        markerGroup.x = 0;
        markerGroup.y = 0;
        markerGroup.flip = false;
        markerGroup.proxyCenter = new THREE.Vector2();
        markerGroup.htmlOffset = new THREE.Vector2();
        markerGroup.htmlSize = new THREE.Vector2();
        markerGroup.distanceFromCenter = 0;
        markerGroup.wholeBoundingBox = new THREE.Box2();
        markerGroup.htmlBoundingBox = new THREE.Box2();

        this.markerGroups.push(markerGroup);
    }

    this.markersWrap.appendChild(marker.html);
    this.update();

    return true;
}

/**
 * Add a model marker to viewer. A model marker has no attachment to any node in the model.
 * @param {string} id The id of the marker to add.
 * @param html Html DOM node object to place as marker.
 * @returns {boolean} - True if the marker was added successfully.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.setModelMarker = function (id, html) {

    if(!html)  {
        return false;
    }

    var marker = {
        id: id,
        html: html
    };

    html.style.display = (this.markersVisible && this.viewer.prefs.showCommentMarkers) ? "block" : "none";

    // add/override marker.
    var index = this.getIndexFromId(id, this.modelMarkers);
    if(index != -1) {

        this.markersWrap.removeChild(this.modelMarkers[index].html);
        this.modelMarkers.splice(index, 1, marker);
    } else {

        this.modelMarkers.push(marker);
    }

    this.markersWrap.appendChild(marker.html);
    this.update();

    return true;
}

/**
 * Remove a marker from the viewer.
 * @param {string} id The id of the marker to remove.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.removeMarker = function (id) {

    // remove it from markers groups
    var markerGroups = this.markerGroups;
    var markerGroupCount = markerGroups.length;

    for(var i = 0; i < markerGroupCount; ++i) {

        var markerGroup = markerGroups[i];
        var markerIndex = this.getIndexFromId(id, markerGroup);

        if(markerIndex != -1) {

            this.markersWrap.removeChild(markerGroup[markerIndex].html);
            markerGroup.splice(markerIndex, 1);

            if(markerGroup.length == 0) {
                markerGroups.splice(i, 1);
            }
            break;
        }
    }

    // remove it from model markers
    var index = this.getIndexFromId(id, this.modelMarkers);
    if (index != -1) {

        this.markersWrap.removeChild(this.modelMarkers[index].html);
        this.modelMarkers.splice(index, 1);
    }

    this.update();
}

/**
 * Add a line segment to the viewer from a viewer's three node to a fixed screen position.
 * @param {string} id Id of the line to add.
 * @param {number} nodeId Id of the three node the line will be attached.
 * @param {number} x X-axis position in client space coordinates of the end of the line segment.
 * @param {number} y Y-axis position in client space coordinates of the end of the line segment.
 * @returns {boolean} True if the line was added successfully.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.setLine = function (id, nodeId, x, y) {

    var fragId = this.getFragmentId(nodeId);
    if( fragId == -1)  {
        return false;
    }

    var line = {
        id:id,
        nodeId: nodeId,
        fragId: this.getFragmentId(nodeId),
        x: x,
        y: y,
    };

    // add/override line.
    var index = this.getIndexFromId(id, this.lines);
    if(index != -1) {
        this.lines.splice(index, 1, line);
    } else {
        this.lines.push(line);
    }

    this.update();
    return true;
}

/**
 * Remove a line segment from the viewer.
 * @param {id} Id of the line segment to remove.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.removeLine = function (id) {

    var index = this.getIndexFromId(id, this.lines);
    if(index != -1) {
        this.lines.splice(index, 1);
    }
    this.update();
}

/**
 * Returns true if markers are visible.
 * @returns {Boolean} True if markers are visible.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.__defineGetter__('visible', function () {

    return this.markersWrap.style.display == "block" ||
        this.markersWrap.style.display == "";
} );

/**
 * Make all markers and lines visible.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.show = function () {

    this.markersWrap.style.display = "block";
    this.update();
}

/**
 * Make all markers and lines hidden.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.hide = function () {

    this.markersWrap.style.display = "none";
}

Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.setEnabled = function( /*enabled*/ ) {

    // 'enabled' gets applied to a viewer.prefs property. update() will take care of using it.
    this.visibilityUpdated();
    this.update();
}

Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.setVisible = function( isVisible ) {

    if (isVisible == this.markersVisible) {
        return;
    }

    this.markersVisible = isVisible;
    this.visibilityUpdated();
    this.update();
}

Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.visibilityUpdated = function () {

    var displayType = (this.markersVisible && this.viewer.prefs.showCommentMarkers) ? "block" : "none";
    var markerGroups = this.markerGroups;
    var markerGroupCount = markerGroups.length;

    for(var i = 0; i < markerGroupCount; ++i) {

        var markers = markerGroups[i];
        var markerCount = markers.length;

        for(var j = 0; j < markerCount; ++j) {
            markers[j].html.style.display = displayType;
        }
    }
}

/**
 * Make all markers visible.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.showMarkers = function () {

    // TODO: DEPRECATED, remove
}

/**
 * Make all markers hidden.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.hideMarkers = function () {

    // TODO: DEPRECATED, remove
}

/**
 * Returns a fragment id associated to a model node id.
 * @param {number} nodeId Id of the model node which fragment ids are required.
 * @returns {number} The first fragment id found for the node or -1 if no fragment was found.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.getFragmentId = function (dbId) {

    // TODO: return an array of fragments ids, no just the fist found.
    var fragId2dbId = this.viewer.model.getData().fragments.fragId2dbId;
    var fragId2dbIdCount = fragId2dbId.length;

    for(var i = 0; i < fragId2dbIdCount; ++i) {
        if(fragId2dbId[i] == dbId) {
            return i;
        }
    }
    return -1;
}

/**
 * Returns the first index found in the array passed as parameter of the element with the matching id passed as
 * parameter.
 * @param {object} id Id of the element which index is required.
 * @param {array} array Array used to search the element.
 * @returns {number} Index of the element found or -1 if no element was found.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.getIndexFromId = function (id, array) {

    var count = array.length;
    for(var i = 0; i < count; ++i) {
        if(array[i].id == id) {
            return i;
        }
    }
    return -1;
}

/**
 * Transform and project into client space coordinates the center of the model's bounding box.
 * @param model Model which its projected center will be calculated.
 * @returns {THREE.Vector3} Transformed and projected into client coordinates model's bounding box center.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.getModelCenter = function (model) {

    var modelCenter = model.getBoundingBox().center();
    return this.worldToClient(modelCenter);
}

/**
 * Transform and project into client space coordinates the corners of the model's bounding box, then, calculates and
 * returns a rectangle that fits these points.
 * @param model Model used to calculate its bounding rectangle.
 * @returns {THREE.Box2} Transformed and projected into client coordinates model's bounding box fit rectangle.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.getModelBoundingRectangle = function (model) {

    var min = model.getBoundingBox().min;
    var max = model.getBoundingBox().max;

    var points = [
        new THREE.Vector3(min.x, min.y, min.z),
        new THREE.Vector3(min.x, max.y, min.z),
        new THREE.Vector3(max.x, min.y, min.z),
        new THREE.Vector3(max.x, max.y, min.z),

        new THREE.Vector3(min.x, min.y, max.z),
        new THREE.Vector3(min.x, max.y, max.z),
        new THREE.Vector3(max.x, min.y, max.z),
        new THREE.Vector3(max.x, max.y, max.z),
    ];

    var minX = Number.POSITIVE_INFINITY;
    var minY = Number.POSITIVE_INFINITY;
    var maxX = Number.NEGATIVE_INFINITY;
    var maxY = Number.NEGATIVE_INFINITY;

    var pointCount = points.length;
    for( var i = 0; i < pointCount; ++i) {

        var transformedPoint = this.worldToClient(points[i]);

        minX = Math.min(minX, transformedPoint.x);
        minY = Math.min(minY, transformedPoint.y);
        maxX = Math.max(maxX, transformedPoint.x);
        maxY = Math.max(maxY, transformedPoint.y);
    }

    return new THREE.Box2(new THREE.Vector2(minX, minY), new THREE.Vector2(maxX, maxY));
}

/**
 * Calculates the bounding box's center in client space coordinates of the fragment with the provided id.
 * @param {number} fragId Id of the fragment which center is required.
 * @returns {THREE.Vector3} Bounding box's center transformed and projected into client space coordinates.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.getProxyCenter = function (fragId) {

    var proxy = this.viewer.impl.getRenderProxy(this.viewer.model, fragId);
    var proxyCenter = proxy.geometry.boundingBox.center();

    proxyCenter.applyMatrix4(proxy.matrixWorld);
    return this.worldToClient(proxyCenter);
}

/**
 * Calculates the pixel position in client space coordinates of a point in world space.
 * @param {THREE.Vector3} point  Point in world space coordinates.
 * @returns {THREE.Vector3} Transformed and projected point in client pixel coordinates.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.worldToClient = function (point) {

    var p = new THREE.Vector4();

    p.x = point.x;
    p.y = point.y;
    p.z = point.z;
    p.w = 1;

    p.applyMatrix4(this.viewer.impl.camera.matrixWorldInverse);
    p.applyMatrix4(this.viewer.impl.camera.projectionMatrix);

    if (p.w > 0) // don't want to mirror values with negative z (behind camera)
    {            // if camera is inside the bounding box, better to throw markers to the screen sides.
        p.x /= p.w;
        p.y /= p.w;
        p.z /= p.w;
    }

    point = this.viewer.impl.viewportToClient(p.x, p.y);

    // snap to the center of the pixel
    point.x = Math.floor(point.x) + 0.5;
    point.y = Math.floor(point.y) + 0.5;

    var clientRect = this.viewer.impl.canvas.getBoundingClientRect();

    point.x -= clientRect.left;
    point.y -= clientRect.top;

    return point;
}

/**
 * Draw a line segment over the viewer.
 * @param {CanvasRenderingContext2D} Context used to draw the line.
 * @param {xO} Initial position in x-axis of the line segment.
 * @param {yO} Initial position in y-axis of the line segment.
 * @param {xF} Final position in x-axis of the line segment.
 * @param {yF} Final position in y-axis of the line segment.
 * @param {color} Color used to draw the line segment.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.drawLine = function (ctx, xO, yO, xF, yF, color) {

    ctx.beginPath();
    ctx.moveTo(xO, yO);
    ctx.lineTo(xF, yF);
    ctx.strokeStyle = color;
    ctx.stroke();
}

/**
 * Toggles highlight for the whole model.
 * @param {boolean} highlight Whether we want to highlight the whole model or not.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.setModelHighlight = function (highlight) {

    this.clearHighlightedNodes();

    if (highlight) {
        this.highlightNode(this.viewer.model.getRoot());
    }
}

/**
 * Highlights a node in the model through the markup overlay.
 * @param {Object} object The node to highlight.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.highlightNode = function (object) {

    var fragIds;
    var objectId;

    // For the model's root, we fetch all fragments
    if (object === this.viewer.model.getRoot()) {

        objectId = object.dbId;
        var fragmentCount = this.viewer.model.getData().fragments.fragId2dbId.length;
        fragIds = new Array(fragmentCount);
        for (var i = 0; i < fragmentCount; ++i) {
            fragIds[i] = i;
        }
    }
    else
    // For every other non-model node, we just fetch its fragment(s)
    {
        fragIds = object.fragIds;
        objectId = object.dbId;
        if (!Array.isArray(fragIds)) {
            fragIds = [fragIds]; //could be just single fragment index in the node, in which case it's not an array
        }
    }

    var meshes = [];
    for (var i = 0; i < fragIds.length; ++i) {
        var fragId = fragIds[i];
        var mesh = this.viewer.impl.getRenderProxy(this.viewer.model, fragId);

        if (!mesh || mesh.markupHighlightProxy) {
            continue;
        }

        mesh.markupHighlightProxy = new THREE.Mesh(mesh.geometry, mesh.material, true);
        mesh.markupHighlightProxy.matrixWorld = mesh.matrixWorld;
        this.viewer.impl.addOverlay("markers", mesh.markupHighlightProxy);
        meshes.push(mesh);
    }
    if (meshes.length) {
        this.highlightedMeshes[objectId] = meshes;
    }
}

/**
 * Clears markup highlights for a nodes in model.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.clearHighlightedNode = function (node) {

    // Clear everything when applied to root node.
    if (node === this.viewer.model.getRoot()) {
        this.clearHighlightedNodes();
        return;
    }

    // Abort if node is not highlighted
    var nodeMeshes = this.highlightedMeshes[node.dbId];
    if(!Array.isArray(nodeMeshes)) {
        return;
    }

    // Clear highlight from the node!
    for (var i = 0, len = nodeMeshes.length; i<len; ++i) {
        var mesh = nodeMeshes[i];
        this.viewer.impl.removeOverlay("markers", mesh.markupHighlightProxy);
        delete mesh["markupHighlightProxy"];
    }

    delete this.highlightedMeshes[node.dbId];
}

/**
 * Clears markup highlights from all nodes in model.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.clearHighlightedNodes = function () {

    // TODO: clearOverlay's implementation throws a runtime error.
    // this.viewer.impl.clearOverlay("markers");

    // Alternative approach.
    for (var id in this.highlightedMeshes) {
        
        var nodeMeshes = this.highlightedMeshes[id];
        for (var i = 0, len = nodeMeshes.length; i<len; ++i) {
            var mesh = nodeMeshes[i];
            this.viewer.impl.removeOverlay("markers", mesh.markupHighlightProxy);
            mesh.markupHighlightProxy = null;
        }
    }
    this.highlightedMeshes = {};
}

/**
 * Draw a markup.
 * @param {CanvasRenderingContext2D} Context used to draw the markup.
 * @param {Object} Markup to be draw.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.drawMarkup = function (ctx, markup) {

    var clientWidth = this.clientWidth;
    var clientHeight = this.clientHeight;
    var pixelOffset = markup.strokeWidth % 2 == 0 ? 0 : 0.5;
    var aspectRatio = this.clientHeight / this.clientWidth;

    ctx.lineWidth = markup.strokeWidth;
    ctx.strokeStyle = markup.strokeColor;
    ctx.beginPath();

    var markupPath = markup.path;
    var markupPathCount = markupPath.length;

    for (var i = 0; i < markupPathCount; i+=3) {

        var x = Math.floor(( markupPath[i+1]*aspectRatio+1) * 0.5 * clientWidth)  + pixelOffset;
        var y = Math.floor((-markupPath[i+2]+1) * 0.5 * clientHeight) + pixelOffset;

        switch(markupPath[i]){
            case "M":
                ctx.moveTo(x,y);
                break;

            case "L":
                ctx.lineTo(x,y);
                break;
        }
    }
    ctx.closePath();
    ctx.stroke();
}

/**
 * Draw a circle over the viewer.
 * @param {CanvasRenderingContext2D} Context used to draw the circle.
 * @param {x} Center position of the circle in x-axis of the circle.
 * @param {y} Center position of the circle in y-axis of the circle.
 * @param {radius} Radius of the circle.
 * @param {color} Color used to draw the circle.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.drawCircle = function (ctx, x, y, radius, color) {

    ctx.beginPath();
    ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
    ctx.fillStyle = color;
    ctx.fill();
}

/**
 * Draw a circumference.
 * @param {CanvasRenderingContext2D} Context used to draw the circumference.
 * @param {x} Center position of the circumference the in x-axis of the circle.
 * @param {y} Center position of the circumference in y-axis of the circle.
 * @param {radius} Radius of the circle.
 * @param {color} Color used to draw the circle.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.drawCircumference = function (ctx, x, y, radius, color) {

    ctx.beginPath();
    ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
    ctx.strokeStyle = color;
    ctx.stroke();}

/**
 * Draw a bounding box.
 * @param {CanvasRenderingContext2D} Context used to draw the bounding box.
 * @param {THREE.Box2} Bounding box to be draw.
 * @param {color} Color used to draw the bounding box.
 * @param {alpha} Alpha used to draw the bounding box.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.drawBoundingBox = function (ctx, boundingBox, color, alpha) {

    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.rect(boundingBox.min.x, boundingBox.min.y, boundingBox.max.x - boundingBox.min.x, boundingBox.max.y - boundingBox.min.y);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.globalAlpha = 1;
}

/**
 * Calculates the initial position of marker group, that is, collisions with other markers are not resolved.
 * @param group Marker group that will be positioned.
 * @param modelCenter
 * @param modelMinX
 * @param modelMaxX
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.updateMarkerGroup = function (group, modelCenter, modelMinX, modelMaxX) {

    if (group.clipped) {

        group.x = group.proxyCenter.x;
        group.y = group.proxyCenter.y;

        this.restrainToViewerBounds(group);
    } else {

        this.placeOutsideModelBoundingBox(group, modelCenter, modelMinX, modelMaxX);
        if (!this.hasMinimumLength(group)) {
            this.placeOutsideModelBoundingBox(group, modelCenter, modelMinX, modelMaxX, !group.flip);
        }
    }
}

/**
 * Calculates and sets the proxies centers (node's bounding box center transformed and projected into client space
 * coordinates) to all marker groups.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.updateProxiesCenters = function () {

    var containerWidth = this.container.offsetWidth;
    var containerHeight = this.container.offsetHeight;

    var markerGroups = this.markerGroups;
    var markerGroupCount = markerGroups.length;

    for(var i = 0; i < markerGroupCount; ++i) {

        var markerGroup = markerGroups[i];
        var proxyCenter = this.getProxyCenter(markerGroup.fragId);

        markerGroup.proxyCenter = proxyCenter;

        markerGroup.visible =
            proxyCenter.y >= 0 && proxyCenter.y <= containerHeight;

        markerGroup.clipped = 
            proxyCenter.x < 0 || proxyCenter.x > containerWidth ||
            proxyCenter.y < 0 || proxyCenter.y > containerHeight;
    }

    var lines = this.lines;
    var lineCount = lines.length;

    for (var i = 0; i < lineCount; ++i) {

        var line = lines[i];
        line.proxyCenter = this.getProxyCenter(line.fragId);
    }
}

/**
 * Calculates and sets two bounding boxes for the marker group (htmlBoundingBox and wholeBoundingBox).
 * HtmlBoundingBox is a rectangle that fits only the HTML DOM node of the marker group.
 * WholeBoundingBox is a rectangle that fits the html bounding box and the marker proxy center.
 * @param group Marker group which bounding boxes will be updated.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.updateMarkerGroupBoundingBoxes = function (group) { 

    var htmlBoundingBox = group.htmlBoundingBox;
    var wholeBoundingBox = group.wholeBoundingBox;
    var min, max;

    // html bounding box
    min = htmlBoundingBox.min;
    max = htmlBoundingBox.max;

    min.x = Math.round(group.x + group.htmlOffset.x);
    min.y = Math.round(group.y + group.htmlOffset.y);
    max.x = min.x + group.htmlSize.x;
    max.y = min.y + group.htmlSize.y;

    htmlBoundingBox.width = max.x - min.x;
    htmlBoundingBox.height = max.y - min.y;

    // whole bounding box
    wholeBoundingBox.set(min, max);
    wholeBoundingBox.expandByPoint(group.proxyCenter);

    min = wholeBoundingBox.min;
    max = wholeBoundingBox.max;

    wholeBoundingBox.width = max.x - min.x;
    wholeBoundingBox.height = max.y - min.y;
}

/**
 * Search for overlaps between maker groups and changes theirs positions avoid overlappings.
 * @param {THREE.Vector2} modelCenter Transformed and projected into client space coordinates model's bounding box center.
 * @param {number} modelMinX Minimum x-axis value of the model's bounding box transformed and projected into client space coordinate.
 * @param {number} modelMaxX Maximum x-axis value of the model's bounding box transformed and projected into client space coordinate.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.resolveMarkersCollisions = function (modelCenter, modelMinX, modelMaxX) {

    var markerGroups = this.markerGroups;
    var markerGroupCount = markerGroups.length;
    var colliders = new Array();

    // try to avoid whole collisions
    for(var i = 0; i < markerGroupCount; ++i) {

        this.getMarkerGroupColliders(markerGroups[i], colliders, false);
        for (var j = 0; j < colliders.length; ++j)
        {
            var colliderA = markerGroups[i];
            var colliderB = colliders[j];

            this.placeOutsideModelBoundingBox(colliderA, modelCenter, modelMinX, modelMaxX, !colliderA.flip);

            if (this.hasMinimumLength(colliderA) &&
                !this.isMarkerGroupColliding(colliderA, false) &&
                !this.isMarkerGroupColliding(colliderB, false)) {
                continue;
            }

            this.placeOutsideModelBoundingBox(colliderA, modelCenter, modelMinX, modelMaxX, !colliderA.flip);
            this.placeOutsideModelBoundingBox(colliderB, modelCenter, modelMinX, modelMaxX, !colliderB.flip);

            if (this.hasMinimumLength(colliderB) &&
                !this.isMarkerGroupColliding(colliderA, false) &&
                !this.isMarkerGroupColliding(colliderB, false)) {
                continue;
            }

            this.placeOutsideModelBoundingBox(colliderB, modelCenter, modelMinX, modelMaxX, !colliderB.flip);
        }
    }

    // try to avoid html collisions
    for (var i = 0; i < markerGroupCount; ++i) {

        this.getMarkerGroupColliders(markerGroups[i], colliders, false);
        for (var j = 0; j < colliders.length; ++j) {

            var colliderA = markerGroups[i];
            var colliderB = colliders[j];

            // push markers outwards and move the one that has to move less distance to avoid collision
            var deltaA, deltaB, moduleA, moduleB;

            deltaA = this.getPushDeltaPosition(colliderA, true);
            deltaB = this.getPushDeltaPosition(colliderB, true);

            moduleA = Math.abs(deltaA);
            moduleB = Math.abs(deltaB);

            if (moduleA > 0 || moduleB > 0) {

                if (moduleA < moduleB) {
                    colliderA.x += deltaA;
                    this.setFlip(colliderA, colliderA.x > colliderA.proxyCenter.x);
                } else {    
                    colliderB.x += deltaB;
                    this.setFlip(colliderB, colliderB.x > colliderB.proxyCenter.x);
                }
                continue;
            }

            // push markers inwards and move the one that has to move less distance to avoid collision
            deltaA = this.getPushDeltaPosition(colliderA, false);
            deltaB = this.getPushDeltaPosition(colliderB, false);

            moduleA = Math.abs(deltaA);
            moduleB = Math.abs(deltaB);

            if (moduleA > 0 || moduleB > 0) {

                if (moduleA < moduleB) {
                    colliderA.x += deltaA;
                    this.setFlip(colliderA, colliderA.x > colliderA.proxyCenter.x);
                } else {
                    colliderB.x += deltaB;
                    this.setFlip(colliderB, colliderB.x > colliderB.proxyCenter.x);
                }
                continue;
            }
        }
    }
}

/**
 * Sets flip state adjusting html size and offset accordingly to the marker flip direction. Also, updates marker group bounding boxes.
 * @param group Marker groups whose flip state will be updated.
 * @param {boolean} flip Flip state to be applied.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.setFlip = function (group, flip)
{
    group.flip = flip;

    var firstHtml = group[0].html;

    group.htmlSize.x = firstHtml.offsetWidth * group.length;
    group.htmlSize.y = firstHtml.offsetHeight;

    group.htmlOffset.x = group.flip ? -firstHtml.offsetWidth * 0.5 : firstHtml.offsetWidth * 0.5 - group.htmlSize.x;
    group.htmlOffset.y =-firstHtml.offsetHeight * 0.5;


    group.htmlSize.x = firstHtml.offsetWidth * group.length;
    group.htmlSize.y = firstHtml.offsetHeight;

    group.htmlOffset.x = group.flip ? -firstHtml.offsetWidth * 0.5 : firstHtml.offsetWidth * 0.5 - group.htmlSize.x;
    group.htmlOffset.y =-firstHtml.offsetHeight * 0.5;

    this.updateMarkerGroupBoundingBoxes(group);
}

/**
 * Returns the minimum delta position a marker has to be moved so its html bounding box doesn't collide with other
 * html bounding boxes. The new position si calculated moving the marker outwards or inwards to center of the model (as
 * specified by the caller). If it's not possible to get a new position for the marker 0 is returned.
 * @param group
 * @param {boolean} outwards True if the marker group should be moved outwards the model, false, otherwise.
 * @returns {number} The delta position the model has to be moved to avoid overlappings with other marker groups.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.getPushDeltaPosition = function (group, outwards)
{
    var direction = (outwards ? 1 : -1) * (group.flip ? 1 : -1);
    var directionStep = direction * 20;
    var deltaPosition = 0;
    
    while (true) {

        group.x += directionStep;
        deltaPosition += directionStep;
        this.updateMarkerGroupBoundingBoxes(group);

        if (this.isHtmlOutsideBounds(group)) {

            group.x -= deltaPosition;
            this.updateMarkerGroupBoundingBoxes(group);
            return 0;
        }

        if (this.hasMinimumLength(group)) {

            if (!this.isMarkerGroupColliding(group, true)) {

                group.x -= deltaPosition;
                this.updateMarkerGroupBoundingBoxes(group);
                return deltaPosition;
            }
        }
    }
}

/**
 * Checks if the HTML DOM Node of the marker groups lays outside the HTML Bounds of the viewer. The HTML Bound of the
 * viewer is and area shrinked by a fixed margin of the client area of the viewer. Markers that are not clipped stays
 * inside the  html bound. A marker is marked as clipped if its proxy center lays out outside the Viewer client area.
 * @param group Marker group used for the test.
 * @returns {boolean} True if the marker html bounding box lays totally inside html bounds.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.isHtmlOutsideBounds = function (group) {

    var htmlBounds = this.htmlBounds;
    var htmlBoundingBox = group.htmlBoundingBox;

    var htmlBoundsMinX = htmlBounds.min.x;
    var htmlBoundsMaxX = htmlBounds.max.x;

    if (group.htmlBoundingBox.isIntersectionBox(this.modelMarkersBoundingBox)) {
        htmlBoundsMinX = this.modelMarkersBoundingBox.max.x;
    }

    if (htmlBoundingBox.max.x > htmlBoundsMaxX) {
        return true;
    }

    if (htmlBoundingBox.min.x < htmlBoundsMinX) {
        return true;
    }
    return false;
}

/**
 * Snap clipped marker group position to the Viewer client area's borders.
 * @param group Marker groups whose position will be restrained.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.restrainToViewerBounds = function (group) {

    var viewerBounds = this.viewerBounds;

    if (group.proxyCenter.x < viewerBounds.min.x) {

        group.x = viewerBounds.min.x;
        this.setFlip(group, false);
        return;
    }

    if (group.proxyCenter.x > viewerBounds.max.x) {

        group.x = viewerBounds.max.x;
        this.setFlip(group, true);
        return;
    }
}

/**
 * Place marker group trying to avoid overlapping with model geometry.
 * @param group Marker group whose position will be updated.
 * @param modelCenter Model's bounding box center transformed and projected into client space coordinates.
 * @param modelMinX Minimum x-axis value of the model's bounding box transformed and projected into client space coordinate.
 * @param modelMaxX Maximum x-axis value of the model's bounding box transformed and projected into client space coordinate.
 * @param [flip] If provided marker will use this flip state, otherwise, flip state will be calculated.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.placeOutsideModelBoundingBox = function (group, modelCenter, modelMinX, modelMaxX, flip) {

    group.distanceFromCenter = Math.abs(group.proxyCenter.x - modelCenter.x);

    var canditatePositionA = group.distanceFromCenter * 0.5 + modelMaxX;
    var canditatePositionB =-group.distanceFromCenter * 0.5 + modelMinX;

    if (flip === undefined) {

        if (modelMinX < this.htmlBounds.min.x ||
            modelMaxX > this.htmlBounds.max.x) {

            flip = modelMinX < this.htmlBounds.min.x;
        } else {

            flip =
                Math.abs(group.proxyCenter.x - canditatePositionA) <
                Math.abs(group.proxyCenter.x - canditatePositionB);
        }
    }

    group.x = flip ? canditatePositionA : canditatePositionB;
    group.y = group.proxyCenter.y;
    this.setFlip(group, flip);

    // calculate html size and offset
    if (!this.hasMinimumLength(group)) {

        group.x = group.proxyCenter.x + (this.minimumGroupMarkerWidth + group.htmlSize.x) * (group.flip ? 1 : -1);
        this.updateMarkerGroupBoundingBoxes(group);
    }

    this.restrainToHtmlBounds(group);
}

/**
 * Snap clipped marker group position to the Viewer html bounds.
 * @param group Marker groups whose position will be restrained.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.restrainToHtmlBounds = function (group) {

    var htmlBounds = this.htmlBounds;
    var htmlBoundingBox = group.htmlBoundingBox;

    var htmlBoundsMinX = htmlBounds.min.x;
    var htmlBoundsMaxX = htmlBounds.max.x;

    if (group.htmlBoundingBox.isIntersectionBox(this.modelMarkersBoundingBox)) {
        htmlBoundsMinX = this.modelMarkersBoundingBox.max.x;
    }

    if (htmlBoundingBox.max.x > htmlBoundsMaxX) {
        group.x = htmlBoundsMaxX - group.htmlOffset.x - group.htmlSize.x;
        this.updateMarkerGroupBoundingBoxes(group);
        return;
    }

    if (htmlBoundingBox.min.x < htmlBoundsMinX) {
        group.x = htmlBoundsMinX - group.htmlOffset.x;
        this.updateMarkerGroupBoundingBoxes(group);
        return;
    }
}

/**
 * Checks if the marker group line has the minimum length allowed.
 * @param group Marker group whose length will be tested.
 * @returns {boolean} True if marker group's line has the minimum length.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.hasMinimumLength = function (group) {

    return group.clipped || (group.wholeBoundingBox.width - group.htmlBoundingBox.width) >= this.minimumGroupMarkerWidth;
}

/**
 * Sort markers groups from top to bottom.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.sortMarkerGroups = function () {

    function comparer(groupA, groupB) {

        if(groupA.proxyCenter.y < groupB.proxyCenter.y) {
            return-1;
        }

        if(groupA.proxyCenter.y > groupB.proxyCenter.y) {
            return 1;
        }

        return 0;
    }

    this.markerGroups.sort(comparer);
}

/**
 * Get all group markers overlapping with the one provided by the caller.
 * @param group Marker group that will be tested against all others.
 * @param {Array} Collection to be filled with overlapping markers.
 * @param checkHTMLOnly Indicates if html bounding boxes or whole bounding boxes have to be used for overlapping tests.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.getMarkerGroupColliders = function (group, colliders, checkHTMLOnly) {

    var markerGroups = this.markerGroups;
    var markerGroupCount = markerGroups.length;

    colliders.splice(0, colliders.length);

    if (group.clipped) {
        return;
    }

    for(var i = 0; i < markerGroupCount; ++i) {

        var markerGroup = markerGroups[i];

        if(markerGroup === group) {
            continue;
        }

        if (markerGroup.clipped) {
            continue;
        }

        if (checkHTMLOnly) {

            if(markerGroup.htmlBoundingBox.isIntersectionBox(group.htmlBoundingBox)) {
                colliders.push(markerGroup);
            }
        }
        else {

            if(markerGroup.wholeBoundingBox.isIntersectionBox(group.wholeBoundingBox)) {
                colliders.push(markerGroup);
            }
        }
    }
}

/**
 * Checks if a marker group is overlapping with any other.
 * @param group Marker group that will be tested against all others.
 * @param checkHTMLOnly Indicates if html bounding boxes or whole  bounding boxes have to be used for overlapping tests.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.isMarkerGroupColliding = function (group, checkHTMLOnly) {

    var markerGroups = this.markerGroups;
    var markerGroupCount = markerGroups.length;

    if (group.clipped) {
        return false;
    }

    // check against node markers
    for(var i = 0; i < markerGroupCount; ++i) {

        var markerGroup = markerGroups[i];

        if(markerGroup === group) {
            continue;
        }

        if (markerGroup.clipped) {
            continue;
        }

        if (checkHTMLOnly) {

            if(markerGroup.htmlBoundingBox.isIntersectionBox(group.htmlBoundingBox)) {
                return true;
            }
        }
        else {

            if(markerGroup.wholeBoundingBox.isIntersectionBox(group.wholeBoundingBox)) {
                return true;
            }
        }
    }
    return false;
}

/**
 * Gets the extension state as a plain object. Intended to be called when viewer state is requested.
 *
 * @param {Object} viewerState - Object to inject extension values.
 *
 * Virtual method can be implemented in subclass
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.getState = function( viewerState ) {

    if (!viewerState.objectSet) {
        viewerState.objectSet = new Array();
    }

    // only markups state is saved
    var markups = this.markups;
    var markupCount = this.markups.length;

    for (var i = 0; i < markupCount; ++i) {

        var markup = markups[i];
        var markupPath = markup.path;
        var markupPathCount = markupPath.length;

        // collapse path into string
        var markupStringPath = markupPath[0];
        for (var j = 1; j < markupPathCount; ++j) {

            markupStringPath += " " + markupPath[j].toString();
        }

        var markup = {
            id: "Autodesk.Markers.Markup",
            path: markupStringPath,
            strokeColor: markup.strokeColor,
            strokeWidth: markup.strokeWidth
        }

        viewerState.objectSet.push(markup);
    }
}

/**
 * Restores the extension state from a given object.
 *
 * @param {Object} viewerState
 * @param {boolean} [immediate] - Whether the new view is applied with (true) or without transition (false)
 *
 * @returns {boolean} true if restore operation was successful.
 *
 * Virtual method can be implemented in subclass
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkers.prototype.restoreState = function (viewerState, immediate) {

    if (!viewerState.objectSet) {
        return true;
    }

    this.markups.splice(0,this.markups.length);

    var objectSet = viewerState.objectSet;
    var objectSetCount = objectSet.length;

    for (var i = 0; i < objectSetCount; ++i) {

        var markup = objectSet[i];
        if (markup.id != "Autodesk.Markers.Markup") {
            continue;
        }

        if(!markup.path || !markup.strokeColor || !markup.strokeWidth) {
            this.markups.splice(0,this.markups.length);
            return false;
        }

        var markupPath = markup.path.split(" ");
        var markupPathCount = markupPath.length;

        for( var j = 0; j < markupPathCount; ++j) {

            if(markupPath[j] == "M" || markupPath[j] == "L" || markupPath[j] == "z") {
                continue;
            }
            markupPath[j] = parseFloat(markupPath[j]);
        }

        this.markups.push({
            path: markupPath,
            strokeWidth: markup.strokeWidth,
            strokeColor: markup.strokeColor });
    }

    return true;
}

/**
 * Register the extension with the extension manager.
 */
Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Markers', Autodesk.Viewing.Extensions.Markers.ViewerMarkers);
;AutodeskNamespace('Autodesk.Viewing.Extensions.Markers');

/**
 * Constructs a ViewerMarkups object. ViewerMarkups is an extension to viewer that permits the user to draw
 * markups over the viewer view. In this class resides all the logic for the markup drawing process, ViewerMarker is
 * the responsible of actually draw the markups over its canvas.
 * @param {Autodesk.Viewing.Viewer} viewer
 * @constructor
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups = function (viewer) {

    Autodesk.Viewing.Extension.call(this, viewer);
}

Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.constructor = Autodesk.Viewing.Extensions.Markers.ViewerMarkups;

/**
 * Initializes the extension and create its needed resources.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.load = function () {

    this.container = this.viewer.container;

    this.mDrawing = false;
    this.mCurrentMarkupIndex = 0;
    this.mCurrentStrokeWidth = 1;
    this.mCurrentStrokeColor = "#FFFFFF";
    this.mOnFinishCallback = null;

    this.mCurrentMarkupIndex = -1;
    this.mCurrentRectangleIniPoint = new THREE.Vector2();

    // We only support Viewer3D. Bail out early if not.
    if (!(this.viewer instanceof Autodesk.Viewing.Viewer3D)) {
        return false;
    }

    this.markupsDiv = document.createElement("div");
    this.markupsDiv.id = "markups";
    this.markupsDiv.style.left = 0;
    this.markupsDiv.style.top = 0;
    this.markupsDiv.style.right = 0;
    this.markupsDiv.style.bottom = 0;
    this.markupsDiv.style.width = "100%";
    this.markupsDiv.style.height = "100%";
    this.markupsDiv.style.backgroundColor = "transparent";
    this.markupsDiv.style.position = "absolute";
    this.markupsDiv.style.zIndex = 10;

    this.markupsDiv.addEventListener("mousemove", this.onMouseMove.bind(this));
    this.markupsDiv.addEventListener("mouseup", this.onMouseUp.bind(this));

    // add message
    var message = document.createElement("div");
    message.className = "markups-message-container";
    message.innerText = Autodesk.Viewing.i18n.translate("View is locked during mark-up.");
    message.setAttribute("data-i18n", "View is locked during mark-up.");
    this.markupsDiv.appendChild(message);

    // add cancel button
    var button = document.createElement("reset");
    button.className = "markups-cancel-button";
    button.innerText = Autodesk.Viewing.i18n.translate("Cancel");
    button.setAttribute("data-i18n", "Cancel");
    button.addEventListener("mouseup", this.onMarkupCancelClick.bind(this));
    button.addEventListener("mousemove", this.onMarkupCancelMove.bind(this));
    this.markupsDiv.appendChild(button);

    return true;
}

/**
 * Dispose resources created for this extension and remove event listeners.
 * @returns {boolean} True if unloading was successful
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.unload = function () {

    // remove event listeners

    if (this.markupsDiv.parentNode) {
        this.markupsDiv.parentNode.removeChild(this.markupsDiv);
    }

    return true;
}

/**
 * Starts to draw a rectangle. First click sets a corner of the rectangle at the mouse position point, a second click
 * ends the rectangle with its opposite diagonal corner at the new mouse position.
 * @param {number} strokeWidth Width of the stroke used to draw the rectangle.
 * @param {string} strokeColor Color of the stroke used to draw the rectangle.
 * @param {function(canceled)} [onFinishCallback] If provided, the function is called when user ends drawing the
 * rectangle. If drawing was canceled, true is passes as parameter to the function, otherwise, false.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.startRectangle = function(strokeWidth, strokeColor, onFinishCallback) {

    if (!this.startDrawing(strokeWidth, strokeColor, onFinishCallback)) {
        return;
    }
    this.mCurrentMarkupIndex = -1;
}

/**
 * Clears all markups.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.clear = function() {

    this.markers.clearMarkups();
}

/**
 * Starts drawing a markup. This function groups common code shared when drawing different types of markups.
 * @param {number} strokeWidth Width of the stroke used to draw the rectangle.
 * @param {string} strokeColor Color of the stroke used to draw the rectangle.
 * @param  {function(calceled)} [onFinishCallback]
 * @returns {boolean} True if function succeeds If provided, the function is called when user ends drawing the
 * rectangle. If drawing was canceled, true is passes as parameter to the function, otherwise, false.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.startDrawing = function(strokeWidth, strokeColor, onFinishCallback) {

    if(this.mDrawing) {
        return false;
    }

    // set drawing attributes
    this.mDrawing = true;
    this.mCurrentMarkupIndex = -1;
    this.mCurrentStrokeWidth = strokeWidth;
    this.mCurrentStrokeColor = strokeColor;
    this.mOnFinishCallback = onFinishCallback;

    this.mCurrentMarkups = this.markers.markups.slice(); // used to restore the state previous drawing

    // add markups div at the top of all extensions and tools, all interaction the viewer is suspended until
    // user stops drawing.
    this.container.appendChild(this.markupsDiv);

    return true;
}

/**
 * Starts drawing a markup. This function groups common code shared when drawing different types of markups.
 * @param {boolean} canceled True if drawing was canceled by user.
 * @returns {boolean} True if function succeeds.
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.endDrawing = function(canceled) {

    if (!this.mDrawing) {
        return false;
    }

    this.mDrawing = false;
    this.mCurrentMarkupIndex = -1;

    // restore previous markups if drawing was canceled.
    if (canceled) {
        var markups = this.mCurrentMarkups;
        var markupCount = markups.length;
        
        for (var i= 0; i < markupCount; ++i) {
            this.markers.markups.push(markups[i]);
            this.markers.update();
        }
    }

    // remove markups div so input can be processed by viewer and its tools and panels again.
    this.markupsDiv.parentNode.removeChild(this.markupsDiv);

    // finished drawing, invoke callback
    if (this.mOnFinishCallback) {
        this.mOnFinishCallback(canceled);
    }

    return true;
}

/**
 * Handled to create markups.
 * @param event
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.onMouseMove = function(event) {

    if (this.mCurrentMarkupIndex == -1) {
        return;
    }

    var mouseX = event.layerX;
    var mouseY = event.layerY;

    var x = Math.min(this.mCurrentRectangleIniPoint.x, mouseX);
    var y = Math.min(this.mCurrentRectangleIniPoint.y, mouseY);
    var w = Math.abs(this.mCurrentRectangleIniPoint.x -mouseX);
    var h = Math.abs(this.mCurrentRectangleIniPoint.y -mouseY);

    this.markers.setRectangularMarkup(
        this.mCurrentMarkupIndex,
        x,
        y,
        w,
        h,
        this.mCurrentStrokeWidth,
        this.mCurrentStrokeColor);
}

/**
 * Handled to create markups.
 * @param event
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.onMouseUp = function(event) {

    if (!this.markers) {
        this.endDrawing(true);
        return;
    }

    // first mouse up creates markup, second finish it.
    if (this.mCurrentMarkupIndex == -1) {

        var mouseX = event.layerX;
        var mouseY = event.layerY;

        this.mCurrentRectangleIniPoint = new THREE.Vector2(mouseX,mouseY);
        this.mCurrentMarkupIndex = this.markers.addRectangularMarkup(
            mouseX,
            mouseY,
            1,
            1,
            this.mCurrentStrokeWidth,
            this.mCurrentStrokeColor);
    } else {

        this.onMouseMove(event);
        this.endDrawing(false);
    }
}

/**
 * Cancel current markup drawing.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.onMarkupCancelClick = function () {

    event.cancelBubble = true;
    event.preventDefault();

    if (this.mCurrentMarkupIndex != -1) {
        this.markers.removeMarkupAt(this.mCurrentMarkupIndex);
    }

    this.endDrawing(true);
}

/**
 * Stops event from bubble if mouse is over the cancel button.
 * @param event
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.onMarkupCancelMove = function (event) {

    event.cancelBubble = true;
    event.preventDefault();
}

/**
 * Returns markers extension.
 * @private
 */
Autodesk.Viewing.Extensions.Markers.ViewerMarkups.prototype.__defineGetter__('markers', function () {
    return this.viewer.loadedExtensions['Autodesk.Markers'];
} );

/**
 * Register the extension with the extension manager.
 * @private
 */
Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Markups', Autodesk.Viewing.Extensions.Markers.ViewerMarkups);;
AutodeskNamespace('Autodesk.Viewing.Extensions');

// Events
Autodesk.Viewing.TOGGLE_COMMENT_PANEL = 'toggleCommentPanel'; // dispatched when the panel should be toggled open or closed
Autodesk.Viewing.UNLOAD_COMMENT_PANEL = 'unloadCommentPanel'; // dispatched when the panel is unloaded

/**
 * CommentingExtension loads comments associated with a URN and then adds markers to the view to show
 * which nodes those comments apply to.  It also creates a CommentPanel (either docking or out of the viewer)
 * as defined by the options parameter.  A new button is added to the UI as well for opening this panel.
 * 
 * Properties that can be used in the options include:
 * parentContainerId - optional - if an id is provided, the CommentPanel is added to that div, otherwise
 * it is added to a DockingPanel
 * createUI - optional - if a function is provided, it is called to create the UI for opening the panel, otherwise
 * the default functionality for opening the panel is used
 * destroyUI - optional - if a function is provided, it is called to destroy the UI for opening the panel when
 * the Extension is unloaded, otherwise the default functionality for destroying the panel UI is used
 */
Autodesk.Viewing.Extensions.Commenting = function (viewer, options) {
    
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

Autodesk.Viewing.Extensions.Commenting.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Commenting.prototype.constructor = Autodesk.Viewing.Extensions.Commenting;

/**
 * Override load to create the CommentPanel and Markers.  It can be created either
 * inside or ouside the viewer depending on the options that have been specified
 */
Autodesk.Viewing.Extensions.Commenting.prototype.load = function () {

    // We only support Viewer3D. Bail out early if not.
    if (!(this.viewer instanceof Autodesk.Viewing.Viewer3D)) {
        return false;
    }

    this.inViewer = (!this.options || !this.options['parentContainerId']);
    var self = this;
    
    if(this.inViewer) {
        this.dockingPanel = new Autodesk.Viewing.Extensions.Commenting.DockingCommentPanel(this.viewer);
        this.panel = this.dockingPanel.commentPanel;
        this.viewer.addPanel(this.dockingPanel);
    } else {
        var parentContainerId = this.options['parentContainerId'];
        var commentPanelDelegate = new Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate();
        this.panel = new Autodesk.Viewing.Extensions.Commenting.CommentPanel(commentPanelDelegate, this.viewer, parentContainerId);
    }
    
    // load the comments
    this.viewer.addEventListener(Autodesk.Viewing.PROGRESS_UPDATE_EVENT, onViewerProgress);
    
    function onViewerProgress(e) {
        if(e.percent >= 100) {
            self.viewer.removeEventListener(Autodesk.Viewing.PROGRESS_UPDATE_EVENT, onViewerProgress);
            self.panel.requestComments();
        }
    }
    
    // add the button to the toolbar
    if(this.viewer.modelTools && this.viewer.modelTools.getToolCount() > 0) {
        onToolbarCreated();
    } else {
        this.viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
    }
    
    function onToolbarCreated(e) {
        self.viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
        self.createUI();
    }

    return true;
};

/**
 * Override unload to remove the CommentPanel and Markers
 */
Autodesk.Viewing.Extensions.Commenting.prototype.unload = function () {
    this.panel.destroy();
    
    if(this.dockingPanel) {
        this.viewer.removePanel(this.dockingPanel);
        this.dockingPanel.uninitialize();
    }

    this.destroyUI();
    this.inViewer = false;
    
    this.panel = null;
    this.dockingPanel = null;
    
    this.viewer.fireEvent({type: Autodesk.Viewing.UNLOAD_COMMENT_PANEL});
    
    return true;
};

/**
 * Creates the UI by adding the Comment button to the toolbar.  To use a different createUI method,
 * on loading the extension, pass in a createUI method in the options
 */
Autodesk.Viewing.Extensions.Commenting.prototype.createUI = function() {
    // Disable in viewer comment button to avoid any confusions.
    // The comment panel A360 / Fusion is going to use is here
    // https://git.autodesk.com/A360/comment.js
    return;

    // if a destroyUI function is provided, use that one
    if(this.options["createUI"] && typeof this.options["createUI"] === "function") {
        this.options["createUI"].call(this);
        return;
    }
    
    // Otherwise use the default createUI functionality
    var self = this;

    var toolbar = this.viewer.getToolbar(true);
    var modelTools = toolbar.getSubToolbarById( Autodesk.Viewing.TOOLBAR.MODELTOOLSID );

    // Create a comment toolbar button.
    this.commentButton = Autodesk.Viewing.UI.Toolbar.createMenuButton("toolbar-commentTool", "Comments and Markers", function(e) {
        var isVisible = self.panel.isVisible();
        self.panel.setVisible(!isVisible);
        if (!isVisible)
            modelTools.select(self.commentButton.id);
        else
            modelTools.deselect(self.commentButton.id);
    });

    // Insert the comment button before "setting" button.
    var settingsTool = modelTools.getTool("toolbar-settingsTool");
    if (settingsTool)
        modelTools.insertToolBefore( this.commentButton, settingsTool );
    else
        modelTools.addTool( this.commentButton );
};

/**
 * Destroys the UI by removing the comment button from the toolbar.  If a different createUI
 * method is used other than the default, a new destroyUI function should be used as well.
 */
Autodesk.Viewing.Extensions.Commenting.prototype.destroyUI = function() {
    // if a destroyUI function is provided, use that one
    if(this.options["destroyUI"] && typeof this.options["destroyUI"] === "function") {
        this.options["destroyUI"].call(this);
        return;
    }
    
    // otherwise use the default destroyUI functionality
    // remove the comment button
    if(this.commentButton) {
        var toolbar = this.viewer.getToolbar(false);
        if (toolbar)
            toolbar.removeFromSubToolbar( Autodesk.Viewing.TOOLBAR.MODELTOOLSID, this.commentButton );
    }
};

/**
 * Register the extension with the extension manager.
 */
Autodesk.Viewing.theExtensionManager.registerExtension('Commenting', Autodesk.Viewing.Extensions.Commenting);;'use strict';
AutodeskNamespace('Autodesk.Viewing.Extensions');

/**
 * Comment Panel control delegate
 * This class allows you to customize the behavior of the comment panel.
 * Override the methods you want and pass an instance of this class to
 * the Comment Panel constructor.
 * @constructor
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate = function () {
};

Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate.prototype.constructor = Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate;

////////////////////////////////////////////////////////////////////////////

/**
 * Override this method to do something when the user clicks on a comment marker
 * @param {panel} panel
 * @param {Object} comment - The comment data
 * @param {Event} event
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate.prototype.onCommentMarkerClick = function (panel, comment) {

    if(panel.selectedComment != comment) {
        if(panel.selectedComment) {
            // clear the previously selected checkbox
            var clearLine = true;
            panel.clearSelectedSnapshot(clearLine);
        }
        panel.restoreCommentSnapshot(comment);
        panel.addCommentAnimationUpdateInterval(comment);
    } else {
        if(panel.selectedComment) {
            // don't clear the line because still hovering over the marker
            panel.clearSelectedSnapshot();
        }
    }
};

/**
 * Override this to do something when the user enters a comment marker
 * @param {Autodesk.Viewing.Extensions.Commenting.CommentPanel} panel
 * @param {Object} node - Node in the model Document
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate.prototype.onCommentMarkerEnter = function (panel, comment) {
    
    var commentDiv = document.getElementById("comment-panel-entry-" + comment.id);
    if(panel.selectedComment) {      
        if(panel.selectedComment.id != comment.id) {
            panel.hideCommentLine(panel.selectedComment);
        }
    }
    
    panel.drawCommentLine(comment, commentDiv);
};

/**
 * Override this to do something when the user leaves a comment marker
 * @param {Autodesk.Viewing.Extensions.Commenting.CommentPanel} panel
 * @param {Object} comment - data associated with a comment
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate.prototype.onCommentMarkerLeave = function (panel, comment) {
    
    if(panel.selectedComment) {
        if(panel.selectedComment != comment) {
            // hide the hovered comment's line
            panel.hideCommentLine(comment);
            
            // restore the selected comment's line, but don't restore an entire highlight
            if(panel.selectedComment["node-id"]) {
                var commentDiv = document.getElementById("comment-panel-entry-" + panel.selectedComment.id);
                panel.drawCommentLine(panel.selectedComment, commentDiv);
            }
            
        } else { // hide the whole model outline
            if(!comment["node-id"]) {
                panel.hideCommentLine(comment);
            }
        }
    } else {
        panel.hideCommentLine(comment);
    }
};

////////////////////////////////////////////////////////////////////////////

/**
 * Override this method to do something when the user clicks on a viewer marker
 * @param {Autodesk.Viewing.Extensions.Commenting.CommentPanel} panel
 * @param {Object} comment - The comment data
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate.prototype.onViewerMarkerClick = function (panel, comment) {
    
    if(!panel.isVisible()) {
        panel.setVisible(true);
        panel.scrollToComment(comment);
    }
    
    if(panel.selectedComment != comment) {
        if(panel.selectedComment) {
            panel.clearSelectedSnapshot();
        }
        panel.restoreCommentSnapshot(comment);
        panel.addCommentAnimationUpdateInterval(comment);
           
        var commentDiv = document.getElementById("comment-panel-entry-" + comment.id);
        panel.drawCommentLine(comment, commentDiv);
        
    } else {
        panel.clearSelectedSnapshot();
        
        if(comment["node-id"]) {
            panel.markers.clearHighlightedNodes();
        } else {
            panel.markers.setModelHighlight(false);
        }
    }
};

/**
 * Override this to get the panel's visibility
 * @param {Autodesk.Viewing.Extensions.Commenting.CommentPanel} panel
 * @returns {boolean}
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate.prototype.isVisible = function (panel) {
    var rootContainer = document.getElementById(panel.rootContainerId);
    return rootContainer.style.display === 'block';
};

/**
 * Override this to get the panel's set visibility
 * By default hides the root container
 *
 * @param {Autodesk.Viewing.Extensions.Commenting.CommentPanel} panel
 * @param {boolean} visible
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate.prototype.setVisible = function (panel, visible) {
    var rootContainer = document.getElementById(panel.rootContainerId);
    if (visible) {
        rootContainer.style.display = 'block'; // TODO: want fade in
        panel.markers.setVisible(false);
    } else {
        rootContainer.style.display = 'none';
        panel.clearSelectedSnapshot(true);
        panel.markers.setVisible(true);
    }
    
    panel.viewer.fireEvent({type: Autodesk.Viewing.TOGGLE_COMMENT_PANEL, visible:visible});
};

/**
 * Comment Panel view control
 * @constructor
 * @param {Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate} delegate
 * @param {Autodesk.Viewing.Viewer3D} viewer
 * @param {HTMLElement|string} parentContainer - Or parentContainerId
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel = function (delegate, viewer, parentContainer) {

    this.VIEWER_STATE_FILTER = true;    // Gathers all viewer state data available
    this.RESTORE_IS_IMMEDIATE = false;  // We want to animate towards the restored state (ex: camera lerps)

    this.myDelegate = delegate;
    this.viewer = viewer;
    
    this.commentList = [];
    this.nextCommentId = 1;
    this.commentsRequested = false;

    this.selectedComment = null;

    this.buildPanel(delegate, parentContainer);
};

Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.constructor = Autodesk.Viewing.Extensions.Commenting.CommentPanel;

/**
 * Constructs the panel UI
 * @param {Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate} delegate
 * @param {HTMLElement|string} parentContainer - Or parentContainerId
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.buildPanel = function(delegate, parentContainer) {
    
    var self = this;
    var parentContainerId;
    if (typeof parentContainer === 'string') {
        parentContainerId = parentContainer;
        parentContainer = document.getElementById(parentContainerId);
    } else {
        parentContainerId = parentContainer.id;
    }

    var className = 'comment-panel-wrapper';
    this.parentContainerId = parentContainerId;
    this.rootContainerId = parentContainerId + '-' + className;

    var rootContainer = document.createElement('div');
    rootContainer.id = this.rootContainerId;
    rootContainer.className = className;
    parentContainer.appendChild(rootContainer);

    var commentBoxContainer = document.createElement('div');
    commentBoxContainer.className = 'comment-panel-container';

    var commentBox = document.createElement('textarea');
    commentBox.name = 'text';
    commentBox.className = 'comment-panel-post-textarea';
    commentBox.placeholder = Autodesk.Viewing.i18n.translate('Comment');
    commentBox.setAttribute("data-i18n", "[placeholder]Comment");

    var submitButton = document.createElement('input');
    submitButton.type = 'submit';
    submitButton.value = Autodesk.Viewing.i18n.translate('Post');
    submitButton.className = 'comment-panel-post-button';
    submitButton.setAttribute("data-i18n", "[value]Post" );

    // tools
    var markupDiv = null; // TODO: Check whether markup extension is available.
    markupDiv = document.createElement('table');
    var tblBody = document.createElement('tbody');
    var row1 = document.createElement('tr');
    {
        // Tool 1 - Draw
        var markupDrawTool = document.createElement('td');
        markupDrawTool.className = "comment-markup-button";
        var markupDrawToolImg = document.createElement('img');
        markupDrawToolImg.src = RESOURCE_ROOT + "icons/markup_draw.png";
        markupDrawTool.appendChild(markupDrawToolImg);
        row1.appendChild(markupDrawTool);
        markupDrawTool.addEventListener('click', function() {
            this.markups.startRectangle( 3, "#FFFFFF");
            this.markups.clear(); // for now, we clear all previous markups. We clear after start drawing so a cancel call
                                  // can restore the markups previous to start drawing.
        }.bind(this));

        // Tool 2 - Clear
        var markupClearTool = document.createElement('td');
        markupClearTool.className = "comment-markup-button";
        var markupClearToolImg = document.createElement('img');
        markupClearToolImg.src = RESOURCE_ROOT + "icons/markup_erase.png";
        markupClearTool.appendChild(markupClearToolImg);
        row1.appendChild(markupClearTool);
        markupClearTool.addEventListener('click', function() {
            this.markups.clear();
        }.bind(this));
    }
    tblBody.appendChild(row1);
    markupDiv.appendChild(tblBody);

    commentBoxContainer.appendChild(commentBox);
    commentBoxContainer.appendChild(submitButton);
    if (markupDiv) {
        commentBoxContainer.appendChild(markupDiv);
    }

    var displayCommentContainer = document.createElement('div');
    displayCommentContainer.className = 'comment-panel-entry-container';

    rootContainer.appendChild(commentBoxContainer);
    rootContainer.appendChild(displayCommentContainer);

    // add event listeners
    var submitClickHandler = function(){
        self.onPostClick(self);
    }
    submitButton.addEventListener("click", submitClickHandler);

    var commentKeyHandler = function(e) {
        if(e.keyCode == 13) {
            self.onPostClick(self);
        }
    };
    commentBox.addEventListener ("keypress", commentKeyHandler);
    
    var scrollHandler = function(e) {
        if(self.selectedComment && self.selectedComment["node-id"]) {
            var selectedCommentDiv = document.getElementById("comment-panel-entry-" + self.selectedComment.id);
            self.drawCommentLine(self.selectedComment, selectedCommentDiv);
        }
    };
    rootContainer.addEventListener("scroll", scrollHandler);
      
    this.clearEventListeners = function() {
        submitButton.removeEventListener("click", submitClickHandler);
        commentBox.removeEventListener ("keypress", commentKeyHandler);
        rootContainer.removeEventListener("scroll", scrollHandler);
    }
    
    this.postTextArea = commentBox;
    this.commentEntryContainer = displayCommentContainer;
};

/**
 * Destroys the panel
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.destroy = function () {
    
    this.clearEventListeners();
    this.clearEventListeners = null;
    var i,len;
    for (i = 0, len = this.commentList.length; i<len; ++i) {
        var comment = this.commentList[i];
        var display = document.getElementById("comment-panel-entry-" + comment.id);
        display.removeListeners();
        this.markers.removeMarker("marker-" + comment.id);
    }
    
    this.commentList = null;
    this.nextCommentId = 1;
    this.commentsRequested = false;
    this.selectedComment = null;
    
    this.postTextArea = null;
    this.commentEntryContainer = null;
    
    var parentContainer = document.getElementById(this.parentContainerId);
    var rootContainer = document.getElementById(this.rootContainerId);
    
    this.parentContainerId = null;
    this.rootContainerId = null;
    
    parentContainer.removeChild(rootContainer);
    
    Autodesk.Viewing.Extensions.Commenting.CommentStorage.destroy();
};

/**
 * Get the comment panel delegate
 * @returns {Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate}
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.delegate = function () {
    return this.myDelegate;
};

/**
 * Gets the comment panel's visibility
 * @returns {Boolean}
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.isVisible = function() {
    return this.myDelegate.isVisible(this);
};

/**
 * Sets the comment panel's visibility
 * @param {boolean} visible
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.setVisible = function(visible) {
    this.myDelegate.setVisible(this, visible);
};

/**
 * Renders a comment from the existing state of the viewer and UI and then saves the comment
 * @param scope
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.onPostClick = function(scope) {

    // Abort if no text
    if (scope.postTextArea.value === "") {
        return;
    }

    var comment = scope.createComment();
    scope.renderComment(scope, comment);
    // scope.serializeComment(scope, comment);
    Autodesk.Viewing.Extensions.Commenting.CommentStorage.saveComment(comment);
};

/**
 * Renders a comment reply from the text in the selected comment's UI and then saves the comment
 * @param {Object} comment - The comment data
 * @param {HTMLElement} responseContainer - Contains all the response divs for a comment
 * @param {HTMLElement TextArea} responseTextArea - The textArea for that comment's response section
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.onPostResponseClick = function(comment, responseContainer, responseTextArea) {

    // Abort if no text
    if (responseTextArea.value === "") {
        return;
    }

    var response = {
        content: responseTextArea.value
    };
    
    if(comment["responses"] == undefined) {
        comment["responses"] = new Array();
    }
    comment["responses"].push(response);
    responseTextArea.value = "";
    
    this.renderResponse(responseContainer, response);
    this.updateResponseHeight(comment);
    
    Autodesk.Viewing.Extensions.Commenting.CommentStorage.saveComment(comment);
};

/**
 * Creates a comment from the state of viewer and the UI
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.createComment = function() {

    var nodeId = null;
    // TODO: use a different id?
    var commentId = this.nextCommentId++;
    var state = this.viewer.getState(this.VIEWER_STATE_FILTER);

    var selectedNodeIds = this.viewer.viewerState.extractSelectedNodeIds(state);
    var isolatedNodeIds = this.viewer.viewerState.extractIsolatedNodeIds(state);
    if (selectedNodeIds.length > 0) {
        nodeId = selectedNodeIds[0];
    } else if (isolatedNodeIds.length > 0){
        nodeId = isolatedNodeIds[0];
    }

    var comment = {
        'id' : commentId,
        'content' : this.postTextArea.value,
        'state' : state,
        'marker-id' : "marker-" + commentId,
        'node-id' : nodeId,
        'highlight-node-ids': selectedNodeIds.concat(isolatedNodeIds)
    };

    return comment;
};

/**
 * Renders a comment from comment data
 * @param scope
 * @param {Object} comment - The comment data
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.renderComment = function(scope, comment) {
    scope.commentList.push(comment);

    var self = this;
    
    // Comment entry
    var displayComment = document.createElement('div');
    displayComment.className = 'comment-panel-entry';
    displayComment.id = "comment-panel-entry-" + comment.id;

    // Content
    var commentContent = document.createElement('div');
    commentContent.className = 'comment-panel-entry-content';
    
    // Label
    var commentText = document.createElement('p');
    commentText.className = "comment-panel-entry-paragraph";
    commentText.textContent = comment.content;
    
    // replies
    var commentReplies = document.createElement('span');
    commentReplies.className = "comment-panel-content-replies";
    
    var br = document.createElement('br');
    commentText.appendChild(br);
    commentText.appendChild(commentReplies);
    
    commentContent.appendChild(commentText);

    // Clean input after posting
    scope.postTextArea.value = "";

    var nodeId = comment["node-id"];
    // Create Markers
    
    // Add marker!
    var getMarkerNode = function(direction) {
        var marker = new Autodesk.Viewing.Extensions.Commenting.Marker(comment.id, null, direction);
        return marker.getDiv();
    };
    
    var viewerMarker = getMarkerNode(nodeId ? "right" : "");
    var commentMarker = viewerMarker.data.cloneDiv("");
    
    commentMarker.id = "comment-marker-"+comment.id;
    commentMarker.classList.add("comment-panel-entry-marker");
    displayComment.appendChild(commentMarker);
    
    var commentMarkerClick = function( /*event*/ ) {
        scope.myDelegate.onCommentMarkerClick(scope, comment);
    };
    commentMarker.addEventListener('click', commentMarkerClick, false);

    var commentMarkerMouseEnter = function(event) {

        scope.myDelegate.onCommentMarkerEnter(scope, comment);
        event.stopPropagation();
        event.preventDefault();
    };
    commentMarker.addEventListener('mouseenter', commentMarkerMouseEnter, false);

    var commentMarkerMouseLeave = function(event) {

        scope.myDelegate.onCommentMarkerLeave(scope, comment);
        event.stopPropagation();
        event.preventDefault();
    };
    commentMarker.addEventListener('mouseleave', commentMarkerMouseLeave, false);

    var viewerMarkerClick = function( event ) {

        scope.myDelegate.onViewerMarkerClick(scope, comment);
        event.stopPropagation();
        event.preventDefault();
    };
    viewerMarker.addEventListener('click', viewerMarkerClick, false);

    
    if (nodeId) {
        // add the little line next to the comment marker. Serves as a visual cue that this comment is
        // associated to a model's 3d-node.
        commentMarker.getElementsByClassName("comment-marker-arrow")[0].classList.add("comment-panel-marker-arrow-override");
        this.markers.setNodeMarker(comment["marker-id"], nodeId, viewerMarker, "#FFFFFF");
    } else {
        this.markers.setModelMarker(comment["marker-id"], viewerMarker);
    }
    
    displayComment.appendChild(commentContent);
    this.commentEntryContainer.appendChild(displayComment);

    // create a comment response div
    var responseWrapper = document.createElement('div');
    responseWrapper.id = 'comment-panel-response-wrapper-' + comment.id;
    responseWrapper.className = 'comment-panel-response-wrapper';
    
    var responseContainer = document.createElement('div');
    responseContainer.className = 'comment-panel-response-container';
    
    if(comment["responses"]) {
        for(var i = 0, len = comment["responses"].length; i < len; ++i) {
            var response = comment["responses"][i];
            this.renderResponse(responseContainer, response);
        }
        this.updateResponseText(commentReplies, comment);
    }
    
    var responseBox = document.createElement('textarea');
    responseBox.name = 'text';
    responseBox.className = 'comment-panel-response-post-textarea';
    responseBox.placeholder = 'Response';
    responseBox.setAttribute("data-i18n", "[placeholder]Response");

    var submitButton = document.createElement('input');
    submitButton.type = 'submit';
    submitButton.value = 'Post';
    submitButton.className = 'comment-panel-response-post-button';
    submitButton.setAttribute("data-i18n", "[value]Post" );
    
    responseWrapper.appendChild(responseContainer);
    responseWrapper.appendChild(responseBox);
    responseWrapper.appendChild(submitButton);
    commentContent.appendChild(responseWrapper);
    
    var submitClickHandler = function(e){
        self.onPostResponseClick(comment, responseContainer, responseBox);
        self.updateResponseText(commentReplies, comment);
    };
    submitButton.addEventListener('click', submitClickHandler);
    var responseKeyHandler = function(e) {
        if(e.keyCode == 13) {
            self.onPostResponseClick(comment, responseContainer, responseBox);
            self.updateResponseText(commentReplies, comment);
        }
    };
    responseBox.addEventListener('keypress', responseKeyHandler);
    
    // add delete link
    var deleteLink = document.createElement('a');
    deleteLink.className = 'comment-panel-entry-delete';
    deleteLink.href = '#';
    deleteLink.textContent = 'Delete Comment';
    deleteLink.setAttribute("data-i18n", "Delete Comment" );
    
    var deleteClick = function(e) {
        e.stopPropagation();
        scope.deleteComment(scope, comment.id);
    };
    deleteLink.addEventListener('click', deleteClick);
    
    commentContent.appendChild(deleteLink);
    
    // used to remove all event listeners associated with this comment
    displayComment.removeListeners = function() {
        commentMarker.removeEventListener('click', commentMarkerClick, false);
        commentMarker.removeEventListener('mouseenter', commentMarkerMouseEnter);
        commentMarker.removeEventListener('mouseleave', commentMarkerMouseLeave);

        viewerMarker.removeEventListener('click', viewerMarkerClick);
        submitButton.removeEventListener('click', submitClickHandler);
        deleteLink.removeEventListener('click', deleteClick);
        responseBox.removeEventListener('keypress', responseKeyHandler);
    };
};

/**
 * Renders a comment response from response data within a comment data object
 * @param {HTMLElement} container - Contains all the response divs for a comment
 * @param {Object} response - The response data
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.renderResponse = function(container, response) {
    // Content
    var responseContent = document.createElement('div');
    responseContent.className = 'comment-panel-response-content';
    
    // Label
    var responseText = document.createElement('p');
    responseText.className = "comment-panel-response-paragraph";
    responseText.textContent = response.content;
    responseContent.appendChild(responseText);
    
    container.appendChild(responseContent);
};

/**
 * Updates the height of the response container for a comment
 * @param {Object} comment - The comment data
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.updateResponseHeight = function(comment) {
    var responseWrapper = document.getElementById("comment-panel-response-wrapper-" + comment.id);
    if(this.selectedComment && this.selectedComment.id === comment.id) {
        responseWrapper.style.maxHeight = responseWrapper.scrollHeight + "px";
    } else {
        responseWrapper.style.maxHeight = "0px";
    }
};

/**
 * Updates the text for the number of responses in the response section of a Comment's UI
 * @param {HTMLElement span} responseSpan - the span containing the text for number of responses
 * @param {Object} comment - The comment data
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.updateResponseText = function(responseSpan, comment) {
    var replies = comment["responses"].length;
    if(replies === 0) {
        responseSpan.innerHTML = "";
    } else {
        responseSpan.innerHTML = comment["responses"].length + (replies === 1 ? " reply" : " replies");
    }   
};

/**
 * Deletes a comment from the UI and then saves that change
 * @param scope
 * @param {int} commentId - The id of the comment to be deleted
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.deleteComment = function(scope, commentId) {

    // Delete DOM element
    var delName = "comment-panel-entry-" + commentId;
    var elems = this.commentEntryContainer.children;
    var i,len;
    for (i = 0, len = elems.length; i<len; ++i) {
        var elem = elems[i];
        if (elem.id == delName) {
            elem.removeListeners();
            this.commentEntryContainer.removeChild(elem);
            break;
        }
    }

    // Delete data object
    var commentList = scope.commentList;
    for (i = 0, len = commentList.length; i<len; ++i) {
        var commentData = commentList[i];
        if (commentData.id === commentId) {
            if (commentData['marker-id']) {
                scope.hideCommentLine(commentData);
                if(scope.selectedComment == commentData) {
                    scope.selectedComment = null;
                }
            }
            var deletedComment = commentList.splice(i,1)[0];
            Autodesk.Viewing.Extensions.Commenting.CommentStorage.deleteComment(deletedComment);
            break;
        }
    }

    this.markers.removeMarker("marker-" + commentId);
    this.markups.clear();
}

Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.serializeComment = function(scope, comment) {
    this.viewer.impl.svfloader.postComments(viewer, comment);
};

/**
 * Highlights a node associated with a comment.
 * If the comment is for a node, draws a line from the node the comment is attached to to the DOM element provided.
 * If the comment is for the entire model, highlights the entire model
 * @param {Object} comment - The comment data
 * @param {HTMLElement} domElem - The DOM element that the comment line will be drawn to
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.drawCommentLine = function(comment, domElem) {

    if (comment["node-id"]) {
        var domViewer = document.getElementsByClassName('adsk-viewing-viewer')[0];
        var viewerPos = this.getElementPosition(domViewer);
        var commentPos = this.getElementPosition(domElem);
        var commentStyle = domElem.currentStyle || window.getComputedStyle(domElem);

        var rootContainer = document.getElementById(this.rootContainerId);
        var paddingX = domElem.offsetLeft + parseInt(commentStyle.marginLeft);
        // TODO: calculate the y height from css sytles
        var paddingY = 28;

        var xPos = Math.floor(commentPos.x - viewerPos.x - paddingX) + 0.5;
        var yPos = Math.floor(commentPos.y - viewerPos.y + paddingY - rootContainer.scrollTop) + 0.5;
    
        this.markers.setLine("line-" + comment.id, comment["node-id"], xPos, yPos, "#FFFFFF");
        
        var model = this.viewer.model;
        if(model) {
            var nodes = model.getNodesByIds(comment["highlight-node-ids"]);
            var nodesLength = nodes.length;
            for(var i = 0; i < nodesLength; ++i) {
                this.markers.highlightNode(nodes[i], comment.id);
            }    
        }
    } else {
        this.markers.setModelHighlight(true);
    }
};

/**
 * Gets the position of an element in the comment panel
 * @param {HTMLElement} element
 * @param {Boolean} useRightBounds - if true, uses the right bounds of the element for the x pos, otherwise uses the left bounds
 * @param {Boolean} useBottomBounds - if true, uses the bottom bounds of the element for the x pos, otherwise uses the top bounds
 * @returns {Object} - contains the x and y position of the element 
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.getElementPosition = function(element, useRightBounds, useBottomBounds) {
    var xPosition = 0;
    var yPosition = 0;

    var originalElement = element;
    while(element) {
        xPosition += (element.offsetLeft - element.scrollLeft + element.clientLeft);
        yPosition += (element.offsetTop - element.scrollTop + element.clientTop);
        element = element.offsetParent;
    }
    
    if(useRightBounds) {
        xPosition += originalElement.offsetWidth;
    }
    
    if(useBottomBounds) {
        yPosition += originalElement.offsetHeight;
    }
    
    return { x: xPosition, y: yPosition };
};

/**
 * Scrolls the CommentPanel so that the comment is at the top of the div
 * @param {Object} comment - The comment data
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.scrollToComment = function(comment) {
    var commentDiv = document.getElementById("comment-panel-entry-" + comment.id);
    var commentPos = this.getElementPosition(commentDiv);
    
    var rootContainer = document.getElementById(this.rootContainerId);
    rootContainer.scrollTop = commentPos.y;
};

/**
 * Makes sure a comment fits in the panel by scrolling the panel to the bottom of the comment if it doesn't fit
 * @param {HTMLElement} commentDiv - contains the comment's UI
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.fitCommentDivInPanel = function(commentDiv) {
    var commentPos = this.getElementPosition(commentDiv, false, true);
    var commentContainerPos = this.getElementPosition(this.commentEntryContainer);
    
    var rootContainer = document.getElementById(this.rootContainerId);
    if(commentPos.y > (rootContainer.scrollTop + rootContainer.offsetHeight)) {
        rootContainer.scrollTop = commentPos.y - rootContainer.offsetHeight;
    }
};

/**
 * Adds an interval to update the comment's position and line while it is animating
 * @param {Object} comment - The comment data
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.addCommentAnimationUpdateInterval = function(comment) {
    // TODO: get the css transition duration from javascript
    var transitionDuration = 400;
    var interval = 30;
    var totalTime = 0; 
    var commentDiv = document.getElementById("comment-panel-entry-" + comment.id);
    var self = this;
    
    this.timer = setInterval(function(){ 
   
        self.fitCommentDivInPanel(commentDiv);
        
        if(comment["node-id"]) {
            self.drawCommentLine(comment, commentDiv);
        }
        
        totalTime += interval;
        if(totalTime >= transitionDuration) {
            clearInterval(self.timer);
        }
    }, interval);  
};

/**
 * Removes any highlight associated with a comment.
 * @param {Object} comment - The comment data
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.hideCommentLine = function(comment) {

    if (comment["node-id"]) {    
        this.markers.removeLine("line-" + comment.id);
        
        var model = this.viewer.model;
        if(model) {
            var nodes = model.getNodesByIds(comment["highlight-node-ids"]);
            var nodesLength = nodes.length;
            for(var i = 0; i < nodesLength; ++i) {
                this.markers.clearHighlightedNode(nodes[i], comment.id);
            }    
        }
        
        // remove the comment line update timer
        if(this.timer) {
            clearInterval(this.timer);
            this.timer = null;
        }
    }
    else {
        this.markers.setModelHighlight(false);
    }
}

/**
 * Restores a viewer state associated with a comment
 * Also replaces selected nodes with the highlights used for comments
 * @param {Object} commentData
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.restoreCommentSnapshot = function(commentData) {

    this.selectedComment = commentData;
    var marker = document.getElementById("comment-marker-" + this.selectedComment.id);
    marker.classList.add("comment-marker-selected");
    
    this.updateResponseHeight(commentData);

    this.viewer.restoreState(commentData.state, this.VIEWER_STATE_FILTER, this.RESTORE_IS_IMMEDIATE);
    this.replaceSelectionWithCommentHighlights(commentData);
}

/**
 * Clears a snapshot.
 * Hides any lines and highlights drawn to it and unselects the marker for the comment
 * @param {Boolean} removeLine - if the line drawn to the comment should be removed as well
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.clearSelectedSnapshot = function(removeLine) {
    if(this.selectedComment) {
        var marker = document.getElementById("comment-marker-" + this.selectedComment.id);
        marker.classList.remove("comment-marker-selected");
        
        if (removeLine) {
            this.hideCommentLine(this.selectedComment);
        }
        
        var lastSelectedComment = this.selectedComment;
        this.selectedComment = null;
        
        this.updateResponseHeight(lastSelectedComment);
    }
};

/**
 * Clears the currently selected nodes in the viewer and then selects all nodes the comment is attached too.
 * If the comment is not assigned to any nodes, highlights the entire model
 * @param {Object} comment - data associated with a comment
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.replaceSelectionWithCommentHighlights = function(comment) {

    var selector = this.viewer.impl ? this.viewer.impl.selector : null;
    if(selector) {
        selector.clearSelection();
    }

    if(comment["node-id"]) {
        var model = this.viewer.model;
        if(model) {
            var nodes = model.getNodesByIds(comment["highlight-node-ids"]);
            var nodesLength = nodes.length;
            for(var i = 0; i < nodesLength; ++i) {
                this.markers.highlightNode(nodes[i]);
            }    
        }
    } else {
        this.markers.setModelHighlight(true);
    }
};

/**
 * Loads the comments from the CommentStorage based on the current URN loaded by the viewer
 * and then renders the comments when the data has loaded
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.requestComments = function() {
    if(this.commentsRequested) {
        return;
    }

    this.commentsRequested = true;

    var self = this;
    var urn = this.viewer.impl.svfloader.svfUrn;
    var readyToRenderComments = function() {
        Autodesk.Viewing.Extensions.Commenting.CommentStorage.loadComments(function(comments){
            for(var i = 0, len = comments.length; i < len; ++i) {
                var data = comments[i];
                self.renderComment(self, data);
                if (data["id"] >= self.nextCommentId) {
                    self.nextCommentId = data["id"] + 1;
                }
            }
        }, "local", urn);

        if(!self.isVisible()) {
            self.markers.setVisible(true);
        }
    };

    if (this.viewer.model && this.viewer.model.isLoadDone()){
        readyToRenderComments();
    } else {
        this.viewer.addEventListener(Autodesk.Viewing.GEOMETRY_LOADED_EVENT, readyToRenderComments);
    }

};

/**
 * Marker UI
 * @constructor
 * @param {commentId} the id of the comment the marker is assocaited with
 * @param {int} symbolType - the type of the symbol which affects its appearance as defined in the CommentPanel.css
 * It can be used to have different symbol appearance for different users.
 * @param {string} direction - the direction the marker's arrow is pointing
 */
Autodesk.Viewing.Extensions.Commenting.Marker = function(commentId, symbolType, direction)
{
    this.commentId = commentId;
    this.symbolType = symbolType || 0;
    this.lastDirection = "";
    direction = direction || "";
    
    
    this.holderDiv = document.createElement("div");
    this.holderDiv.className = "comment-marker-holder";
    this.holderDiv.data = this;
    
    this.arrowDiv = document.createElement("div");
    this.arrowDiv.className = "comment-marker-arrow";
    
    this.symbolDiv = document.createElement("div");
    this.symbolDiv.className = "comment-marker-symbol";
    this.symbolDiv.innerHTML = commentId;
    
    if(this.symbolType > 0) {
        this.symbolDiv.classList.add("comment-marker-symbol" + symbolType);
    }
    
    this.holderDiv.appendChild(this.arrowDiv);
    this.holderDiv.appendChild(this.symbolDiv);
    
    this.lastArrowClassName = null;
    this.setDirection(direction);
};

Autodesk.Viewing.Extensions.Commenting.Marker.prototype.constructor = Autodesk.Viewing.Extensions.Commenting.Marker;

/**
 * Sets the direction of the marker.  Updates the css class used for the direction
 * @param {string} direction - the direction the marker's arrow is pointing
 */
Autodesk.Viewing.Extensions.Commenting.Marker.prototype.setDirection = function( direction )
{
    if(this.lastDirection == direction) {
        return;
    }
    
    if(this.lastArrowClassName) {
        this.arrowDiv.classList.remove(this.lastArrowClassName);
        this.lastArrowClassName = null;
    }
    
    if(direction == "") {
        return;
    }
    
    var arrowClass;
    switch(direction) {
    case "left":
        arrowClass = "comment-marker-left";
        break;
    case "right":
        arrowClass = "comment-marker-right";
        break;
    case "outside_left":
        arrowClass = "comment-marker-outside-left";
        break;
    case "outside_right":
        arrowClass = "comment-marker-outside-right";
        break;
    case "outside_top":
        arrowClass = "comment-marker-outside-top";
        break;
    case "outside_bottom":
        arrowClass = "comment-marker-outside-bottom";
        break;
    }
    this.arrowDiv.classList.add(arrowClass);
    
    this.lastArrowClassName = arrowClass;
    this.lastDirection = direction;
};

/**
 * Sets the number in the inner symbol of the Marker
 * @param {int} number - the number displayed inside the marker
 */
Autodesk.Viewing.Extensions.Commenting.Marker.prototype.setNumber = function(number) {
    this.symbolDiv.innerHTML = number;
};

/**
 * Gets the HTMLElement associated with the marker class
 * @return {HTMLElement} - the HTMLElement that contains the marker's graphics
 */
Autodesk.Viewing.Extensions.Commenting.Marker.prototype.getDiv = function() {
    return this.holderDiv;
};

/**
 * Gets a clone of the HTMLElement associated with the marker
 * @param {string} direction - the direction the marker cloned marker arrow will point to.  Wont' affect the original marker.
 * @return {HTMLElement} - a clone of the HTMLElement that contains the marker's graphics
 */
Autodesk.Viewing.Extensions.Commenting.Marker.prototype.cloneDiv = function(direction) {
    direction = direction != null ? direction : this.lastDirection;
    var clone = new Autodesk.Viewing.Extensions.Commenting.Marker(this.commentId, this.symbolType, direction);
    return clone.getDiv();
};

/**
 * Returns markers extension.
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.__defineGetter__('markers', function () {
    return this.viewer.loadedExtensions['Autodesk.Markers'];
} );

/**
 * Returns markups extension.
 */
Autodesk.Viewing.Extensions.Commenting.CommentPanel.prototype.__defineGetter__('markups', function () {
    return this.viewer.loadedExtensions['Autodesk.Markups'];
} );;AutodeskNamespace('Autodesk.Viewing.Extensions.Commenting');

/**
 * Docking Comment Panel
 * Creates a DockingPanel that contains the CommentPanel UI
 * Overrides some of the CommentPanelDelegate functionality to make it work with inside the DockingPanel
 * and to force the panel to be visible when clicking on a comment marker when the panel is not open
 * @constructor
 * @param {Autodesk.Viewing.Viewer} viewer
 */
Autodesk.Viewing.Extensions.Commenting.DockingCommentPanel = function (viewer) {
    
    this.viewer = viewer;
    
    var self = this;
    var panelId = 'CommentPanel';
    Autodesk.Viewing.UI.DockingPanel.call(this, viewer.container, panelId, 'Comment and Markers');
    
    
    var commentPanelDelegate = new Autodesk.Viewing.Extensions.Commenting.CommentPanelDelegate();
    
    commentPanelDelegate.getViewer = function() {
        return viewer;
    };
    
    commentPanelDelegate.isVisible = function(panel) {
        return self.isVisible();
    };
    
    commentPanelDelegate.setVisible = function(panel, visible) {
        return self.setVisible(visible);
    };
    
    this.commentPanel = new Autodesk.Viewing.Extensions.Commenting.CommentPanel(commentPanelDelegate, viewer, panelId);
    
    this.container.dockRight = true;
};

Autodesk.Viewing.Extensions.Commenting.DockingCommentPanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Extensions.Commenting.DockingCommentPanel.prototype.constructor = Autodesk.Viewing.Extensions.Commenting.DockingCommentPanel;

/**
 * Overrides the uninitialize method
 */
Autodesk.Viewing.Extensions.Commenting.DockingCommentPanel.prototype.uninitialize = function () {
    this.viewer = null;
    this.commentPanel = null;

    Autodesk.Viewing.UI.DockingPanel.prototype.uninitialize.call(this);
};

/**
 * Overrides the DockingPanel's setVisible method to clear any lines drawn from the panel to the viewer
 * when the panel is closed
 * @param {boolean} show
 */
Autodesk.Viewing.Extensions.Commenting.DockingCommentPanel.prototype.setVisible = function(show)
{
    if(show) {
        if (this.commentPanel) {
            // Markers are visible only when the panel is not present
            this.commentPanel.markers.setVisible(false);
        }
    } else {
        if(this.commentPanel) {
            this.commentPanel.clearSelectedSnapshot(true);
            this.commentPanel.markers.setVisible(true);
        }
    }
    
    Autodesk.Viewing.UI.DockingPanel.prototype.setVisible.call(this, show);
};
;/**
 * Interface for saving and loading comments
 *
 * This class will manage keeping track of data for the current page session, but will
 * delegate out persisting that data to other classes.
 * 
 * By default, if no storage class is provided, this class defaults to local storage
 * (Autodesk.Viewing.Persistence.LocalCommentStorage)
 * 
 * A custom persistence class can be added as well. See setPersistenceType to see what
 * methods that custom class will need to contain
 * 
 * The expected data format for the loaded comments is:
 * [{
 *      'id' : commentId,
 *      'content' : content,
 *      'state' : snapshot,
 *      'marker-id' : markerText,
 *      'node-id' : part
 * }]
 */

AutodeskNamespace('Autodesk.Viewing.Extensions.Commenting.CommentStorage');

Autodesk.Viewing.Extensions.Commenting.CommentStorage.instance;

Autodesk.Viewing.Extensions.Commenting.CommentStorage = function() {
    var self = this;
    this.comments = [];
    this.persistence = null;
    this.loading = false;
    this.loaded = false;
    this.onLoadCallbacks = [];
    this.urn = null;
    
    this.byId = {};
    
    this.getIndexById = function(id) {
        var len = self.comments.length;
        for(var i = 0; i < len; ++i) {
            var comment = self.comments[i];
            if(comment["id"] == id) {
                return i;
            }
        }
        return -1;
    }
};

Autodesk.Viewing.Extensions.Commenting.CommentStorage.getInstance = function() {
    if(!Autodesk.Viewing.Extensions.Commenting.CommentStorage.instance) {
        Autodesk.Viewing.Extensions.Commenting.CommentStorage.instance = new Autodesk.Viewing.Extensions.Commenting.CommentStorage();
    }
    
    return Autodesk.Viewing.Extensions.Commenting.CommentStorage.instance;
};

/**
 * Sets the persistence class.  The persistenceType provided can be either a string which defines which built
 * in persistence class is used, or a function or object can be provided as well for a custom class.
 * 
 * If this method is not called, by default, local storage is used.
 * 
 * A custom persistence class can be added as well. This interface will expect that class to have the
 * following methods:
 *
 * -loadComments(callback) : This is used to load all the comments and will return those through a callback
 * function when done.
 * 
 * -saveComment(comment, comments, callback) : This is used to save a comment.  The comment to be saved is
 * passed to the class as well as the whole array of comments in case it is needed for saving the data.
 * The callback is optional
 * 
 * -deleteComment(comment, comments, callback) : This is used to delete a comment.  The comment to be deleted is
 * passed to the class as well as the whole array of comments in case it is needed for saving the data.
 * The callback is optional
 * 
 * @param {object} persistenceType - The type of persistence to use.  Can be either a string or class (object or function)
 * Strings that can be used include:
 *                          "none" - no persistence
 *                          "local" - local storage (Autodesk.Viewing.CommentStorage.LocalCommentStorage)
 *                          "remote" - yet to be created
 * @param {boolean} load - if the comments should be loaded immediately after the peristence class is set
 * @param {callback} - a callback for after all the comments have been loaded
 */
Autodesk.Viewing.Extensions.Commenting.CommentStorage.setPersistenceType = function(persistenceType, load, callback) {
    persistenceType = persistenceType || "none";
    
    var instance = Autodesk.Viewing.Extensions.Commenting.CommentStorage.getInstance();
    instance.loaded = false;
    instance.loading = false;
    
    if(typeof persistenceType == "string") {
        switch(persistenceType) {
        case "none":
            instance.loaded = true;
            instance.loading = true;
            load = false;
            instance.persistence = null;
            if(typeof callback == "function") {
                callback();
            }
            break;
        case "remote": // TODO: Add a class for remote storage
        case "local":
        default:
            instance.persistence = new Autodesk.Viewing.Extensions.Commenting.CommentStorage.LocalCommentStorage();
            break;    
        }
    } else if (typeof persistenceType == "function"){
        instance.persistence = new persistenceType();
    } else if (typeof persistenceType == "object") {
        instance.persistence = persistenceType;
    }
    
    if(load) {
        Autodesk.Viewing.Extensions.Commenting.CommentStorage.loadComments(callback, null, instance.urn);
    }
};

/**
 * Returns if the comments have been loaded
 */
Autodesk.Viewing.Extensions.Commenting.CommentStorage.loaded = function() {
    var instance = Autodesk.Viewing.Extensions.Commenting.CommentStorage.getInstance();
    return instance.loaded;
};

/**
 * Gets all comments
 * @param {function} callback - called when all comments have loaded.  The first
 * argument is an array of all the comments
 */
Autodesk.Viewing.Extensions.Commenting.CommentStorage.getAllComments = function(callback) {
    var instance = Autodesk.Viewing.Extensions.Commenting.CommentStorage.getInstance();
    
    if(!instance.loaded) {
        Autodesk.Viewing.Extensions.Commenting.CommentStorage.loadComments(executeCallback);
    } else {
        executeCallback(instance.comments);
    }
    
    function executeCallback(comments) {
        callback(instance.comments);
    }
};

/**
 * Gets a comment by id
 * @param {function} callback - called when all comments have loaded.  The first
 * argument is the comment
 */
Autodesk.Viewing.Extensions.Commenting.CommentStorage.getCommentById = function(id, callback) {
    var instance = Autodesk.Viewing.Extensions.Commenting.CommentStorage.getInstance();
    
    if(!instance.loaded) {
        Autodesk.Viewing.Extensions.Commenting.CommentStorage.loadComments(executeCallback);
    } else {
        executeCallback(instance.comments);
    }
    
    function executeCallback(comments) {
        callback(instance.byId[id]);
    }
};

/**
 * Gets all comments for the specified node
 * @param {string} nodeId - the id of the node
 * @param {function} callback - called when all comments have loaded.  The first
 * argument is an array of all the comments
 */
Autodesk.Viewing.Extensions.Commenting.CommentStorage.getCommentsByNodeId = function(nodeId, callback) {
    var instance = Autodesk.Viewing.Extensions.Commenting.CommentStorage.getInstance();
    
    if(!instance.loaded) {
        Autodesk.Viewing.Extensions.Commenting.CommentStorage.loadComments(executeCallback);
    } else {
        executeCallback(instance.comments);
    }
    
    function executeCallback(comments) {
        var comments = [];
        var len = instance.comments.length;
        for(var i = 0; i < len; ++i) {
            var comment = instance.comments[i];
            if(comment["node-id"] == nodeId) {
                comments.push(comment);
            }
        }
        
        callback(comments);
    }
};

/**
 * Loads comments for a data source
 * @param {function} callback - called when all comments have loaded.  The first
 * argument is an array of all the comments
 * @param {object} persistenceType - the type of persistence class to use for loading the comments.
 * It is optional and only used if the persistence class has not been initialized
 * @param {string} urn - an optional parameter to filter out comments for a specific URN
 * Comments data should be returned in the following format
 * [{
 *      'id' : commentId,
 *      'content' : content,
 *      'state' : snapshot,
 *      'marker-id' : markerText,
 *      'node-id' : part
 * }]
 */
Autodesk.Viewing.Extensions.Commenting.CommentStorage.loadComments = function(callback, persistenceType, urn) {    
    var instance = Autodesk.Viewing.Extensions.Commenting.CommentStorage.getInstance();
    
    if(urn && instance.urn != urn) {
        instance.loaded = false;
        instance.loading = false;
        instance.urn = urn;
    }
    
    if(!instance.persistence) {
        persistenceType = persistenceType || "local";
        Autodesk.Viewing.Extensions.Commenting.CommentStorage.setPersistenceType(persistenceType, true, callback);
        return;
    }
    
    if(instance.loaded) {
        if(typeof callback == "function") {
            callback(instance.comments);
        }
    } else {
        if(typeof callback == "function") {
            instance.onLoadCallbacks.push(callback);
        }
        
        if(instance.loading) {
            return;
        }
        
        instance.loading = true;
        instance.comments = [];
        instance.byId = {};
        
        if(instance.persistence && typeof instance.persistence.loadComments == "function") {
            callback = callback || function() {};

            function onLoadComplete(data) {
                var i;
                instance.loaded = true;

                if(data && Array.isArray(data)) {
                    instance.comments = data;
                    len = data.length;
                    for(i = 0; i < len; ++i) {
                        var comment = data[i];
                        instance.byId[comment["id"]] = comment;
                    }
                }
                
                var len = instance.onLoadCallbacks.length;
                for(i = 0; i < len; ++i) {
                    var nextCallback = instance.onLoadCallbacks[i];
                    nextCallback(instance.comments);
                }
            }

            instance.persistence.loadComments(urn, onLoadComplete);

        } else {
            if(typeof callback == "function") {
                callback(instance.comments);
            }
        }
    }
};

/**
 * @param {object} comment - the comment data to be saved
 * @param {function} callback - called when the comment has been saved
 */
Autodesk.Viewing.Extensions.Commenting.CommentStorage.saveComment = function(comment, callback) {
    var instance = Autodesk.Viewing.Extensions.Commenting.CommentStorage.getInstance();
    
    if(!instance.loaded) {
        Autodesk.Viewing.Extensions.Commenting.CommentStorage.loadComments(executeCallback);
    } else {
        executeCallback(instance.comments);
    }
    
    function executeCallback(comments) {
        var index = instance.getIndexById(comment["id"]);
        if(index > -1) {
            instance.comments[index] = comment;
        } else {
            instance.comments.push(comment);
        }
        
        instance.byId[comment["id"]] = comment;
        
        if(instance.persistence && typeof instance.persistence.saveComment == "function") {
            instance.persistence.saveComment(comment, instance.comments, instance.urn, callback || function(){});
        }
    }
};

/**
 * @param {object} comment - the comment data to be deleted
 * @param {function} callback - called when the comment has been deleted
 */
Autodesk.Viewing.Extensions.Commenting.CommentStorage.deleteComment = function(comment, callback) {
    var instance = Autodesk.Viewing.Extensions.Commenting.CommentStorage.getInstance();
    
    if(!instance.loaded) {
        Autodesk.Viewing.Extensions.Commenting.CommentStorage.loadComments(executeCallback);
    } else {
        executeCallback(instance.comments);
    }
    
    function executeCallback(comments) {
        var index = instance.getIndexById(comment["id"]);
        if(index > -1) {
            instance.comments.splice(index, 1);
        }
        
        delete instance.byId[comment["id"]];
        
        if(instance.persistence && typeof instance.persistence.deleteComment == "function") {
            instance.persistence.deleteComment(comment, instance.comments, instance.urn, callback || function(){});
        }
    }
};

Autodesk.Viewing.Extensions.Commenting.CommentStorage.getCurrentURN = function() {
    var instance = Autodesk.Viewing.Extensions.Commenting.CommentStorage.getInstance();
    return instance.urn;
};

Autodesk.Viewing.Extensions.Commenting.CommentStorage.destroy = function() {
    if(!Autodesk.Viewing.Extensions.Commenting.CommentStorage.instance)
        return;
    
    var instance = Autodesk.Viewing.Extensions.Commenting.CommentStorage.getInstance();
    
    instance.comments = [];
    instance.persistence = null;
    instance.loading = false;
    instance.loaded = false;
    instance.onLoadCallbacks = [];
    
    instance.byId = {};
    
    Autodesk.Viewing.Extensions.Commenting.CommentStorage.instance = null;
};/**
 * Saves and loads comment data using window.localStorage
 */

AutodeskNamespace('Autodesk.Viewing.Extensions.Commenting.CommentStorage');

Autodesk.Viewing.Extensions.Commenting.CommentStorage.LocalCommentStorage = function() {
    
    var data = [];
    var storageName = "comments";
    var self = this;
    
    this.loadComments = function(urn, callback) {
        var storedData = window.localStorage.getItem(this.getStorageName(urn));
        
        if(storedData) {
            var parsedStoredData = JSON.parse(storedData);
            
            for(var i = 0, len = parsedStoredData.length; i < len; ++i) {
                var item = parsedStoredData[i];
                data.push(item);
            }
        }
        
        callback(data);
    }
    
    this.saveComment = function(comment, comments, urn, callback) {
        window.localStorage.setItem(this.getStorageName(urn), JSON.stringify(comments));
    };
    
    this.deleteComment = function(comment, comments, urn, callback) {
        window.localStorage.setItem(this.getStorageName(urn), JSON.stringify(comments));
    };
    
    this.getStorageName = function(urn) {
        var name = storageName;
        if(urn) {
            name += "." + urn;
        }
        
        return name;
    };
};;// WebRTC adapter (adapter.js) from Google

if (typeof window !== 'undefined')
{

    var RTCPeerConnection = null;
    var getUserMedia = null;
    var attachMediaStream = null;
    var reattachMediaStream = null;
    var webrtcDetectedBrowser = null;
    var webrtcDetectedVersion = null;

    function trace(text) {
        // This function is used for logging.
        if (text[text.length - 1] == '\n') {
            text = text.substring(0, text.length - 1);
        }
        console.log((performance.now() / 1000).toFixed(3) + ": " + text);
    }

    if (navigator.mozGetUserMedia) {
        //console.log("This appears to be Firefox");

        webrtcDetectedBrowser = "firefox";

        webrtcDetectedVersion =
            parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]);

        // The RTCPeerConnection object.
        RTCPeerConnection = mozRTCPeerConnection;

        // The RTCSessionDescription object.
        RTCSessionDescription = mozRTCSessionDescription;

        // The RTCIceCandidate object.
        RTCIceCandidate = mozRTCIceCandidate;

        // Get UserMedia (only difference is the prefix).
        // Code from Adam Barth.
        getUserMedia = navigator.mozGetUserMedia.bind(navigator);

        // Creates iceServer from the url for FF.
        createIceServer = function (url, username, password) {
            var iceServer = null;
            var url_parts = url.split(':');
            if (url_parts[0].indexOf('stun') === 0) {
                // Create iceServer with stun url.
                iceServer = { 'url': url };
            } else if (url_parts[0].indexOf('turn') === 0 &&
                (url.indexOf('transport=udp') !== -1 ||
                    url.indexOf('?transport') === -1)) {
                // Create iceServer with turn url.
                // Ignore the transport parameter from TURN url.
                var turn_url_parts = url.split("?");
                iceServer = { 'url': turn_url_parts[0],
                    'credential': password,
                    'username': username };
            }
            return iceServer;
        };

        // Attach a media stream to an element.
        attachMediaStream = function (element, stream) {
            console.log("Attaching media stream");
            element.mozSrcObject = stream;
            element.play();
        };

        reattachMediaStream = function (to, from) {
            console.log("Reattaching media stream");
            to.mozSrcObject = from.mozSrcObject;
            to.play();
        };

        // Fake get{Video,Audio}Tracks
        MediaStream.prototype.getVideoTracks = function () {
            return [];
        };

        MediaStream.prototype.getAudioTracks = function () {
            return [];
        };
    } else if (navigator.webkitGetUserMedia) {
        //console.log("This appears to be Chrome");

        webrtcDetectedBrowser = "chrome";
        webrtcDetectedVersion =
            parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2]);

        // Creates iceServer from the url for Chrome.
        createIceServer = function (url, username, password) {
            var iceServer = null;
            var url_parts = url.split(':');
            if (url_parts[0].indexOf('stun') === 0) {
                // Create iceServer with stun url.
                iceServer = { 'url': url };
            } else if (url_parts[0].indexOf('turn') === 0) {
                if (webrtcDetectedVersion < 28) {
                    // For pre-M28 chrome versions use old TURN format.
                    var url_turn_parts = url.split("turn:");
                    iceServer = { 'url': 'turn:' + username + '@' + url_turn_parts[1],
                        'credential': password };
                } else {
                    // For Chrome M28 & above use new TURN format.
                    iceServer = { 'url': url,
                        'credential': password,
                        'username': username };
                }
            }
            return iceServer;
        };

        // The RTCPeerConnection object.
        RTCPeerConnection = webkitRTCPeerConnection;

        // Get UserMedia (only difference is the prefix).
        // Code from Adam Barth.
        getUserMedia = navigator.webkitGetUserMedia.bind(navigator);

        // Attach a media stream to an element.
        attachMediaStream = function (element, stream) {
            if (typeof element.srcObject !== 'undefined') {
                element.srcObject = stream;
            } else if (typeof element.mozSrcObject !== 'undefined') {
                element.mozSrcObject = stream;
            } else if (typeof element.src !== 'undefined') {
                element.src = URL.createObjectURL(stream);
            } else {
                console.log('Error attaching stream to element.');
            }
        };

        reattachMediaStream = function (to, from) {
            to.src = from.src;
        };

        // The representation of tracks in a stream is changed in M26.
        // Unify them for earlier Chrome versions in the coexisting period.
        if (!webkitMediaStream.prototype.getVideoTracks) {
            webkitMediaStream.prototype.getVideoTracks = function () {
                return this.videoTracks;
            };
            webkitMediaStream.prototype.getAudioTracks = function () {
                return this.audioTracks;
            };
        }

        // New syntax of getXXXStreams method in M26.
        if (!webkitRTCPeerConnection.prototype.getLocalStreams) {
            webkitRTCPeerConnection.prototype.getLocalStreams = function () {
                return this.localStreams;
            };
            webkitRTCPeerConnection.prototype.getRemoteStreams = function () {
                return this.remoteStreams;
            };
        }
    } else {
        console.log("Browser does not appear to be WebRTC-capable");
    }

}

;AutodeskNamespace('Autodesk.Viewing.Private.Collaboration');

(function() {

    var av = Autodesk.Viewing,
        avp = av.Private,
        avpc = avp.Collaboration;

    var USE_PUBNUB = false;

    /** @constructor */
    avpc.Client = function() {
        return;
        // FIXME: security, can't embed keys in JS app.
        var PUBNUB_PUBLISH_KEY = "";
        var PUBNUB_SUBSCRIBE_KEY = "";

        var _socket;
        // FIXME: is PUBNUB.uuid a blocking call?
        var _myID = USE_PUBNUB ? PUBNUB.uuid() : null;

        // PUBNUB definition requires include of pubnub Javascript SDK.
        // http://www.pubnub.com/docs/javascript/javascript-sdk.html
        var _pubnub = USE_PUBNUB ? PUBNUB.init({
            publish_key: PUBNUB_PUBLISH_KEY,
            subscribe_key: PUBNUB_SUBSCRIBE_KEY,
            uuid: _myID
        }) : null;

        // The assocaitive array where key is user ID, used to decide if a user is in room or not,
        // without looping through entire _users list.
        var _userSet = {};

        var _pubnubSubscribed = false;

        var _serverURL = undefined;
        var _roomId;

        var _users = [];

        var _this = this;


        function onRecv(evt) {

            switch(evt.type) {
                case "camera":                  _this.dispatchEvent({ type: "cameraChange",   data: evt}); break;
                case "joystick":                _this.dispatchEvent({ type: "joystick",       data: evt}); break;
                case "state":                   _this.dispatchEvent({ type: "viewerState",    data: evt}); break;
                case "txt":     onChat(evt);    _this.dispatchEvent({ type: "chatReceived",   data: evt }); break;
                case "joinok":  onJoinOK(evt);  _this.dispatchEvent({ type: "userListChange", data: _users }); break;
                case "joined":  onJoined(evt);  _this.dispatchEvent({ type: "userListChange", data: _users }); break;
                case "left":    onLeft(evt);    _this.dispatchEvent({ type: "userListChange", data: _users }); break;
                case "private":                 _this.dispatchEvent({ type: "privateMessage", data: evt}); break;
                default: console.log(evt); break;
            }
        }

        function onJoined(evt) {
            if (!evt.user.name || !evt.user.name.length)
                evt.user.name = evt.user.id.slice(0,5);

            _users.push(evt.user);
            console.log(evt.user + " joined room " + evt.room);
            //console.log(_users);
        }

        function onLeft(evt) {
            console.log(evt.user + " left room " + evt.room);
            var idx = -1;
            for (var i=0; i<_users.length; i++) {
                if (_users[i].id == evt.user) {
                    idx = i;
                    break;
                }
            }

            if (idx != -1)
                _users.splice(idx, 1);
        }

        function onJoinOK(evt) {
            console.log("Join successful, your id is: " + evt.myid);
            _myID = evt.myid;

            if (evt.users && evt.users.length) {
                _users = evt.users;
            } else {
                _users = [];
            }

            for (var i=0; i<_users.length; i++) {

                //Make up a user name if one is not known
                if (!_users[i].name || !_users[i].name.length) {
                    _users[i].name = _users[i].id.slice(0,5);
                }
            }

            _users.push({ id:_myID, name:_myID.slice(0,5) + " (you)", isSelf : true, status:0 });
        }


        function onChat(evt) {
            if (evt.msg.indexOf("/nick ") == 0) {
                var user = _this.getUserById(evt.from);
                var newname = evt.msg.slice(6);

                if (newname.length) {
                    user.name = newname;
                    if (user.id == _myID)
                        user.name += " (you)";
                }
                _this.dispatchEvent({ type: "userListChange", data: _users });
            }
        }


        /// Pubnub helpers.

        // Joining chat room.
        function pubnubOnJoined() {
            console.log("I am joined with my id " + _myID);
            _users.push({ id:_myID, name:_myID.slice(0,5) + " (you)", isSelf : true, status:0 });
            _userSet[_myID] = true;
            _this.dispatchEvent({ type: "userListChange", data: _users });
        }

        // See who else in chat room.
        function pubnubOnJoinOK(roomId) {
            _pubnub.here_now({
                channel : roomId,
                callback : function(m){
                    // m.uuids is the user list.
                    console.log("user list : " + JSON.stringify(m));

                    var user, id;

                    // Query users who currently in same chat room.
                    for (var i=0; i< m.uuids.length; i++) {
                        id = m.uuids[i];
                        if (_userSet[id]) continue;

                        user = {
                            id : id,
                            name : id.slice(0,5),
                            isSelf : false,
                            status : 0 };
                        _users.push(user);
                        _userSet[id] = true;
                        console.log("new user from server list : " + user.id);
                    }

                    _this.dispatchEvent({ type: "userListChange", data: _users });
                }
            });
        }

        /// End of Pubnub helpers.

        this.connect = function (roomId) {

            if (_socket || _pubnubSubscribed)
                return; //already connected to socket server, or subscribed to pubnub.

            if (typeof window.WebSocket !== "undefined") {
                if (USE_PUBNUB) {
                    // This initialization code path will be hit when we close / reopen
                    // collab window. Otherwise, initialization of pubnubs is done in
                    // Client constructor.
                    if (!_myID) {
                        _myID = PUBNUB.uuid();
                    }
                    if (!_pubnub) {
                        _pubnub = PUBNUB.init({
                            publish_key: PUBNUB_PUBLISH_KEY,
                            subscribe_key: PUBNUB_SUBSCRIBE_KEY,
                            uuid: _myID
                        });
                    }

                    // FIXME: use real room Id (post process it such that it does not contain
                    // chars that pubnub dislikes.
                    roomId = roomId.replace(/\//g, '-');
                    _roomId = roomId;
                    
                    // Initialize pubnub with callbacks.
                    _pubnub.subscribe({
                        channel: roomId,
                        message: function(m){
                            // console.log(JSON.stringify(m));
                            if (m.senderId != _myID)
                                onRecv(m.data);
                        },
                        connect: function(){
                            _pubnubSubscribed = true;
                            pubnubOnJoined();
                            console.log("Connected")
                        },
                        disconnect: function(){
                            // TODO : this does not work yet.
                            pubnub.unsubscribe({
                                channel : roomId
                            });

                            _pubnubSubscribed = false;
                            console.log("Disconnected")
                        },
                        presence : function() {
                            pubnubOnJoinOK(roomId);
                        },
                        reconnect: function(){
                            _pubnubSubscribed = true;
                            console.log("Reconnected")
                        },
                        error: function(){
                            _pubnubSubscribed = false;
                            console.log("Network Error")
                        }
                    });

                    // TODO: It seems it is the viewer who created duplicated connect requests
                    // when collab panel closed / then repoened. Need to fix this.
                    _pubnubSubscribed = true;
                } else {
                    _socket = io.connect(_serverURL, {forceNew:true});
                    _socket.on("message", onRecv);
                    _roomId = roomId;
                    _socket.emit('join', _roomId);
                }

                return true;
            }
            else {
                return false;
            }
        };


        this.disconnect = function () {
            if (_socket) {
                _socket.disconnect();
                //_socket.close();
                _socket = null;
                _users = null;
                _myID = null;
                _roomId = null;
            }

            if (_pubnub) {
                // Explicitly tell others I am leaving.
                var evt = { type:"left", user: _myID, room: _roomId};
                _pubnub.publish({
                    channel : _roomId,
                    message : {
                        type : "left", // For now, this type does not matter...
                        data : evt
                    }
                });

                _pubnub.unsubscribe({
                    channel : _roomId
                });
                _pubnub = null;
                _pubnubSubscribed = false;
                _users = [];
                _userSet = {};
                _myID = null;
                _roomId = null;
            }
        };

        this.sendMessage = function(type, data) {
            var evt = { type:type, from:_myID, msg: data };

            if (USE_PUBNUB) {
                _pubnub.publish({
                    channel : _roomId,
                    message : {
                        type : type,
                        senderId : _myID,
                        data : evt
                    }
                });
            } else {
                _socket.emit("message", evt);
            }
        };

        this.sendPrivateMessage = function(targetId, msg) {
            var evt = { type:"private", target:targetId, from: _myID, msg: msg };
            _socket.emit("message", evt);
        };

        this.sendChatMessage = function(msg) {

            var evt = { type:"txt", from: _myID, msg: msg };

            if (USE_PUBNUB) {
                _pubnub.publish({
                    channel : _roomId,
                    message : {
                        type : "chat",
                        senderId : _myID,
                        data : evt
                    }
                });
            } else {
                _socket.emit("message", evt);
            }

            onRecv(evt);
        };

        this.getUserById = function(id) {
            for (var i=0; i<_users.length; i++) {
                if (_users[i].id == id)
                    return _users[i];
            }
            return null;
        };

        this.getLocalId = function() { return _myID; }

    };

    avpc.Client.prototype.constructor = avpc.Client;
    THREE.EventDispatcher.prototype.apply( avpc.Client.prototype );

    //==================================================================================

    avpc.P2PClient = function(signalClient) {

        var _this = this;

        var _signalClient = signalClient;
        var _pc;
        var _isStarted = false;
        var _targetId;
        var _localStream;
        var _remoteStream;

        var _iceCandidates = [];

        var pc_config = {'iceServers': [{'url': 'stun:stun.l.google.com:19302'}]};

        var pc_constraints = {'optional': [{'DtlsSrtpKeyAgreement': true}]};

        // Set up audio and video regardless of what devices are present.

        var sdpConstraints = {'mandatory': {
          'OfferToReceiveAudio':true,
          'OfferToReceiveVideo':true }};

        _signalClient.addEventListener("privateMessage", onMessage);



        function createPeerConnection() {
          try {

            _pc = new RTCPeerConnection(pc_config);

            _pc.onicecandidate = function(event) {
                  //console.log('handleIceCandidate event: ', event);

                  if (event.candidate) {
                    _signalClient.sendPrivateMessage(_targetId, {
                      type: 'candidate',
                      label: event.candidate.sdpMLineIndex,
                      id: event.candidate.sdpMid,
                      candidate: event.candidate.candidate});
                  } else {
                    console.log('End of candidates.');
                  }
            };

            _pc.onaddstream = function(event) {
                //console.log('Remote stream added.');
                _remoteStream = event.stream;
                _this.dispatchEvent({type:"remoteStreamAdded", data:event.stream});
            };

            _pc.onremovestream = function(event) {
                //console.log('Remote stream removed. Event: ', event);
                _remoteStream = null;
                _this.dispatchEvent({type:"remoteStreamRemoved", data:event.stream});
            };

            //console.log('Created RTCPeerConnnection');

          } catch (e) {
            console.log('Failed to create PeerConnection, exception: ' + e.message);
            alert('Cannot create RTCPeerConnection object.');
              return;
          }
        }


        function handleCreateOfferError(event){
          console.log('createOffer() error: ', e);
        }

        function setLocalAndSendMessage(sessionDescription) {
            // Set Opus as the preferred codec in SDP if Opus is present.
            //sessionDescription.sdp = preferOpus(sessionDescription.sdp);
            _pc.setLocalDescription(sessionDescription);
            //console.log('setLocalAndSendMessage sending message' , sessionDescription);
            _signalClient.sendPrivateMessage(_targetId, sessionDescription);

            if (_iceCandidates.length) {
                for  (var i=0; i<_iceCandidates.length; i++)
                    _pc.addIceCandidate(_iceCandidates[i]);
                _iceCandidates = [];
            }
        }
/*
        function requestTurn(turn_url) {
          var turnExists = false;
          for (var i in pc_config.iceServers) {
            if (pc_config.iceServers[i].url.substr(0, 5) === 'turn:') {
              turnExists = true;
              turnReady = true;
              break;
            }
          }
          if (!turnExists) {
            console.log('Getting TURN server from ', turn_url);
            // No TURN server. Get one from computeengineondemand.appspot.com:
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function(){
              if (xhr.readyState === 4 && xhr.status === 200) {
                var turnServer = JSON.parse(xhr.responseText);
                console.log('Got TURN server: ', turnServer);
                pc_config.iceServers.push({
                  'url': 'turn:' + turnServer.username + '@' + turnServer.turn,
                  'credential': turnServer.password
                });
                turnReady = true;
              }
            };
            xhr.open('GET', turn_url, true);
            xhr.send();
          }
        }
*/

        this.hangup = function() {
          console.log('Hanging up.');
          if (_isStarted) {
              stop();
              _signalClient.sendPrivateMessage(_targetId, 'bye');
          }
        };


        this.initUserMedia = function(createConnectionCB) {
            function handleUserMedia(stream) {
                console.log('Adding local stream.');
                if (createConnectionCB)
                    createConnectionCB(stream);
                _this.dispatchEvent({type:"localStreamAdded", data:stream});
            }

            function handleUserMediaError(error){
                console.log('getUserMedia error: ', error);
            }

            var constraints = {video: true, audio:true};
            window.getUserMedia(constraints, handleUserMedia, handleUserMediaError);

            console.log('Getting user media with constraints', constraints);
        };

        this.callUser = function(userId) {
            _targetId = userId;

            console.log("Calling user " + _targetId);

            this.initUserMedia(function(stream) {
                _localStream = stream;
                if (!_isStarted && typeof _localStream != 'undefined') {
                    createPeerConnection();
                    _pc.addStream(_localStream);
                    _isStarted = true;
                    console.log('Sending offer to peer');
                    _pc.createOffer(setLocalAndSendMessage, handleCreateOfferError);
                }
            });
        };

        this.receiveCall = function(msg) {
            _targetId = msg.from;

            this.initUserMedia(function(stream) {
                _localStream = stream;

                if (!_isStarted && typeof _localStream != 'undefined') {
                    createPeerConnection();
                    _pc.addStream(_localStream);
                    _isStarted = true;
                }

                _pc.setRemoteDescription(new RTCSessionDescription(msg.msg));
                console.log('Sending answer to peer.');
                _pc.createAnswer(setLocalAndSendMessage, null , sdpConstraints);
            });
        };


        function onMessage(evt) {
            var message = evt.data.msg;
            console.log('Client received message:', message);
            if (message.type == 'offer' && !_isStarted) {

                _this.receiveCall(evt.data);

            } else if (message.type === 'answer' && _isStarted) {

                _pc.setRemoteDescription(new RTCSessionDescription(message));

            } else if (message.type === 'candidate') {

                var candidate = new RTCIceCandidate({
                sdpMLineIndex: message.label,
                candidate: message.candidate
                });

                //If we receive ICE candidates before the local
                //session is started, we have to hold them in a temp list until
                //we create the answer
                if (_isStarted)
                    _pc.addIceCandidate(candidate);
                else
                    _iceCandidates.push(candidate);

            } else if (message === 'bye' && _isStarted) {

               _this.dispatchEvent({type:"remoteHangup", data:null});
               console.log('Session terminated.');
               stop();
              // isInitiator = false;

            }
        }

        function stop() {
          _isStarted = false;
          // isAudioMuted = false;
          // isVideoMuted = false;
          _pc.close();
          _pc = null;
          _localStream = null;
          _remoteStream = null;
          _targetId = null;
        }

        this.getCurrentCallTarget = function() { return _targetId; }

    };

    avpc.P2PClient.prototype.constructor = avpc.P2PClient;
    THREE.EventDispatcher.prototype.apply( avpc.P2PClient.prototype );


    //==================================================================================

    avpc.ViewTransceiver = function(client) {

        var _this = this;
        var _viewer = this.viewer = null;
        var _blockEvents = false;
        var _haveControl = false;
        var _lastInControl;
        var _client = this.client = client;

        var _viewerState;
        var VIEWER_STATE_FILTER = {
            seedURN: false,
            objectSet: true,
            viewport: false,
            renderOptions: {
                environment: false,
                ambientOcclusion: false,
                toneMap: {
                    exposure: false
                },
                appearance: false
            }
        };


        function onViewerState(evt) {
            _blockEvents = true;
            var state = JSON.parse(evt.data.msg);
            _viewerState.restoreState(state);
            _viewer.impl.invalidate(true, false, true);
            _blockEvents = false;
        }

        function reduceBits(v) {
            return Math.round(v * 1000) / 1000;
        }

        function reduceBitsV(v) {
            for (var i=0; i< v.length; i++)
                v[i] = reduceBits(v[i]);
        }

        function onCamera(e) {
            var v = e.data.msg;

            if (v[0] != _lastInControl)
            {
                _lastInControl = v[0];
                _this.dispatchEvent({type: "controlChange", data: _lastInControl });
            }

            //For now, automatically relinquish camera control if we receive a remote command to move the camera
            _haveControl = false;

/*
            viewer.navigation.setRequestTransitionWithUp(true, new THREE.Vector3().set(v[1+0],v[1+1],v[1+2]),
                                                                new THREE.Vector3().set(v[1+3],v[1+4],v[1+5]),
                                                                _viewer.navigation.getCamera().fov,
                                                                new THREE.Vector3().set(v[1+6],v[1+7],v[1+8]));
*/

            _viewer.navigation.setView(new THREE.Vector3().set(v[1+0],v[1+1],v[1+2]),
                                       new THREE.Vector3().set(v[1+3],v[1+4],v[1+5]));
            _viewer.navigation.setCameraUpVector(new THREE.Vector3().set(v[1+6],v[1+7],v[1+8]));
        }

        function sendCamera(evt) {
            if (!_haveControl)
                return;

            var c = evt.camera;
            var camParams = [ c.position.x, c.position.y, c.position.z,
                c.target.x, c.target.y, c.target.z,
                c.up.x, c.up.y, c.up.z
            ];

            reduceBitsV(camParams);
            camParams.unshift(client.getLocalId());

            _client.sendMessage("camera", camParams);

            if (_lastInControl != camParams[0]) {
                _lastInControl = camParams[0];
                _this.dispatchEvent({type: "controlChange", data: _lastInControl });
            }
        }



        function sendViewerState(e) {
            if (!_haveControl)
                return;
            if (_blockEvents)
                return;

            var state = _viewerState.getState(VIEWER_STATE_FILTER);

            // TODO: if we kill the socket.io code path, this could be optimized
            // too by removing the JSON.stringify of the state. Pubnub automatically
            // does JSON serialization for us, with optimizations accordingly to their manual.
            client.sendMessage("state", JSON.stringify(state));
        }


        this.takeControl = function() {
            _haveControl = true;
        };


        this.attach = function(viewer) {

            if (_viewer)
                this.detach();

            this.viewer = _viewer = viewer;
            _viewerState = new avp.ViewerState(_viewer);

            _client.addEventListener("cameraChange", onCamera);
            _client.addEventListener("viewerState", onViewerState);


            if (!_viewer.hasEventListener(av.CAMERA_CHANGE_EVENT, sendCamera))
                _viewer.addEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

            if (!_viewer.hasEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState)) {
                _viewer.addEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
                _viewer.addEventListener(av.ISOLATE_EVENT, sendViewerState);
                _viewer.addEventListener(av.HIDE_EVENT, sendViewerState);
                _viewer.addEventListener(av.SHOW_EVENT, sendViewerState);
                _viewer.addEventListener(av.HIGHLIGHT_EVENT, sendViewerState);
                _viewer.addEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
                _viewer.addEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);
            }
        };


        this.detach = function() {

            if (_client) {
                _client.removeEventListener("cameraChange", onCamera);
                _client.removeEventListener("viewerState", onViewerState);
            }

            if (_viewer) {
                _viewer.removeEventListener(av.CAMERA_CHANGE_EVENT, sendCamera);

                _viewer.removeEventListener(av.SELECTION_CHANGED_EVENT, sendViewerState);
                _viewer.removeEventListener(av.ISOLATE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.HIDE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.SHOW_EVENT, sendViewerState);
                _viewer.removeEventListener(av.HIGHLIGHT_EVENT, sendViewerState);
                _viewer.removeEventListener(av.EXPLODE_CHANGE_EVENT, sendViewerState);
                _viewer.removeEventListener(av.LAYER_VISIBILITY_CHANGED_EVENT, sendViewerState);

                this.viewer = _viewer = null;
                _viewerState = null;
            }
        };

    };

    avpc.ViewTransceiver.prototype.constructor = avpc.ViewTransceiver;
    THREE.EventDispatcher.prototype.apply( avpc.ViewTransceiver.prototype );



})();;
AutodeskNamespace('Autodesk.Viewing.Private.Collaboration');

(function() {

    var av = Autodesk.Viewing,
        ave = av.Extensions,
        avp = av.Private,
        avpc = avp.Collaboration;


    avpc.JoyStick = function(controller, canvas) {

        var _this = this;
        var _hammer;
        var _position = this.position = [0,0];

        var _outerRing, _innerRing;

        this.dragStart = function(e) {

        };

        function clamp(v, min, max) {
            if (v > max)
                return max;
            if (v < min)
                return min;
            return v;
        }

        this.dragMove = function(e) {
            var vpx = (e.center.x - canvas.offsetLeft) / canvas.offsetWidth;
            var vpy = (e.center.y - canvas.offsetTop) / canvas.offsetHeight;
            _position[0] = clamp(2*vpx - 1, -1, 1);
            _position[1] = -clamp(2*vpy - 1, -1, 1); //minus to convert to y-up

            controller.sendState();

            _innerRing.style.left = (_position[0] * 25 + 40) + "%";
            _innerRing.style.top = (-_position[1] * 25 + 40) + "%";
        };

        this.dragEnd = function(e) {
            _position[0] = 0;
            _position[1] = 0;

            controller.sendState();

            _innerRing.style.left ="40%";
            _innerRing.style.top = "40%";
        };

        this.onSingleTap = function(e) {
            console.log("on tap");
        };

        this.onDoubleTap = function(e) {
            console.log("double tap");
        };


        function createGUI() {

            _outerRing = document.createElement("div");
            _outerRing.classList.add("joystickOuterRing");
            canvas.appendChild(_outerRing);

            _innerRing = document.createElement("div");
            _innerRing.classList.add("joystickInnerRing");
            canvas.appendChild(_innerRing);
        }

        function initEvents() {
            if( 'ontouchstart' in window )
            {
                _hammer = new Hammer.Manager(canvas, {
                    recognizers: [
                        // RecognizerClass, [options], [recognizeWith, ...], [requireFailure, ...]
                        [Hammer.Tap, { event: 'singletap' } ],
                        [Hammer.Tap, { event: 'doubletap', taps: 2, interval: 500, threshold: 6, posThreshold: 30 }],
                        //[Hammer.Pan, { event: 'drag3', pointers: 3, threshold: 15 } ],
                        //[Hammer.Pan, { event: 'pan', pointers: 2, threshold: 20 } ],
                        [Hammer.Pan, { event: 'drag', pointers: 1 } ]
                        //[Hammer.Rotate, { enable: true, threshold: 7.0 }],
                        //[Hammer.Pinch, { enable: true, threshold: 0.05 }],
                    ]
                });

                _hammer.on("dragstart", _this.dragStart);
                _hammer.on("dragmove", _this.dragMove);
                _hammer.on("dragend", _this.dragEnd);

                _hammer.on("singletap", _this.onSingleTap);
                _hammer.on("doubletap", _this.onDoubleTap);

            }
        }

        createGUI();
        initEvents();

    };

    //==================================================================================

    avpc.RemoteControl = function(client, domElement) {

        //var _client = client;

        var _canvas1, _canvas2;
        var _stick1, _stick2;
        var _this = this;

        this.sendState = function() {
            var msg = { x1: _stick1.position[0],
                        y1: _stick1.position[1],
                        x2: _stick2.position[0],
                        y2: _stick2.position[1]
            };

            client.sendMessage("joystick", msg);
        };


        function fixOrientation() {

            if (window.orientation == 90 || window.orientation == -90) {
                _canvas1.style.width = "50%";
                _canvas1.style.height = "100%";
                _canvas2.style.width = "50%";
                _canvas2.style.height = "100%";

                _canvas2.style.top = "0%";
                _canvas2.style.left = "50%";
            } else {
                _canvas1.style.width = "100%";
                _canvas1.style.height = "50%";
                _canvas2.style.width = "100%";
                _canvas2.style.height = "50%";

                _canvas2.style.top = "50%";
                _canvas2.style.left = "0%";
            }

        }


        function initUI() {


            _canvas1 = document.createElement("div");
            _canvas1.style.position = "absolute";
            _canvas1.style.width = "100%";
            _canvas1.style.height = "100%";
            //_canvas1.style.backgroundColor = "blue";
            domElement.appendChild(_canvas1);

            _canvas2 = document.createElement("div");
            _canvas2.style.position = "absolute";
            _canvas2.style.width = "100%";
            _canvas2.style.height = "100%";
            _canvas2.style.top = "50%";
            //_canvas2.style.backgroundColor = "orange";
            domElement.appendChild(_canvas2);

            if ( 'ondeviceorientation' in window ) {
                //window.addEventListener("deviceorientation", this.onDeviceOrientation, true);
            }

            window.addEventListener("orientationchange", fixOrientation);
            fixOrientation();

            _stick1 = new avpc.JoyStick(_this, _canvas1);
            _stick2 = new avpc.JoyStick(_this, _canvas2);
        }

        initUI();

    };

})();;
AutodeskNamespace('Autodesk.Viewing.Private.Collaboration');

(function() {

    var av = Autodesk.Viewing,
        ave = av.Extensions,
        avp = av.Private,
        avpc = avp.Collaboration;

    function InteractionInterceptor(viewer, viewtx) {

        var _stick1 = new THREE.Vector2();
        var _stick2 = new THREE.Vector2();
        var _camera;
        var _viewer = viewer;

        var MOVE_SCALE = 20.0;
        var LOOK_SCALE = 0.01;
        var _modelScale = 1.0;

        //viewtx.client.addEventListener("joystick", this.onJoystick);

        this.getNames = function() {
            return ["intercept"];
        };

        this.getName = function() {
            return "intercept";
        };


        this.activate = function(name) {
            viewtx.client.addEventListener("joystick", onJoystick);
            _camera = _viewer.navigation.getCamera();

            if (_viewer.model) {
                var box = _viewer.model.getBoundingBox();
                _modelScale = box.size().length() * 0.001;
            }
        };

        this.deactivate = function(name) {
            viewtx.client.removeEventListener("joystick", onJoystick);
            _camera = null;
        };

        this.update = function(timeStamp) {

            if (_stick1.x == 0 && _stick1.y == 0 && _stick2.x == 0 && _stick2.y == 0)
                return false;

            var direction = _camera.target.clone().sub(_camera.position);
            var distance = direction.length();
            direction.multiplyScalar(1.0/distance);
            var right = direction.clone().cross(_camera.up).normalize();

            var forwardMove = direction.clone().multiplyScalar(_stick1.y * MOVE_SCALE);
            _camera.position.add(forwardMove);
            _camera.target.add(forwardMove);


            var strafeMove = right.clone().multiplyScalar(_stick1.x * MOVE_SCALE);
            _camera.position.add(strafeMove);
            _camera.target.add(strafeMove);

            var lookUpDown = new THREE.Quaternion();
            lookUpDown.setFromAxisAngle(right, _stick2.y * LOOK_SCALE);
            var ndir = direction.clone().applyQuaternion(lookUpDown);

            var lookLeftRight = new THREE.Quaternion();
            lookLeftRight.setFromAxisAngle(_camera.up, -_stick2.x * LOOK_SCALE);
            ndir.applyQuaternion(lookLeftRight);

            ndir.multiplyScalar(distance);
            _camera.target.copy(_camera.position).add(ndir);

            return true;
        };

        this.handleSingleClick = function( event, button ) {return false;};
        this.handleDoubleClick = function( event, button ) {return false;};
        this.handleSingleTap = function( tap ) {return false;};
        this.handleDoubleTap = function( tap1, tap2 ) {return false;};
        this.handleKeyDown = function( event, keyCode ) {return false;};
        this.handleKeyUp = function( event, keyCode ) {return false;};

        this.handleWheelInput = function(delta) {
            viewtx.takeControl();
            return false;
        };

        this.handleButtonDown = function(event, button) {
            viewtx.takeControl();
//            stderr("click");
            return false;
        };

        this.handleButtonUp = function(event, button) {return false;};
        this.handleMouseMove = function(event) {return false;};
        this.handleTouchStart = function(event, touches) {return false;};
        this.handleTouchMove = function(event, touches) {return false;};
        this.handleTouchChange = function(event, touches) {return false;};
        this.handleTouchEnd = function(event) {return false;};
        this.handleBlur = function(event) {return false;};
        this.handleResize = function() {};



        function onJoystick(e) {
            var state = e.data.msg;
            _stick1.x = state.x1;
            _stick1.y = state.y1;
            _stick2.x = state.x2;
            _stick2.y = state.y2;

            //console.log(state);
        };

    }



    //==================================================================================

    function DockingCommentPanel(viewer, client, p2p, viewtx) {

        this.viewer = viewer;
        this.client = client;
        this.p2p = p2p;
        this.viewtx = viewtx;

        var panelId = 'CollabPanel';
        av.UI.DockingPanel.call(this, viewer.container, panelId, 'Collaboration');

        this.container.classList.add('collabPanel');
        this.container.style.height = "auto";
        this.container.dockRight = true;

        this.content = document.createElement("div");
        this.container.appendChild(this.content);
        this.content.classList.add("collabPanelContent");

        this.table = document.createElement("table");
        this.table.className = "tftable";
        this.tbody = document.createElement("tbody");
        this.table.appendChild(this.tbody);

        this.content.appendChild(this.table);


        this.chatHistory = document.createElement("div");
        this.chatHistory.classList.add("chatHistory");
        this.chatHistory.classList.add("textEntry");
        this.content.appendChild(this.chatHistory);


        this.chatPanel = document.createElement("div");
        this.chatPanel.classList.add("chatPanel");

        this.textInput = document.createElement("input");
        this.textInput.type = "text";
        this.textInput.classList.add("textEntry");
        this.textInput.placeholder = "Type a message...";
        this.chatPanel.appendChild(this.textInput);

        this.content.appendChild(this.chatPanel);


        var scope = this;

        client.addEventListener("userListChange", function(e) {
            scope.updateUsers(e.data);
        });

        this.viewtx.addEventListener("controlChange", function(e) {
            scope.updateUserInControl(e.data);
        });

        client.addEventListener("chatReceived", function(e) {
            scope.updateChatHistory(e);
        });

        this.textInput.onkeyup = function(e) {
            scope.handleChatInput(e);
        };

        this.p2p.addEventListener("remoteStreamAdded", function(e) {
            if (!scope.videoPanel)
                scope.createVideoPanel();

            scope.remoteVideo.src = window.URL.createObjectURL(e.data);
        });

        this.p2p.addEventListener("localStreamAdded", function(e) {
            if (!scope.videoPanel)
                scope.createVideoPanel();

            scope.localVideo.src = window.URL.createObjectURL(e.data);
        });
    }

    DockingCommentPanel.prototype = Object.create(av.UI.DockingPanel.prototype);
    DockingCommentPanel.prototype.constructor = DockingCommentPanel;

    DockingCommentPanel.prototype.updateUsers = function(users) {

        var scope = this;

        var tbody = document.createElement("tbody");

        for (var i=0; i<users.length; i++) {
            var row = tbody.insertRow(-1);
            row.id = users[i].id;

            var statusCell = row.insertCell(0);
            statusCell.style.width = "14px";
            statusCell.style.cursor = "default";
            var statusIcon = document.createElement("div");
            statusIcon.classList.add("statusBase");
            statusIcon.classList.add("statusNormal");
            statusIcon.innerHTML = "&#9679";
            statusCell.appendChild(statusIcon);

            var nameCell = row.insertCell(1);
            nameCell.textContent = users[i].name;

            if (!users[i].isSelf) {
                var callCell = row.insertCell(2);
                callCell.classList.add("callButton");
                callCell.innerHTML = "&#9742";
                callCell.title = "Start audio/video call";

                callCell.onclick = function(e) {
                    var targetId = e.target.parentNode.id;

                    if (scope.p2p.getCurrentCallTarget() == targetId)
                        return;

                    if (scope.videoPanel) {
                        scope.p2p.hangup();
                        scope.removeVideoPanel();
                    }

                    scope.createVideoPanel();
                    scope.p2p.callUser(targetId);
                };
            }
        }

        this.table.replaceChild(tbody, this.tbody);
        this.tbody = tbody;

        this.fixComponentPlacement();
    };

    DockingCommentPanel.prototype.updateUserInControl = function(id) {
        for (var i=0; i<this.tbody.rows.length; i++) {
            var r = this.tbody.rows[i];
            var icon = r.cells[0].childNodes[0];
            if (r.id == id) {
                icon.classList.remove("statusNormal");
                icon.classList.add("statusInControl");
                icon.innerHTML = "&#9784";
            } else {
                icon.classList.remove("statusInControl");
                icon.classList.add("statusNormal");
                icon.innerHTML = "&#9679";
            }

        }
    };

    DockingCommentPanel.prototype.updateChatHistory = function(e) {

        var user = this.client.getUserById(e.data.from);

//        var line = user.name + ": " + e.data.msg;

        if (this.chatHistory.lastUser != user.name) {

            var pEl = document.createElement("p");

            var nameEl = document.createElement("div");
            nameEl.classList.add("heading");
            nameEl.style.float = "left";
            nameEl.textContent = user.name;
            pEl.appendChild(nameEl);

            var timeEl = document.createElement("div");
            timeEl.classList.add("heading");
            timeEl.style.textAlign = "right";
            timeEl.textContent = new Date().toLocaleTimeString();
            pEl.appendChild(timeEl);

            this.chatHistory.appendChild(pEl);

            this.chatHistory.lastUser = user.name;
        } else {
            var br = document.createElement("br");
            this.chatHistory.appendChild(br);
        }

        var msgEl = document.createElement("span");
        msgEl.classList.add("messageText");
        msgEl.textContent = e.data.msg;
        this.chatHistory.appendChild(msgEl);

        this.chatHistory.scrollTop = this.chatHistory.scrollHeight;
    };

    DockingCommentPanel.prototype.handleChatInput = function(e) {
        if (e.which != 13)
            return;
        if (this.textInput.value.length == 0)
            return;

        this.client.sendChatMessage(this.textInput.value);
        this.textInput.value = "";
        this.textInput.placeholder = "";
    };

    DockingCommentPanel.prototype.fixComponentPlacement = function(e) {

        var heightAdj = this.table.offsetHeight + this.chatPanel.offsetHeight;

        if (this.videoPanel) {
            heightAdj += this.videoPanel.offsetHeight;
            this.chatHistory.style.height = "calc(100% - " + heightAdj + "px)";
        }
        else {
            this.chatHistory.style.height = "calc(100% - " + heightAdj + "px)";
        }

    };

    DockingCommentPanel.prototype.createVideoPanel = function(e) {

        this.videoPanel = document.createElement("div");
        this.videoPanel.classList.add("videoPanel");

        this.localVideo = document.createElement("video");
        this.localVideo.autoplay = true;
        this.localVideo.muted = true;
        this.localVideo.classList.add("videoInset");
        this.videoPanel.appendChild(this.localVideo);

        this.remoteVideo = document.createElement("video");
        this.remoteVideo.autoplay = true;
        this.remoteVideo.classList.add("videoMain");
        this.videoPanel.appendChild(this.remoteVideo);

        var scope = this;
        var closer = document.createElement("div");
        closer.classList.add("dockingPanelClose");
        closer.innerHTML="&times";
        closer.title = "End video call";
        closer.onclick = function(e) {
            scope.p2p.hangup();
            scope.removeVideoPanel();
        };
        this.videoPanel.appendChild(closer);

        this.content.insertBefore(this.videoPanel, this.chatHistory);

        this.fixComponentPlacement();
    };

    DockingCommentPanel.prototype.removeVideoPanel = function() {
        if (this.videoPanel)
            this.content.removeChild(this.videoPanel);
        this.videoPanel = null;
    };

    DockingCommentPanel.prototype.reset = function(e) {
        if (this.tbody) {
            var empty = document.createElement("tbody");
            this.table.replaceChild(empty, this.tbody);
            this.tbody = empty;
        }
        this.chatHistory.textContent = "";
        this.textInput.value = "";
        this.removeVideoPanel();
    };


    //==================================================================================
    //Extension interface

    /** @constructor */
    ave.Collaboration = function (viewer, options) {
        av.Extension.call(this, viewer, options);

        this.viewer = viewer;
        this.client = new avpc.Client();
        this.viewtx = new avpc.ViewTransceiver(this.client);
        this.interceptor = new InteractionInterceptor(viewer, this.viewtx);
        viewer.toolController.registerTool(this.interceptor);

        this.p2p = new avpc.P2PClient(this.client);
    };

    ave.Collaboration.prototype = Object.create(av.Extension.prototype);
    ave.Collaboration.prototype.constructor = ave.Collaboration;


    ave.Collaboration.prototype.createUI = function() {

        var scope = this;
        var viewer = this.viewer;

        this.panel = new DockingCommentPanel(this.viewer, this.client, this.p2p, this.viewtx);

        // Create a comment toolbar button.
        //TODO: HACK: the id is intentionally "commentTool" in order to get the icon for the button from CSS based on id.

        this.collabButton = av.UI.Toolbar.createMenuButton("toolbar-commentTool", "Collaborate", function(e) {
            var isVisible = scope.panel.isVisible();

            if (!isVisible) {

                if (viewer.model) {
                    var svf = viewer.model.getData();
                    scope.client.connect(svf.basePath);
                }

                viewer.toolController.activateTool(scope.interceptor.getName());
                scope.panel.setVisible(true);
            }
            else {
                scope.p2p.hangup();
                scope.viewtx.detach(viewer);
                scope.client.disconnect();
                scope.panel.setVisible(false);
                scope.panel.reset();
                viewer.toolController.deactivateTool(scope.interceptor.getName());
            }

        });

        this.panel.addVisibilityListener(function(state) {
            if (state) {

                if (viewer.model) {
                    var svf = viewer.model.getData();
                    scope.client.connect(svf.basePath);
                    scope.viewtx.attach(viewer);
                }
                viewer.toolController.activateTool(scope.interceptor.getName());

                viewer.modelTools.select(scope.collabButton.id );
            }
            else {
                scope.p2p.hangup();
                scope.viewtx.detach(viewer);
                scope.client.disconnect();
                scope.panel.reset();
                viewer.toolController.deactivateTool(scope.interceptor.getName());

                viewer.modelTools.deselect(scope.collabButton.id );
            }
        });

        // Insert the comment button before "setting" button.
        var settingsTool = viewer.modelTools.getTool("toolbar-settingsTool");
        if (settingsTool)
            viewer.modelTools.insertToolBefore( this.collabButton, settingsTool );
        else
            viewer.modelTools.addTool( this.collabButton );

    };

    ave.Collaboration.prototype.load = function () {
        var viewer = this.viewer;
        var scope = this;

        // add the button to the toolbar
        if(viewer.modelTools && viewer.modelTools.getToolCount() > 0) {
            scope.createUI();
        } else {
            viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
        }

        function onToolbarCreated(e) {
            viewer.removeEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
            scope.createUI();
        }

        return true;
    };

    ave.Collaboration.prototype.unload = function () {

        var viewer = this.viewer;

        this.p2p.hangup();
        this.viewtx.detach(viewer);
        this.client.disconnect();

        viewer.toolController.deactivateTool(this.interceptor.getName());

        if (this.panel) {
            this.panel.reset();
            this.panel.setVisible(false);
            this.panel = null;
        }

        viewer.modelTools.removeTool(this.collabButton);

        return true;
    };

    av.theExtensionManager.registerExtension('Autodesk.Viewing.Collaboration', ave.Collaboration);

})();;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Beeline');

Autodesk.Viewing.Extensions.Beeline.BeelineExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.constructor = Autodesk.Viewing.Extensions.Beeline.BeelineExtension;

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.load = function() {
    var self = this;
    var viewer = this.viewer;
    var toolbar = viewer.getToolbar(true);

    // Register tool
    this.tool = new Autodesk.Viewing.Extensions.Beeline.BeelineTool(viewer.impl, viewer);
    viewer.toolController.registerTool(this.tool);
    var beelineToolIds = this.tool.getNames();

    // Add UI
    // Add beeline button
    this.createUI(toolbar);

    // Add hotkey
    var previousTool;
    function onPress() {
        previousTool = viewer.getActiveNavigationTool();
        viewer.setActiveNavigationTool(beelineToolIds[0]);
        return true;
    }
    function onRelease() {
        viewer.setActiveNavigationTool(previousTool ? previousTool : viewer.defaultNavigationToolName);
        return true;
    }
    this.HOTKEYS_ID = "Autodesk.Beeline.Hotkeys";
    var hotkeys = [];
    hotkeys.push({
        keycodes: [
            Autodesk.Viewing.theHotkeyManager.KEYCODES.CONTROL,
            Autodesk.Viewing.theHotkeyManager.KEYCODES.ALT
        ],
        onPress: onPress,
        onRelease: onRelease
    });
    Autodesk.Viewing.theHotkeyManager.pushHotkeys(this.HOTKEYS_ID, hotkeys);

    // Register listeners
    this.onToolChanged = function (e) {
        if (e.toolName.indexOf('beeline') === -1) {
            return;
        }

        var state = e.active ? Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE : Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE;

        if (e.toolName === "beeline-go-to") {
            Autodesk.Viewing.UI.SubToolbar.setToolState(self.goToButton.id, state);
        } else {
            Autodesk.Viewing.UI.SubToolbar.setToolState(self.passThroughButton.id, state);
        }
    };

    viewer.addEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);

    return true;
};

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.createUI = function(toolbar)
{
    var navTools = toolbar.getSubToolbarById(Autodesk.Viewing.TOOLBAR.NAVTOOLSID);

    var beelineButtonId = "toolbar-beelineSubmenuTool";
    var goToButtonId = "toolbar-beelineGoToTool";
    var passThroughButtonId = "toolbar-beelinePassThroughTool";

    var options = {
        onToolStateChangedCB: function() {
            if (Autodesk.Viewing.UI.SubToolbar.getToolState(beelineButtonId) === Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE) {
                Autodesk.Viewing.UI.SubToolbar.setToolState(goToButtonId, Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE);
                Autodesk.Viewing.UI.SubToolbar.setToolState(passThroughButtonId, Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE);
            }
        }
    };
    var beelineButton = Autodesk.Viewing.UI.Toolbar.createMenuButton(beelineButtonId, "Walkthrough", null, options);
    beelineButton.style.position = "relative";

    var cameraSubmenuTool = navTools.getTool('toolbar-cameraSubmenuTool');
    if (cameraSubmenuTool) {
        navTools.insertToolBefore(beelineButton, cameraSubmenuTool);
    } else {
        navTools.addTool(beelineButton);
    }

    var submenu = document.createElement("ul");
    submenu.style.width    = "48px";
    submenu.style.position = "absolute";
    submenu.style.left     = "2px";
    submenu.style.paddingBottom = "2px";

    var createButton = Autodesk.Viewing.UI.Toolbar.createMenuButton;
    var viewer = this.viewer;

    var options = { defaultTooltipValue : "Pass through" };
    this.passThroughButton = createButton(passThroughButtonId, "Pass through", function(e) {
        var state = Autodesk.Viewing.UI.SubToolbar.getToolState(self.passThroughButton);
        if (state === Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE) {
            viewer.setActiveNavigationTool("beeline-pass-through");
        } else if (state === Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE) {
            viewer.setActiveNavigationTool(viewer.defaultNavigationToolName);
        }
    }, options);
    this.passThroughButton.style.marginLeft = "2px";
    this.passThroughButton.style.marginTop  = "2px";
    submenu.appendChild( this.passThroughButton );

    options.defaultTooltipValue = "Go to (Ctrl+Alt click)";
    this.goToButton = createButton(goToButtonId, "Go to", function(e) {
        var state = Autodesk.Viewing.UI.SubToolbar.getToolState(self.goToButton);
        if (state === Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE) {
            viewer.setActiveNavigationTool("beeline-go-to");
        } else if (state === Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE) {
            viewer.setActiveNavigationTool(viewer.defaultNavigationToolName);
        }
    }, options);
    this.goToButton.style.marginLeft = "2px";
    this.goToButton.style.marginTop  = "2px";

    submenu.appendChild(this.goToButton);

    toolbar.attachSubMenu(beelineButton, submenu);
};

Autodesk.Viewing.Extensions.Beeline.BeelineExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // Remove listeners
    viewer.removeEventListener(Autodesk.Viewing.TOOL_CHANGE_EVENT, this.onToolChanged);
    this.onToolChanged = undefined;

    // Remove hotkey
    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.HOTKEYS_ID);

    // Remove the UI
    var toolbar = viewer.getToolbar(false);
    if (toolbar) {
        toolbar.removeFromSubToolbar(Autodesk.Viewing.TOOLBAR.NAVTOOLSID, this.beelineButton);
    }
    this.beelineButton = null;

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Beeline', Autodesk.Viewing.Extensions.Beeline.BeelineExtension);;AutodeskNamespace('Autodesk.Viewing.Extensions.Beeline');

// /** @constructor */
//
// TODO: Pass in the api instead of the impl, don't use the impl object.
//
Autodesk.Viewing.Extensions.Beeline.BeelineTool = function( viewerImpl, viewerApi )
{
    var MODE = {
        GO_TO: 0,
        PASS_THROUGH: 1,
        DEFAULT: 1
    };

    // Constants
    var kDefaultFlightDuration = 5500; // milliseconds
    var kShortFlightDuration = 1000; // milliseconds
    var kLookSensitivity = 1.0;
    var kMaxFocalLength = 28;
    var kDoubleClickThreshold = 400; // milliseconds

    // States
    var kStartState = 0;
    var kFlightState = 1;

    var self = this;
    var _viewerapi = viewerApi;
    var _container = viewerApi.container;
    var _autocam = viewerApi.autocam;
    var _navapi = viewerApi.navigation;
    var _viewerUtilities = viewerApi.utilities;
    var _names = ["beeline-go-to", "beeline-pass-through"];

    var _mode = MODE.DEFAULT;
    var _state = kStartState;
    var _isDragging = false;
    var _mouseButtons = 0;
    var _flightStartTime = null;
    var _flightDuration = null;
    var _intersectPointNear = new THREE.Vector3();
    var _intersectPointFar = new THREE.Vector3();
    var _flightStartPosition = new THREE.Vector3();
    var _flightEndPosition = new THREE.Vector3();
    var _haltAnimation = false;
    var _mouseXY = new THREE.Vector3();
    var _previousXY = new THREE.Vector3();
    var _previousMouseClickTime = 0;

    var _projector = new THREE.Projector();

    var _expectedCameraState = null;
    var _touchType = null;

    // UI
    var _modeToCursorMap = {
        0: "url(data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAORJREFUeNrElMEKwyAQRN9KIb+WU275rEJP7Z8K8TK9aJE0MaYaurBIRGY2u7MD8ASU5QI8JNEjDZAkUoQQGIYhSBroEC7/CCEwzzPAi44hSVqWRdM0CXjEyy4J4L33GsfxA96b4A74eNKbwPIB52Fm6tB7ux08+BnczL5VdEXcaqpoCWtpQ9MfxI0ujgiwo/ntEsSN3hy0mUlSOq3U2pJMNwkSeP5uTRLvzqtoDZ4KKO2MawGvIXE1S1YCPyJxLZXXkLgKKz/rP0nChypSrT/tbXzR7Hb0rTPv/292PQzwcrN7DwDlOW+PynjQHAAAAABJRU5ErkJggg==), wait",
        1: "url(data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAPFJREFUeNrElM0KwyAQhL+VPFxO3vJYhZ7aNxXMZXpoUqxEo0kgC6K4P7PODgK8ACUrAk9JXLEAlFqMUUCMMVKzNbnml8SQXs7zzDRNAO9lrxYq+cwsj/t27r0X8Nzq5AAtv3MIIWgcx7/iV1EE8ADCstMKsAhiH6D0RO99kaKV1mWvUmRbT02HlPvNTOmdmSHJ8vw1xnWqQ7lPEmZWpMvRaFvFW0Bci0pqxfdA3JnOW0Dcfo7osVVlvwZrA20VQP41JLE2VDqxVtBSfJeKjtrQm1CioxjfO8Reu4+i2kA7JGvDmT+/ZVb3qqhXMbeo6DMA9G9RMtTMcQsAAAAASUVORK5CYII=), wait"
    };

    function screenModeChanged()
    {
        self.revertToStartState();
    }

    // Utility methods
    function getCameraState(camera) {
        var state = {};

        state.target  = camera.target.clone();
        state.worldup = camera.worldup.clone();

        state.position = camera.position.clone();
        state.up = camera.up.clone();

        var props = ['isPerspective', 'fov', 'zoom', 'aspect', 'left', 'right', 'top', 'bottom'];
        for (var i = 0; i < props.length; i++) {
            state[props[i]] = camera[props[i]];
        }

        return state;
    }

    function compareCameraToState(camera, state) {
        var result = camera.target.equals(state.target) &&
            camera.position.equals(state.position) &&
            camera.worldup.equals(state.worldup) &&
            camera.up.equals(state.up);

        if (!result) {
            return false;
        }

        var props = ['isPerspective', 'fov', 'zoom', 'aspect', 'left', 'right', 'top', 'bottom'];
        for (var i = 0; i < props.length; i++) {
            if (camera[props[i]] !== state[props[i]]) {
                return false;
            }
        }

        return true;
    }

    function getIntersectionPoints(event) {
        var viewportVec = new THREE.Vector3(event.normalizedX, event.normalizedY, 1.0);
        var result = viewerImpl.hitTestViewport(viewportVec.clone(), false);

        if (!result.intersectPoint) {
            return [];
        }

        // Get intersection points
        var frags = result.node.fragIds instanceof Array ? result.node.fragIds : [result.node.fragIds];
        var objects = [];
        for (var i = 0; i < frags.length; i++) {
            var object = viewerImpl.getRenderProxy(this.model, frags[i]);
            if (object) {
                objects.push(object);
            }
        }

        var caster = new THREE.Raycaster();
        var vector = viewportVec.clone();
        var camera = viewerImpl.camera;
        var end = new THREE.Vector3( vector.x, vector.y, 1.0 );

        vector.z = -1.0;
        _projector.unprojectVector( vector, camera );
        _projector.unprojectVector( end, camera );
        end.sub(vector).normalize();

        caster.set(_navapi.isPerspective ? camera.position : vector, end);

        return caster.intersectObjects(objects, false);
    }

    function prepareCamera() {
        if (!_navapi.isPerspective) {
            _navapi.toPerspective();
            _viewerUtilities.activatePivot(false);
        }
        if (_navapi.getFocalLength() > kMaxFocalLength) {
            _navapi.setFocalLength(kMaxFocalLength, false);
        }
    }

    function getEventModifierState(event) {
        if( _touchType )
            return true;

        var isMac = (navigator.userAgent.search("Mac OS") !== -1);
        var ctrlKey = event.ctrlKey || (isMac && event.metaKey);
        var metaKey = event.metaKey && !isMac;

        return !metaKey && !event.shiftKey && !(event.altKey ^ ctrlKey);
    }

    // Tool methdos
    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.activate = function(toolName)
    {
        if (toolName === _names[0]) {
            _mode = MODE.GO_TO;
        } else {
            _mode = MODE.PASS_THROUGH;
        }

        _mouseButtons = 0;
        viewerApi.addEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, screenModeChanged);
        _autocam.userLookSpeed = kLookSensitivity;
        this.showHUDMessage(true);
    };

    this.deactivate = function()
    {
        viewerApi.removeEventListener(Autodesk.Viewing.FULLSCREEN_MODE_EVENT, screenModeChanged);
        this.revertToStartState();
        this.showHUDMessage(false);
    };

    this.getCursor = function()
    {
        return !_isDragging && _mouseButtons !== 0 ? null : _modeToCursorMap[_mode];
    };

    this.update = function () {
        var camera = _navapi.getCamera();

        var moved = false;
        if (_isDragging) {
            var deltaXY = _mouseXY.clone().sub(_previousXY);
            if (deltaXY.x !== 0 || deltaXY.y !== 0) {
                var worldDotCamera = _navapi.getWorldUpVector().dot(_navapi.getCameraUpVector());
                var horDirection = viewerApi.prefs.reverseHorizontalLookDirection ? -1 : 1;
                var vertDirection = viewerApi.prefs.reverseVerticalLookDirection ? -1 : 1;

                deltaXY.x *= worldDotCamera < 0 ? -horDirection : horDirection;
                deltaXY.y *= vertDirection;

                // Make sure we're synced with the camera
                _autocam.sync(_navapi.getCamera());
                _autocam.look(deltaXY);
                moved = true;

                _expectedCameraState = getCameraState(camera);
            }
            _previousXY.x = _mouseXY.x;
            _previousXY.y = _mouseXY.y;
        }

        return moved;
    };

    // Beeline methods
    this.revertToStartState = function()
    {
        _viewerUtilities.pivotActive(false);
        _state = kStartState;
        _haltAnimation = true;
        _isDragging = false;
    };

    this.fly = function(duration)
    {
        prepareCamera();

        _flightStartPosition = _navapi.getPosition();
        _flightDuration = duration;
        switch (_mode) {
            case MODE.GO_TO:
                // Fly 80% of the way there
                _flightEndPosition = _flightStartPosition.clone().lerp(_intersectPointNear, 0.8);
                break;

            case MODE.PASS_THROUGH:
                // Fly 2 near planes past the object.
                var near = _autocam.camera.near * 2;
                var distance = _intersectPointFar.clone().sub(_flightStartPosition).length();
                var nearRatio = near / distance;

                _viewerUtilities.setPivotPoint(_flightStartPosition.clone().lerp(_intersectPointFar, 1 + 10 * nearRatio), true, true);
                _flightEndPosition = _flightStartPosition.clone().lerp(_intersectPointFar, 1 + nearRatio);
                break;

            default:
                return;
        }

        _state = kFlightState;

        _haltAnimation = false;
        _flightStartTime = null;

        requestAnimationFrame(self.step);
    };

    // Animating the camera
    this.step = function(timestamp)
    {
        var camera = _navapi.getCamera();

        if (_haltAnimation) {
            return;
        }

        if (_flightStartTime === null) {
            _expectedCameraState = getCameraState(camera);

            _flightStartTime = timestamp;
        } else if (!compareCameraToState(camera, _expectedCameraState)) {
            self.revertToStartState();
            return;
        }

        var flightTime = timestamp - _flightStartTime;
        var t = flightTime < _flightDuration ? flightTime / _flightDuration : 1;

        var newPosition = _flightStartPosition.clone().lerp(_flightEndPosition, t);

        // Keep target the same distance as the pivot
        var viewVec = _navapi.getEyeVector();
        viewVec.multiplyScalar(_navapi.getPivotPoint().sub(_navapi.getPosition()).length() / viewVec.length());

        _navapi.setView(newPosition, viewVec.add(newPosition));

        _expectedCameraState = getCameraState(camera);

        _viewerUtilities.activatePivot(false);

        if (flightTime < _flightDuration) {
            requestAnimationFrame(self.step);
        } else {
            self.revertToStartState();
        }
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    this.handleGesture = function( event )
    {
        switch( event.type )
        {
            case "dragstart":
                _touchType = "drag";
                // Single touch, fake the mouse for now...
                return this.handleButtonDown(event, 0);

            case "dragmove":
                return (_touchType === "drag") ? this.handleMouseMove(event) : false;

            case "dragend":
                if( _touchType === "drag" )
                {
                    this.handleButtonUp(event, 0);
                    _touchType = null;
                    return true;
                }
                return false;
        }
        return false;
    };


    this.handleButtonDown = function( event, button )
    {
        _mouseButtons += 1 << button;

        var modifierState = getEventModifierState(event);
        if (button === 0 && modifierState) {
            _isDragging = true;
            _previousXY.x = _mouseXY.x = event.canvasX;
            _previousXY.y = _mouseXY.y = event.canvasY;
        }
        return button === 0 && modifierState;
    };

    this.handleButtonUp = function( event, button )
    {
        _mouseButtons -= 1 << button;

        var modifierState = getEventModifierState(event);
        if (button === 0 && modifierState) {
            _isDragging = false;
        }
        return button === 0 && modifierState;
    };

    this.handleSingleClick = function( event, button )
    {
        // Anything besides LMB should revert viewer to initial state
        var modifierState = getEventModifierState(event);
        if (button === 0 && modifierState) {
            var timeDelta = event.timeStamp - _previousMouseClickTime;

            switch (_state) {
                case kStartState:
                    var intersectionPoints = getIntersectionPoints(event);

                    if (intersectionPoints.length > 0) {
                        _intersectPointNear = intersectionPoints[0].point;
                        _intersectPointFar = intersectionPoints[intersectionPoints.length - 1].point;
                        _viewerUtilities.setPivotPoint(_intersectPointNear, true, true);
                        _viewerUtilities.pivotActive(true);

                        self.fly(timeDelta <= kDoubleClickThreshold ? kShortFlightDuration : kDefaultFlightDuration);
                    }
                    break;

                case kFlightState:
                    if (timeDelta <= kDoubleClickThreshold) {
                        _flightDuration = kShortFlightDuration;
                    } else {
                        this.revertToStartState();
                    }
                    break;

                default:
                    break;
            }

            _previousMouseClickTime = event.timeStamp;
        } else {
            this.revertToStartState();
        }

        return button === 0 && modifierState;
    };

    this.handleSingleTap = function( event )
    {
        return this.handleSingleClick(event, 0);
    };

    this.handleDoubleTap = function( event )
    {
        _flightDuration = kShortFlightDuration;
        return true;
    };

    this.handleDoubleClick = function( event, button )
    {
        // We handle our own double click. The event isn't triggered if a modifier key is being held.
        var modifierState = getEventModifierState(event);
        return button === 0 && modifierState;
    };

    this.handleMouseMove = function( event )
    {
        _mouseXY.x = event.canvasX;
        _mouseXY.y = event.canvasY;

        if (_isDragging) {
            prepareCamera();
        }

        return _isDragging;
    };

    this.handleBlur = function(event)
    {
        // Reset things when we lose focus...
        this.revertToStartState();
        return false;
    };

    this.showOrthoWarningMessage = function()
    {
        var messageSpecs = {
            "msgTitleKey"   : "Orthographic View Set",
            "messageKey"    : "The view is set to Orthographic Beeline",
            "messageDefaultValue"  : "The view is set to Orthographic. Using this tool will switch to Perspective."
        };
        Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs);
    };

    this.showFocalWarningMessage = function()
    {
        var messageSpecs = {
            "msgTitleKey"   : "Long Focal Length View Set",
            "messageKey"    : "The view is set to a long focal length",
            "messageDefaultValue"  : "This view has a long focal length. Using this tool will set a short focal length."
        };
        Autodesk.Viewing.Private.HudMessage.displayMessage(_container, messageSpecs);
    };

    this.watchCamera = function(e)
    {
        // If camera changed to ORTHO and we are still in Beeline mode
        // put up the warning message that the system will switch to perspective.
        // Similarly, warn for long focal length.
        if (_viewerapi.toolController.getActiveToolName() === _names[0] ||
            _viewerapi.toolController.getActiveToolName() === _names[1]) {
            var camera = _navapi.getCamera();
            var isOrtho = camera && !camera.isPerspective;
            var hasLongFocalLength = _navapi.getFocalLength() > kMaxFocalLength;

            if (isOrtho)
                self.showOrthoWarningMessage();
            else if (hasLongFocalLength)
                self.showFocalWarningMessage();
            else
                Autodesk.Viewing.Private.HudMessage.dismiss();
        }
    };

    this.showHUDMessage = function(state)
    {
        var camera = _navapi.getCamera();
        var isOrtho = camera && !camera.isPerspective;
        var hasLongFocalLength = _navapi.getFocalLength() > kMaxFocalLength;

        if (state && isOrtho) {
            self.showOrthoWarningMessage();
        } else if (state && hasLongFocalLength) {
            self.showFocalWarningMessage();
        } else {
            Autodesk.Viewing.Private.HudMessage.dismiss();
        }

        if (state) {
            _viewerapi.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.watchCamera);
        } else {
            _viewerapi.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, self.watchCamera);
        }
    };

};
;'use strict';

AutodeskNamespace('Autodesk.Viewing.Extensions.Measure');

Autodesk.Viewing.Extensions.Measure.MeasureExtension = function(viewer, options) {
    Autodesk.Viewing.Extension.call(this, viewer, options);
};

Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype = Object.create(Autodesk.Viewing.Extension.prototype);
Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.constructor = Autodesk.Viewing.Extensions.Measure.MeasureExtension;

Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.load = function() {
    var self   = this;
    var viewer = this.viewer;

    this.escapeHotkeyId = 'Autodesk.Measure.Hotkeys.Escape';

    // Register the Measure tool
    this.tool = new Autodesk.Viewing.Extensions.Measure.MeasureTool(viewer, { onCloseCallback: function(e) {
        self.enableMeasureTool(false);
    }});
    viewer.toolController.registerTool(this.tool);

    function onToolbarCreated() {
        viewer.createUI();
    }

    if (this.viewer.toolbar) {
        var modelTools = this.viewer.toolbar.getSubToolbarById(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);
        if (modelTools.getToolCount()>0) {
            this.createUI();
        }
        else {
            this.viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
        }
    } else {
        this.viewer.addEventListener(Autodesk.Viewing.TOOLBAR_CREATED_EVENT, onToolbarCreated);
    }

    return true;
};

Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.unload = function () {
    var viewer = this.viewer;

    // Remove the ui from the viewer.
    this.destroyUI();

    // Deregister tool
    viewer.toolController.deregisterTool(this.tool);
    this.tool = null;

    return true;
};

/**
 * Enable/disable the measure tool.
 * @param {boolean} enable - true to enable, false to disable.
 * @returns {boolean} true if the tool state was changed.
 */
Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.enableMeasureTool = function(enable) {
    if (this.tool) {
        var toolController = this.viewer.toolController,
            isActive = this.tool.isActive();

        if (enable && !isActive) {
            toolController.activateTool("measure");
            Autodesk.Viewing.UI.SubToolbar.setToolState( this.measureToolButton.id, Autodesk.Viewing.UI.SubToolbar.STATE_ACTIVE);
            return true;

        } else if (!enable && isActive) {
            toolController.deactivateTool("measure");
            Autodesk.Viewing.UI.SubToolbar.setToolState( this.measureToolButton.id, Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE);
            return true;
        }
    }
    return false;
};

Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.createUI = function()
{
    var self   = this;
    var viewer = this.viewer;

    this.measureToolButton = null;
    this.inspectToolsButton = null;

    // Do not add Measure Tool for 2d.
    if (!viewer.model || viewer.model.is2d())
        return;

    var toolbar = viewer.getToolbar(true);
    var modelTools = toolbar.getSubToolbarById(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);

    // Create a button for the measure tool.
    var createButton = Autodesk.Viewing.UI.Toolbar.createMenuButton;
    var explodeTool  = viewer.modelTools.getTool("toolbar-explodeTool");

    this.measureToolButton = createButton( "toolbar-measureTool", "Measure", function(e) {
        self.enableMeasureTool(!self.tool.isActive());
        if (explodeTool && self.tool.isActive()) {
            // Deactivate the explode tool.
            //
            // TODO: It should not be done manually, but through the tool API which does not exist yet.
            //
            var isShown = viewer.explodeslider.classList.contains("slider-anim-in");
            if (isShown)
                viewer.showExplodeSlider(false);
            Autodesk.Viewing.UI.SubToolbar.setToolState( explodeTool.id, Autodesk.Viewing.UI.SubToolbar.STATE_NOTACTIVE);
        }
    });
    var toolbarButton = this.measureToolButton;

    if (explodeTool) {
        // If there is an explodeTool button already on the toolbar
        // remove it and added to the Inspect submenu.
        //
        var inspectToolId = "toolbar-inspectTools";
        this.inspectToolsButton = createButton( inspectToolId, "Inspect", null );
        this.inspectToolsButton.style.position = "relative";

        var submenu = document.createElement("ul");
        submenu.style.width = "44px";
        submenu.style.position = "absolute";
        submenu.style.right = 0;

        // Remove the explode button from the toolbar:
        modelTools.removeTool(explodeTool);

        submenu.appendChild( this.measureToolButton );
        submenu.appendChild( explodeTool );

        explodeTool.children[0].style.left = "110%";
        explodeTool.children[0].style.bottom = "10%";

        toolbar.attachSubMenu( this.inspectToolsButton, submenu );
        toolbarButton = this.inspectToolsButton;
    }

    // Insert a new button before "setting" button.
    var resetTool = viewer.modelTools.getTool("toolbar-resetTool");
    if (resetTool)
        modelTools.insertToolBefore( toolbarButton, resetTool );
    else
        modelTools.addTool( toolbarButton );

    // Escape hotkey to exit tool.
    //
    var hotkeys = [{
        keycodes: [
            Autodesk.Viewing.theHotkeyManager.KEYCODES.ESCAPE
        ],
        onRelease: function () {
            return self.enableMeasureTool(false);
        }
    }];
    Autodesk.Viewing.theHotkeyManager.pushHotkeys(this.escapeHotkeyId, hotkeys);
};

Autodesk.Viewing.Extensions.Measure.MeasureExtension.prototype.destroyUI = function()
{
    var viewer = this.viewer;

    if (viewer.model.is2d())
        return;
    
    var toolbar = viewer.getToolbar(false);
    if (toolbar) {
        var modelTools = toolbar.getSubToolbarById(Autodesk.Viewing.TOOLBAR.MODELTOOLSID);
        if (modelTools) {
            if (this.inspectToolsButton)
                toolbar.removeFromSubToolbar(Autodesk.Viewing.TOOLBAR.MODELTOOLSID, this.inspectToolsButton.id);
            else if(this.measureToolButton)
                toolbar.removeFromSubToolbar(Autodesk.Viewing.TOOLBAR.MODELTOOLSID, this.measureToolButton.id);

            this.measureToolButton = null;
            this.inspectToolsButton = null;
        }
    }

    Autodesk.Viewing.theHotkeyManager.popHotkeys(this.escapeHotkeyId);
};

Autodesk.Viewing.theExtensionManager.registerExtension('Autodesk.Measure', Autodesk.Viewing.Extensions.Measure.MeasureExtension);
;AutodeskNamespace('Autodesk.Viewing.Extensions.Measure');

//
// /** @constructor */
//
//
Autodesk.Viewing.Extensions.Measure.MeasureTool = function( viewer, options )
{
    var tool = this;

    var _viewer  = viewer;
    var _options = options;

    var _names  = ["measure"];
    var _active = false;

    var _firstClick = null;
    var _secondClick = null;
    var _isDragging = false;
    var _activePoint = 0;
    var _consumeSingleClick = false;

    var _units = "";
    var _precision = 3;
    var _currDistance = 0;

    // UI.
    var _indicator = null;
    var _measurePanel = null;
    var _cursor = "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAKZJREFUeNrclLEKwzAQQ9+FgH/Nk7d8ViFT+6cG36IsNXgIdMg5kAoOIw8WSDoDvAEN04BdEhFjgCTR4e6klFxSIgDLSNydbdsAPgRCktRaUylFkfZ0Z2qtVTlnAfugGibwAur3JFrAxoBnYGEy1pGYmQCLLNB6Uqmw182M9eRS0yzqGo+y6D9rytSQR8vM7DKfbtHy4x+/xG8J+d4W9WAi8fxFOwYA8W0ypu2ZfcsAAAAASUVORK5CYII=), wait";

    this.isActive = function()
    {
        return _active;
    };

    this.getNames = function()
    {
        return _names;
    };

    this.getName = function()
    {
        return _names[0];
    };

    this.getCursor = function() {
        return (_isDragging && _activePoint === 0) ? null : _cursor;
    };

    this.activate = function()
    {
        _active = true;
        _activePoint = 0;

        if (!_units)
            _units = _viewer.model.getUnitString();

        _isDragging = false;

        activateUI();

       _viewer.addEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCameraChange);
    };

    this.deactivate = function()
    {
        _active = false;
        _firstClick = _secondClick = null;
        _currDistance = 0;

        deactivateUI();

        _viewer.removeEventListener(Autodesk.Viewing.CAMERA_CHANGE_EVENT, onCameraChange);
    };

    this.update = function()
    {
        return false;
    };

    this.getUnits = function() {
        return _units;
    };

    this.setUnits = function( units )
    {
        if (_units !== units ) {
            var oldUnits = _units;

            _units = units;

            // Update UI
            if (_indicator) {
                _currDistance = Autodesk.Viewing.Private.convertUnits(oldUnits, _units, _currDistance );
                _indicator.updateDistance();
            }
        }
    };

    this.getPrecision = function() {
        return _precision;
    };

    this.setPrecision = function( precision ) {

        if (_precision !== precision ) {
            _precision = precision;

            // Update UI
            if (_indicator) {
                _indicator.updateDistance();
            }
        }
    };

    this.getCurrentDistance = function() {
        return _currDistance;
    };

    this.clearMeasurement = function() {
        _firstClick = _secondClick = null;
        _currDistance = 0;
        _indicator.hide();
        _measurePanel.clearPanel();
    };

    // ------------------------
    // Event handler callbacks:
    // These can use "this".

    this._handleMouseEvent = function (event) {
        var result = _viewer.impl.hitTest(event.clientX, event.clientY, false);
        if (result && result.intersectPoint) {
            if (_activePoint === 0) {
                this.clearMeasurement();
                _activePoint = 1;
            }

            if (_activePoint === 1) {
                _firstClick = result.intersectPoint;
                _indicator.showFirst(_firstClick, 0.05);

            } else if (_activePoint === 2) {
                _secondClick = result.intersectPoint;
                _indicator.showSecond(_secondClick, 0.05);

                var fromUnits = _viewer.model.getUnitString(),
                    toUnits   = _units;

                _currDistance = Autodesk.Viewing.Private.convertUnits(fromUnits, toUnits, _firstClick.distanceTo(_secondClick));
                _measurePanel.updatePanel(_firstClick, _secondClick);
                _indicator.drawLine(_firstClick, _secondClick);
            }
            return true;
        }
        return false;
    };

    this.handleButtonDown = function (event, button) {
        _isDragging = true;
        if (button === 0 && !event.ctrlKey && !event.metaKey && !event.shiftKey && !event.altKey) {
            if (this._handleMouseEvent(event)) {
                return true;
            }

            this.clearMeasurement();
            _activePoint = 0;
        }
        return false;
    };

    this.handleMouseMove = function (event) {
        return (_isDragging && (_activePoint === 1 || _activePoint === 2) && this._handleMouseEvent(event));
    };

    this.handleButtonUp = function (event, button) {
        _isDragging = false;
        if (_activePoint === 1 || _activePoint === 2) {
            this._handleMouseEvent(event);
            _activePoint = (_activePoint === 1) ? 2 : 0;
            _consumeSingleClick = true;
            return true;
        }
        return false;
    };

    this.handleSingleClick = function (event, button) {
        if (_consumeSingleClick) {
            _consumeSingleClick = false;
            return true;
        }
        return false;
    };

    // Create UI and initially hide it.
    function activateUI( )
    {
        if (!_indicator) {
            _indicator = new Indicator( _viewer );
        }
        _indicator.hide();

        if (!_measurePanel) {
            _measurePanel = new Autodesk.Viewing.Extensions.Measure.MeasurePanel( tool, _viewer.container, "measure-panel", "Measure", options );
        }
        _measurePanel.setVisible(true);
    }

    function deactivateUI()
    {
        _indicator.hide();
        _indicator.destroy();
        _measurePanel.setVisible(false);
        _measurePanel.clearPanel();
    }

    function onCameraChange(event) {
        _indicator.updateLabelPositions();
    }

    // /** @constructor */
    function Indicator( viewer )
    {
        var that = this,
            _projector = new THREE.Projector(),
            kIndicatorColor = 0xFF0000,
            kIndicatorOpacity = 1.0,        // Not working for some reason!!!
            kEndPointOverlayName = 'MeasureTool-endPoint',
            _materialPre = null,
            _materialPost = null,
            _endPoints = {first: {}, second: {}},
            _lines = {
                xyz: {axis: false, color: 'FF0000'},
                x:   {axis: true,  color: 'FF0000'},
                y:   {axis: true,  color: '00FF00'},
                z:   {axis: true,  color: '0000FF'}
            },
            kHudOffset = 10; // pixels

        this.showFirst = function( position, scale )
        {
            this.showEndPoint('first', position, scale);
        };

        this.showSecond = function( position, scale )
        {
            this.showEndPoint('second', position, scale);
        };

        this.showEndPoint = function (name, position, scale) {
            if (!_materialPre) {
                _materialPre = new THREE.MeshPhongMaterial({
                    color: kIndicatorColor,
                    ambient: kIndicatorColor,
                    opacity: kIndicatorOpacity,
                    transparent: true}
                );

                _materialPost = new THREE.MeshPhongMaterial({
                    color: kIndicatorColor,
                    ambient: kIndicatorColor,
                    opacity: kIndicatorOpacity,
                    transparent: true});

                _viewer.impl.createOverlayScene(kEndPointOverlayName, _materialPre, _materialPost);
            }

            var endPoint = _endPoints[name],
                mesh = endPoint.mesh;

            if (!mesh) {
                endPoint.geometry = new THREE.SphereGeometry(1.0);
                mesh = endPoint.mesh = new THREE.Mesh(endPoint.geometry, _materialPost);
                mesh.visible = true;

                _viewer.impl.addOverlay(kEndPointOverlayName, mesh);
            }

            _materialPre.opacity = kIndicatorOpacity; // Start out full opacity
            _materialPost.opacity = kIndicatorOpacity;

            mesh.scale.x = scale;
            mesh.scale.y = scale;
            mesh.scale.z = scale;
            mesh.position.set(position.x, position.y, position.z);
            mesh.visible = true;

            _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);
        };

        this.updateLabelPositions = function () {
            var camera = _viewer.navigation.getCamera(),
                containerBounds = _viewer.navigation.getScreenViewport();

            for (var name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name],
                        label = item.label;

                    if (label) {
                        var p = new THREE.Vector3(item.labelX, item.labelY, item.labelZ);
                        _projector.projectVector(p, camera);

                        var x = ( p.x + 1) / 2 * containerBounds.width,
                            y = (-p.y + 1) / 2 * containerBounds.height;

                        if (item.axis) { // TODO: need better label placements for axes
                            x += kHudOffset;
                            y += kHudOffset;
                        } else {
                            x += kHudOffset;
                            y += kHudOffset;
                        }
                        label.style.top  = y + 'px';
                        label.style.left = x + 'px';
                    }
                }
            }
        };

        this.drawLine = function( p1, p2 )
        {
            function updateLine(name, x1, y1, z1, x2, y2, z2) {
                var item = _lines[name],
                    line = item.line,
                    label = item.label,
                    p1 = new THREE.Vector3(x1, y1, z1),
                    p2 = new THREE.Vector3(x2, y2, z2);

                if (line) {
                    line.visible = false;
                }
                if (label) {
                    label.classList.remove('visible');
                }

                if (0 < p1.distanceTo(p2)) {
                    var geometry = item.geometry;

                    if (!line) {
                        item.material = new THREE.LineBasicMaterial({color: parseInt(item.color, 16), linewidth: 1});
                        item.overlayName = 'MeasureTool-' + name;
                        _viewer.impl.createOverlayScene(item.overlayName, item.material, item.material);

                        geometry = item.geometry = new THREE.Geometry();
                        geometry.dynamic = true;

                        line = item.line = new THREE.Line(geometry, item.material);
                        _viewer.impl.addOverlay(item.overlayName, line);
                    }

                    geometry.vertices.length = 0;
                    geometry.vertices.push(p1);
                    geometry.vertices.push(p2);
                    geometry.verticesNeedUpdate = true;
                    line.visible = true;

                    if (!label) {
                        label = item.label = document.createElement('div');
                        label.className = 'measure-length';

                        if (item.axis) {
                            label.style.color = '#' + item.color;
                            label.style.backgroundColor = 'transparent';
                            label.textContent = name;
                        }

                        _viewer.container.appendChild(label);
                    }

                    if (item.axis) {
                        item.labelX = x1 + (x2 - x1) / 2;
                        item.labelY = y1 + (y2 - y1) / 2;
                        item.labelZ = z1 + (z2 - z1) / 2;
                    } else {
                        item.labelX = x2;
                        item.labelY = y2;
                        item.labelZ = z2;
                        that.updateDistance();
                    }
                    label.classList.add('visible');
                }
            }

            updateLine('xyz', p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);

            var up = _viewer.navigation.getAlignedUpVector(),
                x = Math.abs(up.x),
                y = Math.abs(up.y),
                z = Math.abs(up.z);

            if (z > x && z > y) { // z up
                updateLine('x', p1.x, p1.y, p1.z, p2.x, p1.y, p1.z);
                updateLine('y', p2.x, p1.y, p1.z, p2.x, p2.y, p1.z);
                updateLine('z', p2.x, p2.y, p1.z, p2.x, p2.y, p2.z);

            } else if (y > x && y > z) { // y up
                updateLine('x', p1.x, p1.y, p1.z, p2.x, p1.y, p1.z);
                updateLine('z', p2.x, p1.y, p1.z, p2.x, p1.y, p2.z);
                updateLine('y', p2.x, p1.y, p2.z, p2.x, p2.y, p2.z);

            } else { // x up - do we ever see this?
                updateLine('y', p1.x, p1.y, p1.z, p1.x, p2.y, p1.z);
                updateLine('z', p1.x, p2.y, p1.z, p1.x, p2.y, p2.z);
                updateLine('x', p1.x, p2.y, p2.z, p2.x, p2.y, p2.z);
            }

            this.updateLabelPositions();
        };

        this.updateDistance = function () {
            var label = _lines.xyz.label;
            label.textContent = Autodesk.Viewing.Private.formatValueWithUnits(tool.getCurrentDistance(), tool.getUnits(), 3, tool.getPrecision());
        };

        this.hide = function () {
            var name;

            for (name in _endPoints) {
                if (_endPoints.hasOwnProperty(name)) {
                    var endPoint = _endPoints[name];
                    if (endPoint.mesh) {
                        endPoint.mesh.visible = false;
                    }
                }
            }

            for (name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        item.line.visible = false;
                    }
                    if (item.label) {
                        item.label.classList.remove('visible');
                    }
                }
            }

            _viewer.impl.invalidate(false, false, /*overlayDirty=*/true);
        };

        this.destroy = function () {
            var name;

            for (name in _endPoints) {
                if (_endPoints.hasOwnProperty(name)) {
                    var endPoint = _endPoints[name];
                    if (endPoint.mesh) {
                        _viewer.impl.removeOverlay(kEndPointOverlayName, endPoint.mesh);
                        endPoint.mesh = endPoint.geometry = null;
                    }
                }
            }

            if (_materialPre) {
                _materialPre = _materialPost = null;
                _viewer.impl.removeOverlayScene(kEndPointOverlayName);
            }

            for (name in _lines) {
                if (_lines.hasOwnProperty(name)) {
                    var item = _lines[name];
                    if (item.line) {
                        _viewer.impl.removeOverlay(item.overlayName, item.line);
                        _viewer.impl.removeOverlayScene(item.overlayName);
                        item.material = item.line = item.geometry = null;
                    }

                    if (item.label) {
                        item.label.parentNode.removeChild(item.label);
                        item.label = null;
                    }
                    item.material = item.line = item.geometry = item.label = null;
                }
            }
        };
    }
};
;AutodeskNamespace('Autodesk.Viewing.Extensions.Measure');

//
// /** @constructor */
//
//
Autodesk.Viewing.Extensions.Measure.MeasurePanel = function(measureTool, parentContainer, id, title, options)
{
    Autodesk.Viewing.UI.DockingPanel.call(this, parentContainer, id, title, options);

    this.kPanelExpandedHeight  = 310; // px
    this.kPanelCollapsedHeight =  35; //px

    this.measureTool = measureTool;
    this.parentContainer = parentContainer;

    this.distance = 0;
    this.deltaX   = 0;
    this.deltaY   = 0;
    this.deltaZ   = 0;

    this.container.classList.add('measurePanel');
    this.container.dockRight = true;

    this.container.style.minWidth  = "325px";
    this.container.style.minHeight = this.kPanelCollapsedHeight + "px";
    this.container.style.height    = this.kPanelExpandedHeight + "px";
    this.container.style.maxHeight = this.kPanelExpandedHeight + "px";
    this.container.style.top       = "200px";
    this.container.style.left      = "220px"; // just needs an initial value dock overrides value
    this.container.style.resize    = "none";
    this.container.style.position  = "absolute";

    this.addEventListener( this.closer, "click", function(e) {
        // WHen the close button is clicked, deactivate the tool as well.
        if (options && options.onCloseCallback)
            options.onCloseCallback();
    });

    function addDropDownMenu(parent, label, optionList, initialIndex, onchange) {

        // Wrap the onchange with the update to that setting
        var handler = function(e) {
            var selectedIndex = e.target.selectedIndex;
            onchange(selectedIndex);
        };

        var selectElem = document.createElement("select");
        selectElem.className = 'optionDropDown';
        for (var i = 0; i < optionList.length; i++) {
            var item = document.createElement("option");
            item.value = i;
            item.setAttribute("data-i18n",  optionList[i]);
            item.textContent = Autodesk.Viewing.i18n.translate( optionList[i] );
            selectElem.add(item);
        }

        var div = document.createElement("div");
        div.className = "measure-submenu-select";

        var lbl = document.createElement("div");
        lbl.className = "measure-submenu-selectlabel";
        lbl.setAttribute ('for', label);
        lbl.setAttribute("data-i18n", label);
        lbl.textContent = Autodesk.Viewing.i18n.translate( label );
        div.appendChild(lbl);
        div.appendChild(selectElem);

        parent.appendChild(div);

        selectElem.selectedIndex = initialIndex;
        selectElem.onchange = handler;

        return selectElem;
    }

    function addDivider(parent) {
        var item = document.createElement("div");
        item.className = "measure-horizontal-divider";
        parent.appendChild(item);
        return item;
    }

    // Add arrow to the title and add expand/collapse behavior..
    var titleElement = this.container.children[0];
    titleElement.classList.add( "measure-panelTitle" );
    titleElement.classList.add( "expanded" );

    this.measureResults = document.createElement("div");
    this.container.appendChild( this.measureResults );

    // Add unit list.
    var self = this;
    var units   = [ "mm", "cm", "m", "in", "ft" ];
    var unitNames = [ "Millimeters", "Centimeters", "Meters", "Inches", "Feet" ];
    var initial = units.indexOf( this.measureTool.getUnits() );
    var unitList = addDropDownMenu( this.measureResults, "Unit type", unitNames, initial, function(index) {

        var fromUnits = self.measureTool.getUnits();
        var toUnits   = units[index];

        self.measureTool.setUnits(toUnits);

        self.distance = self.measureTool.getCurrentDistance();
        self.deltaX = Autodesk.Viewing.Private.convertUnits(fromUnits, toUnits, self.deltaX);
        self.deltaY = Autodesk.Viewing.Private.convertUnits(fromUnits, toUnits, self.deltaY);
        self.deltaZ = Autodesk.Viewing.Private.convertUnits(fromUnits, toUnits, self.deltaZ);

        self.update();
    });

    // Add precision list.
    var precision = [ "0.1", "0.01", "0.001", "0.0001", "0.00001" ];
    var pInitial  = this.measureTool.getPrecision()-1;
    var precisionList = addDropDownMenu( this.measureResults, "Precision", precision, pInitial, function(index) {
        var precision = index + 1;
        self.measureTool.setPrecision(precision);
        self.update();
    });
    precisionList.parentNode.style.paddingBottom= "15px";

    addDivider( this.measureResults );

    // Add the result section.
    var results = document.createElement("div");
    this.measureResults.appendChild(results);

    var resultLabel = document.createElement("div");
    resultLabel.className = 'measure-result';
    resultLabel.setAttribute("data-i18n", "Results");
    resultLabel.textContent = Autodesk.Viewing.i18n.translate("Results");
    results.appendChild(resultLabel);

    this.distanceDiv = document.createElement("div");
    this.distanceDiv.className = 'measure-results';
    results.appendChild( this.distanceDiv );

    var distLabel = document.createElement("div");
    distLabel.className = 'measure-result-label';
    distLabel.setAttribute("data-i18n", "Distance = ");
    distLabel.textContent = Autodesk.Viewing.i18n.translate("Distance = ");
    this.distanceDiv.appendChild(distLabel);

    var distance = document.createElement("div");
    distance.className = 'measure-result-number';
    this.distanceDiv.appendChild(distance);


    this.deltaXDiv = document.createElement("div");
    this.deltaXDiv.className = 'measure-results';
    results.appendChild( this.deltaXDiv );

    var dXLabel = document.createElement("div");
    dXLabel.className = 'measure-result-label';
    dXLabel.setAttribute("data-i18n", "Delta x = ");
    dXLabel.textContent = Autodesk.Viewing.i18n.translate("Delta x = ");
    this.deltaXDiv.appendChild(dXLabel);

    var dXNumber = document.createElement("div");
    dXNumber.className = 'measure-result-number';
    this.deltaXDiv.appendChild(dXNumber);


    this.deltaYDiv = document.createElement("div");
    this.deltaYDiv.className = 'measure-results';
    results.appendChild( this.deltaYDiv );

    var dYLabel = document.createElement("div");
    dYLabel.className = 'measure-result-label';
    dYLabel.setAttribute("data-i18n", "Delta y = ");
    dYLabel.textContent = Autodesk.Viewing.i18n.translate("Delta y = ");
    this.deltaYDiv.appendChild(dYLabel);

    var dYNmber = document.createElement("div");
    dYNmber.className = 'measure-result-number';
    this.deltaYDiv.appendChild(dYNmber);


    this.deltaZDiv = document.createElement("div");
    this.deltaZDiv.className = 'measure-results';
    results.appendChild( this.deltaZDiv );

    var dZLabel = document.createElement("div");
    dZLabel.className = 'measure-result-label';
    dZLabel.setAttribute("data-i18n", "Delta z = ");
    dZLabel.textContent = Autodesk.Viewing.i18n.translate("Delta z = ");
    this.deltaZDiv.appendChild(dZLabel);

    var dZNmber = document.createElement("div");
    dZNmber.className = 'measure-result-number';
    this.deltaZDiv.appendChild(dZNmber);

    addDivider( this.measureResults );

    var restart = document.createElement('div');
    restart.className = 'measure-restart';
    restart.setAttribute("data-i18n", "Restart measurement");
    restart.textContent = Autodesk.Viewing.i18n.translate("Restart measurement");

    restart.addEventListener('click', function () {
       self.measureTool.clearMeasurement();
    }, false);

    this.measureResults.appendChild(restart);
    this.clearPanel();
};

Autodesk.Viewing.Extensions.Measure.MeasurePanel.prototype = Object.create(Autodesk.Viewing.UI.DockingPanel.prototype);
Autodesk.Viewing.Extensions.Measure.MeasurePanel.prototype.constructor = Autodesk.Viewing.Extensions.Measure.MeasurePanel;

Autodesk.Viewing.Extensions.Measure.MeasurePanel.prototype.isExpanded = function() {
    return this.container.children[0].classList.contains("expanded");
};

Autodesk.Viewing.Extensions.Measure.MeasurePanel.prototype.onTitleClick = function(event) {
    var titleElement = this.container.children[0];
    if (titleElement.classList.contains("expanded")) {
        // Collapse the panel.
        titleElement.classList.remove( "expanded" );
        titleElement.classList.add( "collapsed" );

        this.measureResults.style.display = "none";
        this.container.style.height = this.kPanelCollapsedHeight + "px";
    }
    else {
        // Expand the panel.
        titleElement.classList.remove( "collapsed" );
        titleElement.classList.add( "expanded" );

        this.measureResults.style.display = "block";

        // Adjust the height and if necessary the location (top).
        var height = this.parentContainer.offsetHeight;
        var top    = parseInt(this.container.style.top);
        if ((top + this.kPanelExpandedHeight) > height) {
            this.container.style.top = height - this.kPanelExpandedHeight - 50 + "px";
            this.container.style.maxHeight = this.kPanelExpandedHeight + "px";
        }
        this.container.style.height = this.kPanelExpandedHeight + "px";
    }
};

/**
 * Returns the width and height to be used when resizing the panel to the content.
 *
 * @returns {{height: number, width: number}}
 */
Autodesk.Viewing.Extensions.Measure.MeasurePanel.prototype.getContentSize = function () {
    return {
        height: this.isExpanded() ? this.measureResults.clientHeight + 46 : 0,
        width: this.measureResults.clientWidth
    };
};

Autodesk.Viewing.Extensions.Measure.MeasurePanel.prototype.updatePanel = function( p1, p2 ) {

    if (!p1 || !p2) {
        this.clearPanel();
        return;
    }
    
    this.distance = this.measureTool.getCurrentDistance();
    this.deltaX = Math.abs(p1.x - p2.x);
    this.deltaY = Math.abs(p1.y - p2.y);
    this.deltaZ = Math.abs(p1.z - p2.z);

    this.update();
};

Autodesk.Viewing.Extensions.Measure.MeasurePanel.prototype.update = function() {
    var units = this.measureTool.getUnits();
    var precision = this.measureTool.getPrecision();

    this.distanceDiv.children[1].textContent = Autodesk.Viewing.Private.formatValueWithUnits(this.distance, units, 3, precision);
    this.deltaXDiv.children[1].textContent   = Autodesk.Viewing.Private.formatValueWithUnits(this.deltaX, units, 3, precision);
    this.deltaYDiv.children[1].textContent   = Autodesk.Viewing.Private.formatValueWithUnits(this.deltaY, units, 3, precision);
    this.deltaZDiv.children[1].textContent   = Autodesk.Viewing.Private.formatValueWithUnits(this.deltaZ, units, 3, precision);
};

Autodesk.Viewing.Extensions.Measure.MeasurePanel.prototype.clearPanel = function() {
    this.distance = 0;
    this.deltaX = 0;
    this.deltaY = 0;
    this.deltaZ = 0;

    this.update();
};
;/*
 Alertify is licensed under MIT http://www.opensource.org/licenses/MIT
 Copyright (c) 2012, Fabien Doiron
 */
/*global define*/
(function (global, undefined) {
	"use strict";

	var document = global.document,
	    Alertify;

	Alertify = function () {

		var _alertify = {},
		    dialogs   = {},
		    isopen    = false,
		    keys      = { ENTER: 13, ESC: 27, SPACE: 32 },
		    queue     = [],
		    $, btnCancel, btnOK, btnReset, btnResetBack, btnFocus, elCallee, elCover, elDialog, elLog, form, input, getTransitionEvent;

		/**
		 * Markup pieces
		 * @type {Object}
		 */
		dialogs = {
			buttons : {
				holder : "<nav class=\"alertify-buttons\">{{buttons}}</nav>",
				submit : "<button type=\"submit\" class=\"alertify-button alertify-button-ok\" id=\"alertify-ok\">{{ok}}</button>",
				ok     : "<button class=\"alertify-button alertify-button-ok\" id=\"alertify-ok\">{{ok}}</button>",
				cancel : "<button class=\"alertify-button alertify-button-cancel\" id=\"alertify-cancel\">{{cancel}}</button>"
			},
			input   : "<div class=\"alertify-text-wrapper\"><input type=\"text\" class=\"alertify-text\" id=\"alertify-text\"></div>",
			message : "<p class=\"alertify-message\">{{message}}</p>",
			log     : "<article class=\"alertify-log{{class}}\">{{message}}</article>"
		};

		/**
		 * Return the proper transitionend event
		 * @return {String}    Transition type string
		 */
		getTransitionEvent = function () {
			var t,
			    type,
			    supported   = false,
			    el          = document.createElement("fakeelement"),
			    transitions = {
				    "WebkitTransition" : "webkitTransitionEnd",
				    "MozTransition"    : "transitionend",
				    "OTransition"      : "otransitionend",
				    "transition"       : "transitionend"
			    };

			for (t in transitions) {
				if (el.style[t] !== undefined) {
					type      = transitions[t];
					supported = true;
					break;
				}
			}

			return {
				type      : type,
				supported : supported
			};
		};

		/**
		 * Shorthand for document.getElementById()
		 *
		 * @param  {String} id    A specific element ID
		 * @return {Object}       HTML element
		 */
		$ = function (id) {
			return document.getElementById(id);
		};

		/**
		 * Alertify private object
		 * @type {Object}
		 */
		_alertify = {

			/**
			 * Labels object
			 * @type {Object}
			 */
			labels : {
				ok     : "OK",
				cancel : "Cancel"
			},

			/**
			 * Delay number
			 * @type {Number}
			 */
			delay : 5000,

			/**
			 * Whether buttons are reversed (default is secondary/primary)
			 * @type {Boolean}
			 */
			buttonReverse : false,

			/**
			 * Which button should be focused by default
			 * @type {String}	"ok" (default), "cancel", or "none"
			 */
			buttonFocus : "ok",

			/**
			 * Set the transition event on load
			 * @type {[type]}
			 */
			transition : undefined,

			/**
			 * Set the proper button click events
			 *
			 * @param {Function} fn    [Optional] Callback function
			 *
			 * @return {undefined}
			 */
			addListeners : function (fn) {
				var hasOK     = (typeof btnOK !== "undefined"),
				    hasCancel = (typeof btnCancel !== "undefined"),
				    hasInput  = (typeof input !== "undefined"),
				    val       = "",
				    self      = this,
				    ok, cancel, common, key, reset;

				// ok event handler
				ok = function (event) {
					if (typeof event.preventDefault !== "undefined") event.preventDefault();
					common(event);
					if (typeof input !== "undefined") val = input.value;
					if (typeof fn === "function") {
						if (typeof input !== "undefined") {
							fn(true, val);
						}
						else fn(true);
					}
					return false;
				};

				// cancel event handler
				cancel = function (event) {
					if (typeof event.preventDefault !== "undefined") event.preventDefault();
					common(event);
					if (typeof fn === "function") fn(false);
					return false;
				};

				// common event handler (keyup, ok and cancel)
				common = function (event) {
					self.hide();
					self.unbind(document.body, "keyup", key);
					self.unbind(btnReset, "focus", reset);
					if (hasOK) self.unbind(btnOK, "click", ok);
					if (hasCancel) self.unbind(btnCancel, "click", cancel);
				};

				// keyup handler
				key = function (event) {
					var keyCode = event.keyCode;
					if ((keyCode === keys.SPACE && !hasInput) || (hasInput && keyCode === keys.ENTER)) ok(event);
					if (keyCode === keys.ESC && hasCancel) cancel(event);
				};

				// reset focus to first item in the dialog
				reset = function (event) {
					if (hasInput) input.focus();
					else if (!hasCancel || self.buttonReverse) btnOK.focus();
					else btnCancel.focus();
				};

				// handle reset focus link
				// this ensures that the keyboard focus does not
				// ever leave the dialog box until an action has
				// been taken
				this.bind(btnReset, "focus", reset);
				this.bind(btnResetBack, "focus", reset);
				// handle OK click
				if (hasOK) this.bind(btnOK, "click", ok);
				// handle Cancel click
				if (hasCancel) this.bind(btnCancel, "click", cancel);
				// listen for keys, Cancel => ESC
				this.bind(document.body, "keyup", key);
				if (!this.transition.supported) {
					this.setFocus();
				}
			},

			/**
			 * Bind events to elements
			 *
			 * @param  {Object}   el       HTML Object
			 * @param  {Event}    event    Event to attach to element
			 * @param  {Function} fn       Callback function
			 *
			 * @return {undefined}
			 */
			bind : function (el, event, fn) {
				if (typeof el.addEventListener === "function") {
					el.addEventListener(event, fn, false);
				} else if (el.attachEvent) {
					el.attachEvent("on" + event, fn);
				}
			},

			/**
			 * Use alertify as the global error handler (using window.onerror)
			 *
			 * @return {boolean} success
			 */
			handleErrors : function () {
				if (typeof global.onerror !== "undefined") {
					var self = this;
					global.onerror = function (msg, url, line) {
						self.error("[" + msg + " on line " + line + " of " + url + "]", 0);
					};
					return true;
				} else {
					return false;
				}
			},

			/**
			 * Append button HTML strings
			 *
			 * @param {String} secondary    The secondary button HTML string
			 * @param {String} primary      The primary button HTML string
			 *
			 * @return {String}             The appended button HTML strings
			 */
			appendButtons : function (secondary, primary) {
				return this.buttonReverse ? primary + secondary : secondary + primary;
			},

			/**
			 * Build the proper message box
			 *
			 * @param  {Object} item    Current object in the queue
			 *
			 * @return {String}         An HTML string of the message box
			 */
			build : function (item) {
				var html    = "",
				    type    = item.type,
				    message = item.message,
				    css     = item.cssClass || "";

				html += "<div class=\"alertify-dialog\">";
				html += "<a id=\"alertify-resetFocusBack\" class=\"alertify-resetFocus\" href=\"#\">Reset Focus</a>";

				if (_alertify.buttonFocus === "none") html += "<a href=\"#\" id=\"alertify-noneFocus\" class=\"alertify-hidden\"></a>";

				// doens't require an actual form
				if (type === "prompt") html += "<div id=\"alertify-form\">";

				html += "<article class=\"alertify-inner\">";
				html += dialogs.message.replace("{{message}}", message);

				if (type === "prompt") html += dialogs.input;

				html += dialogs.buttons.holder;
				html += "</article>";

				if (type === "prompt") html += "</div>";

				html += "<a id=\"alertify-resetFocus\" class=\"alertify-resetFocus\" href=\"#\">Reset Focus</a>";
				html += "</div>";

				switch (type) {
				case "confirm":
					html = html.replace("{{buttons}}", this.appendButtons(dialogs.buttons.cancel, dialogs.buttons.ok));
					html = html.replace("{{ok}}", this.labels.ok).replace("{{cancel}}", this.labels.cancel);
					break;
				case "prompt":
					html = html.replace("{{buttons}}", this.appendButtons(dialogs.buttons.cancel, dialogs.buttons.submit));
					html = html.replace("{{ok}}", this.labels.ok).replace("{{cancel}}", this.labels.cancel);
					break;
				case "alert":
					html = html.replace("{{buttons}}", dialogs.buttons.ok);
					html = html.replace("{{ok}}", this.labels.ok);
					break;
				default:
					break;
				}

				elDialog.className = "alertify alertify-" + type + " " + css;
				elCover.className  = "alertify-cover";
				return html;
			},

			/**
			 * Close the log messages
			 *
			 * @param  {Object} elem    HTML Element of log message to close
			 * @param  {Number} wait    [optional] Time (in ms) to wait before automatically hiding the message, if 0 never hide
			 *
			 * @return {undefined}
			 */
			close : function (elem, wait) {
				// Unary Plus: +"2" === 2
				var timer = (wait && !isNaN(wait)) ? +wait : this.delay,
				    self  = this,
				    hideElement, transitionDone;

				// set click event on log messages
				this.bind(elem, "click", function () {
					hideElement(elem);
				});
				// Hide the dialog box after transition
				// This ensure it doens't block any element from being clicked
				transitionDone = function (event) {
					event.stopPropagation();
					// unbind event so function only gets called once
					self.unbind(this, self.transition.type, transitionDone);
					// remove log message
					elLog.removeChild(this);
					if (!elLog.hasChildNodes()) elLog.className += " alertify-logs-hidden";
				};
				// this sets the hide class to transition out
				// or removes the child if css transitions aren't supported
				hideElement = function (el) {
					// ensure element exists
					if (typeof el !== "undefined" && el.parentNode === elLog) {
						// whether CSS transition exists
						if (self.transition.supported) {
							self.bind(el, self.transition.type, transitionDone);
							el.className += " alertify-log-hide";
						} else {
							elLog.removeChild(el);
							if (!elLog.hasChildNodes()) elLog.className += " alertify-logs-hidden";
						}
					}
				};
				// never close (until click) if wait is set to 0
				if (wait === 0) return;
				// set timeout to auto close the log message
				setTimeout(function () { hideElement(elem); }, timer);
			},

			/**
			 * Create a dialog box
			 *
			 * @param  {String}   message        The message passed from the callee
			 * @param  {String}   type           Type of dialog to create
			 * @param  {Function} fn             [Optional] Callback function
			 * @param  {String}   placeholder    [Optional] Default value for prompt input field
			 * @param  {String}   cssClass       [Optional] Class(es) to append to dialog box
			 *
			 * @return {Object}
			 */
			dialog : function (message, type, fn, placeholder, cssClass) {
				// set the current active element
				// this allows the keyboard focus to be resetted
				// after the dialog box is closed
				elCallee = document.activeElement;
				// check to ensure the alertify dialog element
				// has been successfully created
				var check = function () {
					if ((elLog && elLog.scrollTop !== null) && (elCover && elCover.scrollTop !== null)) return;
					else check();
				};
				// error catching
				if (typeof message !== "string") throw new Error("message must be a string");
				if (typeof type !== "string") throw new Error("type must be a string");
				if (typeof fn !== "undefined" && typeof fn !== "function") throw new Error("fn must be a function");
				// initialize alertify if it hasn't already been done
				this.init();
				check();

				queue.push({ type: type, message: message, callback: fn, placeholder: placeholder, cssClass: cssClass });
				if (!isopen) this.setup();

				return this;
			},

			/**
			 * Extend the log method to create custom methods
			 *
			 * @param  {String} type    Custom method name
			 *
			 * @return {Function}
			 */
			extend : function (type) {
				if (typeof type !== "string") throw new Error("extend method must have exactly one paramter");
				return function (message, wait) {
					this.log(message, type, wait);
					return this;
				};
			},

			/**
			 * Hide the dialog and rest to defaults
			 *
			 * @return {undefined}
			 */
			hide : function () {
				var transitionDone,
				    self = this;
				// remove reference from queue
				queue.splice(0,1);
				// if items remaining in the queue
				if (queue.length > 0) this.setup(true);
				else {
					isopen = false;
					// Hide the dialog box after transition
					// This ensure it doens't block any element from being clicked
					transitionDone = function (event) {
						event.stopPropagation();
						// unbind event so function only gets called once
						self.unbind(elDialog, self.transition.type, transitionDone);
					};
					// whether CSS transition exists
					if (this.transition.supported) {
						this.bind(elDialog, this.transition.type, transitionDone);
						elDialog.className = "alertify alertify-hide alertify-hidden";
					} else {
						elDialog.className = "alertify alertify-hide alertify-hidden alertify-isHidden";
					}
					elCover.className  = "alertify-cover alertify-cover-hidden";
					// set focus to the last element or body
					// after the dialog is closed
					elCallee.focus();
				}
			},

			/**
			 * Initialize Alertify
			 * Create the 2 main elements
			 *
			 * @return {undefined}
			 */
			init : function () {
				// ensure legacy browsers support html5 tags
				document.createElement("nav");
				document.createElement("article");
				document.createElement("section");
				// cover
				if ($("alertify-cover") == null) {
					elCover = document.createElement("div");
					elCover.setAttribute("id", "alertify-cover");
					elCover.className = "alertify-cover alertify-cover-hidden";
					document.body.appendChild(elCover);
				}
				// main element
				if ($("alertify") == null) {
					isopen = false;
					queue = [];
					elDialog = document.createElement("section");
					elDialog.setAttribute("id", "alertify");
					elDialog.className = "alertify alertify-hidden";
					document.body.appendChild(elDialog);
				}
				// log element
				if ($("alertify-logs") == null) {
					elLog = document.createElement("section");
					elLog.setAttribute("id", "alertify-logs");
					elLog.className = "alertify-logs alertify-logs-hidden";
					document.body.appendChild(elLog);
				}
				// set tabindex attribute on body element
				// this allows script to give it focus
				// after the dialog is closed
				document.body.setAttribute("tabindex", "0");
				// set transition type
				this.transition = getTransitionEvent();
			},

			/**
			 * Show a new log message box
			 *
			 * @param  {String} message    The message passed from the callee
			 * @param  {String} type       [Optional] Optional type of log message
			 * @param  {Number} wait       [Optional] Time (in ms) to wait before auto-hiding the log
			 *
			 * @return {Object}
			 */
			log : function (message, type, wait) {
				// check to ensure the alertify dialog element
				// has been successfully created
				var check = function () {
					if (elLog && elLog.scrollTop !== null) return;
					else check();
				};
				// initialize alertify if it hasn't already been done
				this.init();
				check();

				elLog.className = "alertify-logs";
				this.notify(message, type, wait);
				return this;
			},

			/**
			 * Add new log message
			 * If a type is passed, a class name "alertify-log-{type}" will get added.
			 * This allows for custom look and feel for various types of notifications.
			 *
			 * @param  {String} message    The message passed from the callee
			 * @param  {String} type       [Optional] Type of log message
			 * @param  {Number} wait       [Optional] Time (in ms) to wait before auto-hiding
			 *
			 * @return {undefined}
			 */
			notify : function (message, type, wait) {
				var log = document.createElement("article");
				log.className = "alertify-log" + ((typeof type === "string" && type !== "") ? " alertify-log-" + type : "");
				log.innerHTML = message;
				// append child
				elLog.appendChild(log);
				// triggers the CSS animation
				setTimeout(function() { log.className = log.className + " alertify-log-show"; }, 50);
				this.close(log, wait);
			},

			/**
			 * Set properties
			 *
			 * @param {Object} args     Passing parameters
			 *
			 * @return {undefined}
			 */
			set : function (args) {
				var k;
				// error catching
				if (typeof args !== "object" && args instanceof Array) throw new Error("args must be an object");
				// set parameters
				for (k in args) {
					if (args.hasOwnProperty(k)) {
						this[k] = args[k];
					}
				}
			},

			/**
			 * Common place to set focus to proper element
			 *
			 * @return {undefined}
			 */
			setFocus : function () {
				if (input) {
					input.focus();
					input.select();
				}
				else btnFocus.focus();
			},

			/**
			 * Initiate all the required pieces for the dialog box
			 *
			 * @return {undefined}
			 */
			setup : function (fromQueue) {
				var item = queue[0],
				    self = this,
				    transitionDone;

				// dialog is open
				isopen = true;
				// Set button focus after transition
				transitionDone = function (event) {
					event.stopPropagation();
					self.setFocus();
					// unbind event so function only gets called once
					self.unbind(elDialog, self.transition.type, transitionDone);
				};
				// whether CSS transition exists
				if (this.transition.supported && !fromQueue) {
					this.bind(elDialog, this.transition.type, transitionDone);
				}
				// build the proper dialog HTML
				elDialog.innerHTML = this.build(item);
				// assign all the common elements
				btnReset  = $("alertify-resetFocus");
				btnResetBack  = $("alertify-resetFocusBack");
				btnOK     = $("alertify-ok")     || undefined;
				btnCancel = $("alertify-cancel") || undefined;
				btnFocus  = (_alertify.buttonFocus === "cancel") ? btnCancel : ((_alertify.buttonFocus === "none") ? $("alertify-noneFocus") : btnOK),
				input     = $("alertify-text")   || undefined;
				form      = $("alertify-form")   || undefined;
				// add placeholder value to the input field
				if (typeof item.placeholder === "string" && item.placeholder !== "") input.value = item.placeholder;
				if (fromQueue) this.setFocus();
				this.addListeners(item.callback);
			},

			/**
			 * Unbind events to elements
			 *
			 * @param  {Object}   el       HTML Object
			 * @param  {Event}    event    Event to detach to element
			 * @param  {Function} fn       Callback function
			 *
			 * @return {undefined}
			 */
			unbind : function (el, event, fn) {
				if (typeof el.removeEventListener === "function") {
					el.removeEventListener(event, fn, false);
				} else if (el.detachEvent) {
					el.detachEvent("on" + event, fn);
				}
			}
		};

		return {
			alert   : function (message, fn, cssClass) { _alertify.dialog(message, "alert", fn, "", cssClass); return this; },
			confirm : function (message, fn, cssClass) { _alertify.dialog(message, "confirm", fn, "", cssClass); return this; },
			extend  : _alertify.extend,
			init    : _alertify.init,
			log     : function (message, type, wait) { _alertify.log(message, type, wait); return this; },
			prompt  : function (message, fn, placeholder, cssClass) { _alertify.dialog(message, "prompt", fn, placeholder, cssClass); return this; },
			success : function (message, wait) { _alertify.log(message, "success", wait); return this; },
			error   : function (message, wait) { _alertify.log(message, "error", wait); return this; },
			set     : function (args) { _alertify.set(args); },
			labels  : _alertify.labels,
			debug   : _alertify.handleErrors
		};
	};

	// AMD and window support
	if (typeof define === "function") {
		define([], function () { return new Alertify(); });
	} else if (typeof global.alertify === "undefined") {
		global.alertify = new Alertify();
	}

}(this));
;AutodeskNamespace('Autodesk.Viewing');
AutodeskNamespace('Autodesk.Viewing.Private');

var auth = null;
var VIEWING_URL;
var SEARCH_URL;
var RESOURCE_ROOT = "";
var LOCALIZATION_RESOURCE_ROOT = "";

Autodesk.Viewing.Private.env = null;
Autodesk.Viewing.Private.logger = null;
// Callback function provided by client to get a new access token.
// Viewer uses this to refresh token in a fixed interval.
Autodesk.Viewing.Private.refreshToken = null;
Autodesk.Viewing.Private.lastTokenRefreshTime = null;

// Make sure only one of these is set to true.
var USE_OAUTH_NONE = true;
var USE_OAUTH_ZERO = false;
var USE_OAUTH_ONE = false;
var USE_OAUTH_TWO = false;
// Control whether or not viewer should interactive with viewing service set token end point.
// For prod release, this must set to false, since hosting application will set token instead.
// For development / debugging, set this to true so viewer will take care of set token in cookie.
var SHOULD_SET_TOKEN = true;

// Environment configurations for various services end points.
// Please use this instead of hard code service end points in your code.
Autodesk.Viewing.Private.EnvironmentConfigurations = {
    Local : {
        RESOURCE : '',
        VIEWING : 'https://viewing-dev.api.autodesk.com/viewingservice/v1',
        SEARCH : 'https://search-dev.api.autodesk.com/search/v1'
    },
    Development : {
        RESOURCE : 'https://viewing-dev.api.autodesk.com/viewingservice/v1/viewers/',
        VIEWING : 'https://viewing-dev.api.autodesk.com/viewingservice/v1',
        SEARCH : 'https://search-dev.api.autodesk.com/search/v1'
    },
    Staging : {
        RESOURCE : 'https://viewing-staging.api.autodesk.com/viewingservice/v1/viewers/',
        VIEWING : 'https://viewing-staging.api.autodesk.com/viewingservice/v1',
        SEARCH : 'https://search-staging.api.autodesk.com/search/v1'
    },
    Production : {
        RESOURCE : 'https://viewing.api.autodesk.com/viewingservice/v1/viewers/',
        VIEWING : 'https://viewing.api.autodesk.com/viewingservice/v1',
        SEARCH : 'https://search.api.autodesk.com/search/v1'
    },
    AutodeskDevelopment : {
        RESOURCE : 'https://developer-dev.api.autodesk.com/viewingservice/v1/viewers/',
        VIEWING : 'https://developer-dev.api.autodesk.com/viewingservice/v1',
        SEARCH : 'https://search-dev.api.autodesk.com/search/v1'
    },
    AutodeskStaging : {
        RESOURCE : 'https://developer-stg.api.autodesk.com/viewingservice/v1/viewers/',
        VIEWING : 'https://developer-stg.api.autodesk.com/viewingservice/v1',
        SEARCH : 'https://search-staging.api.autodesk.com/search/v1'
    },
    AutodeskProduction : {
        RESOURCE : 'https://developer.api.autodesk.com/viewingservice/v1/viewers/',
        VIEWING : 'https://developer.api.autodesk.com/viewingservice/v1',
        SEARCH : 'https://search.api.autodesk.com/search/v1'
    }
};

Autodesk.Viewing.Private.setAuthTokenInCookie = function (accessToken, onSuccessCallback, onFailureCallback) {
    var token =
    {
        "oauth":
        {
            "token":""
        }
    };
    token.oauth.token = accessToken;

    // console.log("auth token : " + JSON.stringify(token));

    var xhr = new XMLHttpRequest();
    xhr.open("POST", VIEWING_URL + "/token", true);
    xhr.setRequestHeader("Content-Type", "application/json");
    xhr.withCredentials = true;

    xhr.onload = onSuccessCallback;
    xhr.onerror = onFailureCallback;
    xhr.ontimeout = onFailureCallback;

    xhr.send(JSON.stringify(token));
};

Autodesk.Viewing.Private.setApigeeTokenInCookie = function (accessToken, onSuccessCallback, onFailureCallback) {
    var xhr = new XMLHttpRequest();
    // This really sucks, as Apigee end points use different naming pattern than viewing service.
    var url = VIEWING_URL.substring(0, VIEWING_URL.indexOf("/viewingservice"));

    xhr.open("POST", url + "/utility/v1/settoken", true);
    xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    xhr.withCredentials = true;

    xhr.onload = onSuccessCallback;
    xhr.onerror = onFailureCallback;
    xhr.ontimeout = onFailureCallback;

    xhr.send("access-token=" + accessToken);
};

Autodesk.Viewing.Private.initializeEnvironmentVariable = function (options) {
    var env;

    // Use the enviroment that was explicitly specified.
    //
    if (options && options.env) {
        env = options.env;
    }

    // If not available, check if the environment was specified in the query parameters.
    //
    if (!env) {
        env = Autodesk.Viewing.Private.getParameterByName("env");
    }

    // If still not available, try to resolve the environment based on the url.
    //
    if (!env) {
        switch (window.location.hostname) {
            case "viewing-dev.api.autodesk.com" :
                env = 'Development';
                break;
            case "viewing-staging.api.autodesk.com" :
                env = 'Staging';
                break;
            case "viewing.api.autodesk.com" :
                env = 'Production';
                break;
            case "developer-dev.api.autodesk.com" :
                env = 'AutodeskDevelopment';
                break;
            case "developer-stg.api.autodesk.com" :
                env = 'AutodeskStaging';
                break;
            case "developer.api.autodesk.com" :
                env = 'AutodeskProduction';
                break;
            case "ec2-23-20-101-198.compute-1.amazonaws.com" :
                env = 'Development';
                break;

            case "localhost.autodesk.com" :
                env = 'Local';
                break;
            case "" : // IP addresses on Chrome.
                env = 'Local';
                break;
            case "127.0.0.1" :
                env = 'Local';
                break;
            default:
                env = 'AutodeskProduction';
        }
    }

    console.log("Host name : " + window.location.hostname);
    console.log("Environment initialized as : " + env);
    Autodesk.Viewing.Private.env = env;
};

Autodesk.Viewing.Private.initializeServiceEndPoints = function () {
    var config = Autodesk.Viewing.Private.EnvironmentConfigurations[Autodesk.Viewing.Private.env];
    VIEWING_URL = config['VIEWING'];
    SEARCH_URL = config['SEARCH'];
    RESOURCE_ROOT = config['RESOURCE'];
};

Autodesk.Viewing.Private.initializeAuth = function (onSuccessCallback, options) {
    // Keep this to make existing client code happy.
    auth = true;

    var avp = Autodesk.Viewing.Private;

    var accessToken;
    if (options) {
        if (options.getAccessToken) {
            accessToken = options.getAccessToken();
        } else if (options.accessToken) {
            accessToken = options.accessToken;
        } else {
            accessToken = avp.getParameterByName("accessToken");
        }

        avp.refreshToken = options.refreshToken;
    } else {
        accessToken = avp.getParameterByName("accessToken");
    }

    if (!accessToken) {
        accessToken = "tAndIEVhrHuJZJn4HpPM3niKvJg=";
        console.log("Warning : no access token is provided. Use built in token : " + accessToken);
    }

    // This should be moved to hosting application,
    // so the access token can be securely passed to viewer through
    // Set-Cookie header of viewing service set token API response.
    //
    // Update: 05/23/2014
    // Well, looks like this is never going to happen, and viewer will forever
    // take the job of setting token.
    if (SHOULD_SET_TOKEN) {
        // We support two set token end points, the native VS end point and the wrapped apigee end point.
        if (avp.env.indexOf('Autodesk') == 0)
            avp.setApigeeTokenInCookie(accessToken, onSuccessCallback);
        else
            avp.setAuthTokenInCookie(accessToken, onSuccessCallback);
    }

    avp.initializeLogger(accessToken);

    avp.lastTokenRefreshTime = Date.now();

    // Execute some routine tasks (like logging, token refresh) in a fixed interval.
    setInterval(avp.heartBeat, 60 * 1000);

    return auth;
};

Autodesk.Viewing.Private.initializeLogger = function (accessToken) {
    var loggerConfig = {
        console : false,
        viewingservice : true,
        webstorage : false,
        endpoint : VIEWING_URL,
        flushThreshold : 10
    };

    var logger = Autodesk.Viewing.Private.logger = new Autodesk.Viewing.Private.Logger(loggerConfig);

    var userInfo = {
        viewer_current_time : Date.now(),
        viewer_user_access_token : accessToken,
        viewer_user_host_url : window.location.hostname,
        viewer_user_agent : navigator.userAgent
    };

    logger.log(userInfo);
};

Autodesk.Viewing.Private.heartBeat = function () {

    var avp = Autodesk.Viewing.Private;

    // Flush log every 1 minute.
    if (Date.now() - avp.logger.lastFlushTime > 1000 * 60) {
        avp.logger.flush();
    }

    return;
};

Autodesk.Viewing.Private.getAuthObject = function () {
    return auth;
};

// Returns the query parameter value from window url
Autodesk.Viewing.Private.getParameterByName = function (name) {
    return Autodesk.Viewing.Private.getParameterByNameFromPath(name,window.location.href);
};

// return value of parameter from a url
Autodesk.Viewing.Private.getParameterByNameFromPath = function (name,url) {
    name = name.replace(/[\[]/,"\\\[").replace(/[\]]/,"\\\]");
    var regexS = "[\\?&]"+name+"=([^&#]*)";
    var regex = new RegExp( regexS );
    var results = regex.exec(url);
    if( results == null )
        return "";
    else
        return decodeURIComponent(results[1].replace(/\+/g, " "));
};

// Return a default document URN for demo purpose.
Autodesk.Viewing.Private.getDemoDocumentURN = function () {
    var documentId;

    switch (Autodesk.Viewing.Private.env) {
        case "Development" :
            //documentId = "urn:dXJuOmFkc2sub2JqZWN0czpvcy5vYmplY3Q6Y29sdW1idXMvTWljaGFlbF9IYW5kLV8tYjE0MDk3ODQxNzcwMDZSQ0Nhci5kd2Y";
            documentId = "urn:dXJuOmFkc2suYTM2MGJldGFkZXY6ZnMuZmlsZTplbnRlcnByaXNlLmxtdnRlc3QuRFM1YTczMFFUYmYwMDIyZDA3NTFhYmE5MjZlZDZkMjJlZDY0P3ZlcnNpb249MQ==";
            break;
        case "Staging" :
            documentId = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbicvTU0zNTAwQXNzZW1ibHkuZHdm";
            break;
        case "Production" :
            documentId = "FIXME";
            break;
        default:
            //documentId = "urn:dXJuOmFkc2suczM6ZGVyaXZlZC5maWxlOlZpZXdpbmdTZXJ2aWNlVGVzdEFwcC91c2Vycy9NaWNoYWVsX0hhbmAvUkMgQ2FyLmR3Zg"
            documentId = "urn:dXJuOmFkc2suYTM2MGJldGFkZXY6ZnMuZmlsZTplbnRlcnByaXNlLmxtdnRlc3QuRFM1YTczMFFUYmYwMDIyZDA3NTFhYmE5MjZlZDZkMjJlZDY0P3ZlcnNpb249MQ==";
    }

    return documentId;
};

Autodesk.Viewing.Private.setLanguage = function(language, callback) {

    var options = {
        lng:            language,
        resGetPath:     'locales/__lng__/__ns__.json.generated',
        ns: {
            namespaces: [ 'allstrings'],
            defaultNs: 'allstrings'
        },
        fallbackLng:    "en",
        debug:          false
    };

    LOCALIZATION_RESOURCE_ROOT = RESOURCE_ROOT + "locales/" + language + "/";
    Autodesk.Viewing.i18n.init(options, function(t) {
        Autodesk.Viewing.i18n.localize();
        if (callback) {
            callback();
        };
    });
};

Autodesk.Viewing.Private.initializeLocalization = function() {
    // Initialize language for localization. The corresponding string files
    // will be downloaded.
    var language_complete = navigator.language.split("-");
    var language = (language_complete[0]);

    // TODO: Allow other languages than english once the proper translations are available.
    // But for now, use English.
    language  = "en";
    Autodesk.Viewing.Private.setLanguage( language );
};

function stderr(msg) {
    if (ENABLE_TRACE) {
        console.log(msg);
    }
}




/**
 * This is the Initializer class that initializes the viewer runtime, including:
 *
 *  - End points of cloud services the viewer uses, like viewing service and search service.
 *  - Authentication and authorization cookie settings on the client side.
 *  - Misc runtime environment variables and viewer configurations parameters.
 *
 *  @constructor
 *  @param {object} options - The options object contains configuration parameters used to do initializations. If no
 *                            access token or authentication callback is provided, the Initializer will fall back
 *                            on an access token provided in the URL query string, or a previous access token stored in
 *                            the cookie cache, if available.
 *  @param {string} [options.env] - Can be "Development", "Staging" or "Production", for viewers running without PAAS
 *                                  endpoints. Can be "AutodeskDevelopment", "AutodeskStaging", or "AutodeskProduction"
 *                                  for viewers running with PAAS endpoints.
 *  @param {function} [options.getAccessToken] - A callback that provides the access token
 *  @param {string} [options.accessToken] - An access token
 *  @param {function} [options.refreshToken] - A callback function which when invoked will return a new access token
 *  @param {string} [options.webGLHelpLink] - A link to a help page on webGL if it's disabled.
 *
 *  @param {function} callback - A method the client executes when initialization is finished.
 */
Autodesk.Viewing.Initializer = function(options, callback) {
    Autodesk.Viewing.Private.WEBGL_HELP_LINK = options ? options.webGLHelpLink : null;
    Autodesk.Viewing.Private.initializeEnvironmentVariable(options);
    Autodesk.Viewing.Private.initializeServiceEndPoints();
    Autodesk.Viewing.Private.initializeAuth(callback, options);
    Autodesk.Viewing.Private.initializeLocalization();
};
